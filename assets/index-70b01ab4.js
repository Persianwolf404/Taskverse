var XH = (n, e) => () => (e || n((e = { exports: {} }).exports, e), e.exports); var Ige = XH((ke, Oo) => {
	(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = t(i); fetch(i.href, s) } })(); var YH = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function By(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } var AD = { exports: {} }, Ry = {}, vD = { exports: {} }, zn = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _1 = Symbol.for("react.element"), jH = Symbol.for("react.portal"), JH = Symbol.for("react.fragment"), KH = Symbol.for("react.strict_mode"), qH = Symbol.for("react.profiler"), ZH = Symbol.for("react.provider"), $H = Symbol.for("react.context"), ez = Symbol.for("react.forward_ref"), tz = Symbol.for("react.suspense"), nz = Symbol.for("react.memo"), rz = Symbol.for("react.lazy"), Vw = Symbol.iterator; function iz(n) { return n === null || typeof n != "object" ? null : (n = Vw && n[Vw] || n["@@iterator"], typeof n == "function" ? n : null) } var yD = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, xD = Object.assign, _D = {}; function dm(n, e, t) { this.props = n, this.context = e, this.refs = _D, this.updater = t || yD } dm.prototype.isReactComponent = {}; dm.prototype.setState = function (n, e) { if (typeof n != "object" && typeof n != "function" && n != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, n, e, "setState") }; dm.prototype.forceUpdate = function (n) { this.updater.enqueueForceUpdate(this, n, "forceUpdate") }; function ED() { } ED.prototype = dm.prototype; function J7(n, e, t) { this.props = n, this.context = e, this.refs = _D, this.updater = t || yD } var K7 = J7.prototype = new ED; K7.constructor = J7; xD(K7, dm.prototype); K7.isPureReactComponent = !0; var Ww = Array.isArray, CD = Object.prototype.hasOwnProperty, q7 = { current: null }, SD = { key: !0, ref: !0, __self: !0, __source: !0 }; function TD(n, e, t) { var r, i = {}, s = null, a = null; if (e != null) for (r in e.ref !== void 0 && (a = e.ref), e.key !== void 0 && (s = "" + e.key), e) CD.call(e, r) && !SD.hasOwnProperty(r) && (i[r] = e[r]); var o = arguments.length - 2; if (o === 1) i.children = t; else if (1 < o) { for (var l = Array(o), u = 0; u < o; u++)l[u] = arguments[u + 2]; i.children = l } if (n && n.defaultProps) for (r in o = n.defaultProps, o) i[r] === void 0 && (i[r] = o[r]); return { $$typeof: _1, type: n, key: s, ref: a, props: i, _owner: q7.current } } function sz(n, e) { return { $$typeof: _1, type: n.type, key: e, ref: n.ref, props: n.props, _owner: n._owner } } function Z7(n) { return typeof n == "object" && n !== null && n.$$typeof === _1 } function az(n) { var e = { "=": "=0", ":": "=2" }; return "$" + n.replace(/[=:]/g, function (t) { return e[t] }) } var Xw = /\/+/g; function k4(n, e) { return typeof n == "object" && n !== null && n.key != null ? az("" + n.key) : e.toString(36) } function F5(n, e, t, r, i) { var s = typeof n; (s === "undefined" || s === "boolean") && (n = null); var a = !1; if (n === null) a = !0; else switch (s) { case "string": case "number": a = !0; break; case "object": switch (n.$$typeof) { case _1: case jH: a = !0 } }if (a) return a = n, i = i(a), n = r === "" ? "." + k4(a, 0) : r, Ww(i) ? (t = "", n != null && (t = n.replace(Xw, "$&/") + "/"), F5(i, e, t, "", function (u) { return u })) : i != null && (Z7(i) && (i = sz(i, t + (!i.key || a && a.key === i.key ? "" : ("" + i.key).replace(Xw, "$&/") + "/") + n)), e.push(i)), 1; if (a = 0, r = r === "" ? "." : r + ":", Ww(n)) for (var o = 0; o < n.length; o++) { s = n[o]; var l = r + k4(s, o); a += F5(s, e, t, l, i) } else if (l = iz(n), typeof l == "function") for (n = l.call(n), o = 0; !(s = n.next()).done;)s = s.value, l = r + k4(s, o++), a += F5(s, e, t, l, i); else if (s === "object") throw e = String(n), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return a } function O2(n, e, t) { if (n == null) return n; var r = [], i = 0; return F5(n, r, "", "", function (s) { return e.call(t, s, i++) }), r } function oz(n) { if (n._status === -1) { var e = n._result; e = e(), e.then(function (t) { (n._status === 0 || n._status === -1) && (n._status = 1, n._result = t) }, function (t) { (n._status === 0 || n._status === -1) && (n._status = 2, n._result = t) }), n._status === -1 && (n._status = 0, n._result = e) } if (n._status === 1) return n._result.default; throw n._result } var Qa = { current: null }, k5 = { transition: null }, lz = { ReactCurrentDispatcher: Qa, ReactCurrentBatchConfig: k5, ReactCurrentOwner: q7 }; zn.Children = { map: O2, forEach: function (n, e, t) { O2(n, function () { e.apply(this, arguments) }, t) }, count: function (n) { var e = 0; return O2(n, function () { e++ }), e }, toArray: function (n) { return O2(n, function (e) { return e }) || [] }, only: function (n) { if (!Z7(n)) throw Error("React.Children.only expected to receive a single React element child."); return n } }; zn.Component = dm; zn.Fragment = JH; zn.Profiler = qH; zn.PureComponent = J7; zn.StrictMode = KH; zn.Suspense = tz; zn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lz; zn.cloneElement = function (n, e, t) { if (n == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n + "."); var r = xD({}, n.props), i = n.key, s = n.ref, a = n._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, a = q7.current), e.key !== void 0 && (i = "" + e.key), n.type && n.type.defaultProps) var o = n.type.defaultProps; for (l in e) CD.call(e, l) && !SD.hasOwnProperty(l) && (r[l] = e[l] === void 0 && o !== void 0 ? o[l] : e[l]) } var l = arguments.length - 2; if (l === 1) r.children = t; else if (1 < l) { o = Array(l); for (var u = 0; u < l; u++)o[u] = arguments[u + 2]; r.children = o } return { $$typeof: _1, type: n.type, key: i, ref: s, props: r, _owner: a } }; zn.createContext = function (n) { return n = { $$typeof: $H, _currentValue: n, _currentValue2: n, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n.Provider = { $$typeof: ZH, _context: n }, n.Consumer = n }; zn.createElement = TD; zn.createFactory = function (n) { var e = TD.bind(null, n); return e.type = n, e }; zn.createRef = function () { return { current: null } }; zn.forwardRef = function (n) { return { $$typeof: ez, render: n } }; zn.isValidElement = Z7; zn.lazy = function (n) { return { $$typeof: rz, _payload: { _status: -1, _result: n }, _init: oz } }; zn.memo = function (n, e) { return { $$typeof: nz, type: n, compare: e === void 0 ? null : e } }; zn.startTransition = function (n) { var e = k5.transition; k5.transition = {}; try { n() } finally { k5.transition = e } }; zn.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; zn.useCallback = function (n, e) { return Qa.current.useCallback(n, e) }; zn.useContext = function (n) { return Qa.current.useContext(n) }; zn.useDebugValue = function () { }; zn.useDeferredValue = function (n) { return Qa.current.useDeferredValue(n) }; zn.useEffect = function (n, e) { return Qa.current.useEffect(n, e) }; zn.useId = function () { return Qa.current.useId() }; zn.useImperativeHandle = function (n, e, t) { return Qa.current.useImperativeHandle(n, e, t) }; zn.useInsertionEffect = function (n, e) { return Qa.current.useInsertionEffect(n, e) }; zn.useLayoutEffect = function (n, e) { return Qa.current.useLayoutEffect(n, e) }; zn.useMemo = function (n, e) { return Qa.current.useMemo(n, e) }; zn.useReducer = function (n, e, t) { return Qa.current.useReducer(n, e, t) }; zn.useRef = function (n) { return Qa.current.useRef(n) }; zn.useState = function (n) { return Qa.current.useState(n) }; zn.useSyncExternalStore = function (n, e, t) { return Qa.current.useSyncExternalStore(n, e, t) }; zn.useTransition = function () { return Qa.current.useTransition() }; zn.version = "18.2.0"; vD.exports = zn; var ue = vD.exports; const mr = By(ue);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var uz = ue, cz = Symbol.for("react.element"), fz = Symbol.for("react.fragment"), hz = Object.prototype.hasOwnProperty, dz = uz.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, pz = { key: !0, ref: !0, __self: !0, __source: !0 }; function wD(n, e, t) { var r, i = {}, s = null, a = null; t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (a = e.ref); for (r in e) hz.call(e, r) && !pz.hasOwnProperty(r) && (i[r] = e[r]); if (n && n.defaultProps) for (r in e = n.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: cz, type: n, key: s, ref: a, props: i, _owner: dz.current } } Ry.Fragment = fz; Ry.jsx = wD; Ry.jsxs = wD; AD.exports = Ry; var re = AD.exports, eE = {}, ID = { exports: {} }, jo = {}, MD = { exports: {} }, bD = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(L, Q) { var D = L.length; L.push(Q); e: for (; 0 < D;) { var V = D - 1 >>> 1, J = L[V]; if (0 < i(J, Q)) L[V] = Q, L[D] = J, D = V; else break e } } function t(L) { return L.length === 0 ? null : L[0] } function r(L) { if (L.length === 0) return null; var Q = L[0], D = L.pop(); if (D !== Q) { L[0] = D; e: for (var V = 0, J = L.length, Ee = J >>> 1; V < Ee;) { var xe = 2 * (V + 1) - 1, Be = L[xe], Fe = xe + 1, we = L[Fe]; if (0 > i(Be, D)) Fe < J && 0 > i(we, Be) ? (L[V] = we, L[Fe] = D, V = Fe) : (L[V] = Be, L[xe] = D, V = xe); else if (Fe < J && 0 > i(we, D)) L[V] = we, L[Fe] = D, V = Fe; else break e } } return Q } function i(L, Q) { var D = L.sortIndex - Q.sortIndex; return D !== 0 ? D : L.id - Q.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var a = Date, o = a.now(); n.unstable_now = function () { return a.now() - o } } var l = [], u = [], c = 1, h = null, d = 3, m = !1, g = !1, v = !1, y = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function x(L) { for (var Q = t(u); Q !== null;) { if (Q.callback === null) r(u); else if (Q.startTime <= L) r(u), Q.sortIndex = Q.expirationTime, e(l, Q); else break; Q = t(u) } } function C(L) { if (v = !1, x(L), !g) if (t(l) !== null) g = !0, ne(T); else { var Q = t(u); Q !== null && $(C, Q.startTime - L) } } function T(L, Q) { g = !1, v && (v = !1, A(R), R = -1), m = !0; var D = d; try { for (x(Q), h = t(l); h !== null && (!(h.expirationTime > Q) || L && !F());) { var V = h.callback; if (typeof V == "function") { h.callback = null, d = h.priorityLevel; var J = V(h.expirationTime <= Q); Q = n.unstable_now(), typeof J == "function" ? h.callback = J : h === t(l) && r(l), x(Q) } else r(l); h = t(l) } if (h !== null) var Ee = !0; else { var xe = t(u); xe !== null && $(C, xe.startTime - Q), Ee = !1 } return Ee } finally { h = null, d = D, m = !1 } } var I = !1, w = null, R = -1, b = 5, B = -1; function F() { return !(n.unstable_now() - B < b) } function U() { if (w !== null) { var L = n.unstable_now(); B = L; var Q = !0; try { Q = w(!0, L) } finally { Q ? G() : (I = !1, w = null) } } else I = !1 } var G; if (typeof _ == "function") G = function () { _(U) }; else if (typeof MessageChannel < "u") { var Y = new MessageChannel, Z = Y.port2; Y.port1.onmessage = U, G = function () { Z.postMessage(null) } } else G = function () { y(U, 0) }; function ne(L) { w = L, I || (I = !0, G()) } function $(L, Q) { R = y(function () { L(n.unstable_now()) }, Q) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (L) { L.callback = null }, n.unstable_continueExecution = function () { g || m || (g = !0, ne(T)) }, n.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < L ? Math.floor(1e3 / L) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return d }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (L) { switch (d) { case 1: case 2: case 3: var Q = 3; break; default: Q = d }var D = d; d = Q; try { return L() } finally { d = D } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (L, Q) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var D = d; d = L; try { return Q() } finally { d = D } }, n.unstable_scheduleCallback = function (L, Q, D) { var V = n.unstable_now(); switch (typeof D == "object" && D !== null ? (D = D.delay, D = typeof D == "number" && 0 < D ? V + D : V) : D = V, L) { case 1: var J = -1; break; case 2: J = 250; break; case 5: J = 1073741823; break; case 4: J = 1e4; break; default: J = 5e3 }return J = D + J, L = { id: c++, callback: Q, priorityLevel: L, startTime: D, expirationTime: J, sortIndex: -1 }, D > V ? (L.sortIndex = D, e(u, L), t(l) === null && L === t(u) && (v ? (A(R), R = -1) : v = !0, $(C, D - V))) : (L.sortIndex = J, e(l, L), g || m || (g = !0, ne(T))), L }, n.unstable_shouldYield = F, n.unstable_wrapCallback = function (L) { var Q = d; return function () { var D = d; d = Q; try { return L.apply(this, arguments) } finally { d = D } } } })(bD); MD.exports = bD; var mz = MD.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var BD = ue, Ho = mz; function Ze(n) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1; t < arguments.length; t++)e += "&args[]=" + encodeURIComponent(arguments[t]); return "Minified React error #" + n + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var RD = new Set, gA = {}; function Lp(n, e) { k3(n, e), k3(n + "Capture", e) } function k3(n, e) { for (gA[n] = e, n = 0; n < e.length; n++)RD.add(e[n]) } var of = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), tE = Object.prototype.hasOwnProperty, gz = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Yw = {}, jw = {}; function Az(n) { return tE.call(jw, n) ? !0 : tE.call(Yw, n) ? !1 : gz.test(n) ? jw[n] = !0 : (Yw[n] = !0, !1) } function vz(n, e, t, r) { if (t !== null && t.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : t !== null ? !t.acceptsBooleans : (n = n.toLowerCase().slice(0, 5), n !== "data-" && n !== "aria-"); default: return !1 } } function yz(n, e, t, r) { if (e === null || typeof e > "u" || vz(n, e, t, r)) return !0; if (r) return !1; if (t !== null) switch (t.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function Ha(n, e, t, r, i, s, a) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = t, this.propertyName = n, this.type = e, this.sanitizeURL = s, this.removeEmptyString = a } var $s = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (n) { $s[n] = new Ha(n, 0, !1, n, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (n) { var e = n[0]; $s[e] = new Ha(e, 1, !1, n[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) { $s[n] = new Ha(n, 2, !1, n.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (n) { $s[n] = new Ha(n, 2, !1, n, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (n) { $s[n] = new Ha(n, 3, !1, n.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (n) { $s[n] = new Ha(n, 3, !0, n, null, !1, !1) });["capture", "download"].forEach(function (n) { $s[n] = new Ha(n, 4, !1, n, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (n) { $s[n] = new Ha(n, 6, !1, n, null, !1, !1) });["rowSpan", "start"].forEach(function (n) { $s[n] = new Ha(n, 5, !1, n.toLowerCase(), null, !1, !1) }); var $7 = /[\-:]([a-z])/g; function eC(n) { return n[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (n) { var e = n.replace($7, eC); $s[e] = new Ha(e, 1, !1, n, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (n) { var e = n.replace($7, eC); $s[e] = new Ha(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (n) { var e = n.replace($7, eC); $s[e] = new Ha(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (n) { $s[n] = new Ha(n, 1, !1, n.toLowerCase(), null, !1, !1) }); $s.xlinkHref = new Ha("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (n) { $s[n] = new Ha(n, 1, !1, n.toLowerCase(), null, !0, !0) }); function tC(n, e, t, r) { var i = $s.hasOwnProperty(e) ? $s[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (yz(e, t, i, r) && (t = null), r || i === null ? Az(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t)) : i.mustUseProperty ? n[i.propertyName] = t === null ? i.type === 3 ? !1 : "" : t : (e = i.attributeName, r = i.attributeNamespace, t === null ? n.removeAttribute(e) : (i = i.type, t = i === 3 || i === 4 && t === !0 ? "" : "" + t, r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t)))) } var xf = BD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, U2 = Symbol.for("react.element"), z0 = Symbol.for("react.portal"), V0 = Symbol.for("react.fragment"), nC = Symbol.for("react.strict_mode"), nE = Symbol.for("react.profiler"), PD = Symbol.for("react.provider"), DD = Symbol.for("react.context"), rC = Symbol.for("react.forward_ref"), rE = Symbol.for("react.suspense"), iE = Symbol.for("react.suspense_list"), iC = Symbol.for("react.memo"), qf = Symbol.for("react.lazy"), LD = Symbol.for("react.offscreen"), Jw = Symbol.iterator; function Gm(n) { return n === null || typeof n != "object" ? null : (n = Jw && n[Jw] || n["@@iterator"], typeof n == "function" ? n : null) } var yi = Object.assign, N4; function xg(n) {
		if (N4 === void 0) try { throw Error() } catch (t) { var e = t.stack.trim().match(/\n( *(at )?)/); N4 = e && e[1] || "" } return `
`+ N4 + n
	} var O4 = !1; function U4(n, e) {
		if (!n || O4) return ""; O4 = !0; var t = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var r = u } Reflect.construct(n, [], e) } else { try { e.call() } catch (u) { r = u } n.call(e.prototype) } else { try { throw Error() } catch (u) { r = u } n() } } catch (u) {
			if (u && r && typeof u.stack == "string") {
				for (var i = u.stack.split(`
`), s = r.stack.split(`
`), a = i.length - 1, o = s.length - 1; 1 <= a && 0 <= o && i[a] !== s[o];)o--; for (; 1 <= a && 0 <= o; a--, o--)if (i[a] !== s[o]) {
					if (a !== 1 || o !== 1) do if (a--, o--, 0 > o || i[a] !== s[o]) {
						var l = `
`+ i[a].replace(" at new ", " at "); return n.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n.displayName)), l
					} while (1 <= a && 0 <= o); break
				}
			}
		} finally { O4 = !1, Error.prepareStackTrace = t } return (n = n ? n.displayName || n.name : "") ? xg(n) : ""
	} function xz(n) { switch (n.tag) { case 5: return xg(n.type); case 16: return xg("Lazy"); case 13: return xg("Suspense"); case 19: return xg("SuspenseList"); case 0: case 2: case 15: return n = U4(n.type, !1), n; case 11: return n = U4(n.type.render, !1), n; case 1: return n = U4(n.type, !0), n; default: return "" } } function sE(n) { if (n == null) return null; if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n; switch (n) { case V0: return "Fragment"; case z0: return "Portal"; case nE: return "Profiler"; case nC: return "StrictMode"; case rE: return "Suspense"; case iE: return "SuspenseList" }if (typeof n == "object") switch (n.$$typeof) { case DD: return (n.displayName || "Context") + ".Consumer"; case PD: return (n._context.displayName || "Context") + ".Provider"; case rC: var e = n.render; return n = n.displayName, n || (n = e.displayName || e.name || "", n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"), n; case iC: return e = n.displayName || null, e !== null ? e : sE(n.type) || "Memo"; case qf: e = n._payload, n = n._init; try { return sE(n(e)) } catch { } }return null } function _z(n) { var e = n.type; switch (n.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return n = e.render, n = n.displayName || n.name || "", e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return sE(e); case 8: return e === nC ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function wh(n) { switch (typeof n) { case "boolean": case "number": case "string": case "undefined": return n; case "object": return n; default: return "" } } function FD(n) { var e = n.type; return (n = n.nodeName) && n.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function Ez(n) { var e = FD(n) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e), r = "" + n[e]; if (!n.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") { var i = t.get, s = t.set; return Object.defineProperty(n, e, { configurable: !0, get: function () { return i.call(this) }, set: function (a) { r = "" + a, s.call(this, a) } }), Object.defineProperty(n, e, { enumerable: t.enumerable }), { getValue: function () { return r }, setValue: function (a) { r = "" + a }, stopTracking: function () { n._valueTracker = null, delete n[e] } } } } function G2(n) { n._valueTracker || (n._valueTracker = Ez(n)) } function kD(n) { if (!n) return !1; var e = n._valueTracker; if (!e) return !0; var t = e.getValue(), r = ""; return n && (r = FD(n) ? n.checked ? "true" : "false" : n.value), n = r, n !== t ? (e.setValue(n), !0) : !1 } function y6(n) { if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u") return null; try { return n.activeElement || n.body } catch { return n.body } } function aE(n, e) { var t = e.checked; return yi({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n._wrapperState.initialChecked }) } function Kw(n, e) { var t = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; t = wh(e.value != null ? e.value : t), n._wrapperState = { initialChecked: r, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function ND(n, e) { e = e.checked, e != null && tC(n, "checked", e, !1) } function oE(n, e) { ND(n, e); var t = wh(e.value), r = e.type; if (t != null) r === "number" ? (t === 0 && n.value === "" || n.value != t) && (n.value = "" + t) : n.value !== "" + t && (n.value = "" + t); else if (r === "submit" || r === "reset") { n.removeAttribute("value"); return } e.hasOwnProperty("value") ? lE(n, e.type, t) : e.hasOwnProperty("defaultValue") && lE(n, e.type, wh(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n.defaultChecked = !!e.defaultChecked) } function qw(n, e, t) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + n._wrapperState.initialValue, t || e === n.value || (n.value = e), n.defaultValue = e } t = n.name, t !== "" && (n.name = ""), n.defaultChecked = !!n._wrapperState.initialChecked, t !== "" && (n.name = t) } function lE(n, e, t) { (e !== "number" || y6(n.ownerDocument) !== n) && (t == null ? n.defaultValue = "" + n._wrapperState.initialValue : n.defaultValue !== "" + t && (n.defaultValue = "" + t)) } var _g = Array.isArray; function p3(n, e, t, r) { if (n = n.options, e) { e = {}; for (var i = 0; i < t.length; i++)e["$" + t[i]] = !0; for (t = 0; t < n.length; t++)i = e.hasOwnProperty("$" + n[t].value), n[t].selected !== i && (n[t].selected = i), i && r && (n[t].defaultSelected = !0) } else { for (t = "" + wh(t), e = null, i = 0; i < n.length; i++) { if (n[i].value === t) { n[i].selected = !0, r && (n[i].defaultSelected = !0); return } e !== null || n[i].disabled || (e = n[i]) } e !== null && (e.selected = !0) } } function uE(n, e) { if (e.dangerouslySetInnerHTML != null) throw Error(Ze(91)); return yi({}, e, { value: void 0, defaultValue: void 0, children: "" + n._wrapperState.initialValue }) } function Zw(n, e) { var t = e.value; if (t == null) { if (t = e.children, e = e.defaultValue, t != null) { if (e != null) throw Error(Ze(92)); if (_g(t)) { if (1 < t.length) throw Error(Ze(93)); t = t[0] } e = t } e == null && (e = ""), t = e } n._wrapperState = { initialValue: wh(t) } } function OD(n, e) { var t = wh(e.value), r = wh(e.defaultValue); t != null && (t = "" + t, t !== n.value && (n.value = t), e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)), r != null && (n.defaultValue = "" + r) } function $w(n) { var e = n.textContent; e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e) } function UD(n) { switch (n) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function cE(n, e) { return n == null || n === "http://www.w3.org/1999/xhtml" ? UD(e) : n === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n } var Q2, GD = function (n) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, t, r, i) { MSApp.execUnsafeLocalFunction(function () { return n(e, t, r, i) }) } : n }(function (n, e) { if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n) n.innerHTML = e; else { for (Q2 = Q2 || document.createElement("div"), Q2.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Q2.firstChild; n.firstChild;)n.removeChild(n.firstChild); for (; e.firstChild;)n.appendChild(e.firstChild) } }); function AA(n, e) { if (e) { var t = n.firstChild; if (t && t === n.lastChild && t.nodeType === 3) { t.nodeValue = e; return } } n.textContent = e } var Ng = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Cz = ["Webkit", "ms", "Moz", "O"]; Object.keys(Ng).forEach(function (n) { Cz.forEach(function (e) { e = e + n.charAt(0).toUpperCase() + n.substring(1), Ng[e] = Ng[n] }) }); function QD(n, e, t) { return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Ng.hasOwnProperty(n) && Ng[n] ? ("" + e).trim() : e + "px" } function HD(n, e) { n = n.style; for (var t in e) if (e.hasOwnProperty(t)) { var r = t.indexOf("--") === 0, i = QD(t, e[t], r); t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : n[t] = i } } var Sz = yi({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function fE(n, e) { if (e) { if (Sz[n] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Ze(137, n)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(Ze(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Ze(61)) } if (e.style != null && typeof e.style != "object") throw Error(Ze(62)) } } function hE(n, e) { if (n.indexOf("-") === -1) return typeof e.is == "string"; switch (n) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var dE = null; function sC(n) { return n = n.target || n.srcElement || window, n.correspondingUseElement && (n = n.correspondingUseElement), n.nodeType === 3 ? n.parentNode : n } var pE = null, m3 = null, g3 = null; function eI(n) { if (n = S1(n)) { if (typeof pE != "function") throw Error(Ze(280)); var e = n.stateNode; e && (e = ky(e), pE(n.stateNode, n.type, e)) } } function zD(n) { m3 ? g3 ? g3.push(n) : g3 = [n] : m3 = n } function VD() { if (m3) { var n = m3, e = g3; if (g3 = m3 = null, eI(n), e) for (n = 0; n < e.length; n++)eI(e[n]) } } function WD(n, e) { return n(e) } function XD() { } var G4 = !1; function YD(n, e, t) { if (G4) return n(e, t); G4 = !0; try { return WD(n, e, t) } finally { G4 = !1, (m3 !== null || g3 !== null) && (XD(), VD()) } } function vA(n, e) { var t = n.stateNode; if (t === null) return null; var r = ky(t); if (r === null) return null; t = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (n = n.type, r = !(n === "button" || n === "input" || n === "select" || n === "textarea")), n = !r; break e; default: n = !1 }if (n) return null; if (t && typeof t != "function") throw Error(Ze(231, e, typeof t)); return t } var mE = !1; if (of) try { var Qm = {}; Object.defineProperty(Qm, "passive", { get: function () { mE = !0 } }), window.addEventListener("test", Qm, Qm), window.removeEventListener("test", Qm, Qm) } catch { mE = !1 } function Tz(n, e, t, r, i, s, a, o, l) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(t, u) } catch (c) { this.onError(c) } } var Og = !1, x6 = null, _6 = !1, gE = null, wz = { onError: function (n) { Og = !0, x6 = n } }; function Iz(n, e, t, r, i, s, a, o, l) { Og = !1, x6 = null, Tz.apply(wz, arguments) } function Mz(n, e, t, r, i, s, a, o, l) { if (Iz.apply(this, arguments), Og) { if (Og) { var u = x6; Og = !1, x6 = null } else throw Error(Ze(198)); _6 || (_6 = !0, gE = u) } } function Fp(n) { var e = n, t = n; if (n.alternate) for (; e.return;)e = e.return; else { n = e; do e = n, e.flags & 4098 && (t = e.return), n = e.return; while (n) } return e.tag === 3 ? t : null } function jD(n) { if (n.tag === 13) { var e = n.memoizedState; if (e === null && (n = n.alternate, n !== null && (e = n.memoizedState)), e !== null) return e.dehydrated } return null } function tI(n) { if (Fp(n) !== n) throw Error(Ze(188)) } function bz(n) { var e = n.alternate; if (!e) { if (e = Fp(n), e === null) throw Error(Ze(188)); return e !== n ? null : n } for (var t = n, r = e; ;) { var i = t.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { t = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === t) return tI(i), n; if (s === r) return tI(i), e; s = s.sibling } throw Error(Ze(188)) } if (t.return !== r.return) t = i, r = s; else { for (var a = !1, o = i.child; o;) { if (o === t) { a = !0, t = i, r = s; break } if (o === r) { a = !0, r = i, t = s; break } o = o.sibling } if (!a) { for (o = s.child; o;) { if (o === t) { a = !0, t = s, r = i; break } if (o === r) { a = !0, r = s, t = i; break } o = o.sibling } if (!a) throw Error(Ze(189)) } } if (t.alternate !== r) throw Error(Ze(190)) } if (t.tag !== 3) throw Error(Ze(188)); return t.stateNode.current === t ? n : e } function JD(n) { return n = bz(n), n !== null ? KD(n) : null } function KD(n) { if (n.tag === 5 || n.tag === 6) return n; for (n = n.child; n !== null;) { var e = KD(n); if (e !== null) return e; n = n.sibling } return null } var qD = Ho.unstable_scheduleCallback, nI = Ho.unstable_cancelCallback, Bz = Ho.unstable_shouldYield, Rz = Ho.unstable_requestPaint, Vi = Ho.unstable_now, Pz = Ho.unstable_getCurrentPriorityLevel, aC = Ho.unstable_ImmediatePriority, ZD = Ho.unstable_UserBlockingPriority, E6 = Ho.unstable_NormalPriority, Dz = Ho.unstable_LowPriority, $D = Ho.unstable_IdlePriority, Py = null, ec = null; function Lz(n) { if (ec && typeof ec.onCommitFiberRoot == "function") try { ec.onCommitFiberRoot(Py, n, void 0, (n.current.flags & 128) === 128) } catch { } } var du = Math.clz32 ? Math.clz32 : Nz, Fz = Math.log, kz = Math.LN2; function Nz(n) { return n >>>= 0, n === 0 ? 32 : 31 - (Fz(n) / kz | 0) | 0 } var H2 = 64, z2 = 4194304; function Eg(n) { switch (n & -n) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return n & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return n } } function C6(n, e) { var t = n.pendingLanes; if (t === 0) return 0; var r = 0, i = n.suspendedLanes, s = n.pingedLanes, a = t & 268435455; if (a !== 0) { var o = a & ~i; o !== 0 ? r = Eg(o) : (s &= a, s !== 0 && (r = Eg(s))) } else a = t & ~i, a !== 0 ? r = Eg(a) : s !== 0 && (r = Eg(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= t & 16), e = n.entangledLanes, e !== 0) for (n = n.entanglements, e &= r; 0 < e;)t = 31 - du(e), i = 1 << t, r |= n[t], e &= ~i; return r } function Oz(n, e) { switch (n) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Uz(n, e) { for (var t = n.suspendedLanes, r = n.pingedLanes, i = n.expirationTimes, s = n.pendingLanes; 0 < s;) { var a = 31 - du(s), o = 1 << a, l = i[a]; l === -1 ? (!(o & t) || o & r) && (i[a] = Oz(o, e)) : l <= e && (n.expiredLanes |= o), s &= ~o } } function AE(n) { return n = n.pendingLanes & -1073741825, n !== 0 ? n : n & 1073741824 ? 1073741824 : 0 } function eL() { var n = H2; return H2 <<= 1, !(H2 & 4194240) && (H2 = 64), n } function Q4(n) { for (var e = [], t = 0; 31 > t; t++)e.push(n); return e } function E1(n, e, t) { n.pendingLanes |= e, e !== 536870912 && (n.suspendedLanes = 0, n.pingedLanes = 0), n = n.eventTimes, e = 31 - du(e), n[e] = t } function Gz(n, e) { var t = n.pendingLanes & ~e; n.pendingLanes = e, n.suspendedLanes = 0, n.pingedLanes = 0, n.expiredLanes &= e, n.mutableReadLanes &= e, n.entangledLanes &= e, e = n.entanglements; var r = n.eventTimes; for (n = n.expirationTimes; 0 < t;) { var i = 31 - du(t), s = 1 << i; e[i] = 0, r[i] = -1, n[i] = -1, t &= ~s } } function oC(n, e) { var t = n.entangledLanes |= e; for (n = n.entanglements; t;) { var r = 31 - du(t), i = 1 << r; i & e | n[r] & e && (n[r] |= e), t &= ~i } } var Ar = 0; function tL(n) { return n &= -n, 1 < n ? 4 < n ? n & 268435455 ? 16 : 536870912 : 4 : 1 } var nL, lC, rL, iL, sL, vE = !1, V2 = [], fh = null, hh = null, dh = null, yA = new Map, xA = new Map, eh = [], Qz = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function rI(n, e) { switch (n) { case "focusin": case "focusout": fh = null; break; case "dragenter": case "dragleave": hh = null; break; case "mouseover": case "mouseout": dh = null; break; case "pointerover": case "pointerout": yA.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": xA.delete(e.pointerId) } } function Hm(n, e, t, r, i, s) { return n === null || n.nativeEvent !== s ? (n = { blockedOn: e, domEventName: t, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = S1(e), e !== null && lC(e)), n) : (n.eventSystemFlags |= r, e = n.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), n) } function Hz(n, e, t, r, i) { switch (e) { case "focusin": return fh = Hm(fh, n, e, t, r, i), !0; case "dragenter": return hh = Hm(hh, n, e, t, r, i), !0; case "mouseover": return dh = Hm(dh, n, e, t, r, i), !0; case "pointerover": var s = i.pointerId; return yA.set(s, Hm(yA.get(s) || null, n, e, t, r, i)), !0; case "gotpointercapture": return s = i.pointerId, xA.set(s, Hm(xA.get(s) || null, n, e, t, r, i)), !0 }return !1 } function aL(n) { var e = Hd(n.target); if (e !== null) { var t = Fp(e); if (t !== null) { if (e = t.tag, e === 13) { if (e = jD(t), e !== null) { n.blockedOn = e, sL(n.priority, function () { rL(t) }); return } } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) { n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null; return } } } n.blockedOn = null } function N5(n) { if (n.blockedOn !== null) return !1; for (var e = n.targetContainers; 0 < e.length;) { var t = yE(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent); if (t === null) { t = n.nativeEvent; var r = new t.constructor(t.type, t); dE = r, t.target.dispatchEvent(r), dE = null } else return e = S1(t), e !== null && lC(e), n.blockedOn = t, !1; e.shift() } return !0 } function iI(n, e, t) { N5(n) && t.delete(e) } function zz() { vE = !1, fh !== null && N5(fh) && (fh = null), hh !== null && N5(hh) && (hh = null), dh !== null && N5(dh) && (dh = null), yA.forEach(iI), xA.forEach(iI) } function zm(n, e) { n.blockedOn === e && (n.blockedOn = null, vE || (vE = !0, Ho.unstable_scheduleCallback(Ho.unstable_NormalPriority, zz))) } function _A(n) { function e(i) { return zm(i, n) } if (0 < V2.length) { zm(V2[0], n); for (var t = 1; t < V2.length; t++) { var r = V2[t]; r.blockedOn === n && (r.blockedOn = null) } } for (fh !== null && zm(fh, n), hh !== null && zm(hh, n), dh !== null && zm(dh, n), yA.forEach(e), xA.forEach(e), t = 0; t < eh.length; t++)r = eh[t], r.blockedOn === n && (r.blockedOn = null); for (; 0 < eh.length && (t = eh[0], t.blockedOn === null);)aL(t), t.blockedOn === null && eh.shift() } var A3 = xf.ReactCurrentBatchConfig, S6 = !0; function Vz(n, e, t, r) { var i = Ar, s = A3.transition; A3.transition = null; try { Ar = 1, uC(n, e, t, r) } finally { Ar = i, A3.transition = s } } function Wz(n, e, t, r) { var i = Ar, s = A3.transition; A3.transition = null; try { Ar = 4, uC(n, e, t, r) } finally { Ar = i, A3.transition = s } } function uC(n, e, t, r) { if (S6) { var i = yE(n, e, t, r); if (i === null) q4(n, e, r, T6, t), rI(n, r); else if (Hz(i, n, e, t, r)) r.stopPropagation(); else if (rI(n, r), e & 4 && -1 < Qz.indexOf(n)) { for (; i !== null;) { var s = S1(i); if (s !== null && nL(s), s = yE(n, e, t, r), s === null && q4(n, e, r, T6, t), s === i) break; i = s } i !== null && r.stopPropagation() } else q4(n, e, r, null, t) } } var T6 = null; function yE(n, e, t, r) { if (T6 = null, n = sC(r), n = Hd(n), n !== null) if (e = Fp(n), e === null) n = null; else if (t = e.tag, t === 13) { if (n = jD(e), n !== null) return n; n = null } else if (t === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; n = null } else e !== n && (n = null); return T6 = n, null } function oL(n) { switch (n) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Pz()) { case aC: return 1; case ZD: return 4; case E6: case Dz: return 16; case $D: return 536870912; default: return 16 }default: return 16 } } var nh = null, cC = null, O5 = null; function lL() { if (O5) return O5; var n, e = cC, t = e.length, r, i = "value" in nh ? nh.value : nh.textContent, s = i.length; for (n = 0; n < t && e[n] === i[n]; n++); var a = t - n; for (r = 1; r <= a && e[t - r] === i[s - r]; r++); return O5 = i.slice(n, 1 < r ? 1 - r : void 0) } function U5(n) { var e = n.keyCode; return "charCode" in n ? (n = n.charCode, n === 0 && e === 13 && (n = 13)) : n = e, n === 10 && (n = 13), 32 <= n || n === 13 ? n : 0 } function W2() { return !0 } function sI() { return !1 } function Jo(n) { function e(t, r, i, s, a) { this._reactName = t, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = a, this.currentTarget = null; for (var o in n) n.hasOwnProperty(o) && (t = n[o], this[o] = t ? t(s) : s[o]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? W2 : sI, this.isPropagationStopped = sI, this } return yi(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var t = this.nativeEvent; t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1), this.isDefaultPrevented = W2) }, stopPropagation: function () { var t = this.nativeEvent; t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0), this.isPropagationStopped = W2) }, persist: function () { }, isPersistent: W2 }), e } var pm = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (n) { return n.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, fC = Jo(pm), C1 = yi({}, pm, { view: 0, detail: 0 }), Xz = Jo(C1), H4, z4, Vm, Dy = yi({}, C1, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: hC, button: 0, buttons: 0, relatedTarget: function (n) { return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget }, movementX: function (n) { return "movementX" in n ? n.movementX : (n !== Vm && (Vm && n.type === "mousemove" ? (H4 = n.screenX - Vm.screenX, z4 = n.screenY - Vm.screenY) : z4 = H4 = 0, Vm = n), H4) }, movementY: function (n) { return "movementY" in n ? n.movementY : z4 } }), aI = Jo(Dy), Yz = yi({}, Dy, { dataTransfer: 0 }), jz = Jo(Yz), Jz = yi({}, C1, { relatedTarget: 0 }), V4 = Jo(Jz), Kz = yi({}, pm, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), qz = Jo(Kz), Zz = yi({}, pm, { clipboardData: function (n) { return "clipboardData" in n ? n.clipboardData : window.clipboardData } }), $z = Jo(Zz), eV = yi({}, pm, { data: 0 }), oI = Jo(eV), tV = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, nV = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, rV = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function iV(n) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(n) : (n = rV[n]) ? !!e[n] : !1 } function hC() { return iV } var sV = yi({}, C1, { key: function (n) { if (n.key) { var e = tV[n.key] || n.key; if (e !== "Unidentified") return e } return n.type === "keypress" ? (n = U5(n), n === 13 ? "Enter" : String.fromCharCode(n)) : n.type === "keydown" || n.type === "keyup" ? nV[n.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: hC, charCode: function (n) { return n.type === "keypress" ? U5(n) : 0 }, keyCode: function (n) { return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 }, which: function (n) { return n.type === "keypress" ? U5(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0 } }), aV = Jo(sV), oV = yi({}, Dy, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), lI = Jo(oV), lV = yi({}, C1, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: hC }), uV = Jo(lV), cV = yi({}, pm, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), fV = Jo(cV), hV = yi({}, Dy, { deltaX: function (n) { return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0 }, deltaY: function (n) { return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), dV = Jo(hV), pV = [9, 13, 27, 32], dC = of && "CompositionEvent" in window, Ug = null; of && "documentMode" in document && (Ug = document.documentMode); var mV = of && "TextEvent" in window && !Ug, uL = of && (!dC || Ug && 8 < Ug && 11 >= Ug), uI = String.fromCharCode(32), cI = !1; function cL(n, e) { switch (n) { case "keyup": return pV.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function fL(n) { return n = n.detail, typeof n == "object" && "data" in n ? n.data : null } var W0 = !1; function gV(n, e) { switch (n) { case "compositionend": return fL(e); case "keypress": return e.which !== 32 ? null : (cI = !0, uI); case "textInput": return n = e.data, n === uI && cI ? null : n; default: return null } } function AV(n, e) { if (W0) return n === "compositionend" || !dC && cL(n, e) ? (n = lL(), O5 = cC = nh = null, W0 = !1, n) : null; switch (n) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return uL && e.locale !== "ko" ? null : e.data; default: return null } } var vV = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function fI(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e === "input" ? !!vV[n.type] : e === "textarea" } function hL(n, e, t, r) { zD(r), e = w6(e, "onChange"), 0 < e.length && (t = new fC("onChange", "change", null, t, r), n.push({ event: t, listeners: e })) } var Gg = null, EA = null; function yV(n) { CL(n, 0) } function Ly(n) { var e = j0(n); if (kD(e)) return n } function xV(n, e) { if (n === "change") return e } var dL = !1; if (of) { var W4; if (of) { var X4 = "oninput" in document; if (!X4) { var hI = document.createElement("div"); hI.setAttribute("oninput", "return;"), X4 = typeof hI.oninput == "function" } W4 = X4 } else W4 = !1; dL = W4 && (!document.documentMode || 9 < document.documentMode) } function dI() { Gg && (Gg.detachEvent("onpropertychange", pL), EA = Gg = null) } function pL(n) { if (n.propertyName === "value" && Ly(EA)) { var e = []; hL(e, EA, n, sC(n)), YD(yV, e) } } function _V(n, e, t) { n === "focusin" ? (dI(), Gg = e, EA = t, Gg.attachEvent("onpropertychange", pL)) : n === "focusout" && dI() } function EV(n) { if (n === "selectionchange" || n === "keyup" || n === "keydown") return Ly(EA) } function CV(n, e) { if (n === "click") return Ly(e) } function SV(n, e) { if (n === "input" || n === "change") return Ly(e) } function TV(n, e) { return n === e && (n !== 0 || 1 / n === 1 / e) || n !== n && e !== e } var vu = typeof Object.is == "function" ? Object.is : TV; function CA(n, e) { if (vu(n, e)) return !0; if (typeof n != "object" || n === null || typeof e != "object" || e === null) return !1; var t = Object.keys(n), r = Object.keys(e); if (t.length !== r.length) return !1; for (r = 0; r < t.length; r++) { var i = t[r]; if (!tE.call(e, i) || !vu(n[i], e[i])) return !1 } return !0 } function pI(n) { for (; n && n.firstChild;)n = n.firstChild; return n } function mI(n, e) { var t = pI(n); n = 0; for (var r; t;) { if (t.nodeType === 3) { if (r = n + t.textContent.length, n <= e && r >= e) return { node: t, offset: e - n }; n = r } e: { for (; t;) { if (t.nextSibling) { t = t.nextSibling; break e } t = t.parentNode } t = void 0 } t = pI(t) } } function mL(n, e) { return n && e ? n === e ? !0 : n && n.nodeType === 3 ? !1 : e && e.nodeType === 3 ? mL(n, e.parentNode) : "contains" in n ? n.contains(e) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(e) & 16) : !1 : !1 } function gL() { for (var n = window, e = y6(); e instanceof n.HTMLIFrameElement;) { try { var t = typeof e.contentWindow.location.href == "string" } catch { t = !1 } if (t) n = e.contentWindow; else break; e = y6(n.document) } return e } function pC(n) { var e = n && n.nodeName && n.nodeName.toLowerCase(); return e && (e === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || e === "textarea" || n.contentEditable === "true") } function wV(n) { var e = gL(), t = n.focusedElem, r = n.selectionRange; if (e !== t && t && t.ownerDocument && mL(t.ownerDocument.documentElement, t)) { if (r !== null && pC(t)) { if (e = r.start, n = r.end, n === void 0 && (n = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n, t.value.length); else if (n = (e = t.ownerDocument || document) && e.defaultView || window, n.getSelection) { n = n.getSelection(); var i = t.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !n.extend && s > r && (i = r, r = s, s = i), i = mI(t, s); var a = mI(t, r); i && a && (n.rangeCount !== 1 || n.anchorNode !== i.node || n.anchorOffset !== i.offset || n.focusNode !== a.node || n.focusOffset !== a.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), n.removeAllRanges(), s > r ? (n.addRange(e), n.extend(a.node, a.offset)) : (e.setEnd(a.node, a.offset), n.addRange(e))) } } for (e = [], n = t; n = n.parentNode;)n.nodeType === 1 && e.push({ element: n, left: n.scrollLeft, top: n.scrollTop }); for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)n = e[t], n.element.scrollLeft = n.left, n.element.scrollTop = n.top } } var IV = of && "documentMode" in document && 11 >= document.documentMode, X0 = null, xE = null, Qg = null, _E = !1; function gI(n, e, t) { var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument; _E || X0 == null || X0 !== y6(r) || (r = X0, "selectionStart" in r && pC(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Qg && CA(Qg, r) || (Qg = r, r = w6(xE, "onSelect"), 0 < r.length && (e = new fC("onSelect", "select", null, e, t), n.push({ event: e, listeners: r }), e.target = X0))) } function X2(n, e) { var t = {}; return t[n.toLowerCase()] = e.toLowerCase(), t["Webkit" + n] = "webkit" + e, t["Moz" + n] = "moz" + e, t } var Y0 = { animationend: X2("Animation", "AnimationEnd"), animationiteration: X2("Animation", "AnimationIteration"), animationstart: X2("Animation", "AnimationStart"), transitionend: X2("Transition", "TransitionEnd") }, Y4 = {}, AL = {}; of && (AL = document.createElement("div").style, "AnimationEvent" in window || (delete Y0.animationend.animation, delete Y0.animationiteration.animation, delete Y0.animationstart.animation), "TransitionEvent" in window || delete Y0.transitionend.transition); function Fy(n) { if (Y4[n]) return Y4[n]; if (!Y0[n]) return n; var e = Y0[n], t; for (t in e) if (e.hasOwnProperty(t) && t in AL) return Y4[n] = e[t]; return n } var vL = Fy("animationend"), yL = Fy("animationiteration"), xL = Fy("animationstart"), _L = Fy("transitionend"), EL = new Map, AI = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function zh(n, e) { EL.set(n, e), Lp(e, [n]) } for (var j4 = 0; j4 < AI.length; j4++) { var J4 = AI[j4], MV = J4.toLowerCase(), bV = J4[0].toUpperCase() + J4.slice(1); zh(MV, "on" + bV) } zh(vL, "onAnimationEnd"); zh(yL, "onAnimationIteration"); zh(xL, "onAnimationStart"); zh("dblclick", "onDoubleClick"); zh("focusin", "onFocus"); zh("focusout", "onBlur"); zh(_L, "onTransitionEnd"); k3("onMouseEnter", ["mouseout", "mouseover"]); k3("onMouseLeave", ["mouseout", "mouseover"]); k3("onPointerEnter", ["pointerout", "pointerover"]); k3("onPointerLeave", ["pointerout", "pointerover"]); Lp("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Lp("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Lp("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Lp("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Lp("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Lp("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Cg = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), BV = new Set("cancel close invalid load scroll toggle".split(" ").concat(Cg)); function vI(n, e, t) { var r = n.type || "unknown-event"; n.currentTarget = t, Mz(r, e, void 0, n), n.currentTarget = null } function CL(n, e) { e = (e & 4) !== 0; for (var t = 0; t < n.length; t++) { var r = n[t], i = r.event; r = r.listeners; e: { var s = void 0; if (e) for (var a = r.length - 1; 0 <= a; a--) { var o = r[a], l = o.instance, u = o.currentTarget; if (o = o.listener, l !== s && i.isPropagationStopped()) break e; vI(i, o, u), s = l } else for (a = 0; a < r.length; a++) { if (o = r[a], l = o.instance, u = o.currentTarget, o = o.listener, l !== s && i.isPropagationStopped()) break e; vI(i, o, u), s = l } } } if (_6) throw n = gE, _6 = !1, gE = null, n } function Kr(n, e) { var t = e[wE]; t === void 0 && (t = e[wE] = new Set); var r = n + "__bubble"; t.has(r) || (SL(e, n, 2, !1), t.add(r)) } function K4(n, e, t) { var r = 0; e && (r |= 4), SL(t, n, r, e) } var Y2 = "_reactListening" + Math.random().toString(36).slice(2); function SA(n) { if (!n[Y2]) { n[Y2] = !0, RD.forEach(function (t) { t !== "selectionchange" && (BV.has(t) || K4(t, !1, n), K4(t, !0, n)) }); var e = n.nodeType === 9 ? n : n.ownerDocument; e === null || e[Y2] || (e[Y2] = !0, K4("selectionchange", !1, e)) } } function SL(n, e, t, r) { switch (oL(e)) { case 1: var i = Vz; break; case 4: i = Wz; break; default: i = uC }t = i.bind(null, e, t, n), i = void 0, !mE || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? n.addEventListener(e, t, { capture: !0, passive: i }) : n.addEventListener(e, t, !0) : i !== void 0 ? n.addEventListener(e, t, { passive: i }) : n.addEventListener(e, t, !1) } function q4(n, e, t, r, i) { var s = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var a = r.tag; if (a === 3 || a === 4) { var o = r.stateNode.containerInfo; if (o === i || o.nodeType === 8 && o.parentNode === i) break; if (a === 4) for (a = r.return; a !== null;) { var l = a.tag; if ((l === 3 || l === 4) && (l = a.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; a = a.return } for (; o !== null;) { if (a = Hd(o), a === null) return; if (l = a.tag, l === 5 || l === 6) { r = s = a; continue e } o = o.parentNode } } r = r.return } YD(function () { var u = s, c = sC(t), h = []; e: { var d = EL.get(n); if (d !== void 0) { var m = fC, g = n; switch (n) { case "keypress": if (U5(t) === 0) break e; case "keydown": case "keyup": m = aV; break; case "focusin": g = "focus", m = V4; break; case "focusout": g = "blur", m = V4; break; case "beforeblur": case "afterblur": m = V4; break; case "click": if (t.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": m = aI; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": m = jz; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": m = uV; break; case vL: case yL: case xL: m = qz; break; case _L: m = fV; break; case "scroll": m = Xz; break; case "wheel": m = dV; break; case "copy": case "cut": case "paste": m = $z; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": m = lI }var v = (e & 4) !== 0, y = !v && n === "scroll", A = v ? d !== null ? d + "Capture" : null : d; v = []; for (var _ = u, x; _ !== null;) { x = _; var C = x.stateNode; if (x.tag === 5 && C !== null && (x = C, A !== null && (C = vA(_, A), C != null && v.push(TA(_, C, x)))), y) break; _ = _.return } 0 < v.length && (d = new m(d, g, null, t, c), h.push({ event: d, listeners: v })) } } if (!(e & 7)) { e: { if (d = n === "mouseover" || n === "pointerover", m = n === "mouseout" || n === "pointerout", d && t !== dE && (g = t.relatedTarget || t.fromElement) && (Hd(g) || g[lf])) break e; if ((m || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, m ? (g = t.relatedTarget || t.toElement, m = u, g = g ? Hd(g) : null, g !== null && (y = Fp(g), g !== y || g.tag !== 5 && g.tag !== 6) && (g = null)) : (m = null, g = u), m !== g)) { if (v = aI, C = "onMouseLeave", A = "onMouseEnter", _ = "mouse", (n === "pointerout" || n === "pointerover") && (v = lI, C = "onPointerLeave", A = "onPointerEnter", _ = "pointer"), y = m == null ? d : j0(m), x = g == null ? d : j0(g), d = new v(C, _ + "leave", m, t, c), d.target = y, d.relatedTarget = x, C = null, Hd(c) === u && (v = new v(A, _ + "enter", g, t, c), v.target = x, v.relatedTarget = y, C = v), y = C, m && g) t: { for (v = m, A = g, _ = 0, x = v; x; x = a0(x))_++; for (x = 0, C = A; C; C = a0(C))x++; for (; 0 < _ - x;)v = a0(v), _--; for (; 0 < x - _;)A = a0(A), x--; for (; _--;) { if (v === A || A !== null && v === A.alternate) break t; v = a0(v), A = a0(A) } v = null } else v = null; m !== null && yI(h, d, m, v, !1), g !== null && y !== null && yI(h, y, g, v, !0) } } e: { if (d = u ? j0(u) : window, m = d.nodeName && d.nodeName.toLowerCase(), m === "select" || m === "input" && d.type === "file") var T = xV; else if (fI(d)) if (dL) T = SV; else { T = EV; var I = _V } else (m = d.nodeName) && m.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (T = CV); if (T && (T = T(n, u))) { hL(h, T, t, c); break e } I && I(n, d, u), n === "focusout" && (I = d._wrapperState) && I.controlled && d.type === "number" && lE(d, "number", d.value) } switch (I = u ? j0(u) : window, n) { case "focusin": (fI(I) || I.contentEditable === "true") && (X0 = I, xE = u, Qg = null); break; case "focusout": Qg = xE = X0 = null; break; case "mousedown": _E = !0; break; case "contextmenu": case "mouseup": case "dragend": _E = !1, gI(h, t, c); break; case "selectionchange": if (IV) break; case "keydown": case "keyup": gI(h, t, c) }var w; if (dC) e: { switch (n) { case "compositionstart": var R = "onCompositionStart"; break e; case "compositionend": R = "onCompositionEnd"; break e; case "compositionupdate": R = "onCompositionUpdate"; break e }R = void 0 } else W0 ? cL(n, t) && (R = "onCompositionEnd") : n === "keydown" && t.keyCode === 229 && (R = "onCompositionStart"); R && (uL && t.locale !== "ko" && (W0 || R !== "onCompositionStart" ? R === "onCompositionEnd" && W0 && (w = lL()) : (nh = c, cC = "value" in nh ? nh.value : nh.textContent, W0 = !0)), I = w6(u, R), 0 < I.length && (R = new oI(R, n, null, t, c), h.push({ event: R, listeners: I }), w ? R.data = w : (w = fL(t), w !== null && (R.data = w)))), (w = mV ? gV(n, t) : AV(n, t)) && (u = w6(u, "onBeforeInput"), 0 < u.length && (c = new oI("onBeforeInput", "beforeinput", null, t, c), h.push({ event: c, listeners: u }), c.data = w)) } CL(h, e) }) } function TA(n, e, t) { return { instance: n, listener: e, currentTarget: t } } function w6(n, e) { for (var t = e + "Capture", r = []; n !== null;) { var i = n, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = vA(n, t), s != null && r.unshift(TA(n, s, i)), s = vA(n, e), s != null && r.push(TA(n, s, i))), n = n.return } return r } function a0(n) { if (n === null) return null; do n = n.return; while (n && n.tag !== 5); return n || null } function yI(n, e, t, r, i) { for (var s = e._reactName, a = []; t !== null && t !== r;) { var o = t, l = o.alternate, u = o.stateNode; if (l !== null && l === r) break; o.tag === 5 && u !== null && (o = u, i ? (l = vA(t, s), l != null && a.unshift(TA(t, l, o))) : i || (l = vA(t, s), l != null && a.push(TA(t, l, o)))), t = t.return } a.length !== 0 && n.push({ event: e, listeners: a }) } var RV = /\r\n?/g, PV = /\u0000|\uFFFD/g; function xI(n) {
		return (typeof n == "string" ? n : "" + n).replace(RV, `
`).replace(PV, "")
	} function j2(n, e, t) { if (e = xI(e), xI(n) !== e && t) throw Error(Ze(425)) } function I6() { } var EE = null, CE = null; function SE(n, e) { return n === "textarea" || n === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var TE = typeof setTimeout == "function" ? setTimeout : void 0, DV = typeof clearTimeout == "function" ? clearTimeout : void 0, _I = typeof Promise == "function" ? Promise : void 0, LV = typeof queueMicrotask == "function" ? queueMicrotask : typeof _I < "u" ? function (n) { return _I.resolve(null).then(n).catch(FV) } : TE; function FV(n) { setTimeout(function () { throw n }) } function Z4(n, e) { var t = e, r = 0; do { var i = t.nextSibling; if (n.removeChild(t), i && i.nodeType === 8) if (t = i.data, t === "/$") { if (r === 0) { n.removeChild(i), _A(e); return } r-- } else t !== "$" && t !== "$?" && t !== "$!" || r++; t = i } while (t); _A(e) } function ph(n) { for (; n != null; n = n.nextSibling) { var e = n.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = n.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return n } function EI(n) { n = n.previousSibling; for (var e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "$" || t === "$!" || t === "$?") { if (e === 0) return n; e-- } else t === "/$" && e++ } n = n.previousSibling } return null } var mm = Math.random().toString(36).slice(2), ju = "__reactFiber$" + mm, wA = "__reactProps$" + mm, lf = "__reactContainer$" + mm, wE = "__reactEvents$" + mm, kV = "__reactListeners$" + mm, NV = "__reactHandles$" + mm; function Hd(n) { var e = n[ju]; if (e) return e; for (var t = n.parentNode; t;) { if (e = t[lf] || t[ju]) { if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n = EI(n); n !== null;) { if (t = n[ju]) return t; n = EI(n) } return e } n = t, t = n.parentNode } return null } function S1(n) { return n = n[ju] || n[lf], !n || n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3 ? null : n } function j0(n) { if (n.tag === 5 || n.tag === 6) return n.stateNode; throw Error(Ze(33)) } function ky(n) { return n[wA] || null } var IE = [], J0 = -1; function Vh(n) { return { current: n } } function ti(n) { 0 > J0 || (n.current = IE[J0], IE[J0] = null, J0--) } function Qr(n, e) { J0++, IE[J0] = n.current, n.current = e } var Ih = {}, ma = Vh(Ih), so = Vh(!1), gp = Ih; function N3(n, e) { var t = n.type.contextTypes; if (!t) return Ih; var r = n.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in t) i[s] = e[s]; return r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = e, n.__reactInternalMemoizedMaskedChildContext = i), i } function ao(n) { return n = n.childContextTypes, n != null } function M6() { ti(so), ti(ma) } function CI(n, e, t) { if (ma.current !== Ih) throw Error(Ze(168)); Qr(ma, e), Qr(so, t) } function TL(n, e, t) { var r = n.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return t; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(Ze(108, _z(n) || "Unknown", i)); return yi({}, t, r) } function b6(n) { return n = (n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext || Ih, gp = ma.current, Qr(ma, n), Qr(so, so.current), !0 } function SI(n, e, t) { var r = n.stateNode; if (!r) throw Error(Ze(169)); t ? (n = TL(n, e, gp), r.__reactInternalMemoizedMergedChildContext = n, ti(so), ti(ma), Qr(ma, n)) : ti(so), Qr(so, t) } var Wc = null, Ny = !1, $4 = !1; function wL(n) { Wc === null ? Wc = [n] : Wc.push(n) } function OV(n) { Ny = !0, wL(n) } function Wh() { if (!$4 && Wc !== null) { $4 = !0; var n = 0, e = Ar; try { var t = Wc; for (Ar = 1; n < t.length; n++) { var r = t[n]; do r = r(!0); while (r !== null) } Wc = null, Ny = !1 } catch (i) { throw Wc !== null && (Wc = Wc.slice(n + 1)), qD(aC, Wh), i } finally { Ar = e, $4 = !1 } } return null } var K0 = [], q0 = 0, B6 = null, R6 = 0, gl = [], Al = 0, Ap = null, Jc = 1, Kc = ""; function wd(n, e) { K0[q0++] = R6, K0[q0++] = B6, B6 = n, R6 = e } function IL(n, e, t) { gl[Al++] = Jc, gl[Al++] = Kc, gl[Al++] = Ap, Ap = n; var r = Jc; n = Kc; var i = 32 - du(r) - 1; r &= ~(1 << i), t += 1; var s = 32 - du(e) + i; if (30 < s) { var a = i - i % 5; s = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Jc = 1 << 32 - du(e) + i | t << i | r, Kc = s + n } else Jc = 1 << s | t << i | r, Kc = n } function mC(n) { n.return !== null && (wd(n, 1), IL(n, 1, 0)) } function gC(n) { for (; n === B6;)B6 = K0[--q0], K0[q0] = null, R6 = K0[--q0], K0[q0] = null; for (; n === Ap;)Ap = gl[--Al], gl[Al] = null, Kc = gl[--Al], gl[Al] = null, Jc = gl[--Al], gl[Al] = null } var Uo = null, No = null, ai = !1, ou = null; function ML(n, e) { var t = xl(5, null, null, 0); t.elementType = "DELETED", t.stateNode = e, t.return = n, e = n.deletions, e === null ? (n.deletions = [t], n.flags |= 16) : e.push(t) } function TI(n, e) { switch (n.tag) { case 5: var t = n.type; return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n.stateNode = e, Uo = n, No = ph(e.firstChild), !0) : !1; case 6: return e = n.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n.stateNode = e, Uo = n, No = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Ap !== null ? { id: Jc, overflow: Kc } : null, n.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = xl(18, null, null, 0), t.stateNode = e, t.return = n, n.child = t, Uo = n, No = null, !0) : !1; default: return !1 } } function ME(n) { return (n.mode & 1) !== 0 && (n.flags & 128) === 0 } function bE(n) { if (ai) { var e = No; if (e) { var t = e; if (!TI(n, e)) { if (ME(n)) throw Error(Ze(418)); e = ph(t.nextSibling); var r = Uo; e && TI(n, e) ? ML(r, t) : (n.flags = n.flags & -4097 | 2, ai = !1, Uo = n) } } else { if (ME(n)) throw Error(Ze(418)); n.flags = n.flags & -4097 | 2, ai = !1, Uo = n } } } function wI(n) { for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13;)n = n.return; Uo = n } function J2(n) { if (n !== Uo) return !1; if (!ai) return wI(n), ai = !0, !1; var e; if ((e = n.tag !== 3) && !(e = n.tag !== 5) && (e = n.type, e = e !== "head" && e !== "body" && !SE(n.type, n.memoizedProps)), e && (e = No)) { if (ME(n)) throw bL(), Error(Ze(418)); for (; e;)ML(n, e), e = ph(e.nextSibling) } if (wI(n), n.tag === 13) { if (n = n.memoizedState, n = n !== null ? n.dehydrated : null, !n) throw Error(Ze(317)); e: { for (n = n.nextSibling, e = 0; n;) { if (n.nodeType === 8) { var t = n.data; if (t === "/$") { if (e === 0) { No = ph(n.nextSibling); break e } e-- } else t !== "$" && t !== "$!" && t !== "$?" || e++ } n = n.nextSibling } No = null } } else No = Uo ? ph(n.stateNode.nextSibling) : null; return !0 } function bL() { for (var n = No; n;)n = ph(n.nextSibling) } function O3() { No = Uo = null, ai = !1 } function AC(n) { ou === null ? ou = [n] : ou.push(n) } var UV = xf.ReactCurrentBatchConfig; function ru(n, e) { if (n && n.defaultProps) { e = yi({}, e), n = n.defaultProps; for (var t in n) e[t] === void 0 && (e[t] = n[t]); return e } return e } var P6 = Vh(null), D6 = null, Z0 = null, vC = null; function yC() { vC = Z0 = D6 = null } function xC(n) { var e = P6.current; ti(P6), n._currentValue = e } function BE(n, e, t) { for (; n !== null;) { var r = n.alternate; if ((n.childLanes & e) !== e ? (n.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), n === t) break; n = n.return } } function v3(n, e) { D6 = n, vC = Z0 = null, n = n.dependencies, n !== null && n.firstContext !== null && (n.lanes & e && (io = !0), n.firstContext = null) } function bl(n) { var e = n._currentValue; if (vC !== n) if (n = { context: n, memoizedValue: e, next: null }, Z0 === null) { if (D6 === null) throw Error(Ze(308)); Z0 = n, D6.dependencies = { lanes: 0, firstContext: n } } else Z0 = Z0.next = n; return e } var zd = null; function _C(n) { zd === null ? zd = [n] : zd.push(n) } function BL(n, e, t, r) { var i = e.interleaved; return i === null ? (t.next = t, _C(e)) : (t.next = i.next, i.next = t), e.interleaved = t, uf(n, r) } function uf(n, e) { n.lanes |= e; var t = n.alternate; for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null;)n.childLanes |= e, t = n.alternate, t !== null && (t.childLanes |= e), t = n, n = n.return; return t.tag === 3 ? t.stateNode : null } var Zf = !1; function EC(n) { n.updateQueue = { baseState: n.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function RL(n, e) { n = n.updateQueue, e.updateQueue === n && (e.updateQueue = { baseState: n.baseState, firstBaseUpdate: n.firstBaseUpdate, lastBaseUpdate: n.lastBaseUpdate, shared: n.shared, effects: n.effects }) } function nf(n, e) { return { eventTime: n, lane: e, tag: 0, payload: null, callback: null, next: null } } function mh(n, e, t) { var r = n.updateQueue; if (r === null) return null; if (r = r.shared, er & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, uf(n, t) } return i = r.interleaved, i === null ? (e.next = e, _C(r)) : (e.next = i.next, i.next = e), r.interleaved = e, uf(n, t) } function G5(n, e, t) { if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) { var r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, oC(n, t) } } function II(n, e) { var t = n.updateQueue, r = n.alternate; if (r !== null && (r = r.updateQueue, t === r)) { var i = null, s = null; if (t = t.firstBaseUpdate, t !== null) { do { var a = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null }; s === null ? i = s = a : s = s.next = a, t = t.next } while (t !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; t = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, n.updateQueue = t; return } n = t.lastBaseUpdate, n === null ? t.firstBaseUpdate = e : n.next = e, t.lastBaseUpdate = e } function L6(n, e, t, r) { var i = n.updateQueue; Zf = !1; var s = i.firstBaseUpdate, a = i.lastBaseUpdate, o = i.shared.pending; if (o !== null) { i.shared.pending = null; var l = o, u = l.next; l.next = null, a === null ? s = u : a.next = u, a = l; var c = n.alternate; c !== null && (c = c.updateQueue, o = c.lastBaseUpdate, o !== a && (o === null ? c.firstBaseUpdate = u : o.next = u, c.lastBaseUpdate = l)) } if (s !== null) { var h = i.baseState; a = 0, c = u = l = null, o = s; do { var d = o.lane, m = o.eventTime; if ((r & d) === d) { c !== null && (c = c.next = { eventTime: m, lane: 0, tag: o.tag, payload: o.payload, callback: o.callback, next: null }); e: { var g = n, v = o; switch (d = e, m = t, v.tag) { case 1: if (g = v.payload, typeof g == "function") { h = g.call(m, h, d); break e } h = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = v.payload, d = typeof g == "function" ? g.call(m, h, d) : g, d == null) break e; h = yi({}, h, d); break e; case 2: Zf = !0 } } o.callback !== null && o.lane !== 0 && (n.flags |= 64, d = i.effects, d === null ? i.effects = [o] : d.push(o)) } else m = { eventTime: m, lane: d, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, c === null ? (u = c = m, l = h) : c = c.next = m, a |= d; if (o = o.next, o === null) { if (o = i.shared.pending, o === null) break; d = o, o = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (1); if (c === null && (l = h), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) { i = e; do a |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); yp |= a, n.lanes = a, n.memoizedState = h } } function MI(n, e, t) { if (n = e.effects, e.effects = null, n !== null) for (e = 0; e < n.length; e++) { var r = n[e], i = r.callback; if (i !== null) { if (r.callback = null, r = t, typeof i != "function") throw Error(Ze(191, i)); i.call(r) } } } var PL = new BD.Component().refs; function RE(n, e, t, r) { e = n.memoizedState, t = t(r, e), t = t == null ? e : yi({}, e, t), n.memoizedState = t, n.lanes === 0 && (n.updateQueue.baseState = t) } var Oy = { isMounted: function (n) { return (n = n._reactInternals) ? Fp(n) === n : !1 }, enqueueSetState: function (n, e, t) { n = n._reactInternals; var r = Ua(), i = Ah(n), s = nf(r, i); s.payload = e, t != null && (s.callback = t), e = mh(n, s, i), e !== null && (pu(e, n, i, r), G5(e, n, i)) }, enqueueReplaceState: function (n, e, t) { n = n._reactInternals; var r = Ua(), i = Ah(n), s = nf(r, i); s.tag = 1, s.payload = e, t != null && (s.callback = t), e = mh(n, s, i), e !== null && (pu(e, n, i, r), G5(e, n, i)) }, enqueueForceUpdate: function (n, e) { n = n._reactInternals; var t = Ua(), r = Ah(n), i = nf(t, r); i.tag = 2, e != null && (i.callback = e), e = mh(n, i, r), e !== null && (pu(e, n, r, t), G5(e, n, r)) } }; function bI(n, e, t, r, i, s, a) { return n = n.stateNode, typeof n.shouldComponentUpdate == "function" ? n.shouldComponentUpdate(r, s, a) : e.prototype && e.prototype.isPureReactComponent ? !CA(t, r) || !CA(i, s) : !0 } function DL(n, e, t) { var r = !1, i = Ih, s = e.contextType; return typeof s == "object" && s !== null ? s = bl(s) : (i = ao(e) ? gp : ma.current, r = e.contextTypes, s = (r = r != null) ? N3(n, i) : Ih), e = new e(t, s), n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Oy, n.stateNode = e, e._reactInternals = n, r && (n = n.stateNode, n.__reactInternalMemoizedUnmaskedChildContext = i, n.__reactInternalMemoizedMaskedChildContext = s), e } function BI(n, e, t, r) { n = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, r), e.state !== n && Oy.enqueueReplaceState(e, e.state, null) } function PE(n, e, t, r) { var i = n.stateNode; i.props = t, i.state = n.memoizedState, i.refs = PL, EC(n); var s = e.contextType; typeof s == "object" && s !== null ? i.context = bl(s) : (s = ao(e) ? gp : ma.current, i.context = N3(n, s)), i.state = n.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (RE(n, e, s, t), i.state = n.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && Oy.enqueueReplaceState(i, i.state, null), L6(n, t, i, r), i.state = n.memoizedState), typeof i.componentDidMount == "function" && (n.flags |= 4194308) } function Wm(n, e, t) { if (n = t.ref, n !== null && typeof n != "function" && typeof n != "object") { if (t._owner) { if (t = t._owner, t) { if (t.tag !== 1) throw Error(Ze(309)); var r = t.stateNode } if (!r) throw Error(Ze(147, n)); var i = r, s = "" + n; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (a) { var o = i.refs; o === PL && (o = i.refs = {}), a === null ? delete o[s] : o[s] = a }, e._stringRef = s, e) } if (typeof n != "string") throw Error(Ze(284)); if (!t._owner) throw Error(Ze(290, n)) } return n } function K2(n, e) { throw n = Object.prototype.toString.call(e), Error(Ze(31, n === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n)) } function RI(n) { var e = n._init; return e(n._payload) } function LL(n) { function e(A, _) { if (n) { var x = A.deletions; x === null ? (A.deletions = [_], A.flags |= 16) : x.push(_) } } function t(A, _) { if (!n) return null; for (; _ !== null;)e(A, _), _ = _.sibling; return null } function r(A, _) { for (A = new Map; _ !== null;)_.key !== null ? A.set(_.key, _) : A.set(_.index, _), _ = _.sibling; return A } function i(A, _) { return A = vh(A, _), A.index = 0, A.sibling = null, A } function s(A, _, x) { return A.index = x, n ? (x = A.alternate, x !== null ? (x = x.index, x < _ ? (A.flags |= 2, _) : x) : (A.flags |= 2, _)) : (A.flags |= 1048576, _) } function a(A) { return n && A.alternate === null && (A.flags |= 2), A } function o(A, _, x, C) { return _ === null || _.tag !== 6 ? (_ = ax(x, A.mode, C), _.return = A, _) : (_ = i(_, x), _.return = A, _) } function l(A, _, x, C) { var T = x.type; return T === V0 ? c(A, _, x.props.children, C, x.key) : _ !== null && (_.elementType === T || typeof T == "object" && T !== null && T.$$typeof === qf && RI(T) === _.type) ? (C = i(_, x.props), C.ref = Wm(A, _, x), C.return = A, C) : (C = X5(x.type, x.key, x.props, null, A.mode, C), C.ref = Wm(A, _, x), C.return = A, C) } function u(A, _, x, C) { return _ === null || _.tag !== 4 || _.stateNode.containerInfo !== x.containerInfo || _.stateNode.implementation !== x.implementation ? (_ = ox(x, A.mode, C), _.return = A, _) : (_ = i(_, x.children || []), _.return = A, _) } function c(A, _, x, C, T) { return _ === null || _.tag !== 7 ? (_ = rp(x, A.mode, C, T), _.return = A, _) : (_ = i(_, x), _.return = A, _) } function h(A, _, x) { if (typeof _ == "string" && _ !== "" || typeof _ == "number") return _ = ax("" + _, A.mode, x), _.return = A, _; if (typeof _ == "object" && _ !== null) { switch (_.$$typeof) { case U2: return x = X5(_.type, _.key, _.props, null, A.mode, x), x.ref = Wm(A, null, _), x.return = A, x; case z0: return _ = ox(_, A.mode, x), _.return = A, _; case qf: var C = _._init; return h(A, C(_._payload), x) }if (_g(_) || Gm(_)) return _ = rp(_, A.mode, x, null), _.return = A, _; K2(A, _) } return null } function d(A, _, x, C) { var T = _ !== null ? _.key : null; if (typeof x == "string" && x !== "" || typeof x == "number") return T !== null ? null : o(A, _, "" + x, C); if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case U2: return x.key === T ? l(A, _, x, C) : null; case z0: return x.key === T ? u(A, _, x, C) : null; case qf: return T = x._init, d(A, _, T(x._payload), C) }if (_g(x) || Gm(x)) return T !== null ? null : c(A, _, x, C, null); K2(A, x) } return null } function m(A, _, x, C, T) { if (typeof C == "string" && C !== "" || typeof C == "number") return A = A.get(x) || null, o(_, A, "" + C, T); if (typeof C == "object" && C !== null) { switch (C.$$typeof) { case U2: return A = A.get(C.key === null ? x : C.key) || null, l(_, A, C, T); case z0: return A = A.get(C.key === null ? x : C.key) || null, u(_, A, C, T); case qf: var I = C._init; return m(A, _, x, I(C._payload), T) }if (_g(C) || Gm(C)) return A = A.get(x) || null, c(_, A, C, T, null); K2(_, C) } return null } function g(A, _, x, C) { for (var T = null, I = null, w = _, R = _ = 0, b = null; w !== null && R < x.length; R++) { w.index > R ? (b = w, w = null) : b = w.sibling; var B = d(A, w, x[R], C); if (B === null) { w === null && (w = b); break } n && w && B.alternate === null && e(A, w), _ = s(B, _, R), I === null ? T = B : I.sibling = B, I = B, w = b } if (R === x.length) return t(A, w), ai && wd(A, R), T; if (w === null) { for (; R < x.length; R++)w = h(A, x[R], C), w !== null && (_ = s(w, _, R), I === null ? T = w : I.sibling = w, I = w); return ai && wd(A, R), T } for (w = r(A, w); R < x.length; R++)b = m(w, A, R, x[R], C), b !== null && (n && b.alternate !== null && w.delete(b.key === null ? R : b.key), _ = s(b, _, R), I === null ? T = b : I.sibling = b, I = b); return n && w.forEach(function (F) { return e(A, F) }), ai && wd(A, R), T } function v(A, _, x, C) { var T = Gm(x); if (typeof T != "function") throw Error(Ze(150)); if (x = T.call(x), x == null) throw Error(Ze(151)); for (var I = T = null, w = _, R = _ = 0, b = null, B = x.next(); w !== null && !B.done; R++, B = x.next()) { w.index > R ? (b = w, w = null) : b = w.sibling; var F = d(A, w, B.value, C); if (F === null) { w === null && (w = b); break } n && w && F.alternate === null && e(A, w), _ = s(F, _, R), I === null ? T = F : I.sibling = F, I = F, w = b } if (B.done) return t(A, w), ai && wd(A, R), T; if (w === null) { for (; !B.done; R++, B = x.next())B = h(A, B.value, C), B !== null && (_ = s(B, _, R), I === null ? T = B : I.sibling = B, I = B); return ai && wd(A, R), T } for (w = r(A, w); !B.done; R++, B = x.next())B = m(w, A, R, B.value, C), B !== null && (n && B.alternate !== null && w.delete(B.key === null ? R : B.key), _ = s(B, _, R), I === null ? T = B : I.sibling = B, I = B); return n && w.forEach(function (U) { return e(A, U) }), ai && wd(A, R), T } function y(A, _, x, C) { if (typeof x == "object" && x !== null && x.type === V0 && x.key === null && (x = x.props.children), typeof x == "object" && x !== null) { switch (x.$$typeof) { case U2: e: { for (var T = x.key, I = _; I !== null;) { if (I.key === T) { if (T = x.type, T === V0) { if (I.tag === 7) { t(A, I.sibling), _ = i(I, x.props.children), _.return = A, A = _; break e } } else if (I.elementType === T || typeof T == "object" && T !== null && T.$$typeof === qf && RI(T) === I.type) { t(A, I.sibling), _ = i(I, x.props), _.ref = Wm(A, I, x), _.return = A, A = _; break e } t(A, I); break } else e(A, I); I = I.sibling } x.type === V0 ? (_ = rp(x.props.children, A.mode, C, x.key), _.return = A, A = _) : (C = X5(x.type, x.key, x.props, null, A.mode, C), C.ref = Wm(A, _, x), C.return = A, A = C) } return a(A); case z0: e: { for (I = x.key; _ !== null;) { if (_.key === I) if (_.tag === 4 && _.stateNode.containerInfo === x.containerInfo && _.stateNode.implementation === x.implementation) { t(A, _.sibling), _ = i(_, x.children || []), _.return = A, A = _; break e } else { t(A, _); break } else e(A, _); _ = _.sibling } _ = ox(x, A.mode, C), _.return = A, A = _ } return a(A); case qf: return I = x._init, y(A, _, I(x._payload), C) }if (_g(x)) return g(A, _, x, C); if (Gm(x)) return v(A, _, x, C); K2(A, x) } return typeof x == "string" && x !== "" || typeof x == "number" ? (x = "" + x, _ !== null && _.tag === 6 ? (t(A, _.sibling), _ = i(_, x), _.return = A, A = _) : (t(A, _), _ = ax(x, A.mode, C), _.return = A, A = _), a(A)) : t(A, _) } return y } var U3 = LL(!0), FL = LL(!1), T1 = {}, tc = Vh(T1), IA = Vh(T1), MA = Vh(T1); function Vd(n) { if (n === T1) throw Error(Ze(174)); return n } function CC(n, e) { switch (Qr(MA, e), Qr(IA, n), Qr(tc, T1), n = e.nodeType, n) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : cE(null, ""); break; default: n = n === 8 ? e.parentNode : e, e = n.namespaceURI || null, n = n.tagName, e = cE(e, n) }ti(tc), Qr(tc, e) } function G3() { ti(tc), ti(IA), ti(MA) } function kL(n) { Vd(MA.current); var e = Vd(tc.current), t = cE(e, n.type); e !== t && (Qr(IA, n), Qr(tc, t)) } function SC(n) { IA.current === n && (ti(tc), ti(IA)) } var fi = Vh(0); function F6(n) { for (var e = n; e !== null;) { if (e.tag === 13) { var t = e.memoizedState; if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var ex = []; function TC() { for (var n = 0; n < ex.length; n++)ex[n]._workInProgressVersionPrimary = null; ex.length = 0 } var Q5 = xf.ReactCurrentDispatcher, tx = xf.ReactCurrentBatchConfig, vp = 0, Ai = null, ps = null, Fs = null, k6 = !1, Hg = !1, bA = 0, GV = 0; function sa() { throw Error(Ze(321)) } function wC(n, e) { if (e === null) return !1; for (var t = 0; t < e.length && t < n.length; t++)if (!vu(n[t], e[t])) return !1; return !0 } function IC(n, e, t, r, i, s) { if (vp = s, Ai = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Q5.current = n === null || n.memoizedState === null ? VV : WV, n = t(r, i), Hg) { s = 0; do { if (Hg = !1, bA = 0, 25 <= s) throw Error(Ze(301)); s += 1, Fs = ps = null, e.updateQueue = null, Q5.current = XV, n = t(r, i) } while (Hg) } if (Q5.current = N6, e = ps !== null && ps.next !== null, vp = 0, Fs = ps = Ai = null, k6 = !1, e) throw Error(Ze(300)); return n } function MC() { var n = bA !== 0; return bA = 0, n } function Wu() { var n = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Fs === null ? Ai.memoizedState = Fs = n : Fs = Fs.next = n, Fs } function Bl() { if (ps === null) { var n = Ai.alternate; n = n !== null ? n.memoizedState : null } else n = ps.next; var e = Fs === null ? Ai.memoizedState : Fs.next; if (e !== null) Fs = e, ps = n; else { if (n === null) throw Error(Ze(310)); ps = n, n = { memoizedState: ps.memoizedState, baseState: ps.baseState, baseQueue: ps.baseQueue, queue: ps.queue, next: null }, Fs === null ? Ai.memoizedState = Fs = n : Fs = Fs.next = n } return Fs } function BA(n, e) { return typeof e == "function" ? e(n) : e } function nx(n) { var e = Bl(), t = e.queue; if (t === null) throw Error(Ze(311)); t.lastRenderedReducer = n; var r = ps, i = r.baseQueue, s = t.pending; if (s !== null) { if (i !== null) { var a = i.next; i.next = s.next, s.next = a } r.baseQueue = i = s, t.pending = null } if (i !== null) { s = i.next, r = r.baseState; var o = a = null, l = null, u = s; do { var c = u.lane; if ((vp & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : n(r, u.action); else { var h = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (o = l = h, a = r) : l = l.next = h, Ai.lanes |= c, yp |= c } u = u.next } while (u !== null && u !== s); l === null ? a = r : l.next = o, vu(r, e.memoizedState) || (io = !0), e.memoizedState = r, e.baseState = a, e.baseQueue = l, t.lastRenderedState = r } if (n = t.interleaved, n !== null) { i = n; do s = i.lane, Ai.lanes |= s, yp |= s, i = i.next; while (i !== n) } else i === null && (t.lanes = 0); return [e.memoizedState, t.dispatch] } function rx(n) { var e = Bl(), t = e.queue; if (t === null) throw Error(Ze(311)); t.lastRenderedReducer = n; var r = t.dispatch, i = t.pending, s = e.memoizedState; if (i !== null) { t.pending = null; var a = i = i.next; do s = n(s, a.action), a = a.next; while (a !== i); vu(s, e.memoizedState) || (io = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s } return [s, r] } function NL() { } function OL(n, e) { var t = Ai, r = Bl(), i = e(), s = !vu(r.memoizedState, i); if (s && (r.memoizedState = i, io = !0), r = r.queue, bC(QL.bind(null, t, r, n), [n]), r.getSnapshot !== e || s || Fs !== null && Fs.memoizedState.tag & 1) { if (t.flags |= 2048, RA(9, GL.bind(null, t, r, i, e), void 0, null), Ns === null) throw Error(Ze(349)); vp & 30 || UL(t, e, i) } return i } function UL(n, e, t) { n.flags |= 16384, n = { getSnapshot: e, value: t }, e = Ai.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ai.updateQueue = e, e.stores = [n]) : (t = e.stores, t === null ? e.stores = [n] : t.push(n)) } function GL(n, e, t, r) { e.value = t, e.getSnapshot = r, HL(e) && zL(n) } function QL(n, e, t) { return t(function () { HL(e) && zL(n) }) } function HL(n) { var e = n.getSnapshot; n = n.value; try { var t = e(); return !vu(n, t) } catch { return !0 } } function zL(n) { var e = uf(n, 1); e !== null && pu(e, n, 1, -1) } function PI(n) { var e = Wu(); return typeof n == "function" && (n = n()), e.memoizedState = e.baseState = n, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: BA, lastRenderedState: n }, e.queue = n, n = n.dispatch = zV.bind(null, Ai, n), [e.memoizedState, n] } function RA(n, e, t, r) { return n = { tag: n, create: e, destroy: t, deps: r, next: null }, e = Ai.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ai.updateQueue = e, e.lastEffect = n.next = n) : (t = e.lastEffect, t === null ? e.lastEffect = n.next = n : (r = t.next, t.next = n, n.next = r, e.lastEffect = n)), n } function VL() { return Bl().memoizedState } function H5(n, e, t, r) { var i = Wu(); Ai.flags |= n, i.memoizedState = RA(1 | e, t, void 0, r === void 0 ? null : r) } function Uy(n, e, t, r) { var i = Bl(); r = r === void 0 ? null : r; var s = void 0; if (ps !== null) { var a = ps.memoizedState; if (s = a.destroy, r !== null && wC(r, a.deps)) { i.memoizedState = RA(e, t, s, r); return } } Ai.flags |= n, i.memoizedState = RA(1 | e, t, s, r) } function DI(n, e) { return H5(8390656, 8, n, e) } function bC(n, e) { return Uy(2048, 8, n, e) } function WL(n, e) { return Uy(4, 2, n, e) } function XL(n, e) { return Uy(4, 4, n, e) } function YL(n, e) { if (typeof e == "function") return n = n(), e(n), function () { e(null) }; if (e != null) return n = n(), e.current = n, function () { e.current = null } } function jL(n, e, t) { return t = t != null ? t.concat([n]) : null, Uy(4, 4, YL.bind(null, e, n), t) } function BC() { } function JL(n, e) { var t = Bl(); e = e === void 0 ? null : e; var r = t.memoizedState; return r !== null && e !== null && wC(e, r[1]) ? r[0] : (t.memoizedState = [n, e], n) } function KL(n, e) { var t = Bl(); e = e === void 0 ? null : e; var r = t.memoizedState; return r !== null && e !== null && wC(e, r[1]) ? r[0] : (n = n(), t.memoizedState = [n, e], n) } function qL(n, e, t) { return vp & 21 ? (vu(t, e) || (t = eL(), Ai.lanes |= t, yp |= t, n.baseState = !0), e) : (n.baseState && (n.baseState = !1, io = !0), n.memoizedState = t) } function QV(n, e) { var t = Ar; Ar = t !== 0 && 4 > t ? t : 4, n(!0); var r = tx.transition; tx.transition = {}; try { n(!1), e() } finally { Ar = t, tx.transition = r } } function ZL() { return Bl().memoizedState } function HV(n, e, t) { var r = Ah(n); if (t = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }, $L(n)) eF(e, t); else if (t = BL(n, e, t, r), t !== null) { var i = Ua(); pu(t, n, r, i), tF(t, e, r) } } function zV(n, e, t) { var r = Ah(n), i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null }; if ($L(n)) eF(e, i); else { var s = n.alternate; if (n.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var a = e.lastRenderedState, o = s(a, t); if (i.hasEagerState = !0, i.eagerState = o, vu(o, a)) { var l = e.interleaved; l === null ? (i.next = i, _C(e)) : (i.next = l.next, l.next = i), e.interleaved = i; return } } catch { } finally { } t = BL(n, e, i, r), t !== null && (i = Ua(), pu(t, n, r, i), tF(t, e, r)) } } function $L(n) { var e = n.alternate; return n === Ai || e !== null && e === Ai } function eF(n, e) { Hg = k6 = !0; var t = n.pending; t === null ? e.next = e : (e.next = t.next, t.next = e), n.pending = e } function tF(n, e, t) { if (t & 4194240) { var r = e.lanes; r &= n.pendingLanes, t |= r, e.lanes = t, oC(n, t) } } var N6 = { readContext: bl, useCallback: sa, useContext: sa, useEffect: sa, useImperativeHandle: sa, useInsertionEffect: sa, useLayoutEffect: sa, useMemo: sa, useReducer: sa, useRef: sa, useState: sa, useDebugValue: sa, useDeferredValue: sa, useTransition: sa, useMutableSource: sa, useSyncExternalStore: sa, useId: sa, unstable_isNewReconciler: !1 }, VV = { readContext: bl, useCallback: function (n, e) { return Wu().memoizedState = [n, e === void 0 ? null : e], n }, useContext: bl, useEffect: DI, useImperativeHandle: function (n, e, t) { return t = t != null ? t.concat([n]) : null, H5(4194308, 4, YL.bind(null, e, n), t) }, useLayoutEffect: function (n, e) { return H5(4194308, 4, n, e) }, useInsertionEffect: function (n, e) { return H5(4, 2, n, e) }, useMemo: function (n, e) { var t = Wu(); return e = e === void 0 ? null : e, n = n(), t.memoizedState = [n, e], n }, useReducer: function (n, e, t) { var r = Wu(); return e = t !== void 0 ? t(e) : e, r.memoizedState = r.baseState = e, n = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n, lastRenderedState: e }, r.queue = n, n = n.dispatch = HV.bind(null, Ai, n), [r.memoizedState, n] }, useRef: function (n) { var e = Wu(); return n = { current: n }, e.memoizedState = n }, useState: PI, useDebugValue: BC, useDeferredValue: function (n) { return Wu().memoizedState = n }, useTransition: function () { var n = PI(!1), e = n[0]; return n = QV.bind(null, n[1]), Wu().memoizedState = n, [e, n] }, useMutableSource: function () { }, useSyncExternalStore: function (n, e, t) { var r = Ai, i = Wu(); if (ai) { if (t === void 0) throw Error(Ze(407)); t = t() } else { if (t = e(), Ns === null) throw Error(Ze(349)); vp & 30 || UL(r, e, t) } i.memoizedState = t; var s = { value: t, getSnapshot: e }; return i.queue = s, DI(QL.bind(null, r, s, n), [n]), r.flags |= 2048, RA(9, GL.bind(null, r, s, t, e), void 0, null), t }, useId: function () { var n = Wu(), e = Ns.identifierPrefix; if (ai) { var t = Kc, r = Jc; t = (r & ~(1 << 32 - du(r) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = bA++, 0 < t && (e += "H" + t.toString(32)), e += ":" } else t = GV++, e = ":" + e + "r" + t.toString(32) + ":"; return n.memoizedState = e }, unstable_isNewReconciler: !1 }, WV = { readContext: bl, useCallback: JL, useContext: bl, useEffect: bC, useImperativeHandle: jL, useInsertionEffect: WL, useLayoutEffect: XL, useMemo: KL, useReducer: nx, useRef: VL, useState: function () { return nx(BA) }, useDebugValue: BC, useDeferredValue: function (n) { var e = Bl(); return qL(e, ps.memoizedState, n) }, useTransition: function () { var n = nx(BA)[0], e = Bl().memoizedState; return [n, e] }, useMutableSource: NL, useSyncExternalStore: OL, useId: ZL, unstable_isNewReconciler: !1 }, XV = { readContext: bl, useCallback: JL, useContext: bl, useEffect: bC, useImperativeHandle: jL, useInsertionEffect: WL, useLayoutEffect: XL, useMemo: KL, useReducer: rx, useRef: VL, useState: function () { return rx(BA) }, useDebugValue: BC, useDeferredValue: function (n) { var e = Bl(); return ps === null ? e.memoizedState = n : qL(e, ps.memoizedState, n) }, useTransition: function () { var n = rx(BA)[0], e = Bl().memoizedState; return [n, e] }, useMutableSource: NL, useSyncExternalStore: OL, useId: ZL, unstable_isNewReconciler: !1 }; function Q3(n, e) {
		try { var t = "", r = e; do t += xz(r), r = r.return; while (r); var i = t } catch (s) {
			i = `
Error generating stack: `+ s.message + `
`+ s.stack
		} return { value: n, source: e, stack: i, digest: null }
	} function ix(n, e, t) { return { value: n, source: null, stack: t ?? null, digest: e ?? null } } function DE(n, e) { try { console.error(e.value) } catch (t) { setTimeout(function () { throw t }) } } var YV = typeof WeakMap == "function" ? WeakMap : Map; function nF(n, e, t) { t = nf(-1, t), t.tag = 3, t.payload = { element: null }; var r = e.value; return t.callback = function () { U6 || (U6 = !0, zE = r), DE(n, e) }, t } function rF(n, e, t) { t = nf(-1, t), t.tag = 3; var r = n.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; t.payload = function () { return r(i) }, t.callback = function () { DE(n, e) } } var s = n.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function () { DE(n, e), typeof r != "function" && (gh === null ? gh = new Set([this]) : gh.add(this)); var a = e.stack; this.componentDidCatch(e.value, { componentStack: a !== null ? a : "" }) }), t } function LI(n, e, t) { var r = n.pingCache; if (r === null) { r = n.pingCache = new YV; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(t) || (i.add(t), n = oW.bind(null, n, e, t), e.then(n, n)) } function FI(n) { do { var e; if ((e = n.tag === 13) && (e = n.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return n; n = n.return } while (n !== null); return null } function kI(n, e, t, r, i) { return n.mode & 1 ? (n.flags |= 65536, n.lanes = i, n) : (n === e ? n.flags |= 65536 : (n.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = nf(-1, 1), e.tag = 2, mh(t, e, 1))), t.lanes |= 1), n) } var jV = xf.ReactCurrentOwner, io = !1; function Pa(n, e, t, r) { e.child = n === null ? FL(e, null, t, r) : U3(e, n.child, t, r) } function NI(n, e, t, r, i) { t = t.render; var s = e.ref; return v3(e, i), r = IC(n, e, t, r, s, i), t = MC(), n !== null && !io ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, cf(n, e, i)) : (ai && t && mC(e), e.flags |= 1, Pa(n, e, r, i), e.child) } function OI(n, e, t, r, i) { if (n === null) { var s = t.type; return typeof s == "function" && !OC(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, iF(n, e, s, r, i)) : (n = X5(t.type, null, r, e, e.mode, i), n.ref = e.ref, n.return = e, e.child = n) } if (s = n.child, !(n.lanes & i)) { var a = s.memoizedProps; if (t = t.compare, t = t !== null ? t : CA, t(a, r) && n.ref === e.ref) return cf(n, e, i) } return e.flags |= 1, n = vh(s, r), n.ref = e.ref, n.return = e, e.child = n } function iF(n, e, t, r, i) { if (n !== null) { var s = n.memoizedProps; if (CA(s, r) && n.ref === e.ref) if (io = !1, e.pendingProps = r = s, (n.lanes & i) !== 0) n.flags & 131072 && (io = !0); else return e.lanes = n.lanes, cf(n, e, i) } return LE(n, e, t, r, i) } function sF(n, e, t) { var r = e.pendingProps, i = r.children, s = n !== null ? n.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Qr(e3, Bo), Bo |= t; else { if (!(t & 1073741824)) return n = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n, cachePool: null, transitions: null }, e.updateQueue = null, Qr(e3, Bo), Bo |= n, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : t, Qr(e3, Bo), Bo |= r } else s !== null ? (r = s.baseLanes | t, e.memoizedState = null) : r = t, Qr(e3, Bo), Bo |= r; return Pa(n, e, i, t), e.child } function aF(n, e) { var t = e.ref; (n === null && t !== null || n !== null && n.ref !== t) && (e.flags |= 512, e.flags |= 2097152) } function LE(n, e, t, r, i) { var s = ao(t) ? gp : ma.current; return s = N3(e, s), v3(e, i), t = IC(n, e, t, r, s, i), r = MC(), n !== null && !io ? (e.updateQueue = n.updateQueue, e.flags &= -2053, n.lanes &= ~i, cf(n, e, i)) : (ai && r && mC(e), e.flags |= 1, Pa(n, e, t, i), e.child) } function UI(n, e, t, r, i) { if (ao(t)) { var s = !0; b6(e) } else s = !1; if (v3(e, i), e.stateNode === null) z5(n, e), DL(e, t, r), PE(e, t, r, i), r = !0; else if (n === null) { var a = e.stateNode, o = e.memoizedProps; a.props = o; var l = a.context, u = t.contextType; typeof u == "object" && u !== null ? u = bl(u) : (u = ao(t) ? gp : ma.current, u = N3(e, u)); var c = t.getDerivedStateFromProps, h = typeof c == "function" || typeof a.getSnapshotBeforeUpdate == "function"; h || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== r || l !== u) && BI(e, a, r, u), Zf = !1; var d = e.memoizedState; a.state = d, L6(e, r, a, i), l = e.memoizedState, o !== r || d !== l || so.current || Zf ? (typeof c == "function" && (RE(e, t, c, r), l = e.memoizedState), (o = Zf || bI(e, t, o, r, d, l, u)) ? (h || typeof a.UNSAFE_componentWillMount != "function" && typeof a.componentWillMount != "function" || (typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount()), typeof a.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof a.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = l), a.props = r, a.state = l, a.context = u, r = o) : (typeof a.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { a = e.stateNode, RL(n, e), o = e.memoizedProps, u = e.type === e.elementType ? o : ru(e.type, o), a.props = u, h = e.pendingProps, d = a.context, l = t.contextType, typeof l == "object" && l !== null ? l = bl(l) : (l = ao(t) ? gp : ma.current, l = N3(e, l)); var m = t.getDerivedStateFromProps; (c = typeof m == "function" || typeof a.getSnapshotBeforeUpdate == "function") || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== h || d !== l) && BI(e, a, r, l), Zf = !1, d = e.memoizedState, a.state = d, L6(e, r, a, i); var g = e.memoizedState; o !== h || d !== g || so.current || Zf ? (typeof m == "function" && (RE(e, t, m, r), g = e.memoizedState), (u = Zf || bI(e, t, u, r, d, g, l) || !1) ? (c || typeof a.UNSAFE_componentWillUpdate != "function" && typeof a.componentWillUpdate != "function" || (typeof a.componentWillUpdate == "function" && a.componentWillUpdate(r, g, l), typeof a.UNSAFE_componentWillUpdate == "function" && a.UNSAFE_componentWillUpdate(r, g, l)), typeof a.componentDidUpdate == "function" && (e.flags |= 4), typeof a.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof a.componentDidUpdate != "function" || o === n.memoizedProps && d === n.memoizedState || (e.flags |= 4), typeof a.getSnapshotBeforeUpdate != "function" || o === n.memoizedProps && d === n.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = g), a.props = r, a.state = g, a.context = l, r = u) : (typeof a.componentDidUpdate != "function" || o === n.memoizedProps && d === n.memoizedState || (e.flags |= 4), typeof a.getSnapshotBeforeUpdate != "function" || o === n.memoizedProps && d === n.memoizedState || (e.flags |= 1024), r = !1) } return FE(n, e, t, r, s, i) } function FE(n, e, t, r, i, s) { aF(n, e); var a = (e.flags & 128) !== 0; if (!r && !a) return i && SI(e, t, !1), cf(n, e, s); r = e.stateNode, jV.current = e; var o = a && typeof t.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, n !== null && a ? (e.child = U3(e, n.child, null, s), e.child = U3(e, null, o, s)) : Pa(n, e, o, s), e.memoizedState = r.state, i && SI(e, t, !0), e.child } function oF(n) { var e = n.stateNode; e.pendingContext ? CI(n, e.pendingContext, e.pendingContext !== e.context) : e.context && CI(n, e.context, !1), CC(n, e.containerInfo) } function GI(n, e, t, r, i) { return O3(), AC(i), e.flags |= 256, Pa(n, e, t, r), e.child } var kE = { dehydrated: null, treeContext: null, retryLane: 0 }; function NE(n) { return { baseLanes: n, cachePool: null, transitions: null } } function lF(n, e, t) { var r = e.pendingProps, i = fi.current, s = !1, a = (e.flags & 128) !== 0, o; if ((o = a) || (o = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0), o ? (s = !0, e.flags &= -129) : (n === null || n.memoizedState !== null) && (i |= 1), Qr(fi, i & 1), n === null) return bE(e), n = e.memoizedState, n !== null && (n = n.dehydrated, n !== null) ? (e.mode & 1 ? n.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (a = r.children, n = r.fallback, s ? (r = e.mode, s = e.child, a = { mode: "hidden", children: a }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = a) : s = Hy(a, r, 0, null), n = rp(n, r, t, null), s.return = e, n.return = e, s.sibling = n, e.child = s, e.child.memoizedState = NE(t), e.memoizedState = kE, n) : RC(e, a)); if (i = n.memoizedState, i !== null && (o = i.dehydrated, o !== null)) return JV(n, e, a, r, o, i, t); if (s) { s = r.fallback, a = e.mode, i = n.child, o = i.sibling; var l = { mode: "hidden", children: r.children }; return !(a & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = l, e.deletions = null) : (r = vh(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), o !== null ? s = vh(o, s) : (s = rp(s, a, t, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, a = n.child.memoizedState, a = a === null ? NE(t) : { baseLanes: a.baseLanes | t, cachePool: null, transitions: a.transitions }, s.memoizedState = a, s.childLanes = n.childLanes & ~t, e.memoizedState = kE, r } return s = n.child, n = s.sibling, r = vh(s, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = t), r.return = e, r.sibling = null, n !== null && (t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n)), e.child = r, e.memoizedState = null, r } function RC(n, e) { return e = Hy({ mode: "visible", children: e }, n.mode, 0, null), e.return = n, n.child = e } function q2(n, e, t, r) { return r !== null && AC(r), U3(e, n.child, null, t), n = RC(e, e.pendingProps.children), n.flags |= 2, e.memoizedState = null, n } function JV(n, e, t, r, i, s, a) { if (t) return e.flags & 256 ? (e.flags &= -257, r = ix(Error(Ze(422))), q2(n, e, a, r)) : e.memoizedState !== null ? (e.child = n.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Hy({ mode: "visible", children: r.children }, i, 0, null), s = rp(s, i, a, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && U3(e, n.child, null, a), e.child.memoizedState = NE(a), e.memoizedState = kE, s); if (!(e.mode & 1)) return q2(n, e, a, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var o = r.dgst; return r = o, s = Error(Ze(419)), r = ix(s, r, void 0), q2(n, e, a, r) } if (o = (a & n.childLanes) !== 0, io || o) { if (r = Ns, r !== null) { switch (a & -a) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | a) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, uf(n, i), pu(r, n, i, -1)) } return NC(), r = ix(Error(Ze(421))), q2(n, e, a, r) } return i.data === "$?" ? (e.flags |= 128, e.child = n.child, e = lW.bind(null, n), i._reactRetry = e, null) : (n = s.treeContext, No = ph(i.nextSibling), Uo = e, ai = !0, ou = null, n !== null && (gl[Al++] = Jc, gl[Al++] = Kc, gl[Al++] = Ap, Jc = n.id, Kc = n.overflow, Ap = e), e = RC(e, r.children), e.flags |= 4096, e) } function QI(n, e, t) { n.lanes |= e; var r = n.alternate; r !== null && (r.lanes |= e), BE(n.return, e, t) } function sx(n, e, t, r, i) { var s = n.memoizedState; s === null ? n.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: t, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = t, s.tailMode = i) } function uF(n, e, t) { var r = e.pendingProps, i = r.revealOrder, s = r.tail; if (Pa(n, e, r.children, t), r = fi.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (n !== null && n.flags & 128) e: for (n = e.child; n !== null;) { if (n.tag === 13) n.memoizedState !== null && QI(n, t, e); else if (n.tag === 19) QI(n, t, e); else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break e; for (; n.sibling === null;) { if (n.return === null || n.return === e) break e; n = n.return } n.sibling.return = n.return, n = n.sibling } r &= 1 } if (Qr(fi, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (t = e.child, i = null; t !== null;)n = t.alternate, n !== null && F6(n) === null && (i = t), t = t.sibling; t = i, t === null ? (i = e.child, e.child = null) : (i = t.sibling, t.sibling = null), sx(e, !1, i, t, s); break; case "backwards": for (t = null, i = e.child, e.child = null; i !== null;) { if (n = i.alternate, n !== null && F6(n) === null) { e.child = i; break } n = i.sibling, i.sibling = t, t = i, i = n } sx(e, !0, t, null, s); break; case "together": sx(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function z5(n, e) { !(e.mode & 1) && n !== null && (n.alternate = null, e.alternate = null, e.flags |= 2) } function cf(n, e, t) { if (n !== null && (e.dependencies = n.dependencies), yp |= e.lanes, !(t & e.childLanes)) return null; if (n !== null && e.child !== n.child) throw Error(Ze(153)); if (e.child !== null) { for (n = e.child, t = vh(n, n.pendingProps), e.child = t, t.return = e; n.sibling !== null;)n = n.sibling, t = t.sibling = vh(n, n.pendingProps), t.return = e; t.sibling = null } return e.child } function KV(n, e, t) { switch (e.tag) { case 3: oF(e), O3(); break; case 5: kL(e); break; case 1: ao(e.type) && b6(e); break; case 4: CC(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; Qr(P6, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (Qr(fi, fi.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? lF(n, e, t) : (Qr(fi, fi.current & 1), n = cf(n, e, t), n !== null ? n.sibling : null); Qr(fi, fi.current & 1); break; case 19: if (r = (t & e.childLanes) !== 0, n.flags & 128) { if (r) return uF(n, e, t); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Qr(fi, fi.current), r) break; return null; case 22: case 23: return e.lanes = 0, sF(n, e, t) }return cf(n, e, t) } var cF, OE, fF, hF; cF = function (n, e) { for (var t = e.child; t !== null;) { if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode); else if (t.tag !== 4 && t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return; t = t.return } t.sibling.return = t.return, t = t.sibling } }; OE = function () { }; fF = function (n, e, t, r) { var i = n.memoizedProps; if (i !== r) { n = e.stateNode, Vd(tc.current); var s = null; switch (t) { case "input": i = aE(n, i), r = aE(n, r), s = []; break; case "select": i = yi({}, i, { value: void 0 }), r = yi({}, r, { value: void 0 }), s = []; break; case "textarea": i = uE(n, i), r = uE(n, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (n.onclick = I6) }fE(t, r); var a; t = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var o = i[u]; for (a in o) o.hasOwnProperty(a) && (t || (t = {}), t[a] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (gA.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { var l = r[u]; if (o = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== o && (l != null || o != null)) if (u === "style") if (o) { for (a in o) !o.hasOwnProperty(a) || l && l.hasOwnProperty(a) || (t || (t = {}), t[a] = ""); for (a in l) l.hasOwnProperty(a) && o[a] !== l[a] && (t || (t = {}), t[a] = l[a]) } else t || (s || (s = []), s.push(u, t)), t = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, o = o ? o.__html : void 0, l != null && o !== l && (s = s || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (gA.hasOwnProperty(u) ? (l != null && u === "onScroll" && Kr("scroll", n), s || o === l || (s = [])) : (s = s || []).push(u, l)) } t && (s = s || []).push("style", t); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; hF = function (n, e, t, r) { t !== r && (e.flags |= 4) }; function Xm(n, e) { if (!ai) switch (n.tailMode) { case "hidden": e = n.tail; for (var t = null; e !== null;)e.alternate !== null && (t = e), e = e.sibling; t === null ? n.tail = null : t.sibling = null; break; case "collapsed": t = n.tail; for (var r = null; t !== null;)t.alternate !== null && (r = t), t = t.sibling; r === null ? e || n.tail === null ? n.tail = null : n.tail.sibling = null : r.sibling = null } } function aa(n) { var e = n.alternate !== null && n.alternate.child === n.child, t = 0, r = 0; if (e) for (var i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = n, i = i.sibling; else for (i = n.child; i !== null;)t |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = n, i = i.sibling; return n.subtreeFlags |= r, n.childLanes = t, e } function qV(n, e, t) { var r = e.pendingProps; switch (gC(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return aa(e), null; case 1: return ao(e.type) && M6(), aa(e), null; case 3: return r = e.stateNode, G3(), ti(so), ti(ma), TC(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (n === null || n.child === null) && (J2(e) ? e.flags |= 4 : n === null || n.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, ou !== null && (XE(ou), ou = null))), OE(n, e), aa(e), null; case 5: SC(e); var i = Vd(MA.current); if (t = e.type, n !== null && e.stateNode != null) fF(n, e, t, r, i), n.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(Ze(166)); return aa(e), null } if (n = Vd(tc.current), J2(e)) { r = e.stateNode, t = e.type; var s = e.memoizedProps; switch (r[ju] = e, r[wA] = s, n = (e.mode & 1) !== 0, t) { case "dialog": Kr("cancel", r), Kr("close", r); break; case "iframe": case "object": case "embed": Kr("load", r); break; case "video": case "audio": for (i = 0; i < Cg.length; i++)Kr(Cg[i], r); break; case "source": Kr("error", r); break; case "img": case "image": case "link": Kr("error", r), Kr("load", r); break; case "details": Kr("toggle", r); break; case "input": Kw(r, s), Kr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, Kr("invalid", r); break; case "textarea": Zw(r, s), Kr("invalid", r) }fE(t, s), i = null; for (var a in s) if (s.hasOwnProperty(a)) { var o = s[a]; a === "children" ? typeof o == "string" ? r.textContent !== o && (s.suppressHydrationWarning !== !0 && j2(r.textContent, o, n), i = ["children", o]) : typeof o == "number" && r.textContent !== "" + o && (s.suppressHydrationWarning !== !0 && j2(r.textContent, o, n), i = ["children", "" + o]) : gA.hasOwnProperty(a) && o != null && a === "onScroll" && Kr("scroll", r) } switch (t) { case "input": G2(r), qw(r, s, !0); break; case "textarea": G2(r), $w(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = I6) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { a = i.nodeType === 9 ? i : i.ownerDocument, n === "http://www.w3.org/1999/xhtml" && (n = UD(t)), n === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n = a.createElement("div"), n.innerHTML = "<script><\/script>", n = n.removeChild(n.firstChild)) : typeof r.is == "string" ? n = a.createElement(t, { is: r.is }) : (n = a.createElement(t), t === "select" && (a = n, r.multiple ? a.multiple = !0 : r.size && (a.size = r.size))) : n = a.createElementNS(n, t), n[ju] = e, n[wA] = r, cF(n, e, !1, !1), e.stateNode = n; e: { switch (a = hE(t, r), t) { case "dialog": Kr("cancel", n), Kr("close", n), i = r; break; case "iframe": case "object": case "embed": Kr("load", n), i = r; break; case "video": case "audio": for (i = 0; i < Cg.length; i++)Kr(Cg[i], n); i = r; break; case "source": Kr("error", n), i = r; break; case "img": case "image": case "link": Kr("error", n), Kr("load", n), i = r; break; case "details": Kr("toggle", n), i = r; break; case "input": Kw(n, r), i = aE(n, r), Kr("invalid", n); break; case "option": i = r; break; case "select": n._wrapperState = { wasMultiple: !!r.multiple }, i = yi({}, r, { value: void 0 }), Kr("invalid", n); break; case "textarea": Zw(n, r), i = uE(n, r), Kr("invalid", n); break; default: i = r }fE(t, i), o = i; for (s in o) if (o.hasOwnProperty(s)) { var l = o[s]; s === "style" ? HD(n, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && GD(n, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && AA(n, l) : typeof l == "number" && AA(n, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (gA.hasOwnProperty(s) ? l != null && s === "onScroll" && Kr("scroll", n) : l != null && tC(n, s, l, a)) } switch (t) { case "input": G2(n), qw(n, r, !1); break; case "textarea": G2(n), $w(n); break; case "option": r.value != null && n.setAttribute("value", "" + wh(r.value)); break; case "select": n.multiple = !!r.multiple, s = r.value, s != null ? p3(n, !!r.multiple, s, !1) : r.defaultValue != null && p3(n, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (n.onclick = I6) }switch (t) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return aa(e), null; case 6: if (n && e.stateNode != null) hF(n, e, n.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(Ze(166)); if (t = Vd(MA.current), Vd(tc.current), J2(e)) { if (r = e.stateNode, t = e.memoizedProps, r[ju] = e, (s = r.nodeValue !== t) && (n = Uo, n !== null)) switch (n.tag) { case 3: j2(r.nodeValue, t, (n.mode & 1) !== 0); break; case 5: n.memoizedProps.suppressHydrationWarning !== !0 && j2(r.nodeValue, t, (n.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r), r[ju] = e, e.stateNode = r } return aa(e), null; case 13: if (ti(fi), r = e.memoizedState, n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) { if (ai && No !== null && e.mode & 1 && !(e.flags & 128)) bL(), O3(), e.flags |= 98560, s = !1; else if (s = J2(e), r !== null && r.dehydrated !== null) { if (n === null) { if (!s) throw Error(Ze(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Ze(317)); s[ju] = e } else O3(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; aa(e), s = !1 } else ou !== null && (XE(ou), ou = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = t, e) : (r = r !== null, r !== (n !== null && n.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (n === null || fi.current & 1 ? ys === 0 && (ys = 3) : NC())), e.updateQueue !== null && (e.flags |= 4), aa(e), null); case 4: return G3(), OE(n, e), n === null && SA(e.stateNode.containerInfo), aa(e), null; case 10: return xC(e.type._context), aa(e), null; case 17: return ao(e.type) && M6(), aa(e), null; case 19: if (ti(fi), s = e.memoizedState, s === null) return aa(e), null; if (r = (e.flags & 128) !== 0, a = s.rendering, a === null) if (r) Xm(s, !1); else { if (ys !== 0 || n !== null && n.flags & 128) for (n = e.child; n !== null;) { if (a = F6(n), a !== null) { for (e.flags |= 128, Xm(s, !1), r = a.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = t, t = e.child; t !== null;)s = t, n = r, s.flags &= 14680066, a = s.alternate, a === null ? (s.childLanes = 0, s.lanes = n, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = a.childLanes, s.lanes = a.lanes, s.child = a.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = a.memoizedProps, s.memoizedState = a.memoizedState, s.updateQueue = a.updateQueue, s.type = a.type, n = a.dependencies, s.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }), t = t.sibling; return Qr(fi, fi.current & 1 | 2), e.child } n = n.sibling } s.tail !== null && Vi() > H3 && (e.flags |= 128, r = !0, Xm(s, !1), e.lanes = 4194304) } else { if (!r) if (n = F6(a), n !== null) { if (e.flags |= 128, r = !0, t = n.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Xm(s, !0), s.tail === null && s.tailMode === "hidden" && !a.alternate && !ai) return aa(e), null } else 2 * Vi() - s.renderingStartTime > H3 && t !== 1073741824 && (e.flags |= 128, r = !0, Xm(s, !1), e.lanes = 4194304); s.isBackwards ? (a.sibling = e.child, e.child = a) : (t = s.last, t !== null ? t.sibling = a : e.child = a, s.last = a) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Vi(), e.sibling = null, t = fi.current, Qr(fi, r ? t & 1 | 2 : t & 1), e) : (aa(e), null); case 22: case 23: return kC(), r = e.memoizedState !== null, n !== null && n.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Bo & 1073741824 && (aa(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : aa(e), null; case 24: return null; case 25: return null }throw Error(Ze(156, e.tag)) } function ZV(n, e) { switch (gC(e), e.tag) { case 1: return ao(e.type) && M6(), n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 3: return G3(), ti(so), ti(ma), TC(), n = e.flags, n & 65536 && !(n & 128) ? (e.flags = n & -65537 | 128, e) : null; case 5: return SC(e), null; case 13: if (ti(fi), n = e.memoizedState, n !== null && n.dehydrated !== null) { if (e.alternate === null) throw Error(Ze(340)); O3() } return n = e.flags, n & 65536 ? (e.flags = n & -65537 | 128, e) : null; case 19: return ti(fi), null; case 4: return G3(), null; case 10: return xC(e.type._context), null; case 22: case 23: return kC(), null; case 24: return null; default: return null } } var Z2 = !1, ca = !1, $V = typeof WeakSet == "function" ? WeakSet : Set, wt = null; function $0(n, e) { var t = n.ref; if (t !== null) if (typeof t == "function") try { t(null) } catch (r) { wi(n, e, r) } else t.current = null } function UE(n, e, t) { try { t() } catch (r) { wi(n, e, r) } } var HI = !1; function eW(n, e) { if (EE = S6, n = gL(), pC(n)) { if ("selectionStart" in n) var t = { start: n.selectionStart, end: n.selectionEnd }; else e: { t = (t = n.ownerDocument) && t.defaultView || window; var r = t.getSelection && t.getSelection(); if (r && r.rangeCount !== 0) { t = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { t.nodeType, s.nodeType } catch { t = null; break e } var a = 0, o = -1, l = -1, u = 0, c = 0, h = n, d = null; t: for (; ;) { for (var m; h !== t || i !== 0 && h.nodeType !== 3 || (o = a + i), h !== s || r !== 0 && h.nodeType !== 3 || (l = a + r), h.nodeType === 3 && (a += h.nodeValue.length), (m = h.firstChild) !== null;)d = h, h = m; for (; ;) { if (h === n) break t; if (d === t && ++u === i && (o = a), d === s && ++c === r && (l = a), (m = h.nextSibling) !== null) break; h = d, d = h.parentNode } h = m } t = o === -1 || l === -1 ? null : { start: o, end: l } } else t = null } t = t || { start: 0, end: 0 } } else t = null; for (CE = { focusedElem: n, selectionRange: t }, S6 = !1, wt = e; wt !== null;)if (e = wt, n = e.child, (e.subtreeFlags & 1028) !== 0 && n !== null) n.return = e, wt = n; else for (; wt !== null;) { e = wt; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var v = g.memoizedProps, y = g.memoizedState, A = e.stateNode, _ = A.getSnapshotBeforeUpdate(e.elementType === e.type ? v : ru(e.type, v), y); A.__reactInternalSnapshotBeforeUpdate = _ } break; case 3: var x = e.stateNode.containerInfo; x.nodeType === 1 ? x.textContent = "" : x.nodeType === 9 && x.documentElement && x.removeChild(x.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(Ze(163)) } } catch (C) { wi(e, e.return, C) } if (n = e.sibling, n !== null) { n.return = e.return, wt = n; break } wt = e.return } return g = HI, HI = !1, g } function zg(n, e, t) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & n) === n) { var s = i.destroy; i.destroy = void 0, s !== void 0 && UE(e, t, s) } i = i.next } while (i !== r) } } function Gy(n, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var t = e = e.next; do { if ((t.tag & n) === n) { var r = t.create; t.destroy = r() } t = t.next } while (t !== e) } } function GE(n) { var e = n.ref; if (e !== null) { var t = n.stateNode; switch (n.tag) { case 5: n = t; break; default: n = t }typeof e == "function" ? e(n) : e.current = n } } function dF(n) { var e = n.alternate; e !== null && (n.alternate = null, dF(e)), n.child = null, n.deletions = null, n.sibling = null, n.tag === 5 && (e = n.stateNode, e !== null && (delete e[ju], delete e[wA], delete e[wE], delete e[kV], delete e[NV])), n.stateNode = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null } function pF(n) { return n.tag === 5 || n.tag === 3 || n.tag === 4 } function zI(n) { e: for (; ;) { for (; n.sibling === null;) { if (n.return === null || pF(n.return)) return null; n = n.return } for (n.sibling.return = n.return, n = n.sibling; n.tag !== 5 && n.tag !== 6 && n.tag !== 18;) { if (n.flags & 2 || n.child === null || n.tag === 4) continue e; n.child.return = n, n = n.child } if (!(n.flags & 2)) return n.stateNode } } function QE(n, e, t) { var r = n.tag; if (r === 5 || r === 6) n = n.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n, e) : t.insertBefore(n, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n, t)) : (e = t, e.appendChild(n)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = I6)); else if (r !== 4 && (n = n.child, n !== null)) for (QE(n, e, t), n = n.sibling; n !== null;)QE(n, e, t), n = n.sibling } function HE(n, e, t) { var r = n.tag; if (r === 5 || r === 6) n = n.stateNode, e ? t.insertBefore(n, e) : t.appendChild(n); else if (r !== 4 && (n = n.child, n !== null)) for (HE(n, e, t), n = n.sibling; n !== null;)HE(n, e, t), n = n.sibling } var js = null, au = !1; function Nf(n, e, t) { for (t = t.child; t !== null;)mF(n, e, t), t = t.sibling } function mF(n, e, t) { if (ec && typeof ec.onCommitFiberUnmount == "function") try { ec.onCommitFiberUnmount(Py, t) } catch { } switch (t.tag) { case 5: ca || $0(t, e); case 6: var r = js, i = au; js = null, Nf(n, e, t), js = r, au = i, js !== null && (au ? (n = js, t = t.stateNode, n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t)) : js.removeChild(t.stateNode)); break; case 18: js !== null && (au ? (n = js, t = t.stateNode, n.nodeType === 8 ? Z4(n.parentNode, t) : n.nodeType === 1 && Z4(n, t), _A(n)) : Z4(js, t.stateNode)); break; case 4: r = js, i = au, js = t.stateNode.containerInfo, au = !0, Nf(n, e, t), js = r, au = i; break; case 0: case 11: case 14: case 15: if (!ca && (r = t.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, a = s.destroy; s = s.tag, a !== void 0 && (s & 2 || s & 4) && UE(t, e, a), i = i.next } while (i !== r) } Nf(n, e, t); break; case 1: if (!ca && ($0(t, e), r = t.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = t.memoizedProps, r.state = t.memoizedState, r.componentWillUnmount() } catch (o) { wi(t, e, o) } Nf(n, e, t); break; case 21: Nf(n, e, t); break; case 22: t.mode & 1 ? (ca = (r = ca) || t.memoizedState !== null, Nf(n, e, t), ca = r) : Nf(n, e, t); break; default: Nf(n, e, t) } } function VI(n) { var e = n.updateQueue; if (e !== null) { n.updateQueue = null; var t = n.stateNode; t === null && (t = n.stateNode = new $V), e.forEach(function (r) { var i = uW.bind(null, n, r); t.has(r) || (t.add(r), r.then(i, i)) }) } } function Zl(n, e) { var t = e.deletions; if (t !== null) for (var r = 0; r < t.length; r++) { var i = t[r]; try { var s = n, a = e, o = a; e: for (; o !== null;) { switch (o.tag) { case 5: js = o.stateNode, au = !1; break e; case 3: js = o.stateNode.containerInfo, au = !0; break e; case 4: js = o.stateNode.containerInfo, au = !0; break e }o = o.return } if (js === null) throw Error(Ze(160)); mF(s, a, i), js = null, au = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { wi(i, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)gF(e, n), e = e.sibling } function gF(n, e) { var t = n.alternate, r = n.flags; switch (n.tag) { case 0: case 11: case 14: case 15: if (Zl(e, n), zu(n), r & 4) { try { zg(3, n, n.return), Gy(3, n) } catch (v) { wi(n, n.return, v) } try { zg(5, n, n.return) } catch (v) { wi(n, n.return, v) } } break; case 1: Zl(e, n), zu(n), r & 512 && t !== null && $0(t, t.return); break; case 5: if (Zl(e, n), zu(n), r & 512 && t !== null && $0(t, t.return), n.flags & 32) { var i = n.stateNode; try { AA(i, "") } catch (v) { wi(n, n.return, v) } } if (r & 4 && (i = n.stateNode, i != null)) { var s = n.memoizedProps, a = t !== null ? t.memoizedProps : s, o = n.type, l = n.updateQueue; if (n.updateQueue = null, l !== null) try { o === "input" && s.type === "radio" && s.name != null && ND(i, s), hE(o, a); var u = hE(o, s); for (a = 0; a < l.length; a += 2) { var c = l[a], h = l[a + 1]; c === "style" ? HD(i, h) : c === "dangerouslySetInnerHTML" ? GD(i, h) : c === "children" ? AA(i, h) : tC(i, c, h, u) } switch (o) { case "input": oE(i, s); break; case "textarea": OD(i, s); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var m = s.value; m != null ? p3(i, !!s.multiple, m, !1) : d !== !!s.multiple && (s.defaultValue != null ? p3(i, !!s.multiple, s.defaultValue, !0) : p3(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[wA] = s } catch (v) { wi(n, n.return, v) } } break; case 6: if (Zl(e, n), zu(n), r & 4) { if (n.stateNode === null) throw Error(Ze(162)); i = n.stateNode, s = n.memoizedProps; try { i.nodeValue = s } catch (v) { wi(n, n.return, v) } } break; case 3: if (Zl(e, n), zu(n), r & 4 && t !== null && t.memoizedState.isDehydrated) try { _A(e.containerInfo) } catch (v) { wi(n, n.return, v) } break; case 4: Zl(e, n), zu(n); break; case 13: Zl(e, n), zu(n), i = n.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (LC = Vi())), r & 4 && VI(n); break; case 22: if (c = t !== null && t.memoizedState !== null, n.mode & 1 ? (ca = (u = ca) || c, Zl(e, n), ca = u) : Zl(e, n), zu(n), r & 8192) { if (u = n.memoizedState !== null, (n.stateNode.isHidden = u) && !c && n.mode & 1) for (wt = n, c = n.child; c !== null;) { for (h = wt = c; wt !== null;) { switch (d = wt, m = d.child, d.tag) { case 0: case 11: case 14: case 15: zg(4, d, d.return); break; case 1: $0(d, d.return); var g = d.stateNode; if (typeof g.componentWillUnmount == "function") { r = d, t = d.return; try { e = r, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (v) { wi(r, t, v) } } break; case 5: $0(d, d.return); break; case 22: if (d.memoizedState !== null) { XI(h); continue } }m !== null ? (m.return = d, wt = m) : XI(h) } c = c.sibling } e: for (c = null, h = n; ;) { if (h.tag === 5) { if (c === null) { c = h; try { i = h.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (o = h.stateNode, l = h.memoizedProps.style, a = l != null && l.hasOwnProperty("display") ? l.display : null, o.style.display = QD("display", a)) } catch (v) { wi(n, n.return, v) } } } else if (h.tag === 6) { if (c === null) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (v) { wi(n, n.return, v) } } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === n) && h.child !== null) { h.child.return = h, h = h.child; continue } if (h === n) break e; for (; h.sibling === null;) { if (h.return === null || h.return === n) break e; c === h && (c = null), h = h.return } c === h && (c = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: Zl(e, n), zu(n), r & 4 && VI(n); break; case 21: break; default: Zl(e, n), zu(n) } } function zu(n) { var e = n.flags; if (e & 2) { try { e: { for (var t = n.return; t !== null;) { if (pF(t)) { var r = t; break e } t = t.return } throw Error(Ze(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (AA(i, ""), r.flags &= -33); var s = zI(n); HE(n, s, i); break; case 3: case 4: var a = r.stateNode.containerInfo, o = zI(n); QE(n, o, a); break; default: throw Error(Ze(161)) } } catch (l) { wi(n, n.return, l) } n.flags &= -3 } e & 4096 && (n.flags &= -4097) } function tW(n, e, t) { wt = n, AF(n) } function AF(n, e, t) { for (var r = (n.mode & 1) !== 0; wt !== null;) { var i = wt, s = i.child; if (i.tag === 22 && r) { var a = i.memoizedState !== null || Z2; if (!a) { var o = i.alternate, l = o !== null && o.memoizedState !== null || ca; o = Z2; var u = ca; if (Z2 = a, (ca = l) && !u) for (wt = i; wt !== null;)a = wt, l = a.child, a.tag === 22 && a.memoizedState !== null ? YI(i) : l !== null ? (l.return = a, wt = l) : YI(i); for (; s !== null;)wt = s, AF(s), s = s.sibling; wt = i, Z2 = o, ca = u } WI(n) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, wt = s) : WI(n) } } function WI(n) { for (; wt !== null;) { var e = wt; if (e.flags & 8772) { var t = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: ca || Gy(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !ca) if (t === null) r.componentDidMount(); else { var i = e.elementType === e.type ? t.memoizedProps : ru(e.type, t.memoizedProps); r.componentDidUpdate(i, t.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && MI(e, s, r); break; case 3: var a = e.updateQueue; if (a !== null) { if (t = null, e.child !== null) switch (e.child.tag) { case 5: t = e.child.stateNode; break; case 1: t = e.child.stateNode }MI(e, a, t) } break; case 5: var o = e.stateNode; if (t === null && e.flags & 4) { t = o; var l = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && t.focus(); break; case "img": l.src && (t.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var h = c.dehydrated; h !== null && _A(h) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(Ze(163)) }ca || e.flags & 512 && GE(e) } catch (d) { wi(e, e.return, d) } } if (e === n) { wt = null; break } if (t = e.sibling, t !== null) { t.return = e.return, wt = t; break } wt = e.return } } function XI(n) { for (; wt !== null;) { var e = wt; if (e === n) { wt = null; break } var t = e.sibling; if (t !== null) { t.return = e.return, wt = t; break } wt = e.return } } function YI(n) { for (; wt !== null;) { var e = wt; try { switch (e.tag) { case 0: case 11: case 15: var t = e.return; try { Gy(4, e) } catch (l) { wi(e, t, l) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (l) { wi(e, i, l) } } var s = e.return; try { GE(e) } catch (l) { wi(e, s, l) } break; case 5: var a = e.return; try { GE(e) } catch (l) { wi(e, a, l) } } } catch (l) { wi(e, e.return, l) } if (e === n) { wt = null; break } var o = e.sibling; if (o !== null) { o.return = e.return, wt = o; break } wt = e.return } } var nW = Math.ceil, O6 = xf.ReactCurrentDispatcher, PC = xf.ReactCurrentOwner, Sl = xf.ReactCurrentBatchConfig, er = 0, Ns = null, is = null, Zs = 0, Bo = 0, e3 = Vh(0), ys = 0, PA = null, yp = 0, Qy = 0, DC = 0, Vg = null, eo = null, LC = 0, H3 = 1 / 0, Hc = null, U6 = !1, zE = null, gh = null, $2 = !1, rh = null, G6 = 0, Wg = 0, VE = null, V5 = -1, W5 = 0; function Ua() { return er & 6 ? Vi() : V5 !== -1 ? V5 : V5 = Vi() } function Ah(n) { return n.mode & 1 ? er & 2 && Zs !== 0 ? Zs & -Zs : UV.transition !== null ? (W5 === 0 && (W5 = eL()), W5) : (n = Ar, n !== 0 || (n = window.event, n = n === void 0 ? 16 : oL(n.type)), n) : 1 } function pu(n, e, t, r) { if (50 < Wg) throw Wg = 0, VE = null, Error(Ze(185)); E1(n, t, r), (!(er & 2) || n !== Ns) && (n === Ns && (!(er & 2) && (Qy |= t), ys === 4 && th(n, Zs)), oo(n, r), t === 1 && er === 0 && !(e.mode & 1) && (H3 = Vi() + 500, Ny && Wh())) } function oo(n, e) { var t = n.callbackNode; Uz(n, e); var r = C6(n, n === Ns ? Zs : 0); if (r === 0) t !== null && nI(t), n.callbackNode = null, n.callbackPriority = 0; else if (e = r & -r, n.callbackPriority !== e) { if (t != null && nI(t), e === 1) n.tag === 0 ? OV(jI.bind(null, n)) : wL(jI.bind(null, n)), LV(function () { !(er & 6) && Wh() }), t = null; else { switch (tL(r)) { case 1: t = aC; break; case 4: t = ZD; break; case 16: t = E6; break; case 536870912: t = $D; break; default: t = E6 }t = TF(t, vF.bind(null, n)) } n.callbackPriority = e, n.callbackNode = t } } function vF(n, e) { if (V5 = -1, W5 = 0, er & 6) throw Error(Ze(327)); var t = n.callbackNode; if (y3() && n.callbackNode !== t) return null; var r = C6(n, n === Ns ? Zs : 0); if (r === 0) return null; if (r & 30 || r & n.expiredLanes || e) e = Q6(n, r); else { e = r; var i = er; er |= 2; var s = xF(); (Ns !== n || Zs !== e) && (Hc = null, H3 = Vi() + 500, np(n, e)); do try { sW(); break } catch (o) { yF(n, o) } while (1); yC(), O6.current = s, er = i, is !== null ? e = 0 : (Ns = null, Zs = 0, e = ys) } if (e !== 0) { if (e === 2 && (i = AE(n), i !== 0 && (r = i, e = WE(n, i))), e === 1) throw t = PA, np(n, 0), th(n, r), oo(n, Vi()), t; if (e === 6) th(n, r); else { if (i = n.current.alternate, !(r & 30) && !rW(i) && (e = Q6(n, r), e === 2 && (s = AE(n), s !== 0 && (r = s, e = WE(n, s))), e === 1)) throw t = PA, np(n, 0), th(n, r), oo(n, Vi()), t; switch (n.finishedWork = i, n.finishedLanes = r, e) { case 0: case 1: throw Error(Ze(345)); case 2: Id(n, eo, Hc); break; case 3: if (th(n, r), (r & 130023424) === r && (e = LC + 500 - Vi(), 10 < e)) { if (C6(n, 0) !== 0) break; if (i = n.suspendedLanes, (i & r) !== r) { Ua(), n.pingedLanes |= n.suspendedLanes & i; break } n.timeoutHandle = TE(Id.bind(null, n, eo, Hc), e); break } Id(n, eo, Hc); break; case 4: if (th(n, r), (r & 4194240) === r) break; for (e = n.eventTimes, i = -1; 0 < r;) { var a = 31 - du(r); s = 1 << a, a = e[a], a > i && (i = a), r &= ~s } if (r = i, r = Vi() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * nW(r / 1960)) - r, 10 < r) { n.timeoutHandle = TE(Id.bind(null, n, eo, Hc), r); break } Id(n, eo, Hc); break; case 5: Id(n, eo, Hc); break; default: throw Error(Ze(329)) } } } return oo(n, Vi()), n.callbackNode === t ? vF.bind(null, n) : null } function WE(n, e) { var t = Vg; return n.current.memoizedState.isDehydrated && (np(n, e).flags |= 256), n = Q6(n, e), n !== 2 && (e = eo, eo = t, e !== null && XE(e)), n } function XE(n) { eo === null ? eo = n : eo.push.apply(eo, n) } function rW(n) { for (var e = n; ;) { if (e.flags & 16384) { var t = e.updateQueue; if (t !== null && (t = t.stores, t !== null)) for (var r = 0; r < t.length; r++) { var i = t[r], s = i.getSnapshot; i = i.value; try { if (!vu(s(), i)) return !1 } catch { return !1 } } } if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t; else { if (e === n) break; for (; e.sibling === null;) { if (e.return === null || e.return === n) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function th(n, e) { for (e &= ~DC, e &= ~Qy, n.suspendedLanes |= e, n.pingedLanes &= ~e, n = n.expirationTimes; 0 < e;) { var t = 31 - du(e), r = 1 << t; n[t] = -1, e &= ~r } } function jI(n) { if (er & 6) throw Error(Ze(327)); y3(); var e = C6(n, 0); if (!(e & 1)) return oo(n, Vi()), null; var t = Q6(n, e); if (n.tag !== 0 && t === 2) { var r = AE(n); r !== 0 && (e = r, t = WE(n, r)) } if (t === 1) throw t = PA, np(n, 0), th(n, e), oo(n, Vi()), t; if (t === 6) throw Error(Ze(345)); return n.finishedWork = n.current.alternate, n.finishedLanes = e, Id(n, eo, Hc), oo(n, Vi()), null } function FC(n, e) { var t = er; er |= 1; try { return n(e) } finally { er = t, er === 0 && (H3 = Vi() + 500, Ny && Wh()) } } function xp(n) { rh !== null && rh.tag === 0 && !(er & 6) && y3(); var e = er; er |= 1; var t = Sl.transition, r = Ar; try { if (Sl.transition = null, Ar = 1, n) return n() } finally { Ar = r, Sl.transition = t, er = e, !(er & 6) && Wh() } } function kC() { Bo = e3.current, ti(e3) } function np(n, e) { n.finishedWork = null, n.finishedLanes = 0; var t = n.timeoutHandle; if (t !== -1 && (n.timeoutHandle = -1, DV(t)), is !== null) for (t = is.return; t !== null;) { var r = t; switch (gC(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && M6(); break; case 3: G3(), ti(so), ti(ma), TC(); break; case 5: SC(r); break; case 4: G3(); break; case 13: ti(fi); break; case 19: ti(fi); break; case 10: xC(r.type._context); break; case 22: case 23: kC() }t = t.return } if (Ns = n, is = n = vh(n.current, null), Zs = Bo = e, ys = 0, PA = null, DC = Qy = yp = 0, eo = Vg = null, zd !== null) { for (e = 0; e < zd.length; e++)if (t = zd[e], r = t.interleaved, r !== null) { t.interleaved = null; var i = r.next, s = t.pending; if (s !== null) { var a = s.next; s.next = i, r.next = a } t.pending = r } zd = null } return n } function yF(n, e) { do { var t = is; try { if (yC(), Q5.current = N6, k6) { for (var r = Ai.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } k6 = !1 } if (vp = 0, Fs = ps = Ai = null, Hg = !1, bA = 0, PC.current = null, t === null || t.return === null) { ys = 1, PA = e, is = null; break } e: { var s = n, a = t.return, o = t, l = e; if (e = Zs, o.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = o, h = c.tag; if (!(c.mode & 1) && (h === 0 || h === 11 || h === 15)) { var d = c.alternate; d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null) } var m = FI(a); if (m !== null) { m.flags &= -257, kI(m, a, o, s, e), m.mode & 1 && LI(s, u, e), e = m, l = u; var g = e.updateQueue; if (g === null) { var v = new Set; v.add(l), e.updateQueue = v } else g.add(l); break e } else { if (!(e & 1)) { LI(s, u, e), NC(); break e } l = Error(Ze(426)) } } else if (ai && o.mode & 1) { var y = FI(a); if (y !== null) { !(y.flags & 65536) && (y.flags |= 256), kI(y, a, o, s, e), AC(Q3(l, o)); break e } } s = l = Q3(l, o), ys !== 4 && (ys = 2), Vg === null ? Vg = [s] : Vg.push(s), s = a; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var A = nF(s, l, e); II(s, A); break e; case 1: o = l; var _ = s.type, x = s.stateNode; if (!(s.flags & 128) && (typeof _.getDerivedStateFromError == "function" || x !== null && typeof x.componentDidCatch == "function" && (gh === null || !gh.has(x)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var C = rF(s, o, e); II(s, C); break e } }s = s.return } while (s !== null) } EF(t) } catch (T) { e = T, is === t && t !== null && (is = t = t.return); continue } break } while (1) } function xF() { var n = O6.current; return O6.current = N6, n === null ? N6 : n } function NC() { (ys === 0 || ys === 3 || ys === 2) && (ys = 4), Ns === null || !(yp & 268435455) && !(Qy & 268435455) || th(Ns, Zs) } function Q6(n, e) { var t = er; er |= 2; var r = xF(); (Ns !== n || Zs !== e) && (Hc = null, np(n, e)); do try { iW(); break } catch (i) { yF(n, i) } while (1); if (yC(), er = t, O6.current = r, is !== null) throw Error(Ze(261)); return Ns = null, Zs = 0, ys } function iW() { for (; is !== null;)_F(is) } function sW() { for (; is !== null && !Bz();)_F(is) } function _F(n) { var e = SF(n.alternate, n, Bo); n.memoizedProps = n.pendingProps, e === null ? EF(n) : is = e, PC.current = null } function EF(n) { var e = n; do { var t = e.alternate; if (n = e.return, e.flags & 32768) { if (t = ZV(t, e), t !== null) { t.flags &= 32767, is = t; return } if (n !== null) n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null; else { ys = 6, is = null; return } } else if (t = qV(t, e, Bo), t !== null) { is = t; return } if (e = e.sibling, e !== null) { is = e; return } is = e = n } while (e !== null); ys === 0 && (ys = 5) } function Id(n, e, t) { var r = Ar, i = Sl.transition; try { Sl.transition = null, Ar = 1, aW(n, e, t, r) } finally { Sl.transition = i, Ar = r } return null } function aW(n, e, t, r) { do y3(); while (rh !== null); if (er & 6) throw Error(Ze(327)); t = n.finishedWork; var i = n.finishedLanes; if (t === null) return null; if (n.finishedWork = null, n.finishedLanes = 0, t === n.current) throw Error(Ze(177)); n.callbackNode = null, n.callbackPriority = 0; var s = t.lanes | t.childLanes; if (Gz(n, s), n === Ns && (is = Ns = null, Zs = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || $2 || ($2 = !0, TF(E6, function () { return y3(), null })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) { s = Sl.transition, Sl.transition = null; var a = Ar; Ar = 1; var o = er; er |= 4, PC.current = null, eW(n, t), gF(t, n), wV(CE), S6 = !!EE, CE = EE = null, n.current = t, tW(t), Rz(), er = o, Ar = a, Sl.transition = s } else n.current = t; if ($2 && ($2 = !1, rh = n, G6 = i), s = n.pendingLanes, s === 0 && (gh = null), Lz(t.stateNode), oo(n, Vi()), e !== null) for (r = n.onRecoverableError, t = 0; t < e.length; t++)i = e[t], r(i.value, { componentStack: i.stack, digest: i.digest }); if (U6) throw U6 = !1, n = zE, zE = null, n; return G6 & 1 && n.tag !== 0 && y3(), s = n.pendingLanes, s & 1 ? n === VE ? Wg++ : (Wg = 0, VE = n) : Wg = 0, Wh(), null } function y3() { if (rh !== null) { var n = tL(G6), e = Sl.transition, t = Ar; try { if (Sl.transition = null, Ar = 16 > n ? 16 : n, rh === null) var r = !1; else { if (n = rh, rh = null, G6 = 0, er & 6) throw Error(Ze(331)); var i = er; for (er |= 4, wt = n.current; wt !== null;) { var s = wt, a = s.child; if (wt.flags & 16) { var o = s.deletions; if (o !== null) { for (var l = 0; l < o.length; l++) { var u = o[l]; for (wt = u; wt !== null;) { var c = wt; switch (c.tag) { case 0: case 11: case 15: zg(8, c, s) }var h = c.child; if (h !== null) h.return = c, wt = h; else for (; wt !== null;) { c = wt; var d = c.sibling, m = c.return; if (dF(c), c === u) { wt = null; break } if (d !== null) { d.return = m, wt = d; break } wt = m } } } var g = s.alternate; if (g !== null) { var v = g.child; if (v !== null) { g.child = null; do { var y = v.sibling; v.sibling = null, v = y } while (v !== null) } } wt = s } } if (s.subtreeFlags & 2064 && a !== null) a.return = s, wt = a; else e: for (; wt !== null;) { if (s = wt, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: zg(9, s, s.return) }var A = s.sibling; if (A !== null) { A.return = s.return, wt = A; break e } wt = s.return } } var _ = n.current; for (wt = _; wt !== null;) { a = wt; var x = a.child; if (a.subtreeFlags & 2064 && x !== null) x.return = a, wt = x; else e: for (a = _; wt !== null;) { if (o = wt, o.flags & 2048) try { switch (o.tag) { case 0: case 11: case 15: Gy(9, o) } } catch (T) { wi(o, o.return, T) } if (o === a) { wt = null; break e } var C = o.sibling; if (C !== null) { C.return = o.return, wt = C; break e } wt = o.return } } if (er = i, Wh(), ec && typeof ec.onPostCommitFiberRoot == "function") try { ec.onPostCommitFiberRoot(Py, n) } catch { } r = !0 } return r } finally { Ar = t, Sl.transition = e } } return !1 } function JI(n, e, t) { e = Q3(t, e), e = nF(n, e, 1), n = mh(n, e, 1), e = Ua(), n !== null && (E1(n, 1, e), oo(n, e)) } function wi(n, e, t) { if (n.tag === 3) JI(n, n, t); else for (; e !== null;) { if (e.tag === 3) { JI(e, n, t); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (gh === null || !gh.has(r))) { n = Q3(t, n), n = rF(e, n, 1), e = mh(e, n, 1), n = Ua(), e !== null && (E1(e, 1, n), oo(e, n)); break } } e = e.return } } function oW(n, e, t) { var r = n.pingCache; r !== null && r.delete(e), e = Ua(), n.pingedLanes |= n.suspendedLanes & t, Ns === n && (Zs & t) === t && (ys === 4 || ys === 3 && (Zs & 130023424) === Zs && 500 > Vi() - LC ? np(n, 0) : DC |= t), oo(n, e) } function CF(n, e) { e === 0 && (n.mode & 1 ? (e = z2, z2 <<= 1, !(z2 & 130023424) && (z2 = 4194304)) : e = 1); var t = Ua(); n = uf(n, e), n !== null && (E1(n, e, t), oo(n, t)) } function lW(n) { var e = n.memoizedState, t = 0; e !== null && (t = e.retryLane), CF(n, t) } function uW(n, e) { var t = 0; switch (n.tag) { case 13: var r = n.stateNode, i = n.memoizedState; i !== null && (t = i.retryLane); break; case 19: r = n.stateNode; break; default: throw Error(Ze(314)) }r !== null && r.delete(e), CF(n, t) } var SF; SF = function (n, e, t) { if (n !== null) if (n.memoizedProps !== e.pendingProps || so.current) io = !0; else { if (!(n.lanes & t) && !(e.flags & 128)) return io = !1, KV(n, e, t); io = !!(n.flags & 131072) } else io = !1, ai && e.flags & 1048576 && IL(e, R6, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; z5(n, e), n = e.pendingProps; var i = N3(e, ma.current); v3(e, t), i = IC(null, e, r, n, i, t); var s = MC(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, ao(r) ? (s = !0, b6(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, EC(e), i.updater = Oy, e.stateNode = i, i._reactInternals = e, PE(e, r, n, t), e = FE(null, e, r, !0, s, t)) : (e.tag = 0, ai && s && mC(e), Pa(null, e, i, t), e = e.child), e; case 16: r = e.elementType; e: { switch (z5(n, e), n = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = fW(r), n = ru(r, n), i) { case 0: e = LE(null, e, r, n, t); break e; case 1: e = UI(null, e, r, n, t); break e; case 11: e = NI(null, e, r, n, t); break e; case 14: e = OI(null, e, r, ru(r.type, n), t); break e }throw Error(Ze(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : ru(r, i), LE(n, e, r, i, t); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : ru(r, i), UI(n, e, r, i, t); case 3: e: { if (oF(e), n === null) throw Error(Ze(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, RL(n, e), L6(e, r, null, t); var a = e.memoizedState; if (r = a.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: a.cache, pendingSuspenseBoundaries: a.pendingSuspenseBoundaries, transitions: a.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Q3(Error(Ze(423)), e), e = GI(n, e, r, t, i); break e } else if (r !== i) { i = Q3(Error(Ze(424)), e), e = GI(n, e, r, t, i); break e } else for (No = ph(e.stateNode.containerInfo.firstChild), Uo = e, ai = !0, ou = null, t = FL(e, null, r, t), e.child = t; t;)t.flags = t.flags & -3 | 4096, t = t.sibling; else { if (O3(), r === i) { e = cf(n, e, t); break e } Pa(n, e, r, t) } e = e.child } return e; case 5: return kL(e), n === null && bE(e), r = e.type, i = e.pendingProps, s = n !== null ? n.memoizedProps : null, a = i.children, SE(r, i) ? a = null : s !== null && SE(r, s) && (e.flags |= 32), aF(n, e), Pa(n, e, a, t), e.child; case 6: return n === null && bE(e), null; case 13: return lF(n, e, t); case 4: return CC(e, e.stateNode.containerInfo), r = e.pendingProps, n === null ? e.child = U3(e, null, r, t) : Pa(n, e, r, t), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : ru(r, i), NI(n, e, r, i, t); case 7: return Pa(n, e, e.pendingProps, t), e.child; case 8: return Pa(n, e, e.pendingProps.children, t), e.child; case 12: return Pa(n, e, e.pendingProps.children, t), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, a = i.value, Qr(P6, r._currentValue), r._currentValue = a, s !== null) if (vu(s.value, a)) { if (s.children === i.children && !so.current) { e = cf(n, e, t); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var o = s.dependencies; if (o !== null) { a = s.child; for (var l = o.firstContext; l !== null;) { if (l.context === r) { if (s.tag === 1) { l = nf(-1, t & -t), l.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), BE(s.return, t, e), o.lanes |= t; break } l = l.next } } else if (s.tag === 10) a = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (a = s.return, a === null) throw Error(Ze(341)); a.lanes |= t, o = a.alternate, o !== null && (o.lanes |= t), BE(a, t, e), a = s.sibling } else a = s.child; if (a !== null) a.return = s; else for (a = s; a !== null;) { if (a === e) { a = null; break } if (s = a.sibling, s !== null) { s.return = a.return, a = s; break } a = a.return } s = a } Pa(n, e, i.children, t), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, v3(e, t), i = bl(i), r = r(i), e.flags |= 1, Pa(n, e, r, t), e.child; case 14: return r = e.type, i = ru(r, e.pendingProps), i = ru(r.type, i), OI(n, e, r, i, t); case 15: return iF(n, e, e.type, e.pendingProps, t); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : ru(r, i), z5(n, e), e.tag = 1, ao(r) ? (n = !0, b6(e)) : n = !1, v3(e, t), DL(e, r, i), PE(e, r, i, t), FE(null, e, r, !0, n, t); case 19: return uF(n, e, t); case 22: return sF(n, e, t) }throw Error(Ze(156, e.tag)) }; function TF(n, e) { return qD(n, e) } function cW(n, e, t, r) { this.tag = n, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function xl(n, e, t, r) { return new cW(n, e, t, r) } function OC(n) { return n = n.prototype, !(!n || !n.isReactComponent) } function fW(n) { if (typeof n == "function") return OC(n) ? 1 : 0; if (n != null) { if (n = n.$$typeof, n === rC) return 11; if (n === iC) return 14 } return 2 } function vh(n, e) { var t = n.alternate; return t === null ? (t = xl(n.tag, e, n.key, n.mode), t.elementType = n.elementType, t.type = n.type, t.stateNode = n.stateNode, t.alternate = n, n.alternate = t) : (t.pendingProps = e, t.type = n.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n.flags & 14680064, t.childLanes = n.childLanes, t.lanes = n.lanes, t.child = n.child, t.memoizedProps = n.memoizedProps, t.memoizedState = n.memoizedState, t.updateQueue = n.updateQueue, e = n.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n.sibling, t.index = n.index, t.ref = n.ref, t } function X5(n, e, t, r, i, s) { var a = 2; if (r = n, typeof n == "function") OC(n) && (a = 1); else if (typeof n == "string") a = 5; else e: switch (n) { case V0: return rp(t.children, i, s, e); case nC: a = 8, i |= 8; break; case nE: return n = xl(12, t, e, i | 2), n.elementType = nE, n.lanes = s, n; case rE: return n = xl(13, t, e, i), n.elementType = rE, n.lanes = s, n; case iE: return n = xl(19, t, e, i), n.elementType = iE, n.lanes = s, n; case LD: return Hy(t, i, s, e); default: if (typeof n == "object" && n !== null) switch (n.$$typeof) { case PD: a = 10; break e; case DD: a = 9; break e; case rC: a = 11; break e; case iC: a = 14; break e; case qf: a = 16, r = null; break e }throw Error(Ze(130, n == null ? n : typeof n, "")) }return e = xl(a, t, e, i), e.elementType = n, e.type = r, e.lanes = s, e } function rp(n, e, t, r) { return n = xl(7, n, r, e), n.lanes = t, n } function Hy(n, e, t, r) { return n = xl(22, n, r, e), n.elementType = LD, n.lanes = t, n.stateNode = { isHidden: !1 }, n } function ax(n, e, t) { return n = xl(6, n, null, e), n.lanes = t, n } function ox(n, e, t) { return e = xl(4, n.children !== null ? n.children : [], n.key, e), e.lanes = t, e.stateNode = { containerInfo: n.containerInfo, pendingChildren: null, implementation: n.implementation }, e } function hW(n, e, t, r, i) { this.tag = e, this.containerInfo = n, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Q4(0), this.expirationTimes = Q4(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Q4(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function UC(n, e, t, r, i, s, a, o, l) { return n = new hW(n, e, t, o, l), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = xl(3, null, null, e), n.current = s, s.stateNode = n, s.memoizedState = { element: r, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, EC(s), n } function dW(n, e, t) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: z0, key: r == null ? null : "" + r, children: n, containerInfo: e, implementation: t } } function wF(n) { if (!n) return Ih; n = n._reactInternals; e: { if (Fp(n) !== n || n.tag !== 1) throw Error(Ze(170)); var e = n; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (ao(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(Ze(171)) } if (n.tag === 1) { var t = n.type; if (ao(t)) return TL(n, t, e) } return e } function IF(n, e, t, r, i, s, a, o, l) { return n = UC(t, r, !0, n, i, s, a, o, l), n.context = wF(null), t = n.current, r = Ua(), i = Ah(t), s = nf(r, i), s.callback = e ?? null, mh(t, s, i), n.current.lanes = i, E1(n, i, r), oo(n, r), n } function zy(n, e, t, r) { var i = e.current, s = Ua(), a = Ah(i); return t = wF(t), e.context === null ? e.context = t : e.pendingContext = t, e = nf(s, a), e.payload = { element: n }, r = r === void 0 ? null : r, r !== null && (e.callback = r), n = mh(i, e, a), n !== null && (pu(n, i, a, s), G5(n, i, a)), a } function H6(n) { if (n = n.current, !n.child) return null; switch (n.child.tag) { case 5: return n.child.stateNode; default: return n.child.stateNode } } function KI(n, e) { if (n = n.memoizedState, n !== null && n.dehydrated !== null) { var t = n.retryLane; n.retryLane = t !== 0 && t < e ? t : e } } function GC(n, e) { KI(n, e), (n = n.alternate) && KI(n, e) } function pW() { return null } var MF = typeof reportError == "function" ? reportError : function (n) { console.error(n) }; function QC(n) { this._internalRoot = n } Vy.prototype.render = QC.prototype.render = function (n) { var e = this._internalRoot; if (e === null) throw Error(Ze(409)); zy(n, e, null, null) }; Vy.prototype.unmount = QC.prototype.unmount = function () { var n = this._internalRoot; if (n !== null) { this._internalRoot = null; var e = n.containerInfo; xp(function () { zy(null, n, null, null) }), e[lf] = null } }; function Vy(n) { this._internalRoot = n } Vy.prototype.unstable_scheduleHydration = function (n) { if (n) { var e = iL(); n = { blockedOn: null, target: n, priority: e }; for (var t = 0; t < eh.length && e !== 0 && e < eh[t].priority; t++); eh.splice(t, 0, n), t === 0 && aL(n) } }; function HC(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11) } function Wy(n) { return !(!n || n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11 && (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable ")) } function qI() { } function mW(n, e, t, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var u = H6(a); s.call(u) } } var a = IF(e, r, n, 0, null, !1, !1, "", qI); return n._reactRootContainer = a, n[lf] = a.current, SA(n.nodeType === 8 ? n.parentNode : n), xp(), a } for (; i = n.lastChild;)n.removeChild(i); if (typeof r == "function") { var o = r; r = function () { var u = H6(l); o.call(u) } } var l = UC(n, 0, !1, null, null, !1, !1, "", qI); return n._reactRootContainer = l, n[lf] = l.current, SA(n.nodeType === 8 ? n.parentNode : n), xp(function () { zy(e, l, t, r) }), l } function Xy(n, e, t, r, i) { var s = t._reactRootContainer; if (s) { var a = s; if (typeof i == "function") { var o = i; i = function () { var l = H6(a); o.call(l) } } zy(e, a, n, i) } else a = mW(t, e, n, i, r); return H6(a) } nL = function (n) { switch (n.tag) { case 3: var e = n.stateNode; if (e.current.memoizedState.isDehydrated) { var t = Eg(e.pendingLanes); t !== 0 && (oC(e, t | 1), oo(e, Vi()), !(er & 6) && (H3 = Vi() + 500, Wh())) } break; case 13: xp(function () { var r = uf(n, 1); if (r !== null) { var i = Ua(); pu(r, n, 1, i) } }), GC(n, 1) } }; lC = function (n) { if (n.tag === 13) { var e = uf(n, 134217728); if (e !== null) { var t = Ua(); pu(e, n, 134217728, t) } GC(n, 134217728) } }; rL = function (n) { if (n.tag === 13) { var e = Ah(n), t = uf(n, e); if (t !== null) { var r = Ua(); pu(t, n, e, r) } GC(n, e) } }; iL = function () { return Ar }; sL = function (n, e) { var t = Ar; try { return Ar = n, e() } finally { Ar = t } }; pE = function (n, e, t) { switch (e) { case "input": if (oE(n, t), e = t.name, t.type === "radio" && e != null) { for (t = n; t.parentNode;)t = t.parentNode; for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) { var r = t[e]; if (r !== n && r.form === n.form) { var i = ky(r); if (!i) throw Error(Ze(90)); kD(r), oE(r, i) } } } break; case "textarea": OD(n, t); break; case "select": e = t.value, e != null && p3(n, !!t.multiple, e, !1) } }; WD = FC; XD = xp; var gW = { usingClientEntryPoint: !1, Events: [S1, j0, ky, zD, VD, FC] }, Ym = { findFiberByHostInstance: Hd, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, AW = { bundleType: Ym.bundleType, version: Ym.version, rendererPackageName: Ym.rendererPackageName, rendererConfig: Ym.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: xf.ReactCurrentDispatcher, findHostInstanceByFiber: function (n) { return n = JD(n), n === null ? null : n.stateNode }, findFiberByHostInstance: Ym.findFiberByHostInstance || pW, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var ev = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ev.isDisabled && ev.supportsFiber) try { Py = ev.inject(AW), ec = ev } catch { } } jo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gW; jo.createPortal = function (n, e) { var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!HC(e)) throw Error(Ze(200)); return dW(n, e, null, t) }; jo.createRoot = function (n, e) { if (!HC(n)) throw Error(Ze(299)); var t = !1, r = "", i = MF; return e != null && (e.unstable_strictMode === !0 && (t = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = UC(n, 1, !1, null, null, t, !1, r, i), n[lf] = e.current, SA(n.nodeType === 8 ? n.parentNode : n), new QC(e) }; jo.findDOMNode = function (n) { if (n == null) return null; if (n.nodeType === 1) return n; var e = n._reactInternals; if (e === void 0) throw typeof n.render == "function" ? Error(Ze(188)) : (n = Object.keys(n).join(","), Error(Ze(268, n))); return n = JD(e), n = n === null ? null : n.stateNode, n }; jo.flushSync = function (n) { return xp(n) }; jo.hydrate = function (n, e, t) { if (!Wy(e)) throw Error(Ze(200)); return Xy(null, n, e, !0, t) }; jo.hydrateRoot = function (n, e, t) { if (!HC(n)) throw Error(Ze(405)); var r = t != null && t.hydratedSources || null, i = !1, s = "", a = MF; if (t != null && (t.unstable_strictMode === !0 && (i = !0), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (a = t.onRecoverableError)), e = IF(e, null, n, 1, t ?? null, i, !1, s, a), n[lf] = e.current, SA(n), r) for (n = 0; n < r.length; n++)t = r[n], i = t._getVersion, i = i(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, i] : e.mutableSourceEagerHydrationData.push(t, i); return new Vy(e) }; jo.render = function (n, e, t) { if (!Wy(e)) throw Error(Ze(200)); return Xy(null, n, e, !1, t) }; jo.unmountComponentAtNode = function (n) { if (!Wy(n)) throw Error(Ze(40)); return n._reactRootContainer ? (xp(function () { Xy(null, null, n, !1, function () { n._reactRootContainer = null, n[lf] = null }) }), !0) : !1 }; jo.unstable_batchedUpdates = FC; jo.unstable_renderSubtreeIntoContainer = function (n, e, t, r) { if (!Wy(t)) throw Error(Ze(200)); if (n == null || n._reactInternals === void 0) throw Error(Ze(38)); return Xy(n, e, t, !1, r) }; jo.version = "18.2.0-next-9e3b772b8-20220608"; function bF() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(bF) } catch (n) { console.error(n) } } bF(), ID.exports = jo; var BF = ID.exports, ZI = BF; eE.createRoot = ZI.createRoot, eE.hydrateRoot = ZI.hydrateRoot; function zc(n) { if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return n } function RF(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e }/*!
 * GSAP 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Go = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, z3 = { duration: .5, overwrite: !1, delay: 0 }, zC, ha, Mi, _l = 1e8, Tr = 1 / _l, YE = Math.PI * 2, vW = YE / 4, yW = 0, PF = Math.sqrt, xW = Math.cos, _W = Math.sin, Os = function (e) { return typeof e == "string" }, Di = function (e) { return typeof e == "function" }, ff = function (e) { return typeof e == "number" }, VC = function (e) { return typeof e > "u" }, hc = function (e) { return typeof e == "object" }, lo = function (e) { return e !== !1 }, WC = function () { return typeof window < "u" }, tv = function (e) { return Di(e) || Os(e) }, DF = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { }, da = Array.isArray, jE = /(?:-?\.?\d|\.)+/gi, LF = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, t3 = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, lx = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, FF = /[+-]=-?[.\d]+/, kF = /[^,'"\[\]\s]+/gi, EW = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, hi, dl, JE, XC, zo = {}, z6 = {}, NF, OF = function (e) { return (z6 = _p(e, zo)) && ho }, YC = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, V6 = function (e, t) { return !t && console.warn(e) }, UF = function (e, t) { return e && (zo[e] = t) && z6 && (z6[e] = t) || zo }, DA = function () { return 0 }, CW = { suppressEvents: !0, isStart: !0, kill: !1 }, Y5 = { suppressEvents: !0, kill: !1 }, SW = { suppressEvents: !0 }, jC = {}, yh = [], KE = {}, GF, Po = {}, ux = {}, $I = 30, j5 = [], JC = "", KC = function (e) { var t = e[0], r, i; if (hc(t) || Di(t) || (e = [e]), !(r = (t._gsap || {}).harness)) { for (i = j5.length; i-- && !j5[i].targetTest(t);); r = j5[i] } for (i = e.length; i--;)e[i] && (e[i]._gsap || (e[i]._gsap = new ck(e[i], r))) || e.splice(i, 1); return e }, ip = function (e) { return e._gsap || KC(El(e))[0]._gsap }, QF = function (e, t, r) { return (r = e[t]) && Di(r) ? e[t]() : VC(r) && e.getAttribute && e.getAttribute(t) || r }, uo = function (e, t) { return (e = e.split(",")).forEach(t) || e }, zi = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Js = function (e) { return Math.round(e * 1e7) / 1e7 || 0 }, x3 = function (e, t) { var r = t.charAt(0), i = parseFloat(t.substr(2)); return e = parseFloat(e), r === "+" ? e + i : r === "-" ? e - i : r === "*" ? e * i : e / i }, TW = function (e, t) { for (var r = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < r;); return i < r }, W6 = function () { var e = yh.length, t = yh.slice(0), r, i; for (KE = {}, yh.length = 0, r = 0; r < e; r++)i = t[r], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0) }, HF = function (e, t, r, i) { yh.length && !ha && W6(), e.render(t, r, i || ha && t < 0 && (e._initted || e._startAt)), yh.length && !ha && W6() }, zF = function (e) { var t = parseFloat(e); return (t || t === 0) && (e + "").match(kF).length < 2 ? t : Os(e) ? e.trim() : e }, VF = function (e) { return e }, Rl = function (e, t) { for (var r in t) r in e || (e[r] = t[r]); return e }, wW = function (e) { return function (t, r) { for (var i in r) i in t || i === "duration" && e || i === "ease" || (t[i] = r[i]) } }, _p = function (e, t) { for (var r in t) e[r] = t[r]; return e }, eM = function n(e, t) { for (var r in t) r !== "__proto__" && r !== "constructor" && r !== "prototype" && (e[r] = hc(t[r]) ? n(e[r] || (e[r] = {}), t[r]) : t[r]); return e }, X6 = function (e, t) { var r = {}, i; for (i in e) i in t || (r[i] = e[i]); return r }, Xg = function (e) { var t = e.parent || hi, r = e.keyframes ? wW(da(e.keyframes)) : Rl; if (lo(e.inherit)) for (; t;)r(e, t.vars.defaults), t = t.parent || t._dp; return e }, IW = function (e, t) { for (var r = e.length, i = r === t.length; i && r-- && e[r] === t[r];); return r < 0 }, WF = function (e, t, r, i, s) { r === void 0 && (r = "_first"), i === void 0 && (i = "_last"); var a = e[i], o; if (s) for (o = t[s]; a && a[s] > o;)a = a._prev; return a ? (t._next = a._next, a._next = t) : (t._next = e[r], e[r] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t }, Yy = function (e, t, r, i) { r === void 0 && (r = "_first"), i === void 0 && (i = "_last"); var s = t._prev, a = t._next; s ? s._next = a : e[r] === t && (e[r] = a), a ? a._prev = s : e[i] === t && (e[i] = s), t._next = t._prev = t.parent = null }, Mh = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0 }, sp = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var r = e; r;)r._dirty = 1, r = r.parent; return e }, MW = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, qE = function (e, t, r, i) { return e._startAt && (ha ? e._startAt.revert(Y5) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i)) }, bW = function n(e) { return !e || e._ts && n(e.parent) }, tM = function (e) { return e._repeat ? V3(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, V3 = function (e, t) { var r = Math.floor(e /= t); return e && r === e ? r - 1 : r }, Y6 = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, jy = function (e) { return e._end = Js(e._start + (e._tDur / Math.abs(e._ts || e._rts || Tr) || 0)) }, Jy = function (e, t) { var r = e._dp; return r && r.smoothChildTiming && e._ts && (e._start = Js(r._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), jy(e), r._dirty || sp(r, e)), e }, XF = function (e, t) { var r; if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (r = Y6(e.rawTime(), t), (!t._dur || w1(0, t.totalDuration(), r) - t._tTime > Tr) && t.render(r, !0)), sp(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (r = e; r._dp;)r.rawTime() >= 0 && r.totalTime(r._tTime), r = r._dp; e._zTime = -Tr } }, Ju = function (e, t, r, i) { return t.parent && Mh(t), t._start = Js((ff(r) ? r : r || e !== hi ? hl(e, r, t) : e._time) + t._delay), t._end = Js(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), WF(e, t, "_first", "_last", e._sort ? "_start" : 0), ZE(t) || (e._recent = t), i || XF(e, t), e._ts < 0 && Jy(e, e._tTime), e }, YF = function (e, t) { return (zo.ScrollTrigger || YC("scrollTrigger", t)) && zo.ScrollTrigger.create(t, e) }, jF = function (e, t, r, i, s) { if (ZC(e, t, s), !e._initted) return 1; if (!r && e._pt && !ha && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && GF !== Lo.frame) return yh.push(e), e._lazy = [s, i], 1 }, BW = function n(e) { var t = e.parent; return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t)) }, ZE = function (e) { var t = e.data; return t === "isFromStart" || t === "isStart" }, RW = function (e, t, r, i) { var s = e.ratio, a = t < 0 || !t && (!e._start && BW(e) && !(!e._initted && ZE(e)) || (e._ts < 0 || e._dp._ts < 0) && !ZE(e)) ? 0 : 1, o = e._rDelay, l = 0, u, c, h; if (o && e._repeat && (l = w1(0, e._tDur, t), c = V3(l, o), e._yoyo && c & 1 && (a = 1 - a), c !== V3(e._tTime, o) && (s = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== s || ha || i || e._zTime === Tr || !t && e._zTime) { if (!e._initted && jF(e, t, i, r, l)) return; for (h = e._zTime, e._zTime = t || (r ? Tr : 0), r || (r = t && !h), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, u = e._pt; u;)u.r(a, u.d), u = u._next; t < 0 && qE(e, t, r, !0), e._onUpdate && !r && Cl(e, "onUpdate"), l && e._repeat && !r && e.parent && Cl(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && Mh(e, 1), !r && !ha && (Cl(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }, PW = function (e, t, r) { var i; if (r > t) for (i = e._first; i && i._start <= r;) { if (i.data === "isPause" && i._start > t) return i; i = i._next } else for (i = e._last; i && i._start >= r;) { if (i.data === "isPause" && i._start < t) return i; i = i._prev } }, W3 = function (e, t, r, i) { var s = e._repeat, a = Js(t) || 0, o = e._tTime / e._tDur; return o && !i && (e._time *= a / e._dur), e._dur = a, e._tDur = s ? s < 0 ? 1e10 : Js(a * (s + 1) + e._rDelay * s) : a, o > 0 && !i && Jy(e, e._tTime = e._tDur * o), e.parent && jy(e), r || sp(e.parent, e), e }, nM = function (e) { return e instanceof no ? sp(e) : W3(e, e._dur) }, DW = { _start: 0, endTime: DA, totalDuration: DA }, hl = function n(e, t, r) { var i = e.labels, s = e._recent || DW, a = e.duration() >= _l ? s.endTime(!1) : e._dur, o, l, u; return Os(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), u = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (u ? (o < 0 ? s : r).totalDuration() / 100 : 1)) : o < 0 ? (t in i || (i[t] = a), i[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), u && r && (l = l / 100 * (da(r) ? r[0] : r).totalDuration()), o > 1 ? n(e, t.substr(0, o - 1), r) + l : a + l)) : t == null ? a : +t }, Yg = function (e, t, r) { var i = ff(t[1]), s = (i ? 2 : 1) + (e < 2 ? 0 : 1), a = t[s], o, l; if (i && (a.duration = t[1]), a.parent = r, e) { for (o = a, l = r; l && !("immediateRender" in o);)o = l.vars.defaults || {}, l = lo(l.vars.inherit) && l.parent; a.immediateRender = lo(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1] } return new rs(t[0], a, t[s + 1]) }, Xh = function (e, t) { return e || e === 0 ? t(e) : t }, w1 = function (e, t, r) { return r < e ? e : r > t ? t : r }, fa = function (e, t) { return !Os(e) || !(t = EW.exec(e)) ? "" : t[1] }, LW = function (e, t, r) { return Xh(r, function (i) { return w1(e, t, i) }) }, $E = [].slice, JF = function (e, t) { return e && hc(e) && "length" in e && (!t && !e.length || e.length - 1 in e && hc(e[0])) && !e.nodeType && e !== dl }, FW = function (e, t, r) { return r === void 0 && (r = []), e.forEach(function (i) { var s; return Os(i) && !t || JF(i, 1) ? (s = r).push.apply(s, El(i)) : r.push(i) }) || r }, El = function (e, t, r) { return Mi && !t && Mi.selector ? Mi.selector(e) : Os(e) && !r && (JE || !X3()) ? $E.call((t || XC).querySelectorAll(e), 0) : da(e) ? FW(e, r) : JF(e) ? $E.call(e, 0) : e ? [e] : [] }, e9 = function (e) { return e = El(e)[0] || V6("Invalid scope") || {}, function (t) { var r = e.current || e.nativeElement || e; return El(t, r.querySelectorAll ? r : r === e ? V6("Invalid scope") || XC.createElement("div") : e) } }, KF = function (e) { return e.sort(function () { return .5 - Math.random() }) }, qF = function (e) { if (Di(e)) return e; var t = hc(e) ? e : { each: e }, r = ap(t.ease), i = t.from || 0, s = parseFloat(t.base) || 0, a = {}, o = i > 0 && i < 1, l = isNaN(i) || o, u = t.axis, c = i, h = i; return Os(i) ? c = h = { center: .5, edges: .5, end: 1 }[i] || 0 : !o && l && (c = i[0], h = i[1]), function (d, m, g) { var v = (g || t).length, y = a[v], A, _, x, C, T, I, w, R, b; if (!y) { if (b = t.grid === "auto" ? 0 : (t.grid || [1, _l])[1], !b) { for (w = -_l; w < (w = g[b++].getBoundingClientRect().left) && b < v;); b-- } for (y = a[v] = [], A = l ? Math.min(b, v) * c - .5 : i % b, _ = b === _l ? 0 : l ? v * h / b - .5 : i / b | 0, w = 0, R = _l, I = 0; I < v; I++)x = I % b - A, C = _ - (I / b | 0), y[I] = T = u ? Math.abs(u === "y" ? C : x) : PF(x * x + C * C), T > w && (w = T), T < R && (R = T); i === "random" && KF(y), y.max = w - R, y.min = R, y.v = v = (parseFloat(t.amount) || parseFloat(t.each) * (b > v ? v - 1 : u ? u === "y" ? v / b : b : Math.max(b, v / b)) || 0) * (i === "edges" ? -1 : 1), y.b = v < 0 ? s - v : s, y.u = fa(t.amount || t.each) || 0, r = r && v < 0 ? ok(r) : r } return v = (y[d] - y.min) / y.max || 0, Js(y.b + (r ? r(v) : v) * y.v) + y.u } }, t9 = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (r) { var i = Js(Math.round(parseFloat(r) / e) * e * t); return (i - i % 1) / t + (ff(r) ? 0 : fa(r)) } }, ZF = function (e, t) { var r = da(e), i, s; return !r && hc(e) && (i = r = e.radius || _l, e.values ? (e = El(e.values), (s = !ff(e[0])) && (i *= i)) : e = t9(e.increment)), Xh(t, r ? Di(e) ? function (a) { return s = e(a), Math.abs(s - a) <= i ? s : a } : function (a) { for (var o = parseFloat(s ? a.x : a), l = parseFloat(s ? a.y : 0), u = _l, c = 0, h = e.length, d, m; h--;)s ? (d = e[h].x - o, m = e[h].y - l, d = d * d + m * m) : d = Math.abs(e[h] - o), d < u && (u = d, c = h); return c = !i || u <= i ? e[c] : a, s || c === a || ff(a) ? c : c + fa(a) } : t9(e)) }, $F = function (e, t, r, i) { return Xh(da(e) ? !t : r === !0 ? !!(r = 0) : !i, function () { return da(e) ? e[~~(Math.random() * e.length)] : (r = r || 1e-5) && (i = r < 1 ? Math.pow(10, (r + "").length - 2) : 1) && Math.floor(Math.round((e - r / 2 + Math.random() * (t - e + r * .99)) / r) * r * i) / i }) }, kW = function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; return function (i) { return t.reduce(function (s, a) { return a(s) }, i) } }, NW = function (e, t) { return function (r) { return e(parseFloat(r)) + (t || fa(r)) } }, OW = function (e, t, r) { return tk(e, t, 0, 1, r) }, ek = function (e, t, r) { return Xh(r, function (i) { return e[~~t(i)] }) }, UW = function n(e, t, r) { var i = t - e; return da(e) ? ek(e, n(0, e.length), t) : Xh(r, function (s) { return (i + (s - e) % i) % i + e }) }, GW = function n(e, t, r) { var i = t - e, s = i * 2; return da(e) ? ek(e, n(0, e.length - 1), t) : Xh(r, function (a) { return a = (s + (a - e) % s) % s || 0, e + (a > i ? s - a : a) }) }, LA = function (e) { for (var t = 0, r = "", i, s, a, o; ~(i = e.indexOf("random(", t));)a = e.indexOf(")", i), o = e.charAt(i + 7) === "[", s = e.substr(i + 7, a - i - 7).match(o ? kF : jE), r += e.substr(t, i - t) + $F(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), t = a + 1; return r + e.substr(t, e.length - t) }, tk = function (e, t, r, i, s) { var a = t - e, o = i - r; return Xh(s, function (l) { return r + ((l - e) / a * o || 0) }) }, QW = function n(e, t, r, i) { var s = isNaN(e + t) ? 0 : function (m) { return (1 - m) * e + m * t }; if (!s) { var a = Os(e), o = {}, l, u, c, h, d; if (r === !0 && (i = 1) && (r = null), a) e = { p: e }, t = { p: t }; else if (da(e) && !da(t)) { for (c = [], h = e.length, d = h - 2, u = 1; u < h; u++)c.push(n(e[u - 1], e[u])); h--, s = function (g) { g *= h; var v = Math.min(d, ~~g); return c[v](g - v) }, r = t } else i || (e = _p(da(e) ? [] : {}, e)); if (!c) { for (l in t) qC.call(o, e, l, "get", t[l]); s = function (g) { return tS(g, o) || (a ? e.p : e) } } } return Xh(r, s) }, rM = function (e, t, r) { var i = e.labels, s = _l, a, o, l; for (a in i) o = i[a] - t, o < 0 == !!r && o && s > (o = Math.abs(o)) && (l = a, s = o); return l }, Cl = function (e, t, r) { var i = e.vars, s = i[t], a = Mi, o = e._ctx, l, u, c; if (s) return l = i[t + "Params"], u = i.callbackScope || e, r && yh.length && W6(), o && (Mi = o), c = l ? s.apply(u, l) : s.call(u), Mi = a, c }, Sg = function (e) { return Mh(e), e.scrollTrigger && e.scrollTrigger.kill(!!ha), e.progress() < 1 && Cl(e, "onInterrupt"), e }, n3, nk = [], rk = function (e) { if (WC() && e) { e = !e.name && e.default || e; var t = e.name, r = Di(e), i = t && !r && e.init ? function () { this._props = [] } : e, s = { init: DA, render: tS, add: qC, kill: rX, modifier: nX, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: eS, aliases: {}, register: 0 }; if (X3(), e !== i) { if (Po[t]) return; Rl(i, Rl(X6(e, s), a)), _p(i.prototype, _p(s, X6(e, a))), Po[i.prop = t] = i, e.targetTest && (j5.push(i), jC[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } UF(t, i), e.register && e.register(ho, i, co) } else e && nk.push(e) }, Sr = 255, Tg = { aqua: [0, Sr, Sr], lime: [0, Sr, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, Sr], navy: [0, 0, 128], white: [Sr, Sr, Sr], olive: [128, 128, 0], yellow: [Sr, Sr, 0], orange: [Sr, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [Sr, 0, 0], pink: [Sr, 192, 203], cyan: [0, Sr, Sr], transparent: [Sr, Sr, Sr, 0] }, cx = function (e, t, r) { return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (r - t) * e * 6 : e < .5 ? r : e * 3 < 2 ? t + (r - t) * (2 / 3 - e) * 6 : t) * Sr + .5 | 0 }, ik = function (e, t, r) { var i = e ? ff(e) ? [e >> 16, e >> 8 & Sr, e & Sr] : 0 : Tg.black, s, a, o, l, u, c, h, d, m, g; if (!i) { if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Tg[e]) i = Tg[e]; else if (e.charAt(0) === "#") { if (e.length < 6 && (s = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + s + s + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & Sr, i & Sr, parseInt(e.substr(7), 16) / 255]; e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & Sr, e & Sr] } else if (e.substr(0, 3) === "hsl") { if (i = g = e.match(jE), !t) l = +i[0] % 360 / 360, u = +i[1] / 100, c = +i[2] / 100, a = c <= .5 ? c * (u + 1) : c + u - c * u, s = c * 2 - a, i.length > 3 && (i[3] *= 1), i[0] = cx(l + 1 / 3, s, a), i[1] = cx(l, s, a), i[2] = cx(l - 1 / 3, s, a); else if (~e.indexOf("=")) return i = e.match(LF), r && i.length < 4 && (i[3] = 1), i } else i = e.match(jE) || Tg.transparent; i = i.map(Number) } return t && !g && (s = i[0] / Sr, a = i[1] / Sr, o = i[2] / Sr, h = Math.max(s, a, o), d = Math.min(s, a, o), c = (h + d) / 2, h === d ? l = u = 0 : (m = h - d, u = c > .5 ? m / (2 - h - d) : m / (h + d), l = h === s ? (a - o) / m + (a < o ? 6 : 0) : h === a ? (o - s) / m + 2 : (s - a) / m + 4, l *= 60), i[0] = ~~(l + .5), i[1] = ~~(u * 100 + .5), i[2] = ~~(c * 100 + .5)), r && i.length < 4 && (i[3] = 1), i }, sk = function (e) { var t = [], r = [], i = -1; return e.split(xh).forEach(function (s) { var a = s.match(t3) || []; t.push.apply(t, a), r.push(i += a.length + 1) }), t.c = r, t }, iM = function (e, t, r) { var i = "", s = (e + i).match(xh), a = t ? "hsla(" : "rgba(", o = 0, l, u, c, h; if (!s) return e; if (s = s.map(function (d) { return (d = ik(d, t, 1)) && a + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")" }), r && (c = sk(e), l = r.c, l.join(i) !== c.c.join(i))) for (u = e.replace(xh, "1").split(t3), h = u.length - 1; o < h; o++)i += u[o] + (~l.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (c.length ? c : s.length ? s : r).shift()); if (!u) for (u = e.split(xh), h = u.length - 1; o < h; o++)i += u[o] + s[o]; return i + u[h] }, xh = function () { var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e; for (e in Tg) n += "|" + e + "\\b"; return new RegExp(n + ")", "gi") }(), HW = /hsl[a]?\(/, ak = function (e) { var t = e.join(" "), r; if (xh.lastIndex = 0, xh.test(t)) return r = HW.test(t), e[1] = iM(e[1], r), e[0] = iM(e[0], r, sk(e[1])), !0 }, FA, Lo = function () { var n = Date.now, e = 500, t = 33, r = n(), i = r, s = 1e3 / 240, a = s, o = [], l, u, c, h, d, m, g = function v(y) { var A = n() - i, _ = y === !0, x, C, T, I; if (A > e && (r += A - t), i += A, T = i - r, x = T - a, (x > 0 || _) && (I = ++h.frame, d = T - h.time * 1e3, h.time = T = T / 1e3, a += x + (x >= s ? 4 : s - x), C = 1), _ || (l = u(v)), C) for (m = 0; m < o.length; m++)o[m](T, d, I, y) }; return h = { time: 0, frame: 0, tick: function () { g(!0) }, deltaRatio: function (y) { return d / (1e3 / (y || 60)) }, wake: function () { NF && (!JE && WC() && (dl = JE = window, XC = dl.document || {}, zo.gsap = ho, (dl.gsapVersions || (dl.gsapVersions = [])).push(ho.version), OF(z6 || dl.GreenSockGlobals || !dl.gsap && dl || {}), c = dl.requestAnimationFrame, nk.forEach(rk)), l && h.sleep(), u = c || function (y) { return setTimeout(y, a - h.time * 1e3 + 1 | 0) }, FA = 1, g(2)) }, sleep: function () { (c ? dl.cancelAnimationFrame : clearTimeout)(l), FA = 0, u = DA }, lagSmoothing: function (y, A) { e = y || 1 / 0, t = Math.min(A || 33, e) }, fps: function (y) { s = 1e3 / (y || 240), a = h.time * 1e3 + s }, add: function (y, A, _) { var x = A ? function (C, T, I, w) { y(C, T, I, w), h.remove(x) } : y; return h.remove(y), o[_ ? "unshift" : "push"](x), X3(), x }, remove: function (y, A) { ~(A = o.indexOf(y)) && o.splice(A, 1) && m >= A && m-- }, _listeners: o }, h }(), X3 = function () { return !FA && Lo.wake() }, Kn = {}, zW = /^[\d.\-M][\d.\-,\s]/, VW = /["']/g, WW = function (e) { for (var t = {}, r = e.substr(1, e.length - 3).split(":"), i = r[0], s = 1, a = r.length, o, l, u; s < a; s++)l = r[s], o = s !== a - 1 ? l.lastIndexOf(",") : l.length, u = l.substr(0, o), t[i] = isNaN(u) ? u.replace(VW, "").trim() : +u, i = l.substr(o + 1).trim(); return t }, XW = function (e) { var t = e.indexOf("(") + 1, r = e.indexOf(")"), i = e.indexOf("(", t); return e.substring(t, ~i && i < r ? e.indexOf(")", r + 1) : r) }, YW = function (e) { var t = (e + "").split("("), r = Kn[t[0]]; return r && t.length > 1 && r.config ? r.config.apply(null, ~e.indexOf("{") ? [WW(t[1])] : XW(e).split(",").map(zF)) : Kn._CE && zW.test(e) ? Kn._CE("", e) : r }, ok = function (e) { return function (t) { return 1 - e(1 - t) } }, lk = function n(e, t) { for (var r = e._first, i; r;)r instanceof no ? n(r, t) : r.vars.yoyoEase && (!r._yoyo || !r._repeat) && r._yoyo !== t && (r.timeline ? n(r.timeline, t) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = t)), r = r._next }, ap = function (e, t) { return e && (Di(e) ? e : Kn[e] || YW(e)) || t }, kp = function (e, t, r, i) { r === void 0 && (r = function (l) { return 1 - t(1 - l) }), i === void 0 && (i = function (l) { return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2 }); var s = { easeIn: t, easeOut: r, easeInOut: i }, a; return uo(e, function (o) { Kn[o] = zo[o] = s, Kn[a = o.toLowerCase()] = r; for (var l in s) Kn[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Kn[o + "." + l] = s[l] }), s }, uk = function (e) { return function (t) { return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2 } }, fx = function n(e, t, r) { var i = t >= 1 ? t : 1, s = (r || (e ? .3 : .45)) / (t < 1 ? t : 1), a = s / YE * (Math.asin(1 / i) || 0), o = function (c) { return c === 1 ? 1 : i * Math.pow(2, -10 * c) * _W((c - a) * s) + 1 }, l = e === "out" ? o : e === "in" ? function (u) { return 1 - o(1 - u) } : uk(o); return s = YE / s, l.config = function (u, c) { return n(e, u, c) }, l }, hx = function n(e, t) { t === void 0 && (t = 1.70158); var r = function (a) { return a ? --a * a * ((t + 1) * a + t) + 1 : 0 }, i = e === "out" ? r : e === "in" ? function (s) { return 1 - r(1 - s) } : uk(r); return i.config = function (s) { return n(e, s) }, i }; uo("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) { var t = e < 5 ? e + 1 : e; kp(n + ",Power" + (t - 1), e ? function (r) { return Math.pow(r, t) } : function (r) { return r }, function (r) { return 1 - Math.pow(1 - r, t) }, function (r) { return r < .5 ? Math.pow(r * 2, t) / 2 : 1 - Math.pow((1 - r) * 2, t) / 2 }) }); Kn.Linear.easeNone = Kn.none = Kn.Linear.easeIn; kp("Elastic", fx("in"), fx("out"), fx()); (function (n, e) { var t = 1 / e, r = 2 * t, i = 2.5 * t, s = function (o) { return o < t ? n * o * o : o < r ? n * Math.pow(o - 1.5 / e, 2) + .75 : o < i ? n * (o -= 2.25 / e) * o + .9375 : n * Math.pow(o - 2.625 / e, 2) + .984375 }; kp("Bounce", function (a) { return 1 - s(1 - a) }, s) })(7.5625, 2.75); kp("Expo", function (n) { return n ? Math.pow(2, 10 * (n - 1)) : 0 }); kp("Circ", function (n) { return -(PF(1 - n * n) - 1) }); kp("Sine", function (n) { return n === 1 ? 1 : -xW(n * vW) + 1 }); kp("Back", hx("in"), hx("out"), hx()); Kn.SteppedEase = Kn.steps = zo.SteppedEase = { config: function (e, t) { e === void 0 && (e = 1); var r = 1 / e, i = e + (t ? 0 : 1), s = t ? 1 : 0, a = 1 - Tr; return function (o) { return ((i * w1(0, a, o) | 0) + s) * r } } }; z3.ease = Kn["quad.out"]; uo("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) { return JC += n + "," + n + "Params," }); var ck = function (e, t) { this.id = yW++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : QF, this.set = t ? t.getSetter : eS }, kA = function () { function n(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, W3(this, +t.duration, 1, 1), this.data = t.data, Mi && (this._ctx = Mi, Mi.data.push(this)), FA || Lo.wake() } var e = n.prototype; return e.delay = function (r) { return r || r === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + r - this._delay), this._delay = r, this) : this._delay }, e.duration = function (r) { return arguments.length ? this.totalDuration(this._repeat > 0 ? r + (r + this._rDelay) * this._repeat : r) : this.totalDuration() && this._dur }, e.totalDuration = function (r) { return arguments.length ? (this._dirty = 0, W3(this, this._repeat < 0 ? r : (r - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (r, i) { if (X3(), !arguments.length) return this._tTime; var s = this._dp; if (s && s.smoothChildTiming && this._ts) { for (Jy(this, r), !s._dp || s.parent || XF(s, this); s && s.parent;)s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && r < this._tDur || this._ts < 0 && r > 0 || !this._tDur && !r) && Ju(this._dp, this, this._start - this._delay) } return (this._tTime !== r || !this._dur && !i || this._initted && Math.abs(this._zTime) === Tr || !r && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = r), HF(this, r, i)), this }, e.time = function (r, i) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), r + tM(this)) % (this._dur + this._rDelay) || (r ? this._dur : 0), i) : this._time }, e.totalProgress = function (r, i) { return arguments.length ? this.totalTime(this.totalDuration() * r, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, e.progress = function (r, i) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - r : r) + tM(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, e.iteration = function (r, i) { var s = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (r - 1) * s, i) : this._repeat ? V3(this._tTime, s) + 1 : 1 }, e.timeScale = function (r) { if (!arguments.length) return this._rts === -Tr ? 0 : this._rts; if (this._rts === r) return this; var i = this.parent && this._ts ? Y6(this.parent._time, this) : this._tTime; return this._rts = +r || 0, this._ts = this._ps || r === -Tr ? 0 : this._rts, this.totalTime(w1(-Math.abs(this._delay), this._tDur, i), !0), jy(this), MW(this) }, e.paused = function (r) { return arguments.length ? (this._ps !== r && (this._ps = r, r ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (X3(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Tr && (this._tTime -= Tr)))), this) : this._ps }, e.startTime = function (r) { if (arguments.length) { this._start = r; var i = this.parent || this._dp; return i && (i._sort || !this.parent) && Ju(i, this, r - this._delay), this } return this._start }, e.endTime = function (r) { return this._start + (lo(r) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (r) { var i = this.parent || this._dp; return i ? r && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Y6(i.rawTime(r), this) : this._tTime : this._tTime }, e.revert = function (r) { r === void 0 && (r = SW); var i = ha; return ha = r, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(r), this.totalTime(-.01, r.suppressEvents)), this.data !== "nested" && r.kill !== !1 && this.kill(), ha = i, this }, e.globalTime = function (r) { for (var i = this, s = arguments.length ? r : i.rawTime(); i;)s = i._start + s / (i._ts || 1), i = i._dp; return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 / 0 : this._sat.globalTime(r) : s }, e.repeat = function (r) { return arguments.length ? (this._repeat = r === 1 / 0 ? -2 : r, nM(this)) : this._repeat === -2 ? 1 / 0 : this._repeat }, e.repeatDelay = function (r) { if (arguments.length) { var i = this._time; return this._rDelay = r, nM(this), i ? this.time(i) : this } return this._rDelay }, e.yoyo = function (r) { return arguments.length ? (this._yoyo = r, this) : this._yoyo }, e.seek = function (r, i) { return this.totalTime(hl(this, r), lo(i)) }, e.restart = function (r, i) { return this.play().totalTime(r ? -this._delay : 0, lo(i)) }, e.play = function (r, i) { return r != null && this.seek(r, i), this.reversed(!1).paused(!1) }, e.reverse = function (r, i) { return r != null && this.seek(r || this.totalDuration(), i), this.reversed(!0).paused(!1) }, e.pause = function (r, i) { return r != null && this.seek(r, i), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (r) { return arguments.length ? (!!r !== this.reversed() && this.timeScale(-this._rts || (r ? -Tr : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -Tr, this }, e.isActive = function () { var r = this.parent || this._dp, i = this._start, s; return !!(!r || this._ts && this._initted && r.isActive() && (s = r.rawTime(!0)) >= i && s < this.endTime(!0) - Tr) }, e.eventCallback = function (r, i, s) { var a = this.vars; return arguments.length > 1 ? (i ? (a[r] = i, s && (a[r + "Params"] = s), r === "onUpdate" && (this._onUpdate = i)) : delete a[r], this) : a[r] }, e.then = function (r) { var i = this; return new Promise(function (s) { var a = Di(r) ? r : VF, o = function () { var u = i.then; i.then = null, Di(a) && (a = a(i)) && (a.then || a === i) && (i.then = u), s(a), i.then = u }; i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? o() : i._prom = o }) }, e.kill = function () { Sg(this) }, n }(); Rl(kA.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -Tr, _prom: 0, _ps: !1, _rts: 1 }); var no = function (n) { RF(e, n); function e(r, i) { var s; return r === void 0 && (r = {}), s = n.call(this, r) || this, s.labels = {}, s.smoothChildTiming = !!r.smoothChildTiming, s.autoRemoveChildren = !!r.autoRemoveChildren, s._sort = lo(r.sortChildren), hi && Ju(r.parent || hi, zc(s), i), r.reversed && s.reverse(), r.paused && s.paused(!0), r.scrollTrigger && YF(zc(s), r.scrollTrigger), s } var t = e.prototype; return t.to = function (i, s, a) { return Yg(0, arguments, this), this }, t.from = function (i, s, a) { return Yg(1, arguments, this), this }, t.fromTo = function (i, s, a, o) { return Yg(2, arguments, this), this }, t.set = function (i, s, a) { return s.duration = 0, s.parent = this, Xg(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new rs(i, s, hl(this, a), 1), this }, t.call = function (i, s, a) { return Ju(this, rs.delayedCall(0, i, s), a) }, t.staggerTo = function (i, s, a, o, l, u, c) { return a.duration = s, a.stagger = a.stagger || o, a.onComplete = u, a.onCompleteParams = c, a.parent = this, new rs(i, a, hl(this, l)), this }, t.staggerFrom = function (i, s, a, o, l, u, c) { return a.runBackwards = 1, Xg(a).immediateRender = lo(a.immediateRender), this.staggerTo(i, s, a, o, l, u, c) }, t.staggerFromTo = function (i, s, a, o, l, u, c, h) { return o.startAt = a, Xg(o).immediateRender = lo(o.immediateRender), this.staggerTo(i, s, o, l, u, c, h) }, t.render = function (i, s, a) { var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, u = this._dur, c = i <= 0 ? 0 : Js(i), h = this._zTime < 0 != i < 0 && (this._initted || !u), d, m, g, v, y, A, _, x, C, T, I, w; if (this !== hi && c > l && i >= 0 && (c = l), c !== this._tTime || a || h) { if (o !== this._time && u && (c += this._time - o, i += this._time - o), d = c, C = this._start, x = this._ts, A = !x, h && (u || (o = this._zTime), (i || !s) && (this._zTime = i)), this._repeat) { if (I = this._yoyo, y = u + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(y * 100 + i, s, a); if (d = Js(c % y), c === l ? (v = this._repeat, d = u) : (v = ~~(c / y), v && v === c / y && (d = u, v--), d > u && (d = u)), T = V3(this._tTime, y), !o && this._tTime && T !== v && this._tTime - T * y - this._dur <= 0 && (T = v), I && v & 1 && (d = u - d, w = 1), v !== T && !this._lock) { var R = I && T & 1, b = R === (I && v & 1); if (v < T && (R = !R), o = R ? 0 : c % u ? u : c, this._lock = 1, this.render(o || (w ? 0 : Js(v * y)), s, !u)._lock = 0, this._tTime = c, !s && this.parent && Cl(this, "onRepeat"), this.vars.repeatRefresh && !w && (this.invalidate()._lock = 1), o && o !== this._time || A !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (u = this._dur, l = this._tDur, b && (this._lock = 2, o = R ? u : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !w && this.invalidate()), this._lock = 0, !this._ts && !A) return this; lk(this, w) } } if (this._hasPause && !this._forcing && this._lock < 2 && (_ = PW(this, Js(o), Js(d)), _ && (c -= d - (d = _._start))), this._tTime = c, this._time = d, this._act = !x, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, o = 0), !o && d && !s && !v && (Cl(this, "onStart"), this._tTime !== c)) return this; if (d >= o && i >= 0) for (m = this._first; m;) { if (g = m._next, (m._act || d >= m._start) && m._ts && _ !== m) { if (m.parent !== this) return this.render(i, s, a); if (m.render(m._ts > 0 ? (d - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (d - m._start) * m._ts, s, a), d !== this._time || !this._ts && !A) { _ = 0, g && (c += this._zTime = -Tr); break } } m = g } else { m = this._last; for (var B = i < 0 ? i : d; m;) { if (g = m._prev, (m._act || B <= m._end) && m._ts && _ !== m) { if (m.parent !== this) return this.render(i, s, a); if (m.render(m._ts > 0 ? (B - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (B - m._start) * m._ts, s, a || ha && (m._initted || m._startAt)), d !== this._time || !this._ts && !A) { _ = 0, g && (c += this._zTime = B ? -Tr : Tr); break } } m = g } } if (_ && !s && (this.pause(), _.render(d >= o ? 0 : -Tr)._zTime = d >= o ? 1 : -1, this._ts)) return this._start = C, jy(this), this.render(i, s, a); this._onUpdate && !s && Cl(this, "onUpdate", !0), (c === l && this._tTime >= this.totalDuration() || !c && o) && (C === this._start || Math.abs(x) !== Math.abs(this._ts)) && (this._lock || ((i || !u) && (c === l && this._ts > 0 || !c && this._ts < 0) && Mh(this, 1), !s && !(i < 0 && !o) && (c || o || !l) && (Cl(this, c === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(c < l && this.timeScale() > 0) && this._prom()))) } return this }, t.add = function (i, s) { var a = this; if (ff(s) || (s = hl(this, s, i)), !(i instanceof kA)) { if (da(i)) return i.forEach(function (o) { return a.add(o, s) }), this; if (Os(i)) return this.addLabel(i, s); if (Di(i)) i = rs.delayedCall(0, i); else return this } return this !== i ? Ju(this, i, s) : this }, t.getChildren = function (i, s, a, o) { i === void 0 && (i = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -_l); for (var l = [], u = this._first; u;)u._start >= o && (u instanceof rs ? s && l.push(u) : (a && l.push(u), i && l.push.apply(l, u.getChildren(!0, s, a)))), u = u._next; return l }, t.getById = function (i) { for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)if (s[a].vars.id === i) return s[a] }, t.remove = function (i) { return Os(i) ? this.removeLabel(i) : Di(i) ? this.killTweensOf(i) : (Yy(this, i), i === this._recent && (this._recent = this._last), sp(this)) }, t.totalTime = function (i, s) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Js(Lo.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), n.prototype.totalTime.call(this, i, s), this._forcing = 0, this) : this._tTime }, t.addLabel = function (i, s) { return this.labels[i] = hl(this, s), this }, t.removeLabel = function (i) { return delete this.labels[i], this }, t.addPause = function (i, s, a) { var o = rs.delayedCall(0, s || DA, a); return o.data = "isPause", this._hasPause = 1, Ju(this, o, hl(this, i)) }, t.removePause = function (i) { var s = this._first; for (i = hl(this, i); s;)s._start === i && s.data === "isPause" && Mh(s), s = s._next }, t.killTweensOf = function (i, s, a) { for (var o = this.getTweensOf(i, a), l = o.length; l--;)ih !== o[l] && o[l].kill(i, s); return this }, t.getTweensOf = function (i, s) { for (var a = [], o = El(i), l = this._first, u = ff(s), c; l;)l instanceof rs ? TW(l._targets, o) && (u ? (!ih || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && a.push(l) : (c = l.getTweensOf(o, s)).length && a.push.apply(a, c), l = l._next; return a }, t.tweenTo = function (i, s) { s = s || {}; var a = this, o = hl(a, i), l = s, u = l.startAt, c = l.onStart, h = l.onStartParams, d = l.immediateRender, m, g = rs.to(a, Rl({ ease: s.ease || "none", lazy: !1, immediateRender: !1, time: o, overwrite: "auto", duration: s.duration || Math.abs((o - (u && "time" in u ? u.time : a._time)) / a.timeScale()) || Tr, onStart: function () { if (a.pause(), !m) { var y = s.duration || Math.abs((o - (u && "time" in u ? u.time : a._time)) / a.timeScale()); g._dur !== y && W3(g, y, 0, 1).render(g._time, !0, !0), m = 1 } c && c.apply(g, h || []) } }, s)); return d ? g.render(0) : g }, t.tweenFromTo = function (i, s, a) { return this.tweenTo(s, Rl({ startAt: { time: hl(this, i) } }, a)) }, t.recent = function () { return this._recent }, t.nextLabel = function (i) { return i === void 0 && (i = this._time), rM(this, hl(this, i)) }, t.previousLabel = function (i) { return i === void 0 && (i = this._time), rM(this, hl(this, i), 1) }, t.currentLabel = function (i) { return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Tr) }, t.shiftChildren = function (i, s, a) { a === void 0 && (a = 0); for (var o = this._first, l = this.labels, u; o;)o._start >= a && (o._start += i, o._end += i), o = o._next; if (s) for (u in l) l[u] >= a && (l[u] += i); return sp(this) }, t.invalidate = function (i) { var s = this._first; for (this._lock = 0; s;)s.invalidate(i), s = s._next; return n.prototype.invalidate.call(this, i) }, t.clear = function (i) { i === void 0 && (i = !0); for (var s = this._first, a; s;)a = s._next, this.remove(s), s = a; return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), sp(this) }, t.totalDuration = function (i) { var s = 0, a = this, o = a._last, l = _l, u, c, h; if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -i : i)); if (a._dirty) { for (h = a.parent; o;)u = o._prev, o._dirty && o.totalDuration(), c = o._start, c > l && a._sort && o._ts && !a._lock ? (a._lock = 1, Ju(a, o, c - o._delay, 1)._lock = 0) : l = c, c < 0 && o._ts && (s -= c, (!h && !a._dp || h && h.smoothChildTiming) && (a._start += c / a._ts, a._time -= c, a._tTime -= c), a.shiftChildren(-c, !1, -1 / 0), l = 0), o._end > s && o._ts && (s = o._end), o = u; W3(a, a === hi && a._time > s ? a._time : s, 1, 1), a._dirty = 0 } return a._tDur }, e.updateRoot = function (i) { if (hi._ts && (HF(hi, Y6(i, hi)), GF = Lo.frame), Lo.frame >= $I) { $I += Go.autoSleep || 120; var s = hi._first; if ((!s || !s._ts) && Go.autoSleep && Lo._listeners.length < 2) { for (; s && !s._ts;)s = s._next; s || Lo.sleep() } } }, e }(kA); Rl(no.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var jW = function (e, t, r, i, s, a, o) { var l = new co(this._pt, e, t, 0, 1, gk, null, s), u = 0, c = 0, h, d, m, g, v, y, A, _; for (l.b = r, l.e = i, r += "", i += "", (A = ~i.indexOf("random(")) && (i = LA(i)), a && (_ = [r, i], a(_, e, t), r = _[0], i = _[1]), d = r.match(lx) || []; h = lx.exec(i);)g = h[0], v = i.substring(u, h.index), m ? m = (m + 1) % 5 : v.substr(-5) === "rgba(" && (m = 1), g !== d[c++] && (y = parseFloat(d[c - 1]) || 0, l._pt = { _next: l._pt, p: v || c === 1 ? v : ",", s: y, c: g.charAt(1) === "=" ? x3(y, g) - y : parseFloat(g) - y, m: m && m < 4 ? Math.round : 0 }, u = lx.lastIndex); return l.c = u < i.length ? i.substring(u, i.length) : "", l.fp = o, (FF.test(i) || A) && (l.e = 0), this._pt = l, l }, qC = function (e, t, r, i, s, a, o, l, u, c) { Di(i) && (i = i(s || 0, e, a)); var h = e[t], d = r !== "get" ? r : Di(h) ? u ? e[t.indexOf("set") || !Di(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](u) : e[t]() : h, m = Di(h) ? u ? $W : pk : $C, g; if (Os(i) && (~i.indexOf("random(") && (i = LA(i)), i.charAt(1) === "=" && (g = x3(d, i) + (fa(d) || 0), (g || g === 0) && (i = g))), !c || d !== i || n9) return !isNaN(d * i) && i !== "" ? (g = new co(this._pt, e, t, +d || 0, i - (d || 0), typeof h == "boolean" ? tX : mk, 0, m), u && (g.fp = u), o && g.modifier(o, this, e), this._pt = g) : (!h && !(t in e) && YC(t, i), jW.call(this, e, t, d, i, m, l || Go.stringFilter, u)) }, JW = function (e, t, r, i, s) { if (Di(e) && (e = jg(e, s, t, r, i)), !hc(e) || e.style && e.nodeType || da(e) || DF(e)) return Os(e) ? jg(e, s, t, r, i) : e; var a = {}, o; for (o in e) a[o] = jg(e[o], s, t, r, i); return a }, fk = function (e, t, r, i, s, a) { var o, l, u, c; if (Po[e] && (o = new Po[e]).init(s, o.rawVars ? t[e] : JW(t[e], i, s, a, r), r, i, a) !== !1 && (r._pt = l = new co(r._pt, s, e, 0, 1, o.render, o, 0, o.priority), r !== n3)) for (u = r._ptLookup[r._targets.indexOf(s)], c = o._props.length; c--;)u[o._props[c]] = l; return o }, ih, n9, ZC = function n(e, t, r) { var i = e.vars, s = i.ease, a = i.startAt, o = i.immediateRender, l = i.lazy, u = i.onUpdate, c = i.onUpdateParams, h = i.callbackScope, d = i.runBackwards, m = i.yoyoEase, g = i.keyframes, v = i.autoRevert, y = e._dur, A = e._startAt, _ = e._targets, x = e.parent, C = x && x.data === "nested" ? x.vars.targets : _, T = e._overwrite === "auto" && !zC, I = e.timeline, w, R, b, B, F, U, G, Y, Z, ne, $, L, Q; if (I && (!g || !s) && (s = "none"), e._ease = ap(s, z3.ease), e._yEase = m ? ok(ap(m === !0 ? s : m, z3.ease)) : 0, m && e._yoyo && !e._repeat && (m = e._yEase, e._yEase = e._ease, e._ease = m), e._from = !I && !!i.runBackwards, !I || g && !i.stagger) { if (Y = _[0] ? ip(_[0]).harness : 0, L = Y && i[Y.prop], w = X6(i, jC), A && (A._zTime < 0 && A.progress(1), t < 0 && d && o && !v ? A.render(-1, !0) : A.revert(d && y ? Y5 : CW), A._lazy = 0), a) { if (Mh(e._startAt = rs.set(_, Rl({ data: "isStart", overwrite: !1, parent: x, immediateRender: !0, lazy: !A && lo(l), startAt: null, delay: 0, onUpdate: u, onUpdateParams: c, callbackScope: h, stagger: 0 }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ha || !o && !v) && e._startAt.revert(Y5), o && y && t <= 0 && r <= 0) { t && (e._zTime = t); return } } else if (d && y && !A) { if (t && (o = !1), b = Rl({ overwrite: !1, data: "isFromStart", lazy: o && !A && lo(l), immediateRender: o, stagger: 0, parent: x }, w), L && (b[Y.prop] = L), Mh(e._startAt = rs.set(_, b)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ha ? e._startAt.revert(Y5) : e._startAt.render(-1, !0)), e._zTime = t, !o) n(e._startAt, Tr, Tr); else if (!t) return } for (e._pt = e._ptCache = 0, l = y && lo(l) || l && !y, R = 0; R < _.length; R++) { if (F = _[R], G = F._gsap || KC(_)[R]._gsap, e._ptLookup[R] = ne = {}, KE[G.id] && yh.length && W6(), $ = C === _ ? R : C.indexOf(F), Y && (Z = new Y).init(F, L || w, e, $, C) !== !1 && (e._pt = B = new co(e._pt, F, Z.name, 0, 1, Z.render, Z, 0, Z.priority), Z._props.forEach(function (D) { ne[D] = B }), Z.priority && (U = 1)), !Y || L) for (b in w) Po[b] && (Z = fk(b, w, e, $, F, C)) ? Z.priority && (U = 1) : ne[b] = B = qC.call(e, F, b, "get", w[b], $, C, 0, i.stringFilter); e._op && e._op[R] && e.kill(F, e._op[R]), T && e._pt && (ih = e, hi.killTweensOf(F, ne, e.globalTime(t)), Q = !e.parent, ih = 0), e._pt && l && (KE[G.id] = 1) } U && Ak(e), e._onInit && e._onInit(e) } e._onUpdate = u, e._initted = (!e._op || e._pt) && !Q, g && t <= 0 && I.render(_l, !0, !0) }, KW = function (e, t, r, i, s, a, o) { var l = (e._pt && e._ptCache || (e._ptCache = {}))[t], u, c, h, d; if (!l) for (l = e._ptCache[t] = [], h = e._ptLookup, d = e._targets.length; d--;) { if (u = h[d][t], u && u.d && u.d._pt) for (u = u.d._pt; u && u.p !== t && u.fp !== t;)u = u._next; if (!u) return n9 = 1, e.vars[t] = "+=0", ZC(e, o), n9 = 0, 1; l.push(u) } for (d = l.length; d--;)c = l[d], u = c._pt || c, u.s = (i || i === 0) && !s ? i : u.s + (i || 0) + a * u.c, u.c = r - u.s, c.e && (c.e = zi(r) + fa(c.e)), c.b && (c.b = u.s + fa(c.b)) }, qW = function (e, t) { var r = e[0] ? ip(e[0]).harness : 0, i = r && r.aliases, s, a, o, l; if (!i) return t; s = _p({}, t); for (a in i) if (a in s) for (l = i[a].split(","), o = l.length; o--;)s[l[o]] = s[a]; return s }, ZW = function (e, t, r, i) { var s = t.ease || i || "power1.inOut", a, o; if (da(t)) o = r[e] || (r[e] = []), t.forEach(function (l, u) { return o.push({ t: u / (t.length - 1) * 100, v: l, e: s }) }); else for (a in t) o = r[a] || (r[a] = []), a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s }) }, jg = function (e, t, r, i, s) { return Di(e) ? e.call(t, r, i, s) : Os(e) && ~e.indexOf("random(") ? LA(e) : e }, hk = JC + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", dk = {}; uo(hk + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) { return dk[n] = 1 }); var rs = function (n) { RF(e, n); function e(r, i, s, a) { var o; typeof i == "number" && (s.duration = i, i = s, s = null), o = n.call(this, a ? i : Xg(i)) || this; var l = o.vars, u = l.duration, c = l.delay, h = l.immediateRender, d = l.stagger, m = l.overwrite, g = l.keyframes, v = l.defaults, y = l.scrollTrigger, A = l.yoyoEase, _ = i.parent || hi, x = (da(r) || DF(r) ? ff(r[0]) : "length" in i) ? [r] : El(r), C, T, I, w, R, b, B, F; if (o._targets = x.length ? KC(x) : V6("GSAP target " + r + " not found. https://greensock.com", !Go.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = m, g || d || tv(u) || tv(c)) { if (i = o.vars, C = o.timeline = new no({ data: "nested", defaults: v || {}, targets: _ && _.data === "nested" ? _.vars.targets : x }), C.kill(), C.parent = C._dp = zc(o), C._start = 0, d || tv(u) || tv(c)) { if (w = x.length, B = d && qF(d), hc(d)) for (R in d) ~hk.indexOf(R) && (F || (F = {}), F[R] = d[R]); for (T = 0; T < w; T++)I = X6(i, dk), I.stagger = 0, A && (I.yoyoEase = A), F && _p(I, F), b = x[T], I.duration = +jg(u, zc(o), T, b, x), I.delay = (+jg(c, zc(o), T, b, x) || 0) - o._delay, !d && w === 1 && I.delay && (o._delay = c = I.delay, o._start += c, I.delay = 0), C.to(b, I, B ? B(T, b, x) : 0), C._ease = Kn.none; C.duration() ? u = c = 0 : o.timeline = 0 } else if (g) { Xg(Rl(C.vars.defaults, { ease: "none" })), C._ease = ap(g.ease || i.ease || "none"); var U = 0, G, Y, Z; if (da(g)) g.forEach(function (ne) { return C.to(x, ne, ">") }), C.duration(); else { I = {}; for (R in g) R === "ease" || R === "easeEach" || ZW(R, g[R], I, g.easeEach); for (R in I) for (G = I[R].sort(function (ne, $) { return ne.t - $.t }), U = 0, T = 0; T < G.length; T++)Y = G[T], Z = { ease: Y.e, duration: (Y.t - (T ? G[T - 1].t : 0)) / 100 * u }, Z[R] = Y.v, C.to(x, Z, U), U += Z.duration; C.duration() < u && C.to({}, { duration: u - C.duration() }) } } u || o.duration(u = C.duration()) } else o.timeline = 0; return m === !0 && !zC && (ih = zc(o), hi.killTweensOf(x), ih = 0), Ju(_, zc(o), s), i.reversed && o.reverse(), i.paused && o.paused(!0), (h || !u && !g && o._start === Js(_._time) && lo(h) && bW(zc(o)) && _.data !== "nested") && (o._tTime = -Tr, o.render(Math.max(0, -c) || 0)), y && YF(zc(o), y), o } var t = e.prototype; return t.render = function (i, s, a) { var o = this._time, l = this._tDur, u = this._dur, c = i < 0, h = i > l - Tr && !c ? l : i < Tr ? 0 : i, d, m, g, v, y, A, _, x, C; if (!u) RW(this, i, s, a); else if (h !== this._tTime || !i || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c) { if (d = h, x = this.timeline, this._repeat) { if (v = u + this._rDelay, this._repeat < -1 && c) return this.totalTime(v * 100 + i, s, a); if (d = Js(h % v), h === l ? (g = this._repeat, d = u) : (g = ~~(h / v), g && g === h / v && (d = u, g--), d > u && (d = u)), A = this._yoyo && g & 1, A && (C = this._yEase, d = u - d), y = V3(this._tTime, v), d === o && !a && this._initted) return this._tTime = h, this; g !== y && (x && this._yEase && lk(x, A), this.vars.repeatRefresh && !A && !this._lock && (this._lock = a = 1, this.render(Js(v * g), !0).invalidate()._lock = 0)) } if (!this._initted) { if (jF(this, c ? i : d, a, s, h)) return this._tTime = 0, this; if (o !== this._time) return this; if (u !== this._dur) return this.render(i, s, a) } if (this._tTime = h, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = _ = (C || this._ease)(d / u), this._from && (this.ratio = _ = 1 - _), d && !o && !s && !g && (Cl(this, "onStart"), this._tTime !== h)) return this; for (m = this._pt; m;)m.r(_, m.d), m = m._next; x && x.render(i < 0 ? i : !d && A ? -Tr : x._dur * x._ease(d / this._dur), s, a) || this._startAt && (this._zTime = i), this._onUpdate && !s && (c && qE(this, i, s, a), Cl(this, "onUpdate")), this._repeat && g !== y && this.vars.onRepeat && !s && this.parent && Cl(this, "onRepeat"), (h === this._tDur || !h) && this._tTime === h && (c && !this._onUpdate && qE(this, i, !0, !0), (i || !u) && (h === this._tDur && this._ts > 0 || !h && this._ts < 0) && Mh(this, 1), !s && !(c && !o) && (h || o || A) && (Cl(this, h === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(h < l && this.timeScale() > 0) && this._prom())) } return this }, t.targets = function () { return this._targets }, t.invalidate = function (i) { return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), n.prototype.invalidate.call(this, i) }, t.resetTo = function (i, s, a, o) { FA || Lo.wake(), this._ts || this.play(); var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), u; return this._initted || ZC(this, l), u = this._ease(l / this._dur), KW(this, i, s, a, o, u, l) ? this.resetTo(i, s, a, o) : (Jy(this, 0), this.parent || WF(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, t.kill = function (i, s) { if (s === void 0 && (s = "all"), !i && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? Sg(this) : this; if (this.timeline) { var a = this.timeline.totalDuration(); return this.timeline.killTweensOf(i, s, ih && ih.vars.overwrite !== !0)._first || Sg(this), this.parent && a !== this.timeline.totalDuration() && W3(this, this._dur * this.timeline._tDur / a, 0, 1), this } var o = this._targets, l = i ? El(i) : o, u = this._ptLookup, c = this._pt, h, d, m, g, v, y, A; if ((!s || s === "all") && IW(o, l)) return s === "all" && (this._pt = 0), Sg(this); for (h = this._op = this._op || [], s !== "all" && (Os(s) && (v = {}, uo(s, function (_) { return v[_] = 1 }), s = v), s = qW(o, s)), A = o.length; A--;)if (~l.indexOf(o[A])) { d = u[A], s === "all" ? (h[A] = s, g = d, m = {}) : (m = h[A] = h[A] || {}, g = s); for (v in g) y = d && d[v], y && ((!("kill" in y.d) || y.d.kill(v) === !0) && Yy(this, y, "_pt"), delete d[v]), m !== "all" && (m[v] = 1) } return this._initted && !this._pt && c && Sg(this), this }, e.to = function (i, s) { return new e(i, s, arguments[2]) }, e.from = function (i, s) { return Yg(1, arguments) }, e.delayedCall = function (i, s, a, o) { return new e(s, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: i, onComplete: s, onReverseComplete: s, onCompleteParams: a, onReverseCompleteParams: a, callbackScope: o }) }, e.fromTo = function (i, s, a) { return Yg(2, arguments) }, e.set = function (i, s) { return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(i, s) }, e.killTweensOf = function (i, s, a) { return hi.killTweensOf(i, s, a) }, e }(kA); Rl(rs.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }); uo("staggerTo,staggerFrom,staggerFromTo", function (n) { rs[n] = function () { var e = new no, t = $E.call(arguments, 0); return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t) } }); var $C = function (e, t, r) { return e[t] = r }, pk = function (e, t, r) { return e[t](r) }, $W = function (e, t, r, i) { return e[t](i.fp, r) }, eX = function (e, t, r) { return e.setAttribute(t, r) }, eS = function (e, t) { return Di(e[t]) ? pk : VC(e[t]) && e.setAttribute ? eX : $C }, mk = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t) }, tX = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, gk = function (e, t) { var r = t._pt, i = ""; if (!e && t.b) i = t.b; else if (e === 1 && t.e) i = t.e; else { for (; r;)i = r.p + (r.m ? r.m(r.s + r.c * e) : Math.round((r.s + r.c * e) * 1e4) / 1e4) + i, r = r._next; i += t.c } t.set(t.t, t.p, i, t) }, tS = function (e, t) { for (var r = t._pt; r;)r.r(e, r.d), r = r._next }, nX = function (e, t, r, i) { for (var s = this._pt, a; s;)a = s._next, s.p === i && s.modifier(e, t, r), s = a }, rX = function (e) { for (var t = this._pt, r, i; t;)i = t._next, t.p === e && !t.op || t.op === e ? Yy(this, t, "_pt") : t.dep || (r = 1), t = i; return !r }, iX = function (e, t, r, i) { i.mSet(e, t, i.m.call(i.tween, r, i.mt), i) }, Ak = function (e) { for (var t = e._pt, r, i, s, a; t;) { for (r = t._next, i = s; i && i.pr > t.pr;)i = i._next; (t._prev = i ? i._prev : a) ? t._prev._next = t : s = t, (t._next = i) ? i._prev = t : a = t, t = r } e._pt = s }, co = function () { function n(t, r, i, s, a, o, l, u, c) { this.t = r, this.s = s, this.c = a, this.p = i, this.r = o || mk, this.d = l || this, this.set = u || $C, this.pr = c || 0, this._next = t, t && (t._prev = this) } var e = n.prototype; return e.modifier = function (r, i, s) { this.mSet = this.mSet || this.set, this.set = iX, this.m = r, this.mt = s, this.tween = i }, n }(); uo(JC + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) { return jC[n] = 1 }); zo.TweenMax = zo.TweenLite = rs; zo.TimelineLite = zo.TimelineMax = no; hi = new no({ sortChildren: !1, defaults: z3, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }); Go.stringFilter = ak; var op = [], J5 = {}, sX = [], sM = 0, aX = 0, dx = function (e) { return (J5[e] || sX).map(function (t) { return t() }) }, r9 = function () { var e = Date.now(), t = []; e - sM > 2 && (dx("matchMediaInit"), op.forEach(function (r) { var i = r.queries, s = r.conditions, a, o, l, u; for (o in i) a = dl.matchMedia(i[o]).matches, a && (l = 1), a !== s[o] && (s[o] = a, u = 1); u && (r.revert(), l && t.push(r)) }), dx("matchMediaRevert"), t.forEach(function (r) { return r.onMatch(r) }), sM = e, dx("matchMedia")) }, vk = function () { function n(t, r) { this.selector = r && e9(r), this.data = [], this._r = [], this.isReverted = !1, this.id = aX++, t && this.add(t) } var e = n.prototype; return e.add = function (r, i, s) { Di(r) && (s = i, i = r, r = Di); var a = this, o = function () { var u = Mi, c = a.selector, h; return u && u !== a && u.data.push(a), s && (a.selector = e9(s)), Mi = a, h = i.apply(a, arguments), Di(h) && a._r.push(h), Mi = u, a.selector = c, a.isReverted = !1, h }; return a.last = o, r === Di ? o(a) : r ? a[r] = o : o }, e.ignore = function (r) { var i = Mi; Mi = null, r(this), Mi = i }, e.getTweens = function () { var r = []; return this.data.forEach(function (i) { return i instanceof n ? r.push.apply(r, i.getTweens()) : i instanceof rs && !(i.parent && i.parent.data === "nested") && r.push(i) }), r }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (r, i) { var s = this; if (r) { var a = this.getTweens(); this.data.forEach(function (l) { l.data === "isFlip" && (l.revert(), l.getChildren(!0, !0, !1).forEach(function (u) { return a.splice(a.indexOf(u), 1) })) }), a.map(function (l) { return { g: l.globalTime(0), t: l } }).sort(function (l, u) { return u.g - l.g || -1 / 0 }).forEach(function (l) { return l.t.revert(r) }), this.data.forEach(function (l) { return !(l instanceof rs) && l.revert && l.revert(r) }), this._r.forEach(function (l) { return l(r, s) }), this.isReverted = !0 } else this.data.forEach(function (l) { return l.kill && l.kill() }); if (this.clear(), i) for (var o = op.length; o--;)op[o].id === this.id && op.splice(o, 1) }, e.revert = function (r) { this.kill(r || {}) }, n }(), oX = function () { function n(t) { this.contexts = [], this.scope = t } var e = n.prototype; return e.add = function (r, i, s) { hc(r) || (r = { matches: r }); var a = new vk(0, s || this.scope), o = a.conditions = {}, l, u, c; Mi && !a.selector && (a.selector = Mi.selector), this.contexts.push(a), i = a.add("onMatch", i), a.queries = r; for (u in r) u === "all" ? c = 1 : (l = dl.matchMedia(r[u]), l && (op.indexOf(a) < 0 && op.push(a), (o[u] = l.matches) && (c = 1), l.addListener ? l.addListener(r9) : l.addEventListener("change", r9))); return c && i(a), this }, e.revert = function (r) { this.kill(r || {}) }, e.kill = function (r) { this.contexts.forEach(function (i) { return i.kill(r, !0) }) }, n }(), j6 = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)t[r] = arguments[r]; t.forEach(function (i) { return rk(i) }) }, timeline: function (e) { return new no(e) }, getTweensOf: function (e, t) { return hi.getTweensOf(e, t) }, getProperty: function (e, t, r, i) { Os(e) && (e = El(e)[0]); var s = ip(e || {}).get, a = r ? VF : zF; return r === "native" && (r = ""), e && (t ? a((Po[t] && Po[t].get || s)(e, t, r, i)) : function (o, l, u) { return a((Po[o] && Po[o].get || s)(e, o, l, u)) }) }, quickSetter: function (e, t, r) { if (e = El(e), e.length > 1) { var i = e.map(function (c) { return ho.quickSetter(c, t, r) }), s = i.length; return function (c) { for (var h = s; h--;)i[h](c) } } e = e[0] || {}; var a = Po[t], o = ip(e), l = o.harness && (o.harness.aliases || {})[t] || t, u = a ? function (c) { var h = new a; n3._pt = 0, h.init(e, r ? c + r : c, n3, 0, [e]), h.render(1, h), n3._pt && tS(1, n3) } : o.set(e, l); return a ? u : function (c) { return u(e, l, r ? c + r : c, o, 1) } }, quickTo: function (e, t, r) { var i, s = ho.to(e, _p((i = {}, i[t] = "+=0.1", i.paused = !0, i), r || {})), a = function (l, u, c) { return s.resetTo(t, l, u, c) }; return a.tween = s, a }, isTweening: function (e) { return hi.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = ap(e.ease, z3.ease)), eM(z3, e || {}) }, config: function (e) { return eM(Go, e || {}) }, registerEffect: function (e) { var t = e.name, r = e.effect, i = e.plugins, s = e.defaults, a = e.extendTimeline; (i || "").split(",").forEach(function (o) { return o && !Po[o] && !zo[o] && V6(t + " effect requires " + o + " plugin.") }), ux[t] = function (o, l, u) { return r(El(o), Rl(l || {}, s), u) }, a && (no.prototype[t] = function (o, l, u) { return this.add(ux[t](o, hc(l) ? l : (u = l) && {}, this), u) }) }, registerEase: function (e, t) { Kn[e] = ap(t) }, parseEase: function (e, t) { return arguments.length ? ap(e, t) : Kn }, getById: function (e) { return hi.getById(e) }, exportRoot: function (e, t) { e === void 0 && (e = {}); var r = new no(e), i, s; for (r.smoothChildTiming = lo(e.smoothChildTiming), hi.remove(r), r._dp = 0, r._time = r._tTime = hi._time, i = hi._first; i;)s = i._next, (t || !(!i._dur && i instanceof rs && i.vars.onComplete === i._targets[0])) && Ju(r, i, i._start - i._delay), i = s; return Ju(hi, r, 0), r }, context: function (e, t) { return e ? new vk(e, t) : Mi }, matchMedia: function (e) { return new oX(e) }, matchMediaRefresh: function () { return op.forEach(function (e) { var t = e.conditions, r, i; for (i in t) t[i] && (t[i] = !1, r = 1); r && e.revert() }) || r9() }, addEventListener: function (e, t) { var r = J5[e] || (J5[e] = []); ~r.indexOf(t) || r.push(t) }, removeEventListener: function (e, t) { var r = J5[e], i = r && r.indexOf(t); i >= 0 && r.splice(i, 1) }, utils: { wrap: UW, wrapYoyo: GW, distribute: qF, random: $F, snap: ZF, normalize: OW, getUnit: fa, clamp: LW, splitColor: ik, toArray: El, selector: e9, mapRange: tk, pipe: kW, unitize: NW, interpolate: QW, shuffle: KF }, install: OF, effects: ux, ticker: Lo, updateRoot: no.updateRoot, plugins: Po, globalTimeline: hi, core: { PropTween: co, globals: UF, Tween: rs, Timeline: no, Animation: kA, getCache: ip, _removeLinkedListItem: Yy, reverting: function () { return ha }, context: function (e) { return e && Mi && (Mi.data.push(e), e._ctx = Mi), Mi }, suppressOverwrites: function (e) { return zC = e } } }; uo("to,from,fromTo,delayedCall,set,killTweensOf", function (n) { return j6[n] = rs[n] }); Lo.add(no.updateRoot); n3 = j6.to({}, { duration: 0 }); var lX = function (e, t) { for (var r = e._pt; r && r.p !== t && r.op !== t && r.fp !== t;)r = r._next; return r }, uX = function (e, t) { var r = e._targets, i, s, a; for (i in t) for (s = r.length; s--;)a = e._ptLookup[s][i], a && (a = a.d) && (a._pt && (a = lX(a, i)), a && a.modifier && a.modifier(t[i], e, r[s], i)) }, px = function (e, t) { return { name: e, rawVars: 1, init: function (i, s, a) { a._onInit = function (o) { var l, u; if (Os(s) && (l = {}, uo(s, function (c) { return l[c] = 1 }), s = l), t) { l = {}; for (u in s) l[u] = t(s[u]); s = l } uX(o, s) } } } }, ho = j6.registerPlugin({ name: "attr", init: function (e, t, r, i, s) { var a, o, l; this.tween = r; for (a in t) l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], i, s, 0, 0, a), o.op = a, o.b = l, this._props.push(a) }, render: function (e, t) { for (var r = t._pt; r;)ha ? r.set(r.t, r.p, r.b, r) : r.r(e, r.d), r = r._next } }, { name: "endArray", init: function (e, t) { for (var r = t.length; r--;)this.add(e, r, e[r] || 0, t[r], 0, 0, 0, 0, 0, 1) } }, px("roundProps", t9), px("modifiers"), px("snap", ZF)) || j6; rs.version = no.version = ho.version = "3.12.2"; NF = 1; WC() && X3(); Kn.Power0; Kn.Power1; Kn.Power2; Kn.Power3; Kn.Power4; Kn.Linear; Kn.Quad; Kn.Cubic; Kn.Quart; Kn.Quint; Kn.Strong; Kn.Elastic; var i9 = Kn.Back; Kn.SteppedEase; Kn.Bounce; Kn.Sine; Kn.Expo; Kn.Circ;/*!
 * CSSPlugin 3.12.2
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var aM, sh, _3, nS, Wd, oM, rS, cX = function () { return typeof window < "u" }, hf = {}, Md = 180 / Math.PI, E3 = Math.PI / 180, o0 = Math.atan2, lM = 1e8, iS = /([A-Z])/g, fX = /(left|right|width|margin|padding|x)/i, hX = /[\s,\(]\S/, Ku = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, s9 = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, dX = function (e, t) { return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, pX = function (e, t) { return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t) }, mX = function (e, t) { var r = t.s + t.c * e; t.set(t.t, t.p, ~~(r + (r < 0 ? -.5 : .5)) + t.u, t) }, yk = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, xk = function (e, t) { return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t) }, gX = function (e, t, r) { return e.style[t] = r }, AX = function (e, t, r) { return e.style.setProperty(t, r) }, vX = function (e, t, r) { return e._gsap[t] = r }, yX = function (e, t, r) { return e._gsap.scaleX = e._gsap.scaleY = r }, xX = function (e, t, r, i, s) { var a = e._gsap; a.scaleX = a.scaleY = r, a.renderTransform(s, a) }, _X = function (e, t, r, i, s) { var a = e._gsap; a[t] = r, a.renderTransform(s, a) }, di = "transform", mu = di + "Origin", EX = function n(e, t) { var r = this, i = this.target, s = i.style; if (e in hf && s) { if (this.tfm = this.tfm || {}, e !== "transform") e = Ku[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (a) { return r.tfm[a] = Xc(i, a) }) : this.tfm[e] = i._gsap.x ? i._gsap[e] : Xc(i, e); else return Ku.transform.split(",").forEach(function (a) { return n.call(r, a, t) }); if (this.props.indexOf(di) >= 0) return; i._gsap.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(mu, t, "")), e = di } (s || t) && this.props.push(e, t, s[e]) }, _k = function (e) { e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate")) }, CX = function () { var e = this.props, t = this.target, r = t.style, i = t._gsap, s, a; for (s = 0; s < e.length; s += 3)e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? r[e[s]] = e[s + 2] : r.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(iS, "-$1").toLowerCase()); if (this.tfm) { for (a in this.tfm) i[a] = this.tfm[a]; i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = rS(), (!s || !s.isStart) && !r[di] && (_k(r), i.uncache = 1) } }, Ek = function (e, t) { var r = { target: e, props: [], revert: CX, save: EX }; return e._gsap || ho.core.getCache(e), t && t.split(",").forEach(function (i) { return r.save(i) }), r }, Ck, a9 = function (e, t) { var r = sh.createElementNS ? sh.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : sh.createElement(e); return r.style ? r : sh.createElement(e) }, nc = function n(e, t, r) { var i = getComputedStyle(e); return i[t] || i.getPropertyValue(t.replace(iS, "-$1").toLowerCase()) || i.getPropertyValue(t) || !r && n(e, Y3(t) || t, 1) || "" }, uM = "O,Moz,ms,Ms,Webkit".split(","), Y3 = function (e, t, r) { var i = t || Wd, s = i.style, a = 5; if (e in s && !r) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(uM[a] + e in s);); return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? uM[a] : "") + e }, o9 = function () { cX() && window.document && (aM = window, sh = aM.document, _3 = sh.documentElement, Wd = a9("div") || { style: {} }, a9("div"), di = Y3(di), mu = di + "Origin", Wd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Ck = !!Y3("perspective"), rS = ho.core.reverting, nS = 1) }, mx = function n(e) { var t = a9("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, i = this.nextSibling, s = this.style.cssText, a; if (_3.appendChild(t), t.appendChild(this), this.style.display = "block", e) try { a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n } catch { } else this._gsapBBox && (a = this._gsapBBox()); return r && (i ? r.insertBefore(this, i) : r.appendChild(this)), _3.removeChild(t), this.style.cssText = s, a }, cM = function (e, t) { for (var r = t.length; r--;)if (e.hasAttribute(t[r])) return e.getAttribute(t[r]) }, Sk = function (e) { var t; try { t = e.getBBox() } catch { t = mx.call(e, !0) } return t && (t.width || t.height) || e.getBBox === mx || (t = mx.call(e, !0)), t && !t.width && !t.x && !t.y ? { x: +cM(e, ["x", "cx", "x1"]) || 0, y: +cM(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t }, Tk = function (e) { return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Sk(e)) }, NA = function (e, t) { if (t) { var r = e.style; t in hf && t !== mu && (t = di), r.removeProperty ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), r.removeProperty(t.replace(iS, "-$1").toLowerCase())) : r.removeAttribute(t) } }, ah = function (e, t, r, i, s, a) { var o = new co(e._pt, t, r, 0, 1, a ? xk : yk); return e._pt = o, o.b = i, o.e = s, e._props.push(r), o }, fM = { deg: 1, rad: 1, turn: 1 }, SX = { grid: 1, flex: 1 }, bh = function n(e, t, r, i) { var s = parseFloat(r) || 0, a = (r + "").trim().substr((s + "").length) || "px", o = Wd.style, l = fX.test(t), u = e.tagName.toLowerCase() === "svg", c = (u ? "client" : "offset") + (l ? "Width" : "Height"), h = 100, d = i === "px", m = i === "%", g, v, y, A; return i === a || !s || fM[i] || fM[a] ? s : (a !== "px" && !d && (s = n(e, t, r, "px")), A = e.getCTM && Tk(e), (m || a === "%") && (hf[t] || ~t.indexOf("adius")) ? (g = A ? e.getBBox()[l ? "width" : "height"] : e[c], zi(m ? s / g * h : s / 100 * g)) : (o[l ? "width" : "height"] = h + (d ? a : i), v = ~t.indexOf("adius") || i === "em" && e.appendChild && !u ? e : e.parentNode, A && (v = (e.ownerSVGElement || {}).parentNode), (!v || v === sh || !v.appendChild) && (v = sh.body), y = v._gsap, y && m && y.width && l && y.time === Lo.time && !y.uncache ? zi(s / y.width * h) : ((m || a === "%") && !SX[nc(v, "display")] && (o.position = nc(e, "position")), v === e && (o.position = "static"), v.appendChild(Wd), g = Wd[c], v.removeChild(Wd), o.position = "absolute", l && m && (y = ip(v), y.time = Lo.time, y.width = v[c]), zi(d ? g * s / h : g && s ? h / g * s : 0)))) }, Xc = function (e, t, r, i) { var s; return nS || o9(), t in Ku && t !== "transform" && (t = Ku[t], ~t.indexOf(",") && (t = t.split(",")[0])), hf[t] && t !== "transform" ? (s = UA(e, i), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : K6(nc(e, mu)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = J6[t] && J6[t](e, t, r) || nc(e, t) || QF(e, t) || (t === "opacity" ? 1 : 0))), r && !~(s + "").trim().indexOf(" ") ? bh(e, t, s, r) + r : s }, TX = function (e, t, r, i) { if (!r || r === "none") { var s = Y3(t, e, 1), a = s && nc(e, s, 1); a && a !== r ? (t = s, r = a) : t === "borderColor" && (r = nc(e, "borderTopColor")) } var o = new co(this._pt, e.style, t, 0, 1, gk), l = 0, u = 0, c, h, d, m, g, v, y, A, _, x, C, T; if (o.b = r, o.e = i, r += "", i += "", i === "auto" && (e.style[t] = i, i = nc(e, t) || i, e.style[t] = r), c = [r, i], ak(c), r = c[0], i = c[1], d = r.match(t3) || [], T = i.match(t3) || [], T.length) { for (; h = t3.exec(i);)y = h[0], _ = i.substring(l, h.index), g ? g = (g + 1) % 5 : (_.substr(-5) === "rgba(" || _.substr(-5) === "hsla(") && (g = 1), y !== (v = d[u++] || "") && (m = parseFloat(v) || 0, C = v.substr((m + "").length), y.charAt(1) === "=" && (y = x3(m, y) + C), A = parseFloat(y), x = y.substr((A + "").length), l = t3.lastIndex - x.length, x || (x = x || Go.units[t] || C, l === i.length && (i += x, o.e += x)), C !== x && (m = bh(e, t, v, x) || 0), o._pt = { _next: o._pt, p: _ || u === 1 ? _ : ",", s: m, c: A - m, m: g && g < 4 || t === "zIndex" ? Math.round : 0 }); o.c = l < i.length ? i.substring(l, i.length) : "" } else o.r = t === "display" && i === "none" ? xk : yk; return FF.test(i) && (o.e = 0), this._pt = o, o }, hM = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, wX = function (e) { var t = e.split(" "), r = t[0], i = t[1] || "50%"; return (r === "top" || r === "bottom" || i === "left" || i === "right") && (e = r, r = i, i = e), t[0] = hM[r] || r, t[1] = hM[i] || i, t.join(" ") }, IX = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var r = t.t, i = r.style, s = t.u, a = r._gsap, o, l, u; if (s === "all" || s === !0) i.cssText = "", l = 1; else for (s = s.split(","), u = s.length; --u > -1;)o = s[u], hf[o] && (l = 1, o = o === "transformOrigin" ? mu : di), NA(r, o); l && (NA(r, di), a && (a.svg && r.removeAttribute("transform"), UA(r, 1), a.uncache = 1, _k(i))) } }, J6 = { clearProps: function (e, t, r, i, s) { if (s.data !== "isFromStart") { var a = e._pt = new co(e._pt, t, r, 0, 0, IX); return a.u = i, a.pr = -10, a.tween = s, e._props.push(r), 1 } } }, OA = [1, 0, 0, 1, 0, 0], wk = {}, Ik = function (e) { return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e }, dM = function (e) { var t = nc(e, di); return Ik(t) ? OA : t.substr(7).match(LF).map(zi) }, sS = function (e, t) { var r = e._gsap || ip(e), i = e.style, s = dM(e), a, o, l, u; return r.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? OA : s) : (s === OA && !e.offsetParent && e !== _3 && !r.svg && (l = i.display, i.display = "block", a = e.parentNode, (!a || !e.offsetParent) && (u = 1, o = e.nextElementSibling, _3.appendChild(e)), s = dM(e), l ? i.display = l : NA(e, "display"), u && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : _3.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s) }, l9 = function (e, t, r, i, s, a) { var o = e._gsap, l = s || sS(e, !0), u = o.xOrigin || 0, c = o.yOrigin || 0, h = o.xOffset || 0, d = o.yOffset || 0, m = l[0], g = l[1], v = l[2], y = l[3], A = l[4], _ = l[5], x = t.split(" "), C = parseFloat(x[0]) || 0, T = parseFloat(x[1]) || 0, I, w, R, b; r ? l !== OA && (w = m * y - g * v) && (R = C * (y / w) + T * (-v / w) + (v * _ - y * A) / w, b = C * (-g / w) + T * (m / w) - (m * _ - g * A) / w, C = R, T = b) : (I = Sk(e), C = I.x + (~x[0].indexOf("%") ? C / 100 * I.width : C), T = I.y + (~(x[1] || x[0]).indexOf("%") ? T / 100 * I.height : T)), i || i !== !1 && o.smooth ? (A = C - u, _ = T - c, o.xOffset = h + (A * m + _ * v) - A, o.yOffset = d + (A * g + _ * y) - _) : o.xOffset = o.yOffset = 0, o.xOrigin = C, o.yOrigin = T, o.smooth = !!i, o.origin = t, o.originIsAbsolute = !!r, e.style[mu] = "0px 0px", a && (ah(a, o, "xOrigin", u, C), ah(a, o, "yOrigin", c, T), ah(a, o, "xOffset", h, o.xOffset), ah(a, o, "yOffset", d, o.yOffset)), e.setAttribute("data-svg-origin", C + " " + T) }, UA = function (e, t) { var r = e._gsap || new ck(e); if ("x" in r && !t && !r.uncache) return r; var i = e.style, s = r.scaleX < 0, a = "px", o = "deg", l = getComputedStyle(e), u = nc(e, mu) || "0", c, h, d, m, g, v, y, A, _, x, C, T, I, w, R, b, B, F, U, G, Y, Z, ne, $, L, Q, D, V, J, Ee, xe, Be; return c = h = d = v = y = A = _ = x = C = 0, m = g = 1, r.svg = !!(e.getCTM && Tk(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[di] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[di] !== "none" ? l[di] : "")), i.scale = i.rotate = i.translate = "none"), w = sS(e, r.svg), r.svg && (r.uncache ? (L = e.getBBox(), u = r.xOrigin - L.x + "px " + (r.yOrigin - L.y) + "px", $ = "") : $ = !t && e.getAttribute("data-svg-origin"), l9(e, $ || u, !!$ || r.originIsAbsolute, r.smooth !== !1, w)), T = r.xOrigin || 0, I = r.yOrigin || 0, w !== OA && (F = w[0], U = w[1], G = w[2], Y = w[3], c = Z = w[4], h = ne = w[5], w.length === 6 ? (m = Math.sqrt(F * F + U * U), g = Math.sqrt(Y * Y + G * G), v = F || U ? o0(U, F) * Md : 0, _ = G || Y ? o0(G, Y) * Md + v : 0, _ && (g *= Math.abs(Math.cos(_ * E3))), r.svg && (c -= T - (T * F + I * G), h -= I - (T * U + I * Y))) : (Be = w[6], Ee = w[7], D = w[8], V = w[9], J = w[10], xe = w[11], c = w[12], h = w[13], d = w[14], R = o0(Be, J), y = R * Md, R && (b = Math.cos(-R), B = Math.sin(-R), $ = Z * b + D * B, L = ne * b + V * B, Q = Be * b + J * B, D = Z * -B + D * b, V = ne * -B + V * b, J = Be * -B + J * b, xe = Ee * -B + xe * b, Z = $, ne = L, Be = Q), R = o0(-G, J), A = R * Md, R && (b = Math.cos(-R), B = Math.sin(-R), $ = F * b - D * B, L = U * b - V * B, Q = G * b - J * B, xe = Y * B + xe * b, F = $, U = L, G = Q), R = o0(U, F), v = R * Md, R && (b = Math.cos(R), B = Math.sin(R), $ = F * b + U * B, L = Z * b + ne * B, U = U * b - F * B, ne = ne * b - Z * B, F = $, Z = L), y && Math.abs(y) + Math.abs(v) > 359.9 && (y = v = 0, A = 180 - A), m = zi(Math.sqrt(F * F + U * U + G * G)), g = zi(Math.sqrt(ne * ne + Be * Be)), R = o0(Z, ne), _ = Math.abs(R) > 2e-4 ? R * Md : 0, C = xe ? 1 / (xe < 0 ? -xe : xe) : 0), r.svg && ($ = e.getAttribute("transform"), r.forceCSS = e.setAttribute("transform", "") || !Ik(nc(e, di)), $ && e.setAttribute("transform", $))), Math.abs(_) > 90 && Math.abs(_) < 270 && (s ? (m *= -1, _ += v <= 0 ? 180 : -180, v += v <= 0 ? 180 : -180) : (g *= -1, _ += _ <= 0 ? 180 : -180)), t = t || r.uncache, r.x = c - ((r.xPercent = c && (!t && r.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e.offsetWidth * r.xPercent / 100 : 0) + a, r.y = h - ((r.yPercent = h && (!t && r.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetHeight * r.yPercent / 100 : 0) + a, r.z = d + a, r.scaleX = zi(m), r.scaleY = zi(g), r.rotation = zi(v) + o, r.rotationX = zi(y) + o, r.rotationY = zi(A) + o, r.skewX = _ + o, r.skewY = x + o, r.transformPerspective = C + a, (r.zOrigin = parseFloat(u.split(" ")[2]) || 0) && (i[mu] = K6(u)), r.xOffset = r.yOffset = 0, r.force3D = Go.force3D, r.renderTransform = r.svg ? bX : Ck ? Mk : MX, r.uncache = 0, r }, K6 = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, gx = function (e, t, r) { var i = fa(t); return zi(parseFloat(t) + parseFloat(bh(e, "x", r + "px", i))) + i }, MX = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Mk(e, t) }, fd = "0deg", jm = "0px", hd = ") ", Mk = function (e, t) { var r = t || this, i = r.xPercent, s = r.yPercent, a = r.x, o = r.y, l = r.z, u = r.rotation, c = r.rotationY, h = r.rotationX, d = r.skewX, m = r.skewY, g = r.scaleX, v = r.scaleY, y = r.transformPerspective, A = r.force3D, _ = r.target, x = r.zOrigin, C = "", T = A === "auto" && e && e !== 1 || A === !0; if (x && (h !== fd || c !== fd)) { var I = parseFloat(c) * E3, w = Math.sin(I), R = Math.cos(I), b; I = parseFloat(h) * E3, b = Math.cos(I), a = gx(_, a, w * b * -x), o = gx(_, o, -Math.sin(I) * -x), l = gx(_, l, R * b * -x + x) } y !== jm && (C += "perspective(" + y + hd), (i || s) && (C += "translate(" + i + "%, " + s + "%) "), (T || a !== jm || o !== jm || l !== jm) && (C += l !== jm || T ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + hd), u !== fd && (C += "rotate(" + u + hd), c !== fd && (C += "rotateY(" + c + hd), h !== fd && (C += "rotateX(" + h + hd), (d !== fd || m !== fd) && (C += "skew(" + d + ", " + m + hd), (g !== 1 || v !== 1) && (C += "scale(" + g + ", " + v + hd), _.style[di] = C || "translate(0, 0)" }, bX = function (e, t) { var r = t || this, i = r.xPercent, s = r.yPercent, a = r.x, o = r.y, l = r.rotation, u = r.skewX, c = r.skewY, h = r.scaleX, d = r.scaleY, m = r.target, g = r.xOrigin, v = r.yOrigin, y = r.xOffset, A = r.yOffset, _ = r.forceCSS, x = parseFloat(a), C = parseFloat(o), T, I, w, R, b; l = parseFloat(l), u = parseFloat(u), c = parseFloat(c), c && (c = parseFloat(c), u += c, l += c), l || u ? (l *= E3, u *= E3, T = Math.cos(l) * h, I = Math.sin(l) * h, w = Math.sin(l - u) * -d, R = Math.cos(l - u) * d, u && (c *= E3, b = Math.tan(u - c), b = Math.sqrt(1 + b * b), w *= b, R *= b, c && (b = Math.tan(c), b = Math.sqrt(1 + b * b), T *= b, I *= b)), T = zi(T), I = zi(I), w = zi(w), R = zi(R)) : (T = h, R = d, I = w = 0), (x && !~(a + "").indexOf("px") || C && !~(o + "").indexOf("px")) && (x = bh(m, "x", a, "px"), C = bh(m, "y", o, "px")), (g || v || y || A) && (x = zi(x + g - (g * T + v * w) + y), C = zi(C + v - (g * I + v * R) + A)), (i || s) && (b = m.getBBox(), x = zi(x + i / 100 * b.width), C = zi(C + s / 100 * b.height)), b = "matrix(" + T + "," + I + "," + w + "," + R + "," + x + "," + C + ")", m.setAttribute("transform", b), _ && (m.style[di] = b) }, BX = function (e, t, r, i, s) { var a = 360, o = Os(s), l = parseFloat(s) * (o && ~s.indexOf("rad") ? Md : 1), u = l - i, c = i + u + "deg", h, d; return o && (h = s.split("_")[1], h === "short" && (u %= a, u !== u % (a / 2) && (u += u < 0 ? a : -a)), h === "cw" && u < 0 ? u = (u + a * lM) % a - ~~(u / a) * a : h === "ccw" && u > 0 && (u = (u - a * lM) % a - ~~(u / a) * a)), e._pt = d = new co(e._pt, t, r, i, u, dX), d.e = c, d.u = "deg", e._props.push(r), d }, pM = function (e, t) { for (var r in t) e[r] = t[r]; return e }, RX = function (e, t, r) { var i = pM({}, r._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", a = r.style, o, l, u, c, h, d, m, g; i.svg ? (u = r.getAttribute("transform"), r.setAttribute("transform", ""), a[di] = t, o = UA(r, 1), NA(r, di), r.setAttribute("transform", u)) : (u = getComputedStyle(r)[di], a[di] = t, o = UA(r, 1), a[di] = u); for (l in hf) u = i[l], c = o[l], u !== c && s.indexOf(l) < 0 && (m = fa(u), g = fa(c), h = m !== g ? bh(r, l, u, g) : parseFloat(u), d = parseFloat(c), e._pt = new co(e._pt, o, l, h, d - h, s9), e._pt.u = g || 0, e._props.push(l)); pM(o, i) }; uo("padding,margin,Width,Radius", function (n, e) { var t = "Top", r = "Right", i = "Bottom", s = "Left", a = (e < 3 ? [t, r, i, s] : [t + s, t + r, i + r, i + s]).map(function (o) { return e < 2 ? n + o : "border" + o + n }); J6[e > 1 ? "border" + n : n] = function (o, l, u, c, h) { var d, m; if (arguments.length < 4) return d = a.map(function (g) { return Xc(o, g, u) }), m = d.join(" "), m.split(d[0]).length === 5 ? d[0] : m; d = (c + "").split(" "), m = {}, a.forEach(function (g, v) { return m[g] = d[v] = d[v] || d[(v - 1) / 2 | 0] }), o.init(l, m, h) } }); var bk = { name: "css", register: o9, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, r, i, s) { var a = this._props, o = e.style, l = r.vars.startAt, u, c, h, d, m, g, v, y, A, _, x, C, T, I, w, R; nS || o9(), this.styles = this.styles || Ek(e), R = this.styles.props, this.tween = r; for (v in t) if (v !== "autoRound" && (c = t[v], !(Po[v] && fk(v, t, r, i, e, s)))) { if (m = typeof c, g = J6[v], m === "function" && (c = c.call(r, i, e, s), m = typeof c), m === "string" && ~c.indexOf("random(") && (c = LA(c)), g) g(this, e, v, c, r) && (w = 1); else if (v.substr(0, 2) === "--") u = (getComputedStyle(e).getPropertyValue(v) + "").trim(), c += "", xh.lastIndex = 0, xh.test(u) || (y = fa(u), A = fa(c)), A ? y !== A && (u = bh(e, v, u, A) + A) : y && (c += y), this.add(o, "setProperty", u, c, i, s, 0, 0, v), a.push(v), R.push(v, 0, o[v]); else if (m !== "undefined") { if (l && v in l ? (u = typeof l[v] == "function" ? l[v].call(r, i, e, s) : l[v], Os(u) && ~u.indexOf("random(") && (u = LA(u)), fa(u + "") || (u += Go.units[v] || fa(Xc(e, v)) || ""), (u + "").charAt(1) === "=" && (u = Xc(e, v))) : u = Xc(e, v), d = parseFloat(u), _ = m === "string" && c.charAt(1) === "=" && c.substr(0, 2), _ && (c = c.substr(2)), h = parseFloat(c), v in Ku && (v === "autoAlpha" && (d === 1 && Xc(e, "visibility") === "hidden" && h && (d = 0), R.push("visibility", 0, o.visibility), ah(this, o, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), v !== "scale" && v !== "transform" && (v = Ku[v], ~v.indexOf(",") && (v = v.split(",")[0]))), x = v in hf, x) { if (this.styles.save(v), C || (T = e._gsap, T.renderTransform && !t.parseTransform || UA(e, t.parseTransform), I = t.smoothOrigin !== !1 && T.smooth, C = this._pt = new co(this._pt, o, di, 0, 1, T.renderTransform, T, 0, -1), C.dep = 1), v === "scale") this._pt = new co(this._pt, T, "scaleY", T.scaleY, (_ ? x3(T.scaleY, _ + h) : h) - T.scaleY || 0, s9), this._pt.u = 0, a.push("scaleY", v), v += "X"; else if (v === "transformOrigin") { R.push(mu, 0, o[mu]), c = wX(c), T.svg ? l9(e, c, 0, I, 0, this) : (A = parseFloat(c.split(" ")[2]) || 0, A !== T.zOrigin && ah(this, T, "zOrigin", T.zOrigin, A), ah(this, o, v, K6(u), K6(c))); continue } else if (v === "svgOrigin") { l9(e, c, 1, I, 0, this); continue } else if (v in wk) { BX(this, T, v, d, _ ? x3(d, _ + c) : c); continue } else if (v === "smoothOrigin") { ah(this, T, "smooth", T.smooth, c); continue } else if (v === "force3D") { T[v] = c; continue } else if (v === "transform") { RX(this, c, e); continue } } else v in o || (v = Y3(v) || v); if (x || (h || h === 0) && (d || d === 0) && !hX.test(c) && v in o) y = (u + "").substr((d + "").length), h || (h = 0), A = fa(c) || (v in Go.units ? Go.units[v] : y), y !== A && (d = bh(e, v, u, A)), this._pt = new co(this._pt, x ? T : o, v, d, (_ ? x3(d, _ + h) : h) - d, !x && (A === "px" || v === "zIndex") && t.autoRound !== !1 ? mX : s9), this._pt.u = A || 0, y !== A && A !== "%" && (this._pt.b = u, this._pt.r = pX); else if (v in o) TX.call(this, e, v, u, _ ? _ + c : c); else if (v in e) this.add(e, v, u || e[v], _ ? _ + c : c, i, s); else if (v !== "parseTransform") { YC(v, c); continue } x || (v in o ? R.push(v, 0, o[v]) : R.push(v, 1, u || e[v])), a.push(v) } } w && Ak(this) }, render: function (e, t) { if (t.tween._time || !rS()) for (var r = t._pt; r;)r.r(e, r.d), r = r._next; else t.styles.revert() }, get: Xc, aliases: Ku, getSetter: function (e, t, r) { var i = Ku[t]; return i && i.indexOf(",") < 0 && (t = i), t in hf && t !== mu && (e._gsap.x || Xc(e, "x")) ? r && oM === r ? t === "scale" ? yX : vX : (oM = r || {}) && (t === "scale" ? xX : _X) : e.style && !VC(e.style[t]) ? gX : ~t.indexOf("-") ? AX : eS(e, t) }, core: { _removeProperty: NA, _getMatrix: sS } }; ho.utils.checkPrefix = Y3; ho.core.getStyleSaver = Ek; (function (n, e, t, r) { var i = uo(n + "," + e + "," + t, function (s) { hf[s] = 1 }); uo(e, function (s) { Go.units[s] = "deg", wk[s] = 1 }), Ku[i[13]] = n + "," + e, uo(r, function (s) { var a = s.split(":"); Ku[a[1]] = i[a[0]] }) })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"); uo("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) { Go.units[n] = "px" }); ho.registerPlugin(bk); var pr = ho.registerPlugin(bk) || ho; pr.core.Tween; const PX = () => { const n = ue.useRef(null), e = ue.useRef(null); return ue.useEffect(() => { const t = window.innerWidth; let r = pr.context(() => { t >= 769 ? pr.timeline().from(n.current, { delay: 1.5, x: -15, opacity: 0, duration: .5 }).from(e.current, { x: -15, opacity: 0, duration: .5 }) : pr.timeline().from(n.current, { delay: .5, x: -15, opacity: 0, duration: .5 }).from(e.current, { x: -15, opacity: 0, duration: .5 }) }); return () => r.revert() }, []), re.jsxs("div", { className: "text-con", children: [re.jsx("p", {}), re.jsxs("h1", { className: "md-h1", ref: n, children: ["Hi, I'm ", re.jsx("span", { className: "highlight", children: "TaskVerse" }), ", Your Epic Portal to Limitless Minecraft Adventures"] }), re.jsxs("strong", { ref: e, children: ["Welcome to TaskVerse, our Minecraft server, ", re.jsx("br", {}), " where limitless adventures await in a vibrant community ", re.jsx("br", {}), " of builders and adventurers. ", re.jsx("br", {}), " Join us today and unleash your creativity ", re.jsx("br", {}), "in a world where imagination ", re.jsx("br", {}), " knows no bounds"] })] }) }; function dc() { return dc = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, dc.apply(this, arguments) } var Bk = { exports: {} }, DX = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", LX = DX, FX = LX; function Rk() { } function Pk() { } Pk.resetWarningCache = Rk; var kX = function () { function n(r, i, s, a, o, l) { if (l !== FX) { var u = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw u.name = "Invariant Violation", u } } n.isRequired = n; function e() { return n } var t = { array: n, bigint: n, bool: n, func: n, number: n, object: n, string: n, symbol: n, any: n, arrayOf: e, element: n, elementType: n, instanceOf: e, node: n, objectOf: e, oneOf: e, oneOfType: e, shape: e, exact: e, checkPropTypes: Pk, resetWarningCache: Rk }; return t.PropTypes = t, t }; Bk.exports = kX(); var NX = Bk.exports; const kn = By(NX), OX = () => { const n = ue.useRef(null), e = ue.useRef(null); return ue.useEffect(() => { let t = pr.context(() => { pr.from(n.current, { delay: 1.5, opacity: 0, scale: .4, duration: .5 }); const r = pr.to(e.current, { y: -20, paused: !0 }); return e.current.addEventListener("mouseenter", () => r.play()), e.current.addEventListener("mouseleave", () => r.reverse()), () => { r.kill() } }); return () => t.revert() }, []), re.jsx("div", { className: "img-con", children: re.jsx("div", { ref: n, className: "bg-img", children: re.jsxs("div", { children: [re.jsx("div", { className: "center", children: re.jsx("button", { ref: e, children: "Join The Server Now!" }) }), re.jsxs("div", { className: "ran", children: [re.jsx("span", { className: "status", children: "play.example.com" }), re.jsx("span", { className: "status", children: "1500" })] })] }) }) }) }, UX = () => re.jsx(re.Fragment, { children: re.jsxs("div", { className: "intro-con", children: [re.jsx("div", { className: "filler" }), re.jsx("div", { className: "App ", children: re.jsxs("div", { className: "intro", children: [re.jsx(PX, {}), re.jsx(OX, {})] }) })] }) }), Dk = "/Taskverse/assets/logo-44ed37e5.png"; function mM(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable })), t.push.apply(t, r) } return t } function St(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? mM(Object(t), !0).forEach(function (r) { Es(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : mM(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function q6(n) { "@babel/helpers - typeof"; return q6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, q6(n) } function GX(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } function gM(n, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r) } } function QX(n, e, t) { return e && gM(n.prototype, e), t && gM(n, t), Object.defineProperty(n, "prototype", { writable: !1 }), n } function Es(n, e, t) { return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function aS(n, e) { return zX(n) || WX(n, e) || Lk(n, e) || YX() } function I1(n) { return HX(n) || VX(n) || Lk(n) || XX() } function HX(n) { if (Array.isArray(n)) return u9(n) } function zX(n) { if (Array.isArray(n)) return n } function VX(n) { if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n) } function WX(n, e) { var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"]; if (t != null) { var r = [], i = !0, s = !1, a, o; try { for (t = t.call(n); !(i = (a = t.next()).done) && (r.push(a.value), !(e && r.length === e)); i = !0); } catch (l) { s = !0, o = l } finally { try { !i && t.return != null && t.return() } finally { if (s) throw o } } return r } } function Lk(n, e) { if (n) { if (typeof n == "string") return u9(n, e); var t = Object.prototype.toString.call(n).slice(8, -1); if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set") return Array.from(n); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return u9(n, e) } } function u9(n, e) { (e == null || e > n.length) && (e = n.length); for (var t = 0, r = new Array(e); t < e; t++)r[t] = n[t]; return r } function XX() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	} function YX() {
		throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	} var AM = function () { }, oS = {}, Fk = {}, kk = null, Nk = { mark: AM, measure: AM }; try { typeof window < "u" && (oS = window), typeof document < "u" && (Fk = document), typeof MutationObserver < "u" && (kk = MutationObserver), typeof performance < "u" && (Nk = performance) } catch { } var jX = oS.navigator || {}, vM = jX.userAgent, yM = vM === void 0 ? "" : vM, Bh = oS, ni = Fk, xM = kk, nv = Nk; Bh.document; var _f = !!ni.documentElement && !!ni.head && typeof ni.addEventListener == "function" && typeof ni.createElement == "function", Ok = ~yM.indexOf("MSIE") || ~yM.indexOf("Trident/"), rv, iv, sv, av, ov, df = "___FONT_AWESOME___", c9 = 16, Uk = "fa", Gk = "svg-inline--fa", Ep = "data-fa-i2svg", f9 = "data-fa-pseudo-element", JX = "data-fa-pseudo-element-pending", lS = "data-prefix", uS = "data-icon", _M = "fontawesome-i2svg", KX = "async", qX = ["HTML", "HEAD", "STYLE", "SCRIPT"], Qk = function () { try { return !0 } catch { return !1 } }(), ei = "classic", Ii = "sharp", cS = [ei, Ii]; function M1(n) { return new Proxy(n, { get: function (t, r) { return r in t ? t[r] : t[ei] } }) } var GA = M1((rv = {}, Es(rv, ei, { fa: "solid", fas: "solid", "fa-solid": "solid", far: "regular", "fa-regular": "regular", fal: "light", "fa-light": "light", fat: "thin", "fa-thin": "thin", fad: "duotone", "fa-duotone": "duotone", fab: "brands", "fa-brands": "brands", fak: "kit", "fa-kit": "kit" }), Es(rv, Ii, { fa: "solid", fass: "solid", "fa-solid": "solid", fasr: "regular", "fa-regular": "regular", fasl: "light", "fa-light": "light" }), rv)), QA = M1((iv = {}, Es(iv, ei, { solid: "fas", regular: "far", light: "fal", thin: "fat", duotone: "fad", brands: "fab", kit: "fak" }), Es(iv, Ii, { solid: "fass", regular: "fasr", light: "fasl" }), iv)), HA = M1((sv = {}, Es(sv, ei, { fab: "fa-brands", fad: "fa-duotone", fak: "fa-kit", fal: "fa-light", far: "fa-regular", fas: "fa-solid", fat: "fa-thin" }), Es(sv, Ii, { fass: "fa-solid", fasr: "fa-regular", fasl: "fa-light" }), sv)), ZX = M1((av = {}, Es(av, ei, { "fa-brands": "fab", "fa-duotone": "fad", "fa-kit": "fak", "fa-light": "fal", "fa-regular": "far", "fa-solid": "fas", "fa-thin": "fat" }), Es(av, Ii, { "fa-solid": "fass", "fa-regular": "fasr", "fa-light": "fasl" }), av)), $X = /fa(s|r|l|t|d|b|k|ss|sr|sl)?[\-\ ]/, Hk = "fa-layers-text", eY = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i, tY = M1((ov = {}, Es(ov, ei, { 900: "fas", 400: "far", normal: "far", 300: "fal", 100: "fat" }), Es(ov, Ii, { 900: "fass", 400: "fasr", 300: "fasl" }), ov)), zk = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], nY = zk.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), rY = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Xd = { GROUP: "duotone-group", SWAP_OPACITY: "swap-opacity", PRIMARY: "primary", SECONDARY: "secondary" }, zA = new Set; Object.keys(QA[ei]).map(zA.add.bind(zA)); Object.keys(QA[Ii]).map(zA.add.bind(zA)); var iY = [].concat(cS, I1(zA), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", Xd.GROUP, Xd.SWAP_OPACITY, Xd.PRIMARY, Xd.SECONDARY]).concat(zk.map(function (n) { return "".concat(n, "x") })).concat(nY.map(function (n) { return "w-".concat(n) })), Jg = Bh.FontAwesomeConfig || {}; function sY(n) { var e = ni.querySelector("script[" + n + "]"); if (e) return e.getAttribute(n) } function aY(n) { return n === "" ? !0 : n === "false" ? !1 : n === "true" ? !0 : n } if (ni && typeof ni.querySelector == "function") { var oY = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]]; oY.forEach(function (n) { var e = aS(n, 2), t = e[0], r = e[1], i = aY(sY(t)); i != null && (Jg[r] = i) }) } var Vk = { styleDefault: "solid", familyDefault: "classic", cssPrefix: Uk, replacementClass: Gk, autoReplaceSvg: !0, autoAddCss: !0, autoA11y: !0, searchPseudoElements: !1, observeMutations: !0, mutateApproach: "async", keepOriginalSource: !0, measurePerformance: !1, showMissingIcons: !0 }; Jg.familyPrefix && (Jg.cssPrefix = Jg.familyPrefix); var j3 = St(St({}, Vk), Jg); j3.autoReplaceSvg || (j3.observeMutations = !1); var Ft = {}; Object.keys(Vk).forEach(function (n) { Object.defineProperty(Ft, n, { enumerable: !0, set: function (t) { j3[n] = t, Kg.forEach(function (r) { return r(Ft) }) }, get: function () { return j3[n] } }) }); Object.defineProperty(Ft, "familyPrefix", { enumerable: !0, set: function (e) { j3.cssPrefix = e, Kg.forEach(function (t) { return t(Ft) }) }, get: function () { return j3.cssPrefix } }); Bh.FontAwesomeConfig = Ft; var Kg = []; function lY(n) { return Kg.push(n), function () { Kg.splice(Kg.indexOf(n), 1) } } var Of = c9, qu = { size: 16, x: 0, y: 0, rotate: 0, flipX: !1, flipY: !1 }; function uY(n) { if (!(!n || !_f)) { var e = ni.createElement("style"); e.setAttribute("type", "text/css"), e.innerHTML = n; for (var t = ni.head.childNodes, r = null, i = t.length - 1; i > -1; i--) { var s = t[i], a = (s.tagName || "").toUpperCase();["STYLE", "LINK"].indexOf(a) > -1 && (r = s) } return ni.head.insertBefore(e, r), n } } var cY = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; function VA() { for (var n = 12, e = ""; n-- > 0;)e += cY[Math.random() * 62 | 0]; return e } function gm(n) { for (var e = [], t = (n || []).length >>> 0; t--;)e[t] = n[t]; return e } function fS(n) { return n.classList ? gm(n.classList) : (n.getAttribute("class") || "").split(" ").filter(function (e) { return e }) } function Wk(n) { return "".concat(n).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function fY(n) { return Object.keys(n || {}).reduce(function (e, t) { return e + "".concat(t, '="').concat(Wk(n[t]), '" ') }, "").trim() } function Ky(n) { return Object.keys(n || {}).reduce(function (e, t) { return e + "".concat(t, ": ").concat(n[t].trim(), ";") }, "") } function hS(n) { return n.size !== qu.size || n.x !== qu.x || n.y !== qu.y || n.rotate !== qu.rotate || n.flipX || n.flipY } function hY(n) { var e = n.transform, t = n.containerWidth, r = n.iconWidth, i = { transform: "translate(".concat(t / 2, " 256)") }, s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "), a = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "), o = "rotate(".concat(e.rotate, " 0 0)"), l = { transform: "".concat(s, " ").concat(a, " ").concat(o) }, u = { transform: "translate(".concat(r / 2 * -1, " -256)") }; return { outer: i, inner: l, path: u } } function dY(n) { var e = n.transform, t = n.width, r = t === void 0 ? c9 : t, i = n.height, s = i === void 0 ? c9 : i, a = n.startCentered, o = a === void 0 ? !1 : a, l = ""; return o && Ok ? l += "translate(".concat(e.x / Of - r / 2, "em, ").concat(e.y / Of - s / 2, "em) ") : o ? l += "translate(calc(-50% + ".concat(e.x / Of, "em), calc(-50% + ").concat(e.y / Of, "em)) ") : l += "translate(".concat(e.x / Of, "em, ").concat(e.y / Of, "em) "), l += "scale(".concat(e.size / Of * (e.flipX ? -1 : 1), ", ").concat(e.size / Of * (e.flipY ? -1 : 1), ") "), l += "rotate(".concat(e.rotate, "deg) "), l } var pY = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`; function Xk() { var n = Uk, e = Gk, t = Ft.cssPrefix, r = Ft.replacementClass, i = pY; if (t !== n || r !== e) { var s = new RegExp("\\.".concat(n, "\\-"), "g"), a = new RegExp("\\--".concat(n, "\\-"), "g"), o = new RegExp("\\.".concat(e), "g"); i = i.replace(s, ".".concat(t, "-")).replace(a, "--".concat(t, "-")).replace(o, ".".concat(r)) } return i } var EM = !1; function Ax() { Ft.autoAddCss && !EM && (uY(Xk()), EM = !0) } var mY = { mixout: function () { return { dom: { css: Xk, insertCss: Ax } } }, hooks: function () { return { beforeDOMElementCreation: function () { Ax() }, beforeI2svg: function () { Ax() } } } }, pf = Bh || {}; pf[df] || (pf[df] = {}); pf[df].styles || (pf[df].styles = {}); pf[df].hooks || (pf[df].hooks = {}); pf[df].shims || (pf[df].shims = []); var fu = pf[df], Yk = [], gY = function n() { ni.removeEventListener("DOMContentLoaded", n), Z6 = 1, Yk.map(function (e) { return e() }) }, Z6 = !1; _f && (Z6 = (ni.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(ni.readyState), Z6 || ni.addEventListener("DOMContentLoaded", gY)); function AY(n) { _f && (Z6 ? setTimeout(n, 0) : Yk.push(n)) } function b1(n) { var e = n.tag, t = n.attributes, r = t === void 0 ? {} : t, i = n.children, s = i === void 0 ? [] : i; return typeof n == "string" ? Wk(n) : "<".concat(e, " ").concat(fY(r), ">").concat(s.map(b1).join(""), "</").concat(e, ">") } function CM(n, e, t) { if (n && n[e] && n[e][t]) return { prefix: e, iconName: t, icon: n[e][t] } } var vY = function (e, t) { return function (r, i, s, a) { return e.call(t, r, i, s, a) } }, vx = function (e, t, r, i) { var s = Object.keys(e), a = s.length, o = i !== void 0 ? vY(t, i) : t, l, u, c; for (r === void 0 ? (l = 1, c = e[s[0]]) : (l = 0, c = r); l < a; l++)u = s[l], c = o(c, e[u], u, e); return c }; function yY(n) { for (var e = [], t = 0, r = n.length; t < r;) { var i = n.charCodeAt(t++); if (i >= 55296 && i <= 56319 && t < r) { var s = n.charCodeAt(t++); (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), t--) } else e.push(i) } return e } function h9(n) { var e = yY(n); return e.length === 1 ? e[0].toString(16) : null } function xY(n, e) { var t = n.length, r = n.charCodeAt(e), i; return r >= 55296 && r <= 56319 && t > e + 1 && (i = n.charCodeAt(e + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r } function SM(n) { return Object.keys(n).reduce(function (e, t) { var r = n[t], i = !!r.icon; return i ? e[r.iconName] = r.icon : e[t] = r, e }, {}) } function d9(n, e) { var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = t.skipHooks, i = r === void 0 ? !1 : r, s = SM(e); typeof fu.hooks.addPack == "function" && !i ? fu.hooks.addPack(n, SM(e)) : fu.styles[n] = St(St({}, fu.styles[n] || {}), s), n === "fas" && d9("fa", e) } var lv, uv, cv, r3 = fu.styles, _Y = fu.shims, EY = (lv = {}, Es(lv, ei, Object.values(HA[ei])), Es(lv, Ii, Object.values(HA[Ii])), lv), dS = null, jk = {}, Jk = {}, Kk = {}, qk = {}, Zk = {}, CY = (uv = {}, Es(uv, ei, Object.keys(GA[ei])), Es(uv, Ii, Object.keys(GA[Ii])), uv); function SY(n) { return ~iY.indexOf(n) } function TY(n, e) { var t = e.split("-"), r = t[0], i = t.slice(1).join("-"); return r === n && i !== "" && !SY(i) ? i : null } var $k = function () { var e = function (s) { return vx(r3, function (a, o, l) { return a[l] = vx(o, s, {}), a }, {}) }; jk = e(function (i, s, a) { if (s[3] && (i[s[3]] = a), s[2]) { var o = s[2].filter(function (l) { return typeof l == "number" }); o.forEach(function (l) { i[l.toString(16)] = a }) } return i }), Jk = e(function (i, s, a) { if (i[a] = a, s[2]) { var o = s[2].filter(function (l) { return typeof l == "string" }); o.forEach(function (l) { i[l] = a }) } return i }), Zk = e(function (i, s, a) { var o = s[2]; return i[a] = a, o.forEach(function (l) { i[l] = a }), i }); var t = "far" in r3 || Ft.autoFetchSvg, r = vx(_Y, function (i, s) { var a = s[0], o = s[1], l = s[2]; return o === "far" && !t && (o = "fas"), typeof a == "string" && (i.names[a] = { prefix: o, iconName: l }), typeof a == "number" && (i.unicodes[a.toString(16)] = { prefix: o, iconName: l }), i }, { names: {}, unicodes: {} }); Kk = r.names, qk = r.unicodes, dS = qy(Ft.styleDefault, { family: Ft.familyDefault }) }; lY(function (n) { dS = qy(n.styleDefault, { family: Ft.familyDefault }) }); $k(); function pS(n, e) { return (jk[n] || {})[e] } function wY(n, e) { return (Jk[n] || {})[e] } function Yd(n, e) { return (Zk[n] || {})[e] } function eN(n) { return Kk[n] || { prefix: null, iconName: null } } function IY(n) { var e = qk[n], t = pS("fas", n); return e || (t ? { prefix: "fas", iconName: t } : null) || { prefix: null, iconName: null } } function Rh() { return dS } var mS = function () { return { prefix: null, iconName: null, rest: [] } }; function qy(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.family, r = t === void 0 ? ei : t, i = GA[r][n], s = QA[r][n] || QA[r][i], a = n in fu.styles ? n : null; return s || a || null } var TM = (cv = {}, Es(cv, ei, Object.keys(HA[ei])), Es(cv, Ii, Object.keys(HA[Ii])), cv); function Zy(n) { var e, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t.skipLookups, i = r === void 0 ? !1 : r, s = (e = {}, Es(e, ei, "".concat(Ft.cssPrefix, "-").concat(ei)), Es(e, Ii, "".concat(Ft.cssPrefix, "-").concat(Ii)), e), a = null, o = ei; (n.includes(s[ei]) || n.some(function (u) { return TM[ei].includes(u) })) && (o = ei), (n.includes(s[Ii]) || n.some(function (u) { return TM[Ii].includes(u) })) && (o = Ii); var l = n.reduce(function (u, c) { var h = TY(Ft.cssPrefix, c); if (r3[c] ? (c = EY[o].includes(c) ? ZX[o][c] : c, a = c, u.prefix = c) : CY[o].indexOf(c) > -1 ? (a = c, u.prefix = qy(c, { family: o })) : h ? u.iconName = h : c !== Ft.replacementClass && c !== s[ei] && c !== s[Ii] && u.rest.push(c), !i && u.prefix && u.iconName) { var d = a === "fa" ? eN(u.iconName) : {}, m = Yd(u.prefix, u.iconName); d.prefix && (a = null), u.iconName = d.iconName || m || u.iconName, u.prefix = d.prefix || u.prefix, u.prefix === "far" && !r3.far && r3.fas && !Ft.autoFetchSvg && (u.prefix = "fas") } return u }, mS()); return (n.includes("fa-brands") || n.includes("fab")) && (l.prefix = "fab"), (n.includes("fa-duotone") || n.includes("fad")) && (l.prefix = "fad"), !l.prefix && o === Ii && (r3.fass || Ft.autoFetchSvg) && (l.prefix = "fass", l.iconName = Yd(l.prefix, l.iconName) || l.iconName), (l.prefix === "fa" || a === "fa") && (l.prefix = Rh() || "fas"), l } var MY = function () { function n() { GX(this, n), this.definitions = {} } return QX(n, [{ key: "add", value: function () { for (var t = this, r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; var a = i.reduce(this._pullDefinitions, {}); Object.keys(a).forEach(function (o) { t.definitions[o] = St(St({}, t.definitions[o] || {}), a[o]), d9(o, a[o]); var l = HA[ei][o]; l && d9(l, a[o]), $k() }) } }, { key: "reset", value: function () { this.definitions = {} } }, { key: "_pullDefinitions", value: function (t, r) { var i = r.prefix && r.iconName && r.icon ? { 0: r } : r; return Object.keys(i).map(function (s) { var a = i[s], o = a.prefix, l = a.iconName, u = a.icon, c = u[2]; t[o] || (t[o] = {}), c.length > 0 && c.forEach(function (h) { typeof h == "string" && (t[o][h] = u) }), t[o][l] = u }), t } }]), n }(), wM = [], i3 = {}, C3 = {}, bY = Object.keys(C3); function BY(n, e) { var t = e.mixoutsTo; return wM = n, i3 = {}, Object.keys(C3).forEach(function (r) { bY.indexOf(r) === -1 && delete C3[r] }), wM.forEach(function (r) { var i = r.mixout ? r.mixout() : {}; if (Object.keys(i).forEach(function (a) { typeof i[a] == "function" && (t[a] = i[a]), q6(i[a]) === "object" && Object.keys(i[a]).forEach(function (o) { t[a] || (t[a] = {}), t[a][o] = i[a][o] }) }), r.hooks) { var s = r.hooks(); Object.keys(s).forEach(function (a) { i3[a] || (i3[a] = []), i3[a].push(s[a]) }) } r.provides && r.provides(C3) }), t } function p9(n, e) { for (var t = arguments.length, r = new Array(t > 2 ? t - 2 : 0), i = 2; i < t; i++)r[i - 2] = arguments[i]; var s = i3[n] || []; return s.forEach(function (a) { e = a.apply(null, [e].concat(r)) }), e } function Cp(n) { for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)t[r - 1] = arguments[r]; var i = i3[n] || []; i.forEach(function (s) { s.apply(null, t) }) } function mf() { var n = arguments[0], e = Array.prototype.slice.call(arguments, 1); return C3[n] ? C3[n].apply(null, e) : void 0 } function m9(n) { n.prefix === "fa" && (n.prefix = "fas"); var e = n.iconName, t = n.prefix || Rh(); if (e) return e = Yd(t, e) || e, CM(tN.definitions, t, e) || CM(fu.styles, t, e) } var tN = new MY, RY = function () { Ft.autoReplaceSvg = !1, Ft.observeMutations = !1, Cp("noAuto") }, PY = { i2svg: function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; return _f ? (Cp("beforeI2svg", e), mf("pseudoElements2svg", e), mf("i2svg", e)) : Promise.reject("Operation requires a DOM of some kind.") }, watch: function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot; Ft.autoReplaceSvg === !1 && (Ft.autoReplaceSvg = !0), Ft.observeMutations = !0, AY(function () { LY({ autoReplaceSvgRoot: t }), Cp("watch", e) }) } }, DY = { icon: function (e) { if (e === null) return null; if (q6(e) === "object" && e.prefix && e.iconName) return { prefix: e.prefix, iconName: Yd(e.prefix, e.iconName) || e.iconName }; if (Array.isArray(e) && e.length === 2) { var t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], r = qy(e[0]); return { prefix: r, iconName: Yd(r, t) || t } } if (typeof e == "string" && (e.indexOf("".concat(Ft.cssPrefix, "-")) > -1 || e.match($X))) { var i = Zy(e.split(" "), { skipLookups: !0 }); return { prefix: i.prefix || Rh(), iconName: Yd(i.prefix, i.iconName) || i.iconName } } if (typeof e == "string") { var s = Rh(); return { prefix: s, iconName: Yd(s, e) || e } } } }, Ko = { noAuto: RY, config: Ft, dom: PY, parse: DY, library: tN, findIconDefinition: m9, toHtml: b1 }, LY = function () { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.autoReplaceSvgRoot, r = t === void 0 ? ni : t; (Object.keys(fu.styles).length > 0 || Ft.autoFetchSvg) && _f && Ft.autoReplaceSvg && Ko.dom.i2svg({ node: r }) }; function $y(n, e) { return Object.defineProperty(n, "abstract", { get: e }), Object.defineProperty(n, "html", { get: function () { return n.abstract.map(function (r) { return b1(r) }) } }), Object.defineProperty(n, "node", { get: function () { if (_f) { var r = ni.createElement("div"); return r.innerHTML = n.html, r.children } } }), n } function FY(n) { var e = n.children, t = n.main, r = n.mask, i = n.attributes, s = n.styles, a = n.transform; if (hS(a) && t.found && !r.found) { var o = t.width, l = t.height, u = { x: o / l / 2, y: .5 }; i.style = Ky(St(St({}, s), {}, { "transform-origin": "".concat(u.x + a.x / 16, "em ").concat(u.y + a.y / 16, "em") })) } return [{ tag: "svg", attributes: i, children: e }] } function kY(n) { var e = n.prefix, t = n.iconName, r = n.children, i = n.attributes, s = n.symbol, a = s === !0 ? "".concat(e, "-").concat(Ft.cssPrefix, "-").concat(t) : s; return [{ tag: "svg", attributes: { style: "display: none;" }, children: [{ tag: "symbol", attributes: St(St({}, i), {}, { id: a }), children: r }] }] } function gS(n) { var e = n.icons, t = e.main, r = e.mask, i = n.prefix, s = n.iconName, a = n.transform, o = n.symbol, l = n.title, u = n.maskId, c = n.titleId, h = n.extra, d = n.watchable, m = d === void 0 ? !1 : d, g = r.found ? r : t, v = g.width, y = g.height, A = i === "fak", _ = [Ft.replacementClass, s ? "".concat(Ft.cssPrefix, "-").concat(s) : ""].filter(function (b) { return h.classes.indexOf(b) === -1 }).filter(function (b) { return b !== "" || !!b }).concat(h.classes).join(" "), x = { children: [], attributes: St(St({}, h.attributes), {}, { "data-prefix": i, "data-icon": s, class: _, role: h.attributes.role || "img", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 ".concat(v, " ").concat(y) }) }, C = A && !~h.classes.indexOf("fa-fw") ? { width: "".concat(v / y * 16 * .0625, "em") } : {}; m && (x.attributes[Ep] = ""), l && (x.children.push({ tag: "title", attributes: { id: x.attributes["aria-labelledby"] || "title-".concat(c || VA()) }, children: [l] }), delete x.attributes.title); var T = St(St({}, x), {}, { prefix: i, iconName: s, main: t, mask: r, maskId: u, transform: a, symbol: o, styles: St(St({}, C), h.styles) }), I = r.found && t.found ? mf("generateAbstractMask", T) || { children: [], attributes: {} } : mf("generateAbstractIcon", T) || { children: [], attributes: {} }, w = I.children, R = I.attributes; return T.children = w, T.attributes = R, o ? kY(T) : FY(T) } function IM(n) { var e = n.content, t = n.width, r = n.height, i = n.transform, s = n.title, a = n.extra, o = n.watchable, l = o === void 0 ? !1 : o, u = St(St(St({}, a.attributes), s ? { title: s } : {}), {}, { class: a.classes.join(" ") }); l && (u[Ep] = ""); var c = St({}, a.styles); hS(i) && (c.transform = dY({ transform: i, startCentered: !0, width: t, height: r }), c["-webkit-transform"] = c.transform); var h = Ky(c); h.length > 0 && (u.style = h); var d = []; return d.push({ tag: "span", attributes: u, children: [e] }), s && d.push({ tag: "span", attributes: { class: "sr-only" }, children: [s] }), d } function NY(n) { var e = n.content, t = n.title, r = n.extra, i = St(St(St({}, r.attributes), t ? { title: t } : {}), {}, { class: r.classes.join(" ") }), s = Ky(r.styles); s.length > 0 && (i.style = s); var a = []; return a.push({ tag: "span", attributes: i, children: [e] }), t && a.push({ tag: "span", attributes: { class: "sr-only" }, children: [t] }), a } var yx = fu.styles; function g9(n) { var e = n[0], t = n[1], r = n.slice(4), i = aS(r, 1), s = i[0], a = null; return Array.isArray(s) ? a = { tag: "g", attributes: { class: "".concat(Ft.cssPrefix, "-").concat(Xd.GROUP) }, children: [{ tag: "path", attributes: { class: "".concat(Ft.cssPrefix, "-").concat(Xd.SECONDARY), fill: "currentColor", d: s[0] } }, { tag: "path", attributes: { class: "".concat(Ft.cssPrefix, "-").concat(Xd.PRIMARY), fill: "currentColor", d: s[1] } }] } : a = { tag: "path", attributes: { fill: "currentColor", d: s } }, { found: !0, width: e, height: t, icon: a } } var OY = { found: !1, width: 512, height: 512 }; function UY(n, e) { !Qk && !Ft.showMissingIcons && n && console.error('Icon with name "'.concat(n, '" and prefix "').concat(e, '" is missing.')) } function A9(n, e) { var t = e; return e === "fa" && Ft.styleDefault !== null && (e = Rh()), new Promise(function (r, i) { if (mf("missingIconAbstract"), t === "fa") { var s = eN(n) || {}; n = s.iconName || n, e = s.prefix || e } if (n && e && yx[e] && yx[e][n]) { var a = yx[e][n]; return r(g9(a)) } UY(n, e), r(St(St({}, OY), {}, { icon: Ft.showMissingIcons && n ? mf("missingIconAbstract") || {} : {} })) }) } var MM = function () { }, v9 = Ft.measurePerformance && nv && nv.mark && nv.measure ? nv : { mark: MM, measure: MM }, wg = 'FA "6.4.2"', GY = function (e) { return v9.mark("".concat(wg, " ").concat(e, " begins")), function () { return nN(e) } }, nN = function (e) { v9.mark("".concat(wg, " ").concat(e, " ends")), v9.measure("".concat(wg, " ").concat(e), "".concat(wg, " ").concat(e, " begins"), "".concat(wg, " ").concat(e, " ends")) }, AS = { begin: GY, end: nN }, K5 = function () { }; function bM(n) { var e = n.getAttribute ? n.getAttribute(Ep) : null; return typeof e == "string" } function QY(n) { var e = n.getAttribute ? n.getAttribute(lS) : null, t = n.getAttribute ? n.getAttribute(uS) : null; return e && t } function HY(n) { return n && n.classList && n.classList.contains && n.classList.contains(Ft.replacementClass) } function zY() { if (Ft.autoReplaceSvg === !0) return q5.replace; var n = q5[Ft.autoReplaceSvg]; return n || q5.replace } function VY(n) { return ni.createElementNS("http://www.w3.org/2000/svg", n) } function WY(n) { return ni.createElement(n) } function rN(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.ceFn, r = t === void 0 ? n.tag === "svg" ? VY : WY : t; if (typeof n == "string") return ni.createTextNode(n); var i = r(n.tag); Object.keys(n.attributes || []).forEach(function (a) { i.setAttribute(a, n.attributes[a]) }); var s = n.children || []; return s.forEach(function (a) { i.appendChild(rN(a, { ceFn: r })) }), i } function XY(n) { var e = " ".concat(n.outerHTML, " "); return e = "".concat(e, "Font Awesome fontawesome.com "), e } var q5 = {
		replace: function (e) { var t = e[0]; if (t.parentNode) if (e[1].forEach(function (i) { t.parentNode.insertBefore(rN(i), t) }), t.getAttribute(Ep) === null && Ft.keepOriginalSource) { var r = ni.createComment(XY(t)); t.parentNode.replaceChild(r, t) } else t.remove() }, nest: function (e) {
			var t = e[0], r = e[1]; if (~fS(t).indexOf(Ft.replacementClass)) return q5.replace(e); var i = new RegExp("".concat(Ft.cssPrefix, "-.*")); if (delete r[0].attributes.id, r[0].attributes.class) { var s = r[0].attributes.class.split(" ").reduce(function (o, l) { return l === Ft.replacementClass || l.match(i) ? o.toSvg.push(l) : o.toNode.push(l), o }, { toNode: [], toSvg: [] }); r[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", s.toNode.join(" ")) } var a = r.map(function (o) { return b1(o) }).join(`
`); t.setAttribute(Ep, ""), t.innerHTML = a
		}
	}; function BM(n) { n() } function iN(n, e) { var t = typeof e == "function" ? e : K5; if (n.length === 0) t(); else { var r = BM; Ft.mutateApproach === KX && (r = Bh.requestAnimationFrame || BM), r(function () { var i = zY(), s = AS.begin("mutate"); n.map(i), s(), t() }) } } var vS = !1; function sN() { vS = !0 } function y9() { vS = !1 } var $6 = null; function RM(n) { if (xM && Ft.observeMutations) { var e = n.treeCallback, t = e === void 0 ? K5 : e, r = n.nodeCallback, i = r === void 0 ? K5 : r, s = n.pseudoElementsCallback, a = s === void 0 ? K5 : s, o = n.observeMutationsRoot, l = o === void 0 ? ni : o; $6 = new xM(function (u) { if (!vS) { var c = Rh(); gm(u).forEach(function (h) { if (h.type === "childList" && h.addedNodes.length > 0 && !bM(h.addedNodes[0]) && (Ft.searchPseudoElements && a(h.target), t(h.target)), h.type === "attributes" && h.target.parentNode && Ft.searchPseudoElements && a(h.target.parentNode), h.type === "attributes" && bM(h.target) && ~rY.indexOf(h.attributeName)) if (h.attributeName === "class" && QY(h.target)) { var d = Zy(fS(h.target)), m = d.prefix, g = d.iconName; h.target.setAttribute(lS, m || c), g && h.target.setAttribute(uS, g) } else HY(h.target) && i(h.target) }) } }), _f && $6.observe(l, { childList: !0, attributes: !0, characterData: !0, subtree: !0 }) } } function YY() { $6 && $6.disconnect() } function jY(n) { var e = n.getAttribute("style"), t = []; return e && (t = e.split(";").reduce(function (r, i) { var s = i.split(":"), a = s[0], o = s.slice(1); return a && o.length > 0 && (r[a] = o.join(":").trim()), r }, {})), t } function JY(n) { var e = n.getAttribute("data-prefix"), t = n.getAttribute("data-icon"), r = n.innerText !== void 0 ? n.innerText.trim() : "", i = Zy(fS(n)); return i.prefix || (i.prefix = Rh()), e && t && (i.prefix = e, i.iconName = t), i.iconName && i.prefix || (i.prefix && r.length > 0 && (i.iconName = wY(i.prefix, n.innerText) || pS(i.prefix, h9(n.innerText))), !i.iconName && Ft.autoFetchSvg && n.firstChild && n.firstChild.nodeType === Node.TEXT_NODE && (i.iconName = n.firstChild.data)), i } function KY(n) { var e = gm(n.attributes).reduce(function (i, s) { return i.name !== "class" && i.name !== "style" && (i[s.name] = s.value), i }, {}), t = n.getAttribute("title"), r = n.getAttribute("data-fa-title-id"); return Ft.autoA11y && (t ? e["aria-labelledby"] = "".concat(Ft.replacementClass, "-title-").concat(r || VA()) : (e["aria-hidden"] = "true", e.focusable = "false")), e } function qY() { return { iconName: null, title: null, titleId: null, prefix: null, transform: qu, symbol: !1, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, extra: { classes: [], styles: {}, attributes: {} } } } function PM(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { styleParser: !0 }, t = JY(n), r = t.iconName, i = t.prefix, s = t.rest, a = KY(n), o = p9("parseNodeAttributes", {}, n), l = e.styleParser ? jY(n) : []; return St({ iconName: r, title: n.getAttribute("title"), titleId: n.getAttribute("data-fa-title-id"), prefix: i, transform: qu, mask: { iconName: null, prefix: null, rest: [] }, maskId: null, symbol: !1, extra: { classes: s, styles: l, attributes: a } }, o) } var ZY = fu.styles; function aN(n) { var e = Ft.autoReplaceSvg === "nest" ? PM(n, { styleParser: !1 }) : PM(n); return ~e.extra.classes.indexOf(Hk) ? mf("generateLayersText", n, e) : mf("generateSvgReplacementMutation", n, e) } var Ph = new Set; cS.map(function (n) { Ph.add("fa-".concat(n)) }); Object.keys(GA[ei]).map(Ph.add.bind(Ph)); Object.keys(GA[Ii]).map(Ph.add.bind(Ph)); Ph = I1(Ph); function DM(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; if (!_f) return Promise.resolve(); var t = ni.documentElement.classList, r = function (h) { return t.add("".concat(_M, "-").concat(h)) }, i = function (h) { return t.remove("".concat(_M, "-").concat(h)) }, s = Ft.autoFetchSvg ? Ph : cS.map(function (c) { return "fa-".concat(c) }).concat(Object.keys(ZY)); s.includes("fa") || s.push("fa"); var a = [".".concat(Hk, ":not([").concat(Ep, "])")].concat(s.map(function (c) { return ".".concat(c, ":not([").concat(Ep, "])") })).join(", "); if (a.length === 0) return Promise.resolve(); var o = []; try { o = gm(n.querySelectorAll(a)) } catch { } if (o.length > 0) r("pending"), i("complete"); else return Promise.resolve(); var l = AS.begin("onTree"), u = o.reduce(function (c, h) { try { var d = aN(h); d && c.push(d) } catch (m) { Qk || m.name === "MissingIcon" && console.error(m) } return c }, []); return new Promise(function (c, h) { Promise.all(u).then(function (d) { iN(d, function () { r("active"), r("complete"), i("pending"), typeof e == "function" && e(), l(), c() }) }).catch(function (d) { l(), h(d) }) }) } function $Y(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null; aN(n).then(function (t) { t && iN([t], e) }) } function ej(n) { return function (e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (e || {}).icon ? e : m9(e || {}), i = t.mask; return i && (i = (i || {}).icon ? i : m9(i || {})), n(r, St(St({}, t), {}, { mask: i })) } } var tj = function (e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t.transform, i = r === void 0 ? qu : r, s = t.symbol, a = s === void 0 ? !1 : s, o = t.mask, l = o === void 0 ? null : o, u = t.maskId, c = u === void 0 ? null : u, h = t.title, d = h === void 0 ? null : h, m = t.titleId, g = m === void 0 ? null : m, v = t.classes, y = v === void 0 ? [] : v, A = t.attributes, _ = A === void 0 ? {} : A, x = t.styles, C = x === void 0 ? {} : x; if (e) { var T = e.prefix, I = e.iconName, w = e.icon; return $y(St({ type: "icon" }, e), function () { return Cp("beforeDOMElementCreation", { iconDefinition: e, params: t }), Ft.autoA11y && (d ? _["aria-labelledby"] = "".concat(Ft.replacementClass, "-title-").concat(g || VA()) : (_["aria-hidden"] = "true", _.focusable = "false")), gS({ icons: { main: g9(w), mask: l ? g9(l.icon) : { found: !1, width: null, height: null, icon: {} } }, prefix: T, iconName: I, transform: St(St({}, qu), i), symbol: a, title: d, maskId: c, titleId: g, extra: { attributes: _, styles: C, classes: y } }) }) } }, nj = { mixout: function () { return { icon: ej(tj) } }, hooks: function () { return { mutationObserverCallbacks: function (t) { return t.treeCallback = DM, t.nodeCallback = $Y, t } } }, provides: function (e) { e.i2svg = function (t) { var r = t.node, i = r === void 0 ? ni : r, s = t.callback, a = s === void 0 ? function () { } : s; return DM(i, a) }, e.generateSvgReplacementMutation = function (t, r) { var i = r.iconName, s = r.title, a = r.titleId, o = r.prefix, l = r.transform, u = r.symbol, c = r.mask, h = r.maskId, d = r.extra; return new Promise(function (m, g) { Promise.all([A9(i, o), c.iconName ? A9(c.iconName, c.prefix) : Promise.resolve({ found: !1, width: 512, height: 512, icon: {} })]).then(function (v) { var y = aS(v, 2), A = y[0], _ = y[1]; m([t, gS({ icons: { main: A, mask: _ }, prefix: o, iconName: i, transform: l, symbol: u, maskId: h, title: s, titleId: a, extra: d, watchable: !0 })]) }).catch(g) }) }, e.generateAbstractIcon = function (t) { var r = t.children, i = t.attributes, s = t.main, a = t.transform, o = t.styles, l = Ky(o); l.length > 0 && (i.style = l); var u; return hS(a) && (u = mf("generateAbstractTransformGrouping", { main: s, transform: a, containerWidth: s.width, iconWidth: s.width })), r.push(u || s.icon), { children: r, attributes: i } } } }, rj = { mixout: function () { return { layer: function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.classes, s = i === void 0 ? [] : i; return $y({ type: "layer" }, function () { Cp("beforeDOMElementCreation", { assembler: t, params: r }); var a = []; return t(function (o) { Array.isArray(o) ? o.map(function (l) { a = a.concat(l.abstract) }) : a = a.concat(o.abstract) }), [{ tag: "span", attributes: { class: ["".concat(Ft.cssPrefix, "-layers")].concat(I1(s)).join(" ") }, children: a }] }) } } } }, ij = { mixout: function () { return { counter: function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.title, s = i === void 0 ? null : i, a = r.classes, o = a === void 0 ? [] : a, l = r.attributes, u = l === void 0 ? {} : l, c = r.styles, h = c === void 0 ? {} : c; return $y({ type: "counter", content: t }, function () { return Cp("beforeDOMElementCreation", { content: t, params: r }), NY({ content: t.toString(), title: s, extra: { attributes: u, styles: h, classes: ["".concat(Ft.cssPrefix, "-layers-counter")].concat(I1(o)) } }) }) } } } }, sj = { mixout: function () { return { text: function (t) { var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = r.transform, s = i === void 0 ? qu : i, a = r.title, o = a === void 0 ? null : a, l = r.classes, u = l === void 0 ? [] : l, c = r.attributes, h = c === void 0 ? {} : c, d = r.styles, m = d === void 0 ? {} : d; return $y({ type: "text", content: t }, function () { return Cp("beforeDOMElementCreation", { content: t, params: r }), IM({ content: t, transform: St(St({}, qu), s), title: o, extra: { attributes: h, styles: m, classes: ["".concat(Ft.cssPrefix, "-layers-text")].concat(I1(u)) } }) }) } } }, provides: function (e) { e.generateLayersText = function (t, r) { var i = r.title, s = r.transform, a = r.extra, o = null, l = null; if (Ok) { var u = parseInt(getComputedStyle(t).fontSize, 10), c = t.getBoundingClientRect(); o = c.width / u, l = c.height / u } return Ft.autoA11y && !i && (a.attributes["aria-hidden"] = "true"), Promise.resolve([t, IM({ content: t.innerHTML, width: o, height: l, transform: s, title: i, extra: a, watchable: !0 })]) } } }, aj = new RegExp('"', "ug"), LM = [1105920, 1112319]; function oj(n) { var e = n.replace(aj, ""), t = xY(e, 0), r = t >= LM[0] && t <= LM[1], i = e.length === 2 ? e[0] === e[1] : !1; return { value: h9(i ? e[0] : e), isSecondary: r || i } } function FM(n, e) {
		var t = "".concat(JX).concat(e.replace(":", "-")); return new Promise(function (r, i) {
			if (n.getAttribute(t) !== null) return r(); var s = gm(n.children), a = s.filter(function (w) { return w.getAttribute(f9) === e })[0], o = Bh.getComputedStyle(n, e), l = o.getPropertyValue("font-family").match(eY), u = o.getPropertyValue("font-weight"), c = o.getPropertyValue("content"); if (a && !l) return n.removeChild(a), r(); if (l && c !== "none" && c !== "") {
				var h = o.getPropertyValue("content"), d = ~["Sharp"].indexOf(l[2]) ? Ii : ei, m = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(l[2]) ? QA[d][l[2].toLowerCase()] : tY[d][u], g = oj(h), v = g.value, y = g.isSecondary, A = l[0].startsWith("FontAwesome"), _ = pS(m, v), x = _; if (A) { var C = IY(v); C.iconName && C.prefix && (_ = C.iconName, m = C.prefix) } if (_ && !y && (!a || a.getAttribute(lS) !== m || a.getAttribute(uS) !== x)) {
					n.setAttribute(t, x), a && n.removeChild(a); var T = qY(), I = T.extra; I.attributes[f9] = e, A9(_, m).then(function (w) {
						var R = gS(St(St({}, T), {}, { icons: { main: w, mask: mS() }, prefix: m, iconName: x, extra: I, watchable: !0 })), b = ni.createElementNS("http://www.w3.org/2000/svg", "svg"); e === "::before" ? n.insertBefore(b, n.firstChild) : n.appendChild(b), b.outerHTML = R.map(function (B) { return b1(B) }).join(`
`), n.removeAttribute(t), r()
					}).catch(i)
				} else r()
			} else r()
		})
	} function lj(n) { return Promise.all([FM(n, "::before"), FM(n, "::after")]) } function uj(n) { return n.parentNode !== document.head && !~qX.indexOf(n.tagName.toUpperCase()) && !n.getAttribute(f9) && (!n.parentNode || n.parentNode.tagName !== "svg") } function kM(n) { if (_f) return new Promise(function (e, t) { var r = gm(n.querySelectorAll("*")).filter(uj).map(lj), i = AS.begin("searchPseudoElements"); sN(), Promise.all(r).then(function () { i(), y9(), e() }).catch(function () { i(), y9(), t() }) }) } var cj = { hooks: function () { return { mutationObserverCallbacks: function (t) { return t.pseudoElementsCallback = kM, t } } }, provides: function (e) { e.pseudoElements2svg = function (t) { var r = t.node, i = r === void 0 ? ni : r; Ft.searchPseudoElements && kM(i) } } }, NM = !1, fj = { mixout: function () { return { dom: { unwatch: function () { sN(), NM = !0 } } } }, hooks: function () { return { bootstrap: function () { RM(p9("mutationObserverCallbacks", {})) }, noAuto: function () { YY() }, watch: function (t) { var r = t.observeMutationsRoot; NM ? y9() : RM(p9("mutationObserverCallbacks", { observeMutationsRoot: r })) } } } }, OM = function (e) { var t = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }; return e.toLowerCase().split(" ").reduce(function (r, i) { var s = i.toLowerCase().split("-"), a = s[0], o = s.slice(1).join("-"); if (a && o === "h") return r.flipX = !0, r; if (a && o === "v") return r.flipY = !0, r; if (o = parseFloat(o), isNaN(o)) return r; switch (a) { case "grow": r.size = r.size + o; break; case "shrink": r.size = r.size - o; break; case "left": r.x = r.x - o; break; case "right": r.x = r.x + o; break; case "up": r.y = r.y - o; break; case "down": r.y = r.y + o; break; case "rotate": r.rotate = r.rotate + o; break }return r }, t) }, hj = { mixout: function () { return { parse: { transform: function (t) { return OM(t) } } } }, hooks: function () { return { parseNodeAttributes: function (t, r) { var i = r.getAttribute("data-fa-transform"); return i && (t.transform = OM(i)), t } } }, provides: function (e) { e.generateAbstractTransformGrouping = function (t) { var r = t.main, i = t.transform, s = t.containerWidth, a = t.iconWidth, o = { transform: "translate(".concat(s / 2, " 256)") }, l = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "), u = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "), c = "rotate(".concat(i.rotate, " 0 0)"), h = { transform: "".concat(l, " ").concat(u, " ").concat(c) }, d = { transform: "translate(".concat(a / 2 * -1, " -256)") }, m = { outer: o, inner: h, path: d }; return { tag: "g", attributes: St({}, m.outer), children: [{ tag: "g", attributes: St({}, m.inner), children: [{ tag: r.icon.tag, children: r.icon.children, attributes: St(St({}, r.icon.attributes), m.path) }] }] } } } }, xx = { x: 0, y: 0, width: "100%", height: "100%" }; function UM(n) { var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0; return n.attributes && (n.attributes.fill || e) && (n.attributes.fill = "black"), n } function dj(n) { return n.tag === "g" ? n.children : [n] } var pj = { hooks: function () { return { parseNodeAttributes: function (t, r) { var i = r.getAttribute("data-fa-mask"), s = i ? Zy(i.split(" ").map(function (a) { return a.trim() })) : mS(); return s.prefix || (s.prefix = Rh()), t.mask = s, t.maskId = r.getAttribute("data-fa-mask-id"), t } } }, provides: function (e) { e.generateAbstractMask = function (t) { var r = t.children, i = t.attributes, s = t.main, a = t.mask, o = t.maskId, l = t.transform, u = s.width, c = s.icon, h = a.width, d = a.icon, m = hY({ transform: l, containerWidth: h, iconWidth: u }), g = { tag: "rect", attributes: St(St({}, xx), {}, { fill: "white" }) }, v = c.children ? { children: c.children.map(UM) } : {}, y = { tag: "g", attributes: St({}, m.inner), children: [UM(St({ tag: c.tag, attributes: St(St({}, c.attributes), m.path) }, v))] }, A = { tag: "g", attributes: St({}, m.outer), children: [y] }, _ = "mask-".concat(o || VA()), x = "clip-".concat(o || VA()), C = { tag: "mask", attributes: St(St({}, xx), {}, { id: _, maskUnits: "userSpaceOnUse", maskContentUnits: "userSpaceOnUse" }), children: [g, A] }, T = { tag: "defs", children: [{ tag: "clipPath", attributes: { id: x }, children: dj(d) }, C] }; return r.push(T, { tag: "rect", attributes: St({ fill: "currentColor", "clip-path": "url(#".concat(x, ")"), mask: "url(#".concat(_, ")") }, xx) }), { children: r, attributes: i } } } }, mj = { provides: function (e) { var t = !1; Bh.matchMedia && (t = Bh.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function () { var r = [], i = { fill: "currentColor" }, s = { attributeType: "XML", repeatCount: "indefinite", dur: "2s" }; r.push({ tag: "path", attributes: St(St({}, i), {}, { d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z" }) }); var a = St(St({}, s), {}, { attributeName: "opacity" }), o = { tag: "circle", attributes: St(St({}, i), {}, { cx: "256", cy: "364", r: "28" }), children: [] }; return t || o.children.push({ tag: "animate", attributes: St(St({}, s), {}, { attributeName: "r", values: "28;14;28;28;14;28;" }) }, { tag: "animate", attributes: St(St({}, a), {}, { values: "1;0;1;1;0;1;" }) }), r.push(o), r.push({ tag: "path", attributes: St(St({}, i), {}, { opacity: "1", d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z" }), children: t ? [] : [{ tag: "animate", attributes: St(St({}, a), {}, { values: "1;0;0;0;0;1;" }) }] }), t || r.push({ tag: "path", attributes: St(St({}, i), {}, { opacity: "0", d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z" }), children: [{ tag: "animate", attributes: St(St({}, a), {}, { values: "0;0;1;1;0;0;" }) }] }), { tag: "g", attributes: { class: "missing" }, children: r } } } }, gj = { hooks: function () { return { parseNodeAttributes: function (t, r) { var i = r.getAttribute("data-fa-symbol"), s = i === null ? !1 : i === "" ? !0 : i; return t.symbol = s, t } } } }, Aj = [mY, nj, rj, ij, sj, cj, fj, hj, pj, mj, gj]; BY(Aj, { mixoutsTo: Ko }); Ko.noAuto; Ko.config; Ko.library; Ko.dom; var x9 = Ko.parse; Ko.findIconDefinition; Ko.toHtml; var vj = Ko.icon; Ko.layer; Ko.text; Ko.counter; function GM(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable })), t.push.apply(t, r) } return t } function oh(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? GM(Object(t), !0).forEach(function (r) { s3(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : GM(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } function ey(n) { "@babel/helpers - typeof"; return ey = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (e) { return typeof e } : function (e) { return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, ey(n) } function s3(n, e, t) { return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function yj(n, e) { if (n == null) return {}; var t = {}, r = Object.keys(n), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (t[i] = n[i]); return t } function xj(n, e) { if (n == null) return {}; var t = yj(n, e), r, i; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(n); for (i = 0; i < s.length; i++)r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]) } return t } function _9(n) { return _j(n) || Ej(n) || Cj(n) || Sj() } function _j(n) { if (Array.isArray(n)) return E9(n) } function Ej(n) { if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n) } function Cj(n, e) { if (n) { if (typeof n == "string") return E9(n, e); var t = Object.prototype.toString.call(n).slice(8, -1); if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set") return Array.from(n); if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return E9(n, e) } } function E9(n, e) { (e == null || e > n.length) && (e = n.length); for (var t = 0, r = new Array(e); t < e; t++)r[t] = n[t]; return r } function Sj() {
		throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
	} function Tj(n) { var e, t = n.beat, r = n.fade, i = n.beatFade, s = n.bounce, a = n.shake, o = n.flash, l = n.spin, u = n.spinPulse, c = n.spinReverse, h = n.pulse, d = n.fixedWidth, m = n.inverse, g = n.border, v = n.listItem, y = n.flip, A = n.size, _ = n.rotation, x = n.pull, C = (e = { "fa-beat": t, "fa-fade": r, "fa-beat-fade": i, "fa-bounce": s, "fa-shake": a, "fa-flash": o, "fa-spin": l, "fa-spin-reverse": c, "fa-spin-pulse": u, "fa-pulse": h, "fa-fw": d, "fa-inverse": m, "fa-border": g, "fa-li": v, "fa-flip": y === !0, "fa-flip-horizontal": y === "horizontal" || y === "both", "fa-flip-vertical": y === "vertical" || y === "both" }, s3(e, "fa-".concat(A), typeof A < "u" && A !== null), s3(e, "fa-rotate-".concat(_), typeof _ < "u" && _ !== null && _ !== 0), s3(e, "fa-pull-".concat(x), typeof x < "u" && x !== null), s3(e, "fa-swap-opacity", n.swapOpacity), e); return Object.keys(C).map(function (T) { return C[T] ? T : null }).filter(function (T) { return T }) } function wj(n) { return n = n - 0, n === n } function oN(n) { return wj(n) ? n : (n = n.replace(/[\-_\s]+(.)?/g, function (e, t) { return t ? t.toUpperCase() : "" }), n.substr(0, 1).toLowerCase() + n.substr(1)) } var Ij = ["style"]; function Mj(n) { return n.charAt(0).toUpperCase() + n.slice(1) } function bj(n) { return n.split(";").map(function (e) { return e.trim() }).filter(function (e) { return e }).reduce(function (e, t) { var r = t.indexOf(":"), i = oN(t.slice(0, r)), s = t.slice(r + 1).trim(); return i.startsWith("webkit") ? e[Mj(i)] = s : e[i] = s, e }, {}) } function lN(n, e) { var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (typeof e == "string") return e; var r = (e.children || []).map(function (l) { return lN(n, l) }), i = Object.keys(e.attributes || {}).reduce(function (l, u) { var c = e.attributes[u]; switch (u) { case "class": l.attrs.className = c, delete e.attributes.class; break; case "style": l.attrs.style = bj(c); break; default: u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? l.attrs[u.toLowerCase()] = c : l.attrs[oN(u)] = c }return l }, { attrs: {} }), s = t.style, a = s === void 0 ? {} : s, o = xj(t, Ij); return i.attrs.style = oh(oh({}, i.attrs.style), a), n.apply(void 0, [e.tag, oh(oh({}, i.attrs), o)].concat(_9(r))) } var uN = !1; try { uN = !0 } catch { } function Bj() { if (!uN && console && typeof console.error == "function") { var n; (n = console).error.apply(n, arguments) } } function QM(n) { if (n && ey(n) === "object" && n.prefix && n.iconName && n.icon) return n; if (x9.icon) return x9.icon(n); if (n === null) return null; if (n && ey(n) === "object" && n.prefix && n.iconName) return n; if (Array.isArray(n) && n.length === 2) return { prefix: n[0], iconName: n[1] }; if (typeof n == "string") return { prefix: "fas", iconName: n } } function _x(n, e) { return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? s3({}, n, e) : {} } var si = mr.forwardRef(function (n, e) { var t = n.icon, r = n.mask, i = n.symbol, s = n.className, a = n.title, o = n.titleId, l = n.maskId, u = QM(t), c = _x("classes", [].concat(_9(Tj(n)), _9(s.split(" ")))), h = _x("transform", typeof n.transform == "string" ? x9.transform(n.transform) : n.transform), d = _x("mask", QM(r)), m = vj(u, oh(oh(oh(oh({}, c), h), d), {}, { symbol: i, title: a, titleId: o, maskId: l })); if (!m) return Bj("Could not find icon", u), null; var g = m.abstract, v = { ref: e }; return Object.keys(n).forEach(function (y) { si.defaultProps.hasOwnProperty(y) || (v[y] = n[y]) }), Rj(g[0], v) }); si.displayName = "FontAwesomeIcon"; si.propTypes = { beat: kn.bool, border: kn.bool, beatFade: kn.bool, bounce: kn.bool, className: kn.string, fade: kn.bool, flash: kn.bool, mask: kn.oneOfType([kn.object, kn.array, kn.string]), maskId: kn.string, fixedWidth: kn.bool, inverse: kn.bool, flip: kn.oneOf([!0, !1, "horizontal", "vertical", "both"]), icon: kn.oneOfType([kn.object, kn.array, kn.string]), listItem: kn.bool, pull: kn.oneOf(["right", "left"]), pulse: kn.bool, rotation: kn.oneOf([0, 90, 180, 270]), shake: kn.bool, size: kn.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]), spin: kn.bool, spinPulse: kn.bool, spinReverse: kn.bool, symbol: kn.oneOfType([kn.bool, kn.string]), title: kn.string, titleId: kn.string, transform: kn.oneOfType([kn.string, kn.object]), swapOpacity: kn.bool }; si.defaultProps = { border: !1, className: "", mask: null, maskId: null, fixedWidth: !1, inverse: !1, flip: !1, icon: null, listItem: !1, pull: null, pulse: !1, rotation: null, size: null, spin: !1, spinPulse: !1, spinReverse: !1, beat: !1, fade: !1, beatFade: !1, bounce: !1, shake: !1, symbol: !1, title: "", titleId: null, transform: null, swapOpacity: !1 }; var Rj = lN.bind(null, mr.createElement), Vc = { prefix: "fas", iconName: "user", icon: [448, 512, [128100, 62144], "f007", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512H418.3c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304H178.3z"] }, dd = { prefix: "fas", iconName: "server", icon: [512, 512, [], "f233", "M64 32C28.7 32 0 60.7 0 96v64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm280 72a24 24 0 1 1 0 48 24 24 0 1 1 0-48zm48 24a24 24 0 1 1 48 0 24 24 0 1 1 -48 0zM64 288c-35.3 0-64 28.7-64 64v64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V352c0-35.3-28.7-64-64-64H64zm280 72a24 24 0 1 1 0 48 24 24 0 1 1 0-48zm56 24a24 24 0 1 1 48 0 24 24 0 1 1 -48 0z"] }, Pj = { prefix: "fas", iconName: "copyright", icon: [512, 512, [169], "f1f9", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM199.4 312.6c31.2 31.2 81.9 31.2 113.1 0c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9c-50 50-131 50-181 0s-50-131 0-181s131-50 181 0c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0c-31.2-31.2-81.9-31.2-113.1 0s-31.2 81.9 0 113.1z"] }; const Dj = () => { const n = ue.useRef(null), e = ue.useRef(null), t = ue.useRef(null), r = ue.useRef(null), i = ue.useRef(null), s = ue.useRef(null), a = ue.useRef(null), [o, l] = ue.useState(null); return ue.useEffect(() => { const u = document.querySelector("#home"), c = document.querySelector("#game"), h = document.querySelector("#about"), d = document.querySelector("#contact"), m = document.querySelector("#foot"), g = window.innerWidth; u && u.addEventListener("click", () => { let y = document.querySelector(".intro-con"); y && y.scrollIntoView({ behavior: "smooth" }), l("home") }), c && c.addEventListener("click", () => { let y = document.querySelector(".gamemods"); y && y.scrollIntoView({ behavior: "smooth" }), l("game") }), h && h.addEventListener("click", () => { let y = document.querySelector(".abts"); y && y.scrollIntoView({ behavior: "smooth" }), l("about") }), d && d.addEventListener("click", () => { let y = document.querySelector(".contact-con"); y && y.scrollIntoView({ behavior: "smooth" }), l("contact") }), m && m.addEventListener("click", () => { let y = document.querySelector(".footer-con"); y && y.scrollIntoView({ behavior: "smooth" }), l("foot") }); let v = pr.context(() => { let y = pr.timeline(); g >= 769 ? y.from(n.current, { delay: .1, opacity: 0, duration: .5 }).addLabel("second").from(e.current, { x: -5, opacity: 0, duration: .3 }, "second").from(t.current, { x: 5, opacity: 0, duration: .3 }, "second").addLabel("third").from(r.current, { x: -5, opacity: 0, duration: .3 }, "third").from(i.current, { x: 5, opacity: 0, duration: .3 }, "third").from(s.current, { delay: .3, x: 10, opacity: 0, duration: .5 }, "third").from(a.current, { delay: .3, x: -10, opacity: 0, duration: .5 }, "third") : (pr.from(s.current, { opacity: 0, scale: .5 }), pr.from(a.current, { opacity: 0, scale: .5 })) }); return () => v.revert() }, []), re.jsx("nav", { children: re.jsxs("div", { className: "App navbar", children: [re.jsx("div", { className: "nav-sub logo-con", children: re.jsx("img", { ref: s, className: "logo", src: Dk, alt: "taskify logo" }) }), re.jsx("div", { className: "nav-sub nav-item-con", children: re.jsxs("ul", { children: [re.jsx("li", { id: "home", ref: r, className: o === "home" ? "active" : "", children: "Home" }), re.jsx("li", { id: "game", ref: e, className: o === "game" ? "active" : "", children: "Game Modes" }), re.jsx("li", { id: "about", ref: n, className: o === "about" ? "active" : "", children: "About Us" }), re.jsx("li", { id: "contact", ref: t, className: o === "contact" ? "active" : "", children: "Contact" }), re.jsx("li", { id: "foot", ref: i, className: o === "foot" ? "active" : "", children: "Footer" })] }) }), re.jsx("div", { className: "nav-sub dashbord-con", children: re.jsxs("button", { ref: a, className: "pad", children: [re.jsxs("span", { className: "nn", children: [re.jsx(si, { icon: Vc }), " Dashboard"] }), re.jsx(si, { className: "usr", icon: Vc })] }) })] }) }) }; var C9 = { exports: {} }; (function (n, e) {
		(function (t, r) { r(e) })(YH, function (t) {
			function r(pe, k) { for (var te = 0; te < k.length; te++) { var z = k[te]; z.enumerable = z.enumerable || !1, z.configurable = !0, "value" in z && (z.writable = !0), Object.defineProperty(pe, z.key, z) } } function i(pe, k, te) { return k && r(pe.prototype, k), te && r(pe, te), pe }/*!
 * Observer 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var s, a, o, l, u, c, h, d, m, g, v, y, A, _ = function () { return s || typeof window < "u" && (s = window.gsap) && s.registerPlugin && s }, x = 1, C = [], T = [], I = [], w = Date.now, R = function (k, te) { return te }, b = function () { var k = m.core, te = k.bridge || {}, z = k._scrollers, W = k._proxies; z.push.apply(z, T), W.push.apply(W, I), T = z, I = W, R = function (Pe, ye) { return te[Pe](ye) } }, B = function (k, te) { return ~I.indexOf(k) && I[I.indexOf(k) + 1][te] }, F = function (k) { return !!~g.indexOf(k) }, U = function (k, te, z, W, le) { return k.addEventListener(te, z, { passive: !W, capture: !!le }) }, G = function (k, te, z, W) { return k.removeEventListener(te, z, !!W) }, Y = "scrollLeft", Z = "scrollTop", ne = function () { return v && v.isPressed || T.cache++ }, $ = function (k, te) { var z = function W(le) { if (le || le === 0) { x && (o.history.scrollRestoration = "manual"); var Pe = v && v.isPressed; le = W.v = Math.round(le) || (v && v.iOS ? 1 : 0), k(le), W.cacheID = T.cache, Pe && R("ss", le) } else (te || T.cache !== W.cacheID || R("ref")) && (W.cacheID = T.cache, W.v = k()); return W.v + W.offset }; return z.offset = 0, k && z }, L = { s: Y, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: $(function (pe) { return arguments.length ? o.scrollTo(pe, Q.sc()) : o.pageXOffset || l[Y] || u[Y] || c[Y] || 0 }) }, Q = { s: Z, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: L, sc: $(function (pe) { return arguments.length ? o.scrollTo(L.sc(), pe) : o.pageYOffset || l[Z] || u[Z] || c[Z] || 0 }) }, D = function (k, te) { return (te && te._ctx && te._ctx.selector || s.utils.toArray)(k)[0] || (typeof k == "string" && s.config().nullTargetWarn !== !1 ? console.warn("Element not found:", k) : null) }, V = function (k, te) { var z = te.s, W = te.sc; F(k) && (k = l.scrollingElement || u); var le = T.indexOf(k), Pe = W === Q.sc ? 1 : 2; !~le && (le = T.push(k) - 1), T[le + Pe] || U(k, "scroll", ne); var ye = T[le + Pe], lt = ye || (T[le + Pe] = $(B(k, z), !0) || (F(k) ? W : $(function (Jt) { return arguments.length ? k[z] = Jt : k[z] }))); return lt.target = k, ye || (lt.smooth = s.getProperty(k, "scrollBehavior") === "smooth"), lt }, J = function (k, te, z) { var W = k, le = k, Pe = w(), ye = Pe, lt = te || 50, Jt = Math.max(500, lt * 3), Pn = function (kt, cr) { var Wn = w(); cr || Wn - Pe > lt ? (le = W, W = kt, ye = Pe, Pe = Wn) : z ? W += kt : W = le + (kt - le) / (Wn - ye) * (Pe - ye) }, Dn = function () { le = W = z ? 0 : W, ye = Pe = 0 }, Tt = function (kt) { var cr = ye, Wn = le, _r = w(); return (kt || kt === 0) && kt !== W && Pn(kt), Pe === ye || _r - ye > Jt ? 0 : (W + (z ? Wn : -Wn)) / ((z ? _r : Pe) - cr) * 1e3 }; return { update: Pn, reset: Dn, getVelocity: Tt } }, Ee = function (k, te) { return te && !k._gsapAllow && k.preventDefault(), k.changedTouches ? k.changedTouches[0] : k }, xe = function (k) { var te = Math.max.apply(Math, k), z = Math.min.apply(Math, k); return Math.abs(te) >= Math.abs(z) ? te : z }, Be = function () { m = s.core.globals().ScrollTrigger, m && m.core && b() }, Fe = function (k) { return s = k || _(), s && typeof document < "u" && document.body && (o = window, l = document, u = l.documentElement, c = l.body, g = [o, l, u, c], s.utils.clamp, A = s.core.context || function () { }, d = "onpointerenter" in c ? "pointer" : "mouse", h = we.isTouch = o.matchMedia && o.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in o || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, y = we.eventTypes = ("ontouchstart" in u ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in u ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return x = 0 }, 500), Be(), a = 1), a }; L.op = Q, T.cache = 0; var we = function () { function pe(te) { this.init(te) } var k = pe.prototype; return k.init = function (z) { a || Fe(s) || console.warn("Please gsap.registerPlugin(Observer)"), m || Be(); var W = z.tolerance, le = z.dragMinimum, Pe = z.type, ye = z.target, lt = z.lineHeight, Jt = z.debounce, Pn = z.preventDefault, Dn = z.onStop, Tt = z.onStopDelay, He = z.ignore, kt = z.wheelSpeed, cr = z.event, Wn = z.onDragStart, _r = z.onDragEnd, br = z.onDrag, ki = z.onPress, dn = z.onRelease, Br = z.onRight, bn = z.onLeft, _t = z.onUp, Ni = z.onDown, Rr = z.onChangeX, Wt = z.onChangeY, Ji = z.onChange, en = z.onToggleX, xo = z.onToggleY, xi = z.onHover, Oi = z.onHoverEnd, _i = z.onMove, fr = z.ignoreCheck, Pr = z.isNormalizer, Xr = z.onGestureStart, me = z.onGestureEnd, Ei = z.onWheel, Va = z.onEnable, Hl = z.onDisable, Ms = z.onClick, Ci = z.scrollSpeed, Ui = z.capture, Er = z.allowClicks, Dr = z.lockAxis, Ki = z.onLockAxis; this.target = ye = D(ye) || u, this.vars = z, He && (He = s.utils.toArray(He)), W = W || 1e-9, le = le || 0, kt = kt || 1, Ci = Ci || 1, Pe = Pe || "wheel,touch,pointer", Jt = Jt !== !1, lt || (lt = parseFloat(o.getComputedStyle(c).lineHeight) || 22); var ya, Qs, Wa, Ht, Yr, bs, Hs, Re = this, Lr = 0, ta = 0, hr = V(ye, L), Ln = V(ye, Q), Fr = hr(), il = Ln(), zl = ~Pe.indexOf("touch") && !~Pe.indexOf("pointer") && y[0] === "pointerdown", li = F(ye), ui = ye.ownerDocument || l, yr = [0, 0, 0], xa = [0, 0, 0], Vl = 0, _o = function () { return Vl = w() }, qi = function (zt, qn) { return (Re.event = zt) && He && ~He.indexOf(zt.target) || qn && zl && zt.pointerType !== "touch" || fr && fr(zt, qn) }, jr = function () { Re._vx.reset(), Re._vy.reset(), Qs.pause(), Dn && Dn(Re) }, _a = function () { var zt = Re.deltaX = xe(yr), qn = Re.deltaY = xe(xa), Jr = Math.abs(zt) >= W, Et = Math.abs(qn) >= W; Ji && (Jr || Et) && Ji(Re, zt, qn, yr, xa), Jr && (Br && Re.deltaX > 0 && Br(Re), bn && Re.deltaX < 0 && bn(Re), Rr && Rr(Re), en && Re.deltaX < 0 != Lr < 0 && en(Re), Lr = Re.deltaX, yr[0] = yr[1] = yr[2] = 0), Et && (Ni && Re.deltaY > 0 && Ni(Re), _t && Re.deltaY < 0 && _t(Re), Wt && Wt(Re), xo && Re.deltaY < 0 != ta < 0 && xo(Re), ta = Re.deltaY, xa[0] = xa[1] = xa[2] = 0), (Ht || Wa) && (_i && _i(Re), Wa && (br(Re), Wa = !1), Ht = !1), bs && !(bs = !1) && Ki && Ki(Re), Yr && (Ei(Re), Yr = !1), ya = 0 }, Wl = function (zt, qn, Jr) { yr[Jr] += zt, xa[Jr] += qn, Re._vx.update(zt), Re._vy.update(qn), Jt ? ya || (ya = requestAnimationFrame(_a)) : _a() }, Xl = function (zt, qn) { Dr && !Hs && (Re.axis = Hs = Math.abs(zt) > Math.abs(qn) ? "x" : "y", bs = !0), Hs !== "y" && (yr[2] += zt, Re._vx.update(zt, !0)), Hs !== "x" && (xa[2] += qn, Re._vy.update(qn, !0)), Jt ? ya || (ya = requestAnimationFrame(_a)) : _a() }, Ou = function (zt) { if (!qi(zt, 1)) { zt = Ee(zt, Pn); var qn = zt.clientX, Jr = zt.clientY, Et = qn - Re.x, Fn = Jr - Re.y, qt = Re.isDragging; Re.x = qn, Re.y = Jr, (qt || Math.abs(Re.startX - qn) >= le || Math.abs(Re.startY - Jr) >= le) && (br && (Wa = !0), qt || (Re.isDragging = !0), Xl(Et, Fn), qt || Wn && Wn(Re)) } }, Yl = Re.onPress = function (un) { qi(un, 1) || un && un.button || (Re.axis = Hs = null, Qs.pause(), Re.isPressed = !0, un = Ee(un), Lr = ta = 0, Re.startX = Re.x = un.clientX, Re.startY = Re.y = un.clientY, Re._vx.reset(), Re._vy.reset(), U(Pr ? ye : ui, y[1], Ou, Pn, !0), Re.deltaX = Re.deltaY = 0, ki && ki(Re)) }, jl = Re.onRelease = function (un) { if (!qi(un, 1)) { G(Pr ? ye : ui, y[1], Ou, !0); var zt = !isNaN(Re.y - Re.startY), qn = Re.isDragging && (Math.abs(Re.x - Re.startX) > 3 || Math.abs(Re.y - Re.startY) > 3), Jr = Ee(un); !qn && zt && (Re._vx.reset(), Re._vy.reset(), Pn && Er && s.delayedCall(.08, function () { if (w() - Vl > 300 && !un.defaultPrevented) { if (un.target.click) un.target.click(); else if (ui.createEvent) { var Et = ui.createEvent("MouseEvents"); Et.initMouseEvent("click", !0, !0, o, 1, Jr.screenX, Jr.screenY, Jr.clientX, Jr.clientY, !1, !1, !1, !1, 0, null), un.target.dispatchEvent(Et) } } })), Re.isDragging = Re.isGesturing = Re.isPressed = !1, Dn && !Pr && Qs.restart(!0), _r && qn && _r(Re), dn && dn(Re, qn) } }, Gn = function (zt) { return zt.touches && zt.touches.length > 1 && (Re.isGesturing = !0) && Xr(zt, Re.isDragging) }, Uu = function () { return (Re.isGesturing = !1) || me(Re) }, Xa = function (zt) { if (!qi(zt)) { var qn = hr(), Jr = Ln(); Wl((qn - Fr) * Ci, (Jr - il) * Ci, 1), Fr = qn, il = Jr, Dn && Qs.restart(!0) } }, Ea = function (zt) { if (!qi(zt)) { zt = Ee(zt, Pn), Ei && (Yr = !0); var qn = (zt.deltaMode === 1 ? lt : zt.deltaMode === 2 ? o.innerHeight : 1) * kt; Wl(zt.deltaX * qn, zt.deltaY * qn, 0), Dn && !Pr && Qs.restart(!0) } }, zs = function (zt) { if (!qi(zt)) { var qn = zt.clientX, Jr = zt.clientY, Et = qn - Re.x, Fn = Jr - Re.y; Re.x = qn, Re.y = Jr, Ht = !0, (Et || Fn) && Xl(Et, Fn) } }, Gu = function (zt) { Re.event = zt, xi(Re) }, Jl = function (zt) { Re.event = zt, Oi(Re) }, Ya = function (zt) { return qi(zt) || Ee(zt, Pn) && Ms(Re) }; Qs = Re._dc = s.delayedCall(Tt || .25, jr).pause(), Re.deltaX = Re.deltaY = 0, Re._vx = J(0, 50, !0), Re._vy = J(0, 50, !0), Re.scrollX = hr, Re.scrollY = Ln, Re.isDragging = Re.isGesturing = Re.isPressed = !1, A(this), Re.enable = function (un) { return Re.isEnabled || (U(li ? ui : ye, "scroll", ne), Pe.indexOf("scroll") >= 0 && U(li ? ui : ye, "scroll", Xa, Pn, Ui), Pe.indexOf("wheel") >= 0 && U(ye, "wheel", Ea, Pn, Ui), (Pe.indexOf("touch") >= 0 && h || Pe.indexOf("pointer") >= 0) && (U(ye, y[0], Yl, Pn, Ui), U(ui, y[2], jl), U(ui, y[3], jl), Er && U(ye, "click", _o, !1, !0), Ms && U(ye, "click", Ya), Xr && U(ui, "gesturestart", Gn), me && U(ui, "gestureend", Uu), xi && U(ye, d + "enter", Gu), Oi && U(ye, d + "leave", Jl), _i && U(ye, d + "move", zs)), Re.isEnabled = !0, un && un.type && Yl(un), Va && Va(Re)), Re }, Re.disable = function () { Re.isEnabled && (C.filter(function (un) { return un !== Re && F(un.target) }).length || G(li ? ui : ye, "scroll", ne), Re.isPressed && (Re._vx.reset(), Re._vy.reset(), G(Pr ? ye : ui, y[1], Ou, !0)), G(li ? ui : ye, "scroll", Xa, Ui), G(ye, "wheel", Ea, Ui), G(ye, y[0], Yl, Ui), G(ui, y[2], jl), G(ui, y[3], jl), G(ye, "click", _o, !0), G(ye, "click", Ya), G(ui, "gesturestart", Gn), G(ui, "gestureend", Uu), G(ye, d + "enter", Gu), G(ye, d + "leave", Jl), G(ye, d + "move", zs), Re.isEnabled = Re.isPressed = Re.isDragging = !1, Hl && Hl(Re)) }, Re.kill = Re.revert = function () { Re.disable(); var un = C.indexOf(Re); un >= 0 && C.splice(un, 1), v === Re && (v = 0) }, C.push(Re), Pr && F(ye) && (v = Re), Re.enable(cr) }, i(pe, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), pe }(); we.version = "3.12.2", we.create = function (pe) { return new we(pe) }, we.register = Fe, we.getAll = function () { return C.slice() }, we.getById = function (pe) { return C.filter(function (k) { return k.vars.id === pe })[0] }, _() && s.registerPlugin(we);/*!
 * ScrollTrigger 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var ge, tt, je, Oe, K, de, Ce, Qe, De, ie, qe, nt, it, xt, mn, X, O, fe, Ne, Ue, We, ut, Ge, Ae, st, vt, dt, at, ee, Ie, Ke, j, Ve = 1, oe = Date.now, ze = oe(), Ye = 0, jt = 0, ln = function (k, te, z) { var W = H(k) && (k.substr(0, 6) === "clamp(" || k.indexOf("max") > -1); return z["_" + te + "Clamp"] = W, W ? k.substr(6, k.length - 7) : k }, fn = function (k, te) { return te && (!H(k) || k.substr(0, 6) !== "clamp(") ? "clamp(" + k + ")" : k }, Dt = function pe() { return jt && requestAnimationFrame(pe) }, $e = function () { return xt = 1 }, Xt = function () { return xt = 0 }, Qt = function (k) { return k }, ft = function (k) { return Math.round(k * 1e5) / 1e5 || 0 }, xn = function () { return typeof window < "u" }, Vt = function () { return ge || xn() && (ge = window.gsap) && ge.registerPlugin && ge }, Yt = function (k) { return !!~Ce.indexOf(k) }, Mr = function (k) { return (k === "Height" ? Ke : je["inner" + k]) || K["client" + k] || de["client" + k] }, sn = function (k) { return B(k, "getBoundingClientRect") || (Yt(k) ? function () { return Ql.width = je.innerWidth, Ql.height = Ke, Ql } : function () { return ir(k) }) }, vr = function (k, te, z) { var W = z.d, le = z.d2, Pe = z.a; return (Pe = B(k, "getBoundingClientRect")) ? function () { return Pe()[W] } : function () { return (te ? Mr(le) : k["client" + le]) || 0 } }, Fi = function (k, te) { return !te || ~I.indexOf(k) ? sn(k) : function () { return Ql } }, ur = function (k, te) { var z = te.s, W = te.d2, le = te.d, Pe = te.a; return Math.max(0, (z = "scroll" + W) && (Pe = B(k, z)) ? Pe() - sn(k)()[le] : Yt(k) ? (K[z] || de[z]) - Mr(W) : k[z] - k["offset" + W]) }, rr = function (k, te) { for (var z = 0; z < Ne.length; z += 3)(!te || ~te.indexOf(Ne[z + 1])) && k(Ne[z], Ne[z + 1], Ne[z + 2]) }, H = function (k) { return typeof k == "string" }, ae = function (k) { return typeof k == "function" }, ve = function (k) { return typeof k == "number" }, he = function (k) { return typeof k == "object" }, Te = function (k, te, z) { return k && k.progress(te ? 0 : 1) && z && k.pause() }, rt = function (k, te) { if (k.enabled) { var z = te(k); z && z.totalTime && (k.callbackAnimation = z) } }, ct = Math.abs, Ct = "left", Nt = "top", nn = "right", yt = "bottom", pt = "width", hn = "height", Vn = "Right", oi = "Left", Vr = "Top", gn = "Bottom", gt = "padding", an = "margin", Lt = "Width", Xi = "Height", Rn = "px", $n = function (k) { return je.getComputedStyle(k) }, go = function (k) { var te = $n(k).position; k.style.position = te === "absolute" || te === "fixed" ? te : "relative" }, Wr = function (k, te) { for (var z in te) z in k || (k[z] = te[z]); return k }, ir = function (k, te) { var z = te && $n(k)[mn] !== "matrix(1, 0, 0, 1, 0, 0)" && ge.to(k, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), W = k.getBoundingClientRect(); return z && z.progress(0).kill(), W }, $o = function (k, te) { var z = te.d2; return k["offset" + z] || k["client" + z] || 0 }, os = function (k) { var te = [], z = k.labels, W = k.duration(), le; for (le in z) te.push(z[le] / W); return te }, wf = function (k) { return function (te) { return ge.utils.snap(os(k), te) } }, Lu = function (k) { var te = ge.utils.snap(k), z = Array.isArray(k) && k.slice(0).sort(function (W, le) { return W - le }); return z ? function (W, le, Pe) { Pe === void 0 && (Pe = .001); var ye; if (!le) return te(W); if (le > 0) { for (W -= Pe, ye = 0; ye < z.length; ye++)if (z[ye] >= W) return z[ye]; return z[ye - 1] } else for (ye = z.length, W += Pe; ye--;)if (z[ye] <= W) return z[ye]; return z[0] } : function (W, le, Pe) { Pe === void 0 && (Pe = .001); var ye = te(W); return !le || Math.abs(ye - W) < Pe || ye - W < 0 == le < 0 ? ye : te(le < 0 ? W - k : W + k) } }, td = function (k) { return function (te, z) { return Lu(os(k))(te, z.direction) } }, ea = function (k, te, z, W) { return z.split(",").forEach(function (le) { return k(te, le, W) }) }, Yi = function (k, te, z, W, le) { return k.addEventListener(te, z, { passive: !W, capture: !!le }) }, ji = function (k, te, z, W) { return k.removeEventListener(te, z, !!W) }, Xp = function (k, te, z) { z = z && z.wheelHandler, z && (k(te, "wheel", z), k(te, "touchmove", z)) }, nd = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Sc = { toggleActions: "play", anticipatePin: 0 }, Fu = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Tc = function (k, te) { if (H(k)) { var z = k.indexOf("="), W = ~z ? +(k.charAt(z - 1) + 1) * parseFloat(k.substr(z + 1)) : 0; ~z && (k.indexOf("%") > z && (W *= te / 100), k = k.substr(0, z - 1)), k = W + (k in Fu ? Fu[k] * te : ~k.indexOf("%") ? parseFloat(k) * te / 100 : parseFloat(k) || 0) } return k }, Yp = function (k, te, z, W, le, Pe, ye, lt) { var Jt = le.startColor, Pn = le.endColor, Dn = le.fontSize, Tt = le.indent, He = le.fontWeight, kt = Oe.createElement("div"), cr = Yt(z) || B(z, "pinType") === "fixed", Wn = k.indexOf("scroller") !== -1, _r = cr ? de : z, br = k.indexOf("start") !== -1, ki = br ? Jt : Pn, dn = "border-color:" + ki + ";font-size:" + Dn + ";color:" + ki + ";font-weight:" + He + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return dn += "position:" + ((Wn || lt) && cr ? "fixed;" : "absolute;"), (Wn || lt || !cr) && (dn += (W === Q ? nn : yt) + ":" + (Pe + parseFloat(Tt)) + "px;"), ye && (dn += "box-sizing:border-box;text-align:left;width:" + ye.offsetWidth + "px;"), kt._isStart = br, kt.setAttribute("class", "gsap-marker-" + k + (te ? " marker-" + te : "")), kt.style.cssText = dn, kt.innerText = te || te === 0 ? k + "-" + te : k, _r.children[0] ? _r.insertBefore(kt, _r.children[0]) : _r.appendChild(kt), kt._offset = kt["offset" + W.op.d2], jp(kt, 0, W, br), kt }, jp = function (k, te, z, W) { var le = { display: "block" }, Pe = z[W ? "os2" : "p2"], ye = z[W ? "p2" : "os2"]; k._isFlipped = W, le[z.a + "Percent"] = W ? -100 : 0, le[z.a] = W ? "1px" : 0, le["border" + Pe + Lt] = 1, le["border" + ye + Lt] = 0, le[z.p] = te + "px", ge.set(k, le) }, _n = [], rd = {}, Ul, c2 = function () { return oe() - Ye > 34 && (Ul || (Ul = requestAnimationFrame(tl))) }, ku = function () { (!Ge || !Ge.isPressed || Ge.startX > de.clientWidth) && (T.cache++, Ge ? Ul || (Ul = requestAnimationFrame(tl)) : tl(), Ye || wc("scrollStart"), Ye = oe()) }, Un = function () { vt = je.innerWidth, st = je.innerHeight }, If = function () { T.cache++, !it && !ut && !Oe.fullscreenElement && !Oe.webkitFullscreenElement && (!Ae || vt !== je.innerWidth || Math.abs(je.innerHeight - st) > je.innerHeight * .25) && Qe.restart(!0) }, Gl = {}, f2 = [], h2 = function pe() { return ji($t, "scrollEnd", pe) || ws(!0) }, wc = function (k) { return Gl[k] && Gl[k].map(function (te) { return te() }) || f2 }, sr = [], Jp = function (k) { for (var te = 0; te < sr.length; te += 5)(!k || sr[te + 4] && sr[te + 4].query === k) && (sr[te].style.cssText = sr[te + 1], sr[te].getBBox && sr[te].setAttribute("transform", sr[te + 2] || ""), sr[te + 3].uncache = 1) }, Mm = function (k, te) { var z; for (X = 0; X < _n.length; X++)z = _n[X], z && (!te || z._ctx === te) && (k ? z.kill(1) : z.revert(!0, !0)); te && Jp(te), te || wc("revert") }, Kp = function (k, te) { T.cache++, (te || !Gs) && T.forEach(function (z) { return ae(z) && z.cacheID++ && (z.rec = 0) }), H(k) && (je.history.scrollRestoration = ee = k) }, Gs, el = 0, Ao, a4 = function () { if (Ao !== el) { var k = Ao = el; requestAnimationFrame(function () { return k === el && ws(!0) }) } }, d2 = function () { de.appendChild(Ie), Ke = Ie.offsetHeight || je.innerHeight, de.removeChild(Ie) }, ws = function (k, te) { if (Ye && !k) { Yi($t, "scrollEnd", h2); return } d2(), Gs = $t.isRefreshing = !0, T.forEach(function (W) { return ae(W) && ++W.cacheID && (W.rec = W()) }); var z = wc("refreshInit"); Ue && $t.sort(), te || Mm(), T.forEach(function (W) { ae(W) && (W.smooth && (W.target.style.scrollBehavior = "auto"), W(0)) }), _n.slice(0).forEach(function (W) { return W.refresh() }), _n.forEach(function (W, le) { if (W._subPinOffset && W.pin) { var Pe = W.vars.horizontal ? "offsetWidth" : "offsetHeight", ye = W.pin[Pe]; W.revert(!0, 1), W.adjustPinSpacing(W.pin[Pe] - ye), W.refresh() } }), _n.forEach(function (W) { var le = ur(W.scroller, W._dir); (W.vars.end === "max" || W._endClamp && W.end > le) && W.setPositions(W.start, Math.max(W.start + 1, le), !0) }), z.forEach(function (W) { return W && W.render && W.render(-1) }), T.forEach(function (W) { ae(W) && (W.smooth && requestAnimationFrame(function () { return W.target.style.scrollBehavior = "smooth" }), W.rec && W(W.rec)) }), Kp(ee, 1), Qe.pause(), el++, Gs = 2, tl(2), _n.forEach(function (W) { return ae(W.vars.onRefresh) && W.vars.onRefresh(W) }), Gs = $t.isRefreshing = !1, wc("refresh") }, vo = 0, Ic = 1, Mc, tl = function (k) { if (!Gs || k === 2) { $t.isUpdating = !0, Mc && Mc.update(0); var te = _n.length, z = oe(), W = z - ze >= 50, le = te && _n[0].scroll(); if (Ic = vo > le ? -1 : 1, Gs || (vo = le), W && (Ye && !xt && z - Ye > 200 && (Ye = 0, wc("scrollEnd")), qe = ze, ze = z), Ic < 0) { for (X = te; X-- > 0;)_n[X] && _n[X].update(0, W); Ic = 1 } else for (X = 0; X < te; X++)_n[X] && _n[X].update(0, W); $t.isUpdating = !1 } Ul = 0 }, bm = [Ct, Nt, yt, nn, an + gn, an + Vn, an + Vr, an + oi, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], va = bm.concat([pt, hn, "boxSizing", "max" + Lt, "max" + Xi, "position", an, gt, gt + Vr, gt + Vn, gt + gn, gt + oi]), o4 = function (k, te, z) { Is(z); var W = k._gsap; if (W.spacerIsNative) Is(W.spacerState); else if (k._gsap.swappedIn) { var le = te.parentNode; le && (le.insertBefore(k, te), le.removeChild(te)) } k._gsap.swappedIn = !1 }, Mf = function (k, te, z, W) { if (!k._gsap.swappedIn) { for (var le = bm.length, Pe = te.style, ye = k.style, lt; le--;)lt = bm[le], Pe[lt] = z[lt]; Pe.position = z.position === "absolute" ? "absolute" : "relative", z.display === "inline" && (Pe.display = "inline-block"), ye[yt] = ye[nn] = "auto", Pe.flexBasis = z.flexBasis || "auto", Pe.overflow = "visible", Pe.boxSizing = "border-box", Pe[pt] = $o(k, L) + Rn, Pe[hn] = $o(k, Q) + Rn, Pe[gt] = ye[an] = ye[Nt] = ye[Ct] = "0", Is(W), ye[pt] = ye["max" + Lt] = z[pt], ye[hn] = ye["max" + Xi] = z[hn], ye[gt] = z[gt], k.parentNode !== te && (k.parentNode.insertBefore(te, k), te.appendChild(k)), k._gsap.swappedIn = !0 } }, l4 = /([A-Z])/g, Is = function (k) { if (k) { var te = k.t.style, z = k.length, W = 0, le, Pe; for ((k.t._gsap || ge.core.getCache(k.t)).uncache = 1; W < z; W += 2)Pe = k[W + 1], le = k[W], Pe ? te[le] = Pe : te[le] && te.removeProperty(le.replace(l4, "-$1").toLowerCase()) } }, bc = function (k) { for (var te = va.length, z = k.style, W = [], le = 0; le < te; le++)W.push(va[le], z[va[le]]); return W.t = k, W }, qp = function (k, te, z) { for (var W = [], le = k.length, Pe = z ? 8 : 0, ye; Pe < le; Pe += 2)ye = k[Pe], W.push(ye, ye in te ? te[ye] : k[Pe + 1]); return W.t = k.t, W }, Ql = { left: 0, top: 0 }, Zp = function (k, te, z, W, le, Pe, ye, lt, Jt, Pn, Dn, Tt, He, kt) { ae(k) && (k = k(lt)), H(k) && k.substr(0, 3) === "max" && (k = Tt + (k.charAt(4) === "=" ? Tc("0" + k.substr(3), z) : 0)); var cr = He ? He.time() : 0, Wn, _r, br; if (He && He.seek(0), isNaN(k) || (k = +k), ve(k)) He && (k = ge.utils.mapRange(He.scrollTrigger.start, He.scrollTrigger.end, 0, Tt, k)), ye && jp(ye, z, W, !0); else { ae(te) && (te = te(lt)); var ki = (k || "0").split(" "), dn, Br, bn, _t; br = D(te, lt) || de, dn = ir(br) || {}, (!dn || !dn.left && !dn.top) && $n(br).display === "none" && (_t = br.style.display, br.style.display = "block", dn = ir(br), _t ? br.style.display = _t : br.style.removeProperty("display")), Br = Tc(ki[0], dn[W.d]), bn = Tc(ki[1] || "0", z), k = dn[W.p] - Jt[W.p] - Pn + Br + le - bn, ye && jp(ye, bn, W, z - bn < 20 || ye._isStart && bn > 20), z -= z - bn } if (kt && (lt[kt] = k || -.001, k < 0 && (k = 0)), Pe) { var Ni = k + z, Rr = Pe._isStart; Wn = "scroll" + W.d2, jp(Pe, Ni, W, Rr && Ni > 20 || !Rr && (Dn ? Math.max(de[Wn], K[Wn]) : Pe.parentNode[Wn]) <= Ni + 1), Dn && (Jt = ir(ye), Dn && (Pe.style[W.op.p] = Jt[W.op.p] - W.op.m - Pe._offset + Rn)) } return He && br && (Wn = ir(br), He.seek(Tt), _r = ir(br), He._caScrollDist = Wn[W.p] - _r[W.p], k = k / He._caScrollDist * Tt), He && He.seek(cr), He ? k : Math.round(k) }, Bm = /(webkit|moz|length|cssText|inset)/i, Rm = function (k, te, z, W) { if (k.parentNode !== te) { var le = k.style, Pe, ye; if (te === de) { k._stOrig = le.cssText, ye = $n(k); for (Pe in ye) !+Pe && !Bm.test(Pe) && ye[Pe] && typeof le[Pe] == "string" && Pe !== "0" && (le[Pe] = ye[Pe]); le.top = z, le.left = W } else le.cssText = k._stOrig; ge.core.getCache(k).uncache = 1, te.appendChild(k) } }, $p = function (k, te, z) { var W = te, le = W; return function (Pe) { var ye = Math.round(k()); return ye !== W && ye !== le && Math.abs(ye - W) > 3 && Math.abs(ye - le) > 3 && (Pe = ye, z && z()), le = W, W = Pe, Pe } }, bf = function (k, te, z) { var W = {}; W[te.p] = "+=" + z, ge.set(k, W) }, Bc = function (k, te) { var z = V(k, te), W = "_scroll" + te.p2, le = function Pe(ye, lt, Jt, Pn, Dn) { var Tt = Pe.tween, He = lt.onComplete, kt = {}; Jt = Jt || z(); var cr = $p(z, Jt, function () { Tt.kill(), Pe.tween = 0 }); return Dn = Pn && Dn || 0, Pn = Pn || ye - Jt, Tt && Tt.kill(), lt[W] = ye, lt.modifiers = kt, kt[W] = function () { return cr(Jt + Pn * Tt.ratio + Dn * Tt.ratio * Tt.ratio) }, lt.onUpdate = function () { T.cache++, tl() }, lt.onComplete = function () { Pe.tween = 0, He && He.call(Tt) }, Tt = Pe.tween = ge.to(k, lt), Tt }; return k[W] = z, z.wheelHandler = function () { return le.tween && le.tween.kill() && (le.tween = 0) }, Yi(k, "wheel", z.wheelHandler), $t.isTouch && Yi(k, "touchmove", z.wheelHandler), le }, $t = function () { function pe(te, z) { tt || pe.register(ge) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), at(this), this.init(te, z) } var k = pe.prototype; return k.init = function (z, W) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !jt) { this.update = this.refresh = this.kill = Qt; return } z = Wr(H(z) || ve(z) || z.nodeType ? { trigger: z } : z, Sc); var le = z, Pe = le.onUpdate, ye = le.toggleClass, lt = le.id, Jt = le.onToggle, Pn = le.onRefresh, Dn = le.scrub, Tt = le.trigger, He = le.pin, kt = le.pinSpacing, cr = le.invalidateOnRefresh, Wn = le.anticipatePin, _r = le.onScrubComplete, br = le.onSnapComplete, ki = le.once, dn = le.snap, Br = le.pinReparent, bn = le.pinSpacer, _t = le.containerAnimation, Ni = le.fastScrollEnd, Rr = le.preventOverlaps, Wt = z.horizontal || z.containerAnimation && z.horizontal !== !1 ? L : Q, Ji = !Dn && Dn !== 0, en = D(z.scroller || je), xo = ge.core.getCache(en), xi = Yt(en), Oi = ("pinType" in z ? z.pinType : B(en, "pinType") || xi && "fixed") === "fixed", _i = [z.onEnter, z.onLeave, z.onEnterBack, z.onLeaveBack], fr = Ji && z.toggleActions.split(" "), Pr = "markers" in z ? z.markers : Sc.markers, Xr = xi ? 0 : parseFloat($n(en)["border" + Wt.p2 + Lt]) || 0, me = this, Ei = z.onRefreshInit && function () { return z.onRefreshInit(me) }, Va = vr(en, xi, Wt), Hl = Fi(en, xi), Ms = 0, Ci = 0, Ui = 0, Er = V(en, Wt), Dr, Ki, ya, Qs, Wa, Ht, Yr, bs, Hs, Re, Lr, ta, hr, Ln, Fr, il, zl, li, ui, yr, xa, Vl, _o, qi, jr, _a, Wl, Xl, Ou, Yl, jl, Gn, Uu, Xa, Ea, zs, Gu, Jl, Ya; if (me._startClamp = me._endClamp = !1, me._dir = Wt, Wn *= 45, me.scroller = en, me.scroll = _t ? _t.time.bind(_t) : Er, Qs = Er(), me.vars = z, W = W || z.animation, "refreshPriority" in z && (Ue = 1, z.refreshPriority === -9999 && (Mc = me)), xo.tweenScroll = xo.tweenScroll || { top: Bc(en, Q), left: Bc(en, L) }, me.tweenTo = Dr = xo.tweenScroll[Wt.p], me.scrubDuration = function (Et) { Uu = ve(Et) && Et, Uu ? Gn ? Gn.duration(Et) : Gn = ge.to(W, { ease: "expo", totalProgress: "+=0", duration: Uu, paused: !0, onComplete: function () { return _r && _r(me) } }) : (Gn && Gn.progress(1).kill(), Gn = 0) }, W && (W.vars.lazy = !1, W._initted && !me.isReverted || W.vars.immediateRender !== !1 && z.immediateRender !== !1 && W.duration() && W.render(0, !0, !0), me.animation = W.pause(), W.scrollTrigger = me, me.scrubDuration(Dn), Yl = 0, lt || (lt = W.vars.id)), dn && ((!he(dn) || dn.push) && (dn = { snapTo: dn }), "scrollBehavior" in de.style && ge.set(xi ? [de, K] : en, { scrollBehavior: "auto" }), T.forEach(function (Et) { return ae(Et) && Et.target === (xi ? Oe.scrollingElement || K : en) && (Et.smooth = !1) }), ya = ae(dn.snapTo) ? dn.snapTo : dn.snapTo === "labels" ? wf(W) : dn.snapTo === "labelsDirectional" ? td(W) : dn.directional !== !1 ? function (Et, Fn) { return Lu(dn.snapTo)(Et, oe() - Ci < 500 ? 0 : Fn.direction) } : ge.utils.snap(dn.snapTo), Xa = dn.duration || { min: .1, max: 2 }, Xa = he(Xa) ? ie(Xa.min, Xa.max) : ie(Xa, Xa), Ea = ge.delayedCall(dn.delay || Uu / 2 || .1, function () { var Et = Er(), Fn = oe() - Ci < 500, qt = Dr.tween; if ((Fn || Math.abs(me.getVelocity()) < 10) && !qt && !xt && Ms !== Et) { var Tn = (Et - Ht) / Ln, Gi = W && !Ji ? W.totalProgress() : Tn, Xn = Fn ? 0 : (Gi - jl) / (oe() - qe) * 1e3 || 0, ii = ge.utils.clamp(-Tn, 1 - Tn, ct(Xn / 2) * Xn / .185), Vs = Tn + (dn.inertia === !1 ? 0 : ii), ls = ie(0, 1, ya(Vs, me)), kr = Math.round(Ht + ls * Ln), dr = dn, ja = dr.onStart, Nr = dr.onInterrupt, Bs = dr.onComplete; if (Et <= Yr && Et >= Ht && kr !== Et) { if (qt && !qt._initted && qt.data <= ct(kr - Et)) return; dn.inertia === !1 && (ii = ls - Tn), Dr(kr, { duration: Xa(ct(Math.max(ct(Vs - Gi), ct(ls - Gi)) * .185 / Xn / .05 || 0)), ease: dn.ease || "power3", data: ct(kr - Et), onInterrupt: function () { return Ea.restart(!0) && Nr && Nr(me) }, onComplete: function () { me.update(), Ms = Er(), Yl = jl = W && !Ji ? W.totalProgress() : me.progress, br && br(me), Bs && Bs(me) } }, Et, ii * Ln, kr - Et - ii * Ln), ja && ja(me, Dr.tween) } } else me.isActive && Ms !== Et && Ea.restart(!0) }).pause()), lt && (rd[lt] = me), Tt = me.trigger = D(Tt || He !== !0 && He), Ya = Tt && Tt._gsap && Tt._gsap.stRevert, Ya && (Ya = Ya(me)), He = He === !0 ? Tt : D(He), H(ye) && (ye = { targets: Tt, className: ye }), He && (kt === !1 || kt === an || (kt = !kt && He.parentNode && He.parentNode.style && $n(He.parentNode).display === "flex" ? !1 : gt), me.pin = He, Ki = ge.core.getCache(He), Ki.spacer ? Fr = Ki.pinState : (bn && (bn = D(bn), bn && !bn.nodeType && (bn = bn.current || bn.nativeElement), Ki.spacerIsNative = !!bn, bn && (Ki.spacerState = bc(bn))), Ki.spacer = li = bn || Oe.createElement("div"), li.classList.add("pin-spacer"), lt && li.classList.add("pin-spacer-" + lt), Ki.pinState = Fr = bc(He)), z.force3D !== !1 && ge.set(He, { force3D: !0 }), me.spacer = li = Ki.spacer, Ou = $n(He), qi = Ou[kt + Wt.os2], yr = ge.getProperty(He), xa = ge.quickSetter(He, Wt.a, Rn), Mf(He, li, Ou), zl = bc(He)), Pr) { ta = he(Pr) ? Wr(Pr, nd) : nd, Re = Yp("scroller-start", lt, en, Wt, ta, 0), Lr = Yp("scroller-end", lt, en, Wt, ta, 0, Re), ui = Re["offset" + Wt.op.d2]; var un = D(B(en, "content") || en); bs = this.markerStart = Yp("start", lt, un, Wt, ta, ui, 0, _t), Hs = this.markerEnd = Yp("end", lt, un, Wt, ta, ui, 0, _t), _t && (Jl = ge.quickSetter([bs, Hs], Wt.a, Rn)), !Oi && !(I.length && B(en, "fixedMarkers") === !0) && (go(xi ? de : en), ge.set([Re, Lr], { force3D: !0 }), _a = ge.quickSetter(Re, Wt.a, Rn), Xl = ge.quickSetter(Lr, Wt.a, Rn)) } if (_t) { var zt = _t.vars.onUpdate, qn = _t.vars.onUpdateParams; _t.eventCallback("onUpdate", function () { me.update(0, 0, 1), zt && zt.apply(_t, qn || []) }) } if (me.previous = function () { return _n[_n.indexOf(me) - 1] }, me.next = function () { return _n[_n.indexOf(me) + 1] }, me.revert = function (Et, Fn) { if (!Fn) return me.kill(!0); var qt = Et !== !1 || !me.enabled, Tn = it; qt !== me.isReverted && (qt && (zs = Math.max(Er(), me.scroll.rec || 0), Ui = me.progress, Gu = W && W.progress()), bs && [bs, Hs, Re, Lr].forEach(function (Gi) { return Gi.style.display = qt ? "none" : "block" }), qt && (it = me, me.update(qt)), He && (!Br || !me.isActive) && (qt ? o4(He, li, Fr) : Mf(He, li, $n(He), jr)), qt || me.update(qt), it = Tn, me.isReverted = qt) }, me.refresh = function (Et, Fn, qt, Tn) { if (!((it || !me.enabled) && !Fn)) { if (He && Et && Ye) { Yi(pe, "scrollEnd", h2); return } !Gs && Ei && Ei(me), it = me, Dr.tween && !qt && (Dr.tween.kill(), Dr.tween = 0), Gn && Gn.pause(), cr && W && W.revert({ kill: !1 }).invalidate(), me.isReverted || me.revert(!0, !0), me._subPinOffset = !1; var Gi = Va(), Xn = Hl(), ii = _t ? _t.duration() : ur(en, Wt), Vs = Ln <= .01, ls = 0, kr = Tn || 0, dr = he(qt) ? qt.end : z.end, ja = z.endTrigger || Tt, Nr = he(qt) ? qt.start : z.start || (z.start === 0 || !Tt ? 0 : He ? "0 0" : "0 100%"), Bs = me.pinnedContainer = z.pinnedContainer && D(z.pinnedContainer, me), sl = Tt && Math.max(0, _n.indexOf(me)) || 0, Ca = sl, us, Zi, Kl, t0, cs, Si, Eo, n0, Dm, na, Co, ql, Qu; for (Pr && he(qt) && (ql = ge.getProperty(Re, Wt.p), Qu = ge.getProperty(Lr, Wt.p)); Ca--;)Si = _n[Ca], Si.end || Si.refresh(0, 1) || (it = me), Eo = Si.pin, Eo && (Eo === Tt || Eo === He || Eo === Bs) && !Si.isReverted && (na || (na = []), na.unshift(Si), Si.revert(!0, !0)), Si !== _n[Ca] && (sl--, Ca--); for (ae(Nr) && (Nr = Nr(me)), Nr = ln(Nr, "start", me), Ht = Zp(Nr, Tt, Gi, Wt, Er(), bs, Re, me, Xn, Xr, Oi, ii, _t, me._startClamp && "_startClamp") || (He ? -.001 : 0), ae(dr) && (dr = dr(me)), H(dr) && !dr.indexOf("+=") && (~dr.indexOf(" ") ? dr = (H(Nr) ? Nr.split(" ")[0] : "") + dr : (ls = Tc(dr.substr(2), Gi), dr = H(Nr) ? Nr : (_t ? ge.utils.mapRange(0, _t.duration(), _t.scrollTrigger.start, _t.scrollTrigger.end, Ht) : Ht) + ls, ja = Tt)), dr = ln(dr, "end", me), Yr = Math.max(Ht, Zp(dr || (ja ? "100% 0" : ii), ja, Gi, Wt, Er() + ls, Hs, Lr, me, Xn, Xr, Oi, ii, _t, me._endClamp && "_endClamp")) || -.001, ls = 0, Ca = sl; Ca--;)Si = _n[Ca], Eo = Si.pin, Eo && Si.start - Si._pinPush <= Ht && !_t && Si.end > 0 && (us = Si.end - (me._startClamp ? Math.max(0, Si.start) : Si.start), (Eo === Tt && Si.start - Si._pinPush < Ht || Eo === Bs) && isNaN(Nr) && (ls += us * (1 - Si.progress)), Eo === He && (kr += us)); if (Ht += ls, Yr += ls, me._startClamp && (me._startClamp += ls), me._endClamp && !Gs && (me._endClamp = Yr || -.001, Yr = Math.min(Yr, ur(en, Wt))), Ln = Yr - Ht || (Ht -= .01) && .001, Vs && (Ui = ge.utils.clamp(0, 1, ge.utils.normalize(Ht, Yr, zs))), me._pinPush = kr, bs && ls && (us = {}, us[Wt.a] = "+=" + ls, Bs && (us[Wt.p] = "-=" + Er()), ge.set([bs, Hs], us)), He) us = $n(He), t0 = Wt === Q, Kl = Er(), Vl = parseFloat(yr(Wt.a)) + kr, !ii && Yr > 1 && (Co = (xi ? Oe.scrollingElement || K : en).style, Co = { style: Co, value: Co["overflow" + Wt.a.toUpperCase()] }, xi && $n(de)["overflow" + Wt.a.toUpperCase()] !== "scroll" && (Co.style["overflow" + Wt.a.toUpperCase()] = "scroll")), Mf(He, li, us), zl = bc(He), Zi = ir(He, !0), n0 = Oi && V(en, t0 ? L : Q)(), kt && (jr = [kt + Wt.os2, Ln + kr + Rn], jr.t = li, Ca = kt === gt ? $o(He, Wt) + Ln + kr : 0, Ca && jr.push(Wt.d, Ca + Rn), Is(jr), Bs && _n.forEach(function (Hu) { Hu.pin === Bs && Hu.vars.pinSpacing !== !1 && (Hu._subPinOffset = !0) }), Oi && Er(zs)), Oi && (cs = { top: Zi.top + (t0 ? Kl - Ht : n0) + Rn, left: Zi.left + (t0 ? n0 : Kl - Ht) + Rn, boxSizing: "border-box", position: "fixed" }, cs[pt] = cs["max" + Lt] = Math.ceil(Zi.width) + Rn, cs[hn] = cs["max" + Xi] = Math.ceil(Zi.height) + Rn, cs[an] = cs[an + Vr] = cs[an + Vn] = cs[an + gn] = cs[an + oi] = "0", cs[gt] = us[gt], cs[gt + Vr] = us[gt + Vr], cs[gt + Vn] = us[gt + Vn], cs[gt + gn] = us[gt + gn], cs[gt + oi] = us[gt + oi], il = qp(Fr, cs, Br), Gs && Er(0)), W ? (Dm = W._initted, We(1), W.render(W.duration(), !0, !0), _o = yr(Wt.a) - Vl + Ln + kr, Wl = Math.abs(Ln - _o) > 1, Oi && Wl && il.splice(il.length - 2, 2), W.render(0, !0, !0), Dm || W.invalidate(!0), W.parent || W.totalTime(W.totalTime()), We(0)) : _o = Ln, Co && (Co.value ? Co.style["overflow" + Wt.a.toUpperCase()] = Co.value : Co.style.removeProperty("overflow-" + Wt.a)); else if (Tt && Er() && !_t) for (Zi = Tt.parentNode; Zi && Zi !== de;)Zi._pinOffset && (Ht -= Zi._pinOffset, Yr -= Zi._pinOffset), Zi = Zi.parentNode; na && na.forEach(function (Hu) { return Hu.revert(!1, !0) }), me.start = Ht, me.end = Yr, Qs = Wa = Gs ? zs : Er(), !_t && !Gs && (Qs < zs && Er(zs), me.scroll.rec = 0), me.revert(!1, !0), Ci = oe(), Ea && (Ms = -1, Ea.restart(!0)), it = 0, W && Ji && (W._initted || Gu) && W.progress() !== Gu && W.progress(Gu || 0, !0).render(W.time(), !0, !0), (Vs || Ui !== me.progress || _t) && (W && !Ji && W.totalProgress(_t && Ht < -.001 && !Ui ? ge.utils.normalize(Ht, Yr, 0) : Ui, !0), me.progress = Vs || (Qs - Ht) / Ln === Ui ? 0 : Ui), He && kt && (li._pinOffset = Math.round(me.progress * _o)), Gn && Gn.invalidate(), isNaN(ql) || (ql -= ge.getProperty(Re, Wt.p), Qu -= ge.getProperty(Lr, Wt.p), bf(Re, Wt, ql), bf(bs, Wt, ql - (Tn || 0)), bf(Lr, Wt, Qu), bf(Hs, Wt, Qu - (Tn || 0))), Vs && !Gs && me.update(), Pn && !Gs && !hr && (hr = !0, Pn(me), hr = !1) } }, me.getVelocity = function () { return (Er() - Wa) / (oe() - qe) * 1e3 || 0 }, me.endAnimation = function () { Te(me.callbackAnimation), W && (Gn ? Gn.progress(1) : W.paused() ? Ji || Te(W, me.direction < 0, 1) : Te(W, W.reversed())) }, me.labelToScroll = function (Et) { return W && W.labels && (Ht || me.refresh() || Ht) + W.labels[Et] / W.duration() * Ln || 0 }, me.getTrailing = function (Et) { var Fn = _n.indexOf(me), qt = me.direction > 0 ? _n.slice(0, Fn).reverse() : _n.slice(Fn + 1); return (H(Et) ? qt.filter(function (Tn) { return Tn.vars.preventOverlaps === Et }) : qt).filter(function (Tn) { return me.direction > 0 ? Tn.end <= Ht : Tn.start >= Yr }) }, me.update = function (Et, Fn, qt) { if (!(_t && !qt && !Et)) { var Tn = Gs === !0 ? zs : me.scroll(), Gi = Et ? 0 : (Tn - Ht) / Ln, Xn = Gi < 0 ? 0 : Gi > 1 ? 1 : Gi || 0, ii = me.progress, Vs, ls, kr, dr, ja, Nr, Bs, sl; if (Fn && (Wa = Qs, Qs = _t ? Er() : Tn, dn && (jl = Yl, Yl = W && !Ji ? W.totalProgress() : Xn)), Wn && !Xn && He && !it && !Ve && Ye && Ht < Tn + (Tn - Wa) / (oe() - qe) * Wn && (Xn = 1e-4), Xn !== ii && me.enabled) { if (Vs = me.isActive = !!Xn && Xn < 1, ls = !!ii && ii < 1, Nr = Vs !== ls, ja = Nr || !!Xn != !!ii, me.direction = Xn > ii ? 1 : -1, me.progress = Xn, ja && !it && (kr = Xn && !ii ? 0 : Xn === 1 ? 1 : ii === 1 ? 2 : 3, Ji && (dr = !Nr && fr[kr + 1] !== "none" && fr[kr + 1] || fr[kr], sl = W && (dr === "complete" || dr === "reset" || dr in W))), Rr && (Nr || sl) && (sl || Dn || !W) && (ae(Rr) ? Rr(me) : me.getTrailing(Rr).forEach(function (Kl) { return Kl.endAnimation() })), Ji || (Gn && !it && !Ve ? (Gn._dp._time - Gn._start !== Gn._time && Gn.render(Gn._dp._time - Gn._start), Gn.resetTo ? Gn.resetTo("totalProgress", Xn, W._tTime / W._tDur) : (Gn.vars.totalProgress = Xn, Gn.invalidate().restart())) : W && W.totalProgress(Xn, !!(it && (Ci || Et)))), He) { if (Et && kt && (li.style[kt + Wt.os2] = qi), !Oi) xa(ft(Vl + _o * Xn)); else if (ja) { if (Bs = !Et && Xn > ii && Yr + 1 > Tn && Tn + 1 >= ur(en, Wt), Br) if (!Et && (Vs || Bs)) { var Ca = ir(He, !0), us = Tn - Ht; Rm(He, de, Ca.top + (Wt === Q ? us : 0) + Rn, Ca.left + (Wt === Q ? 0 : us) + Rn) } else Rm(He, li); Is(Vs || Bs ? il : zl), Wl && Xn < 1 && Vs || xa(Vl + (Xn === 1 && !Bs ? _o : 0)) } } dn && !Dr.tween && !it && !Ve && Ea.restart(!0), ye && (Nr || ki && Xn && (Xn < 1 || !j)) && De(ye.targets).forEach(function (Kl) { return Kl.classList[Vs || ki ? "add" : "remove"](ye.className) }), Pe && !Ji && !Et && Pe(me), ja && !it ? (Ji && (sl && (dr === "complete" ? W.pause().totalProgress(1) : dr === "reset" ? W.restart(!0).pause() : dr === "restart" ? W.restart(!0) : W[dr]()), Pe && Pe(me)), (Nr || !j) && (Jt && Nr && rt(me, Jt), _i[kr] && rt(me, _i[kr]), ki && (Xn === 1 ? me.kill(!1, 1) : _i[kr] = 0), Nr || (kr = Xn === 1 ? 1 : 3, _i[kr] && rt(me, _i[kr]))), Ni && !Vs && Math.abs(me.getVelocity()) > (ve(Ni) ? Ni : 2500) && (Te(me.callbackAnimation), Gn ? Gn.progress(1) : Te(W, dr === "reverse" ? 1 : !Xn, 1))) : Ji && Pe && !it && Pe(me) } if (Xl) { var Zi = _t ? Tn / _t.duration() * (_t._caScrollDist || 0) : Tn; _a(Zi + (Re._isFlipped ? 1 : 0)), Xl(Zi) } Jl && Jl(-Tn / _t.duration() * (_t._caScrollDist || 0)) } }, me.enable = function (Et, Fn) { me.enabled || (me.enabled = !0, Yi(en, "resize", If), xi || Yi(en, "scroll", ku), Ei && Yi(pe, "refreshInit", Ei), Et !== !1 && (me.progress = Ui = 0, Qs = Wa = Ms = Er()), Fn !== !1 && me.refresh()) }, me.getTween = function (Et) { return Et && Dr ? Dr.tween : Gn }, me.setPositions = function (Et, Fn, qt, Tn) { if (_t) { var Gi = _t.scrollTrigger, Xn = _t.duration(), ii = Gi.end - Gi.start; Et = Gi.start + ii * Et / Xn, Fn = Gi.start + ii * Fn / Xn } me.refresh(!1, !1, { start: fn(Et, qt && !!me._startClamp), end: fn(Fn, qt && !!me._endClamp) }, Tn), me.update() }, me.adjustPinSpacing = function (Et) { if (jr && Et) { var Fn = jr.indexOf(Wt.d) + 1; jr[Fn] = parseFloat(jr[Fn]) + Et + Rn, jr[1] = parseFloat(jr[1]) + Et + Rn, Is(jr) } }, me.disable = function (Et, Fn) { if (me.enabled && (Et !== !1 && me.revert(!0, !0), me.enabled = me.isActive = !1, Fn || Gn && Gn.pause(), zs = 0, Ki && (Ki.uncache = 1), Ei && ji(pe, "refreshInit", Ei), Ea && (Ea.pause(), Dr.tween && Dr.tween.kill() && (Dr.tween = 0)), !xi)) { for (var qt = _n.length; qt--;)if (_n[qt].scroller === en && _n[qt] !== me) return; ji(en, "resize", If), xi || ji(en, "scroll", ku) } }, me.kill = function (Et, Fn) { me.disable(Et, Fn), Gn && !Fn && Gn.kill(), lt && delete rd[lt]; var qt = _n.indexOf(me); qt >= 0 && _n.splice(qt, 1), qt === X && Ic > 0 && X--, qt = 0, _n.forEach(function (Tn) { return Tn.scroller === me.scroller && (qt = 1) }), qt || Gs || (me.scroll.rec = 0), W && (W.scrollTrigger = null, Et && W.revert({ kill: !1 }), Fn || W.kill()), bs && [bs, Hs, Re, Lr].forEach(function (Tn) { return Tn.parentNode && Tn.parentNode.removeChild(Tn) }), Mc === me && (Mc = 0), He && (Ki && (Ki.uncache = 1), qt = 0, _n.forEach(function (Tn) { return Tn.pin === He && qt++ }), qt || (Ki.spacer = 0)), z.onKill && z.onKill(me) }, _n.push(me), me.enable(!1, !1), Ya && Ya(me), W && W.add && !Ln) { var Jr = me.update; me.update = function () { me.update = Jr, Ht || Yr || me.refresh() }, ge.delayedCall(.01, me.update), Ln = .01, Ht = Yr = 0 } else me.refresh(); He && a4() }, pe.register = function (z) { return tt || (ge = z || Vt(), xn() && window.document && pe.enable(), tt = jt), tt }, pe.defaults = function (z) { if (z) for (var W in z) Sc[W] = z[W]; return Sc }, pe.disable = function (z, W) { jt = 0, _n.forEach(function (Pe) { return Pe[W ? "kill" : "disable"](z) }), ji(je, "wheel", ku), ji(Oe, "scroll", ku), clearInterval(nt), ji(Oe, "touchcancel", Qt), ji(de, "touchstart", Qt), ea(ji, Oe, "pointerdown,touchstart,mousedown", $e), ea(ji, Oe, "pointerup,touchend,mouseup", Xt), Qe.kill(), rr(ji); for (var le = 0; le < T.length; le += 3)Xp(ji, T[le], T[le + 1]), Xp(ji, T[le], T[le + 2]) }, pe.enable = function () { if (je = window, Oe = document, K = Oe.documentElement, de = Oe.body, ge && (De = ge.utils.toArray, ie = ge.utils.clamp, at = ge.core.context || Qt, We = ge.core.suppressOverwrites || Qt, ee = je.history.scrollRestoration || "auto", vo = je.pageYOffset, ge.core.globals("ScrollTrigger", pe), de)) { jt = 1, Ie = document.createElement("div"), Ie.style.height = "100vh", Ie.style.position = "absolute", d2(), Dt(), we.register(ge), pe.isTouch = we.isTouch, dt = we.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Yi(je, "wheel", ku), Ce = [je, Oe, K, de], ge.matchMedia ? (pe.matchMedia = function (lt) { var Jt = ge.matchMedia(), Pn; for (Pn in lt) Jt.add(Pn, lt[Pn]); return Jt }, ge.addEventListener("matchMediaInit", function () { return Mm() }), ge.addEventListener("matchMediaRevert", function () { return Jp() }), ge.addEventListener("matchMedia", function () { ws(0, 1), wc("matchMedia") }), ge.matchMedia("(orientation: portrait)", function () { return Un(), Un })) : console.warn("Requires GSAP 3.11.0 or later"), Un(), Yi(Oe, "scroll", ku); var z = de.style, W = z.borderTopStyle, le = ge.core.Animation.prototype, Pe, ye; for (le.revert || Object.defineProperty(le, "revert", { value: function () { return this.time(-.01, !0) } }), z.borderTopStyle = "solid", Pe = ir(de), Q.m = Math.round(Pe.top + Q.sc()) || 0, L.m = Math.round(Pe.left + L.sc()) || 0, W ? z.borderTopStyle = W : z.removeProperty("border-top-style"), nt = setInterval(c2, 250), ge.delayedCall(.5, function () { return Ve = 0 }), Yi(Oe, "touchcancel", Qt), Yi(de, "touchstart", Qt), ea(Yi, Oe, "pointerdown,touchstart,mousedown", $e), ea(Yi, Oe, "pointerup,touchend,mouseup", Xt), mn = ge.utils.checkPrefix("transform"), va.push(mn), tt = oe(), Qe = ge.delayedCall(.2, ws).pause(), Ne = [Oe, "visibilitychange", function () { var lt = je.innerWidth, Jt = je.innerHeight; Oe.hidden ? (O = lt, fe = Jt) : (O !== lt || fe !== Jt) && If() }, Oe, "DOMContentLoaded", ws, je, "load", ws, je, "resize", If], rr(Yi), _n.forEach(function (lt) { return lt.enable(0, 1) }), ye = 0; ye < T.length; ye += 3)Xp(ji, T[ye], T[ye + 1]), Xp(ji, T[ye], T[ye + 2]) } }, pe.config = function (z) { "limitCallbacks" in z && (j = !!z.limitCallbacks); var W = z.syncInterval; W && clearInterval(nt) || (nt = W) && setInterval(c2, W), "ignoreMobileResize" in z && (Ae = pe.isTouch === 1 && z.ignoreMobileResize), "autoRefreshEvents" in z && (rr(ji) || rr(Yi, z.autoRefreshEvents || "none"), ut = (z.autoRefreshEvents + "").indexOf("resize") === -1) }, pe.scrollerProxy = function (z, W) { var le = D(z), Pe = T.indexOf(le), ye = Yt(le); ~Pe && T.splice(Pe, ye ? 6 : 2), W && (ye ? I.unshift(je, W, de, W, K, W) : I.unshift(le, W)) }, pe.clearMatchMedia = function (z) { _n.forEach(function (W) { return W._ctx && W._ctx.query === z && W._ctx.kill(!0, !0) }) }, pe.isInViewport = function (z, W, le) { var Pe = (H(z) ? D(z) : z).getBoundingClientRect(), ye = Pe[le ? pt : hn] * W || 0; return le ? Pe.right - ye > 0 && Pe.left + ye < je.innerWidth : Pe.bottom - ye > 0 && Pe.top + ye < je.innerHeight }, pe.positionInViewport = function (z, W, le) { H(z) && (z = D(z)); var Pe = z.getBoundingClientRect(), ye = Pe[le ? pt : hn], lt = W == null ? ye / 2 : W in Fu ? Fu[W] * ye : ~W.indexOf("%") ? parseFloat(W) * ye / 100 : parseFloat(W) || 0; return le ? (Pe.left + lt) / je.innerWidth : (Pe.top + lt) / je.innerHeight }, pe.killAll = function (z) { if (_n.slice(0).forEach(function (le) { return le.vars.id !== "ScrollSmoother" && le.kill() }), z !== !0) { var W = Gl.killAll || []; Gl = {}, W.forEach(function (le) { return le() }) } }, pe }(); $t.version = "3.12.2", $t.saveStyles = function (pe) { return pe ? De(pe).forEach(function (k) { if (k && k.style) { var te = sr.indexOf(k); te >= 0 && sr.splice(te, 5), sr.push(k, k.style.cssText, k.getBBox && k.getAttribute("transform"), ge.core.getCache(k), at()) } }) : sr }, $t.revert = function (pe, k) { return Mm(!pe, k) }, $t.create = function (pe, k) { return new $t(pe, k) }, $t.refresh = function (pe) { return pe ? If() : (tt || $t.register()) && ws(!0) }, $t.update = function (pe) { return ++T.cache && tl(pe === !0 ? 2 : 0) }, $t.clearScrollMemory = Kp, $t.maxScroll = function (pe, k) { return ur(pe, k ? L : Q) }, $t.getScrollFunc = function (pe, k) { return V(D(pe), k ? L : Q) }, $t.getById = function (pe) { return rd[pe] }, $t.getAll = function () { return _n.filter(function (pe) { return pe.vars.id !== "ScrollSmoother" }) }, $t.isScrolling = function () { return !!Ye }, $t.snapDirectional = Lu, $t.addEventListener = function (pe, k) { var te = Gl[pe] || (Gl[pe] = []); ~te.indexOf(k) || te.push(k) }, $t.removeEventListener = function (pe, k) { var te = Gl[pe], z = te && te.indexOf(k); z >= 0 && te.splice(z, 1) }, $t.batch = function (pe, k) { var te = [], z = {}, W = k.interval || .016, le = k.batchMax || 1e9, Pe = function (Jt, Pn) { var Dn = [], Tt = [], He = ge.delayedCall(W, function () { Pn(Dn, Tt), Dn = [], Tt = [] }).pause(); return function (kt) { Dn.length || He.restart(!0), Dn.push(kt.trigger), Tt.push(kt), le <= Dn.length && He.progress(1) } }, ye; for (ye in k) z[ye] = ye.substr(0, 2) === "on" && ae(k[ye]) && ye !== "onRefreshInit" ? Pe(ye, k[ye]) : k[ye]; return ae(le) && (le = le(), Yi($t, "refresh", function () { return le = k.batchMax() })), De(pe).forEach(function (lt) { var Jt = {}; for (ye in z) Jt[ye] = z[ye]; Jt.trigger = lt, te.push($t.create(Jt)) }), te }; var yo = function (k, te, z, W) { return te > W ? k(W) : te < 0 && k(0), z > W ? (W - te) / (z - te) : z < 0 ? te / (te - z) : 1 }, nl = function pe(k, te) { te === !0 ? k.style.removeProperty("touch-action") : k.style.touchAction = te === !0 ? "auto" : te ? "pan-" + te + (we.isTouch ? " pinch-zoom" : "") : "none", k === K && pe(de, te) }, Bf = { auto: 1, scroll: 1 }, p2 = function (k) { var te = k.event, z = k.target, W = k.axis, le = (te.changedTouches ? te.changedTouches[0] : te).target, Pe = le._gsap || ge.core.getCache(le), ye = oe(), lt; if (!Pe._isScrollT || ye - Pe._isScrollT > 2e3) { for (; le && le !== de && (le.scrollHeight <= le.clientHeight && le.scrollWidth <= le.clientWidth || !(Bf[(lt = $n(le)).overflowY] || Bf[lt.overflowX]));)le = le.parentNode; Pe._isScroll = le && le !== z && !Yt(le) && (Bf[(lt = $n(le)).overflowY] || Bf[lt.overflowX]), Pe._isScrollT = ye } (Pe._isScroll || W === "x") && (te.stopPropagation(), te._gsapAllow = !0) }, rl = function (k, te, z, W) { return we.create({ target: k, capture: !0, debounce: !1, lockAxis: !0, type: te, onWheel: W = W && p2, onPress: W, onDrag: W, onScroll: W, onEnable: function () { return z && Yi(Oe, we.eventTypes[0], Pm, !1, !0) }, onDisable: function () { return ji(Oe, we.eventTypes[0], Pm, !0) } }) }, Nu = /(input|label|select|textarea)/i, id, Pm = function (k) { var te = Nu.test(k.target.tagName); (te || id) && (k._gsapAllow = !0, id = te) }, e0 = function (k) { he(k) || (k = {}), k.preventDefault = k.isNormalizer = k.allowClicks = !0, k.type || (k.type = "wheel,touch"), k.debounce = !!k.debounce, k.id = k.id || "normalizer"; var te = k, z = te.normalizeScrollX, W = te.momentum, le = te.allowNestedScroll, Pe = te.onRelease, ye, lt, Jt = D(k.target) || K, Pn = ge.core.globals().ScrollSmoother, Dn = Pn && Pn.get(), Tt = dt && (k.content && D(k.content) || Dn && k.content !== !1 && !Dn.smooth() && Dn.content()), He = V(Jt, Q), kt = V(Jt, L), cr = 1, Wn = (we.isTouch && je.visualViewport ? je.visualViewport.scale * je.visualViewport.width : je.outerWidth) / je.innerWidth, _r = 0, br = ae(W) ? function () { return W(ye) } : function () { return W || 2.8 }, ki, dn, Br = rl(Jt, k.type, !0, le), bn = function () { return dn = !1 }, _t = Qt, Ni = Qt, Rr = function () { lt = ur(Jt, Q), Ni = ie(dt ? 1 : 0, lt), z && (_t = ie(0, ur(Jt, L))), ki = el }, Wt = function () { Tt._gsap.y = ft(parseFloat(Tt._gsap.y) + He.offset) + "px", Tt.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(Tt._gsap.y) + ", 0, 1)", He.offset = He.cacheID = 0 }, Ji = function () { if (dn) { requestAnimationFrame(bn); var Pr = ft(ye.deltaY / 2), Xr = Ni(He.v - Pr); if (Tt && Xr !== He.v + He.offset) { He.offset = Xr - He.v; var me = ft((parseFloat(Tt && Tt._gsap.y) || 0) - He.offset); Tt.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + me + ", 0, 1)", Tt._gsap.y = me + "px", He.cacheID = T.cache, tl() } return !0 } He.offset && Wt(), dn = !0 }, en, xo, xi, Oi, _i = function () { Rr(), en.isActive() && en.vars.scrollY > lt && (He() > lt ? en.progress(1) && He(lt) : en.resetTo("scrollY", lt)) }; return Tt && ge.set(Tt, { y: "+=0" }), k.ignoreCheck = function (fr) { return dt && fr.type === "touchmove" && Ji() || cr > 1.05 && fr.type !== "touchstart" || ye.isGesturing || fr.touches && fr.touches.length > 1 }, k.onPress = function () { dn = !1; var fr = cr; cr = ft((je.visualViewport && je.visualViewport.scale || 1) / Wn), en.pause(), fr !== cr && nl(Jt, cr > 1.01 ? !0 : z ? !1 : "x"), xo = kt(), xi = He(), Rr(), ki = el }, k.onRelease = k.onGestureStart = function (fr, Pr) { if (He.offset && Wt(), !Pr) Oi.restart(!0); else { T.cache++; var Xr = br(), me, Ei; z && (me = kt(), Ei = me + Xr * .05 * -fr.velocityX / .227, Xr *= yo(kt, me, Ei, ur(Jt, L)), en.vars.scrollX = _t(Ei)), me = He(), Ei = me + Xr * .05 * -fr.velocityY / .227, Xr *= yo(He, me, Ei, ur(Jt, Q)), en.vars.scrollY = Ni(Ei), en.invalidate().duration(Xr).play(.01), (dt && en.vars.scrollY >= lt || me >= lt - 1) && ge.to({}, { onUpdate: _i, duration: Xr }) } Pe && Pe(fr) }, k.onWheel = function () { en._ts && en.pause(), oe() - _r > 1e3 && (ki = 0, _r = oe()) }, k.onChange = function (fr, Pr, Xr, me, Ei) { if (el !== ki && Rr(), Pr && z && kt(_t(me[2] === Pr ? xo + (fr.startX - fr.x) : kt() + Pr - me[1])), Xr) { He.offset && Wt(); var Va = Ei[2] === Xr, Hl = Va ? xi + fr.startY - fr.y : He() + Xr - Ei[1], Ms = Ni(Hl); Va && Hl !== Ms && (xi += Ms - Hl), He(Ms) } (Xr || Pr) && tl() }, k.onEnable = function () { nl(Jt, z ? !1 : "x"), $t.addEventListener("refresh", _i), Yi(je, "resize", _i), He.smooth && (He.target.style.scrollBehavior = "auto", He.smooth = kt.smooth = !1), Br.enable() }, k.onDisable = function () { nl(Jt, !0), ji(je, "resize", _i), $t.removeEventListener("refresh", _i), Br.kill() }, k.lockAxis = k.lockAxis !== !1, ye = new we(k), ye.iOS = dt, dt && !He() && He(1), dt && ge.ticker.add(Qt), Oi = ye._dc, en = ge.to(ye, { ease: "power4", paused: !0, scrollX: z ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: $p(He, He(), function () { return en.pause() }) }, onUpdate: tl, onComplete: Oi.vars.onComplete }), ye }; $t.sort = function (pe) { return _n.sort(pe || function (k, te) { return (k.vars.refreshPriority || 0) * -1e6 + k.start - (te.start + (te.vars.refreshPriority || 0) * -1e6) }) }, $t.observe = function (pe) { return new we(pe) }, $t.normalizeScroll = function (pe) { if (typeof pe > "u") return Ge; if (pe === !0 && Ge) return Ge.enable(); if (pe === !1) return Ge && Ge.kill(); var k = pe instanceof we ? pe : e0(pe); return Ge && Ge.target === k.target && Ge.kill(), Yt(k.target) && (Ge = k), k }, $t.core = { _getVelocityProp: J, _inputObserver: rl, _scrollers: T, _proxies: I, bridge: { ss: function () { Ye || wc("scrollStart"), Ye = oe() }, ref: function () { return it } } }, Vt() && ge.registerPlugin($t), t.ScrollTrigger = $t, t.default = $t, typeof window > "u" || window !== t ? Object.defineProperty(t, "__esModule", { value: !0 }) : delete window.default
		})
	})(C9, C9.exports); var Lj = C9.exports; const cN = n => { const e = ue.useRef(null), t = ue.useRef(null); return pr.registerPlugin(Lj.ScrollTrigger), ue.useEffect(() => { let r = pr.context(() => { pr.timeline({ scrollTrigger: { trigger: e.current, start: "top 60%", end: "top 60%" } }).from(t.current, { opacity: 0, x: -20 }).to(e.current, { width: "100%", duration: 1, ease: "Power3.out" }) }); return () => r.revert() }, []), re.jsx("div", { ref: e, className: "header-con", children: re.jsxs("h1", { ref: t, className: "gmh", children: [re.jsx("span", { className: "h1h highlight", children: n.highlight }), " ", n.text] }) }) }, HM = "/Taskverse/assets/bed-0d58e3e3.png", Fj = "data:image/webp;base64,UklGRqQGAABXRUJQVlA4WAoAAAAQAAAAPwAAPwAAQUxQSFUDAAANoINt2yHJer7/r+rB2jyKbCNixsj2yWzbto3Itm3btgfdVf//BlNdVV2LOCImgHrNqDXSXKme5rq426ZDDpAJE8iE+j47XU0xbTK73wDDwMAwxH93ytSEFLJ2X4fqrdEWRnfl9WVAdK1qwo2iEj1sbdSft7/AqhlT1omAZJKSX9+pyTTp4okaD66aY9kLHYYZZpE3jzDVAsrTiBk9F7VbgqOJPQg/pSFOHexd7eLvrX/q+/fCrYJfQCAORSPvo+eqr9CBKli1XhtYhRrVk8hZzwQBJgMD/+8ue0VXobfi/W+JgBAIjCkrySqYegHOKOtMWT81egj1RZWKMkb7K2VE0dTN53Xa32DljKU39H7o3lFTE45cShPBlXOsdogYPuZvGmhq9wXMUVXCZZ5mGp4azcCF3qVzXQx/YgUjPxpuXlo0VtYrF5e+cyCmEQcE/+aOPgzcsUx03Zro+3B0DzEQ+o1GS05YF5PJR7rLmoBhjBWYEMK69dqHLU/6x30XC4K/9sIpYQUAo6x6AnNmDnqKZd/9M5TT5NTRluWQAFlwLVOCQoOyCO2+hMLUR1qdnEJrhGmbtYY7n+CKrvxiIFkbFcmase2SyXgwQMb1v4dhiEVG7z2ETitgDgjI93U8ihSaSqmmgBGdp9CbQFHUa6iOdNVWnv3IWNnQO3K2HKKklRI1mqbeMikOCl/w2V6BALFMRdVQ6FigZci6Waxk5WSVfEqWtjHGZjkDbV+JLM3wDhTMB1/Bh80uHWr9EgqCv+2Yqf8tCSolhrf9auDvE3fotB7ffzCb41EpmDSx31Es+yP7T1SPX7aNcdNlf/3WjpR3jhwEBgSZd9FAlXAQjTwBB7FUjJClRqE3kWaizggkJCR5pLSLu2/+T3yPAtn5L0x0axNrgcjtLwe/Aipn2nBW/wDdHhpuj4BqEi+8wTDlHMQ8yTEPEriBkYQYqd05UKBsBIJPGGsGuJjTyxip6DebnLc/wQpGHml7vybqSVVT66xZGg8ekP1+cJsOxAaBQhIxAwlnacch0WgzHGPNwOdEmi5jrGz4L0vDZBbY6O49dEJ7ukONMxXAsIYjC6Ksi4sO4gJgrgtEFkDR3u9nyZS4lRcMiC//i4Qy0IKBo1hiAY1dFs8BAFZQOCAoAwAAcA8AnQEqQABAAD6JNpNHpSMhoTX13MigEQlqAMqrzEmQ7XncB+BBt2OeA9Ce85byr/jfOApo4y0b3LQ0rjO28G9ABhZD3gFuqrUMFJS7Wl5K0IU8Ljz4ti+ZAJDNv/2wC+xNKSXVNUokkfQnErIeSMUQUi3Pz3DYpVxJFA9DM52kR6MAAP79Nn7B7w3iZR7InI1A6vkJNMD7MfCbvG0APLq0p9+dn+7pl4+c3zfY1nMJyd+VKprCjs8tqsGayzT31H2/78sMYdbsx9Pb/qb5yg5VcdZl08s8HWezXcp+jQepHfGpxCL0ktnvJjYiPpQWCH/k0R4rpC0ZCHjj3TvrwhCbd2jTP6uBOsWl5XcpPJGtdaZW7U5QgTl3Q04rdpJ46Hl0icBr/NclDS57yf18MkgQHFpE8DjwHv9OMpKCIxi/+o2TOZKAB7iABvRIVt4VK3X6y8KwR6fPoeISTdlJDw2qTyZu+tgKZZfRDRn1t14DmhGFCgfVrCVcHZBmc1lAlTupbKUgOJAvQkveR6kDeiE1iqGWmP17bmf1hVqPulFV67Tp+RZXh8pIUXH2v0nWQikadTnjuv9M19sXjm5kLms1PvDnANjiTaldmjla24XWjVVeXXN0KGNNfIV8WqJQnQYhMzvnTmCVg65zUmm1UolzKvPUdKvlDfPYA94HDnncaePTNHklhFjumWVkEHXdxQKGG9hsQ2Q17xTny9jciIq/xwyTltH0WW8zaN4T/UX99rt5JLiX4i1kM7Ou30EgfCuZ/Ak+TiOiP2UBFn7KzSE1fBdBCk2VZx7Uo3v5htm84Pil4NFTu3yqBWbWy7Fs+3XvKielkeqFC7/yCE0a2EBlfuTSXvyTp2uKXLr1OuouDirM/T1cQy4+Ei+I1K98Zmljav0jdo88RbsZrsxxiQ9zDZCgpdKqwqTTXX3giekET5XIFLRti6TtvcK+dI9SdfjQGv2Toqt79SkJ3k9N5vB3+udF9zsJq6RdT0hk7/gpF+OgJi4E6MvC94V7RWnbf7P1yEMJgzz7H0iFpv5Yzbj4IC6ZgLzuHVpKkj6nzNuZNNyA1cgAAA==", kj = "data:image/webp;base64,UklGRvIGAABXRUJQVlA4WAoAAAAQAAAAPwAAPwAAQUxQSLEDAAANsHXbtjHJ9pDG2nsH0pnHtm3btm3b9nm0z5tt27Zt6950VgW+vdZDfPFl5BcVERPADLC8lLcUC98NiuXO6Xy3l5EG5cKnfMwdEH0k1YsFouXP49NQEtrZsccShfLNnzltF2HblZQnvhFrF1AVL+aJbeOcYUTaWThvzdL/DhoXy1P00UmGZefC3qsE1fyIx5NVzUclIbfGf1fG6rELqWvihN7DfderzznNy+CtdXaa16QJQs9xZT58Ki8gjujIbpGgCJYTUzDJJh6cGvlVDv60OveDHSZp4Nn1sOLgwYNi+YDvR7HFQxZhnsWxD6uC5cRLEiJCVk2K9YCR12jUxlzSUzZp4gLFUCtpxfKB8vd200cu2zX6JggzPzgnf+wwIpYLiP836t0JzqWBn9MT/qkF1Qzi06K1AE8MBDJHfAIJWS2mtTZGrn/FRk/bKPomXpjlglL/bY86TXG67Ol1ASuc87PTyWF8/K1niflNmiB0bl/ih4/FUsTm3iCYAE//X6wF4ByJI7tFQiSjSQIQFKOlqjBUHpFZXTPx0FXpk/Eqrl/GyoQGxMRaApGzb+7qeXbAJA0Cx5z6v9lPupeBp7u6BpGUKZ1WI/YImXt6FTcNPwuBPArmlOwGYmCIIWliU2CQ/O4q/bOZNBGgr9bHOALwe8UVZsNahzG2ySC7Xhx9EwhcekSlYmnbfBMqgk4BoKBOcc2gEGiuRPIoONpZefOBSucZM5u0zxfPwm79UdwkTMVZLkBcDIZjsuIMsXyYUvuWWliykMVk+HvvFiGnxvi+vzLzbbOqa6bulVMKdUHzAagRPdmNSJ4VVCSLiaF5Ku7QV43DSAbHfOsU3UNDYrkQ6zy/vwiTWPkkOO+PfIhPfM0neKExGgSwRHyIgWhTZ5GkRKCpFxrFQ0LC1Dtdbe+xZARJi/7u5zp6zi+bCBw/c/BX/Sk2VSus2wkIscHCiz9PL+1TjuLgkDmN2/8MDWotA3UJXsA3QKHuneIBokpIiEy1IwDEPxIB+iEmf0u9aw7wzpit1tnwX30KUtX9u+NgMML/AwxtMVHd6CZDEO5ZccKZS/b50rUuCVWgWDUSwACbDtNLdYoC/QUAGanT+gIlgGLNBMAAwQIFGg1AjNZHXr63roj0ltCGRlM+vcbqFyyoThoQrGXGNy+iEMlu/PGUsMWsJuRQPKlJJhBP4hDyaDFtshbBxCQPM3J1Zili0h4OkRTErC3eq1UtRViMNjSO/gRNUUDzB0FonhjtmFiGGSIAVlA4IBoDAAAQDwCdASpAAEAAPo04l0elIyIhMfcbaKARiWwAyUBOqV+7YrPAt23PPD+iDeIN5Nn1/NnY3K94F6XpnDd8BviwwAuA9uu6kbvH0ZhTHrK3KcfTUOi/hFTPgZwGY6CMFLn9Pu0ZBQCtLuL6pbNJJoU8X/mTZcgHcP9+lbpwVjyFqIAA/vLynEy2OpWHSP4UoVy3KU6g73tc97owg6SbGvlBaDQPTyjGWXjj5/PMqh2la/f1i/jvCrY5iO5tiFh//fmeT237uNbHoq1h17jM0KeQbsOM9iSPu0t831GpWn5uIJNyxDSyhuw79Nzhv9hJ/byt6yONK0sdYzeWCE/zraD3ARhhbglRfMsVmrCAIlqtrWlPTr+uKcdsXPTiDTLWaD5EfehiPmO1xNVtssNdPCUYNK/0z/tDdaZ4iy9n/yGeCOS8Nm9sN/swmBV9Ag/lxLa09prrN8Y5r/q4t9nfLSy3h2smTGrRCbF75U2vBtkj+BuyFGwOgjSVZdtUXtuCTANpJA0JjbOpN6lFwsYEjTjtoo4OJHgytZuPh/6KB5U46y6N9SWVCJNYkVboGvkZzbuETvzeB1rrqycOx+DfkfyU4ohqkV5kKFmcf4OvooiS1c2cqWxCA4khZ3GlxWRj8X6IuK7NJLj7TQRO3u42YG9TeRMbbe3/Xko34FU7r7S9W5iHRWKtDfAJOFYKn+4YJK74ofko12RK5nvkEBp3wDnkklfHNIBwDSNOULVVWEx/6EUY1fLypUSQmnvFVZ/CugAbv4cJtPtk34/KmRR9gatPz4eNBKpsxWdXcMsH/rDmmcFs+Vi8vb0q+f0fu5zBHmYUP1CtADq1ZG+d0jAh1N8RvB8EZFJoTihk6QyD3h6cARBD8Xx7X2L/Z93Cu3vW7D3lCDzboPP0qJuSUg10mtTOrxLk2hHorIEiHuqw2qE3RvyZOTARNia/Ykq/3OD5gcU+ZeH9XPF+CAullGrYGu7ptXI8ziHPwjEorSORmbBeoGHMGci+7hBvg77M+xi2tu1F4BlswAVACJbhsg0uf071HG5924AfB3/QAA==", Nj = "data:image/webp;base64,UklGRuQHAABXRUJQVlA4WAoAAAAQAAAAPwAARQAAQUxQSIsCAAABoENtu2nb+f4550F3VcW201ltOtW2bbO2Otu2bSet7aO115z/9wUba691gjIiJgDNWpyaBLD6fvd99+09e68G2MRkRHtjCgBW3u+BX9X31wf2XQlATKEVIRqAVQ96eEZSye65iPr9gQNWBmDJxmQRANY6/Mk5UcU10IuomccPXQMAojVlaWoCsI2OenJGVCkasbiomSePXB/AxFSy0WIKQNjouGcXJOZMNcicKc0/fcwGAQgpDhUigLjRiS/0JOVMNe45S6qeP2H9AFgMfSwCCBuf/GpPUnGN3Yuo6sUTNjIA0QAgbHnaG7Wk4mppKZJ6r5+2uQGIW571ZpaYC9VilkypfvXUzcJLRSpVplrPXLlUXsrKrs56UakksTOSqlp/J9mVup9EdiQPkshO1MNIJNtGLfSGkkS2rh5FItmuPJpItkeqmpBEdk0SW1M3JpLslqR25LFIZNdE/m/m7Jx3pV40xM41/X8X/wUsdC93S6r+/6kXNXbOfdGj5otnNsexsWbvFalkNiWNh9nlj03s9lgRC9vHQi3cvoMZbJub50VvGZ366bJNAEOKwIaX/CTmwrYwF+rzs1aBpQgAMRpWOv0zsa5bwVyk9w5ZAksRAy0Ylhz8nuQ+mo9UqPLMHpOwiOEtGqZ2f9aVKx+Bw5WqaOHOHQ0W0WAKCDveUYnZhxm+ZOrnyzcBYkKzlgKw6bUzUvEm3Klvzl0VCMnQfDDDqud/I7r3I/sVUh8fugQWDGMOwbDiqE+l3OPfXJJXLr6w1zQsGFoYkmFyzxcpzxQpz9TCbdsCIRlaGpIh7PpALboXp369cmPAkqG9IU1GYOvrZuWur85bDTYxmQwtDwFY6+LvPjpkCRADmgcAVlA4IDIFAACwFQCdASpAAEYAPpE8mkkloyKhLNYKqLASCWQAq0PCzNChPP7c7zAecBpp+8rz4vmjBo7wdRqvoyZQVdjoRDlkfos93kWd77PXUJ/k/T19Br9cj2GctEmPzqNkszWax4x0gdtSxWCamFqEaQxVfOGcZXeB9UpoZL7ynnH1EjRyi6BTPrf/+IhLinTCVujn29lsUDAJXoqQHspv4GGv6MVoEK9XOor0hFFfdcxHnHfBSLRFYLgZQAD8QqonZAMo/kDmZaa12EnfoV83Jifn/1sgJciYXOz9EL2yyr28iFsPItLj71r3Vb0epPYjjOkq/K67enESb8FeAPywXX5jvfUGrwlQ/c1cVKlvDRGz+ZARmKIAvAv1FtkoGDBwm57ZTNrBR5rY20HCgJ0XPWhOC8Dh1yxWCh4iHfyhaLZU8Aabn4Pl9Xsh71o+fcmsC+xbsweIKt7orWFLh8xBqAGObU9CggPMxi1QzpNvJUaGZ70kWBmNnITlutri/pOTppYuHsGxy/4wX+Q3NqYf4wSHslFkeHrCnjfBV9zGpvoJKZOh3KL8eLS44/hJJELzMMNsK/z1iFlQ1kEBSJmzYJNVA40HzSGTTnPjvSTjvCvvCReWBK+3LcyYeGpdqNf6QYgVmH8TTyThu/8Hb5/8FTRc0D/qTQxJS47VoDgcoCDAI1pgAYEgiMu3WdkZ98qVq8UYROoLpd+7Qcj0/uPGOQNb5iorpKkldzLssEbQKK57LtJlyFMfxletwgRNhAFDa0k6ktQLfrM0wAX0uotr2WwJBJ9UrqtViP+rFzbIrwWt9Opq5dXaTGYP13+8zv0ZpP6/QiSZJGi8dFJygzpK6sAyM/ZyXAj2BtXxZJ9XUlooR/RlaJ1Naqot//QxIUV8lZlTodRCfBGD4DB0fj40wWWvLkbHjyHQJqXB2pPOxQaixHXGmFm4st5mK6BtydkQDZaKujM5lJhfhMBKm2U2qvW1zV20e0wWfjqA8JECvkWahxzZUF3/pUjVui+FqdpZoCf3YoUAsYuqm9S04+9Ts1NopO+aQdjkxaW8LcGAXvS0rqzjf9tzQVYsRyXMa8TkJGEJ+qXJRiY9RNDXd7ygbI6lGuh2jfJ0Jr5W4dvAubiB31xf+QniKOILawRV2S79on9/oeo7JinxQP/h3xDD6mIXze1+yc6Rtg7D63bdruh3IWcSAChtFiEo0D0ioUTpkwFvgMlWY0hULAUwAW1seOIeMx52PuZBvcwoeU2Qz9p3XTT7YdF6dmITaOUNeGFzLsUO1JGC8JuMGsOK5rly9c7ugbh8Wp9EHLpKjV8Sy4BU8SAtgS8CzPUbfdbThtpld/TGM15dn9lVuoytpY3lmIdzBLLlldJbMEQRQ/jIAY+V52emSpTVenrjJv8tA6kJxJNH1t7Tc+ZMIAsERJ4c3bRfunFLsouckWj6AkCHR+sQAoq7BD+FDsEnZ+lkz5XbHLfUfQbGQtu0ItahLpjWb1PAol3Uxaamms2zN9HNlJ/76dRrlXwYxrcl63pnAKEfrDitIA0bVz77t3//ywQuI+T9/9/xNMv8n+TvujcjFoeFM2hi8IjXl8n9I2R+FMckupkQOyym4V/ujKoAsiKq0ZLGTmukqyqNzJq5Hw/52V7+275Dit9tV+v/5rxUJ1I/FO6GPh3DJh8kjwQ3M+ztgtDgx3lDn66R/+lmpZu5ILjFvn2de/+na4+CrQN5cZLAwIumx6NuZAL8ZO1WFU1n/9AEB//oKaOYvsTidfOTTQ2OrCOEzAAA", Oj = "data:image/webp;base64,UklGRvQEAABXRUJQVlA4WAoAAAAQAAAAPwAAPwAAQUxQSKoAAAABcBzbdptoaf3yoAwlV+MCldp4ZOT3WDMRwcZt20DV4slT7866J7iTWAjmhGx7A9q+yVKueKFmSbA48YEZ6TW+dHyhFc9NFQtUXrA4sMjg1FjuOEHPRu6h11jqINCjracBEiMtBb9XEKm7/5oePWRa8t/uOI21Z+FaIaJeXs8BGcf/h6PfTfLdpt6N6t2q3s3q3a72BrW3qL1J7W1qb1R7q9qbf9nb5f8NHFZQOCAkBAAAUBMAnQEqQABAAD6RQJlJJaOiISoWa6CwEgliAMBcCgcsj+0qMrcT9NG2z53zz/4Ev7De+fyUANjO3DRSwcuK4O7reEHAZudN+KSyWzkJVsCDnVGmCUt7RuZhokPD5N0G/nutOYCacgTrL+4Pf1fN135ASZkdloW8J/9RgwHSBsi3gWdxJP0Q+PCMCtAeig9jC0aRQ3/qMPZgQhMcdxeQMA9ZAAD+/HFmhruB4rh9KE3abyJoJo7Lz5yxSv7TuzUxosfHYxodxOOoYHkfCjDRtGwd6KauB7fyXDhqAFWcFZlVUnU1pX+pPLHd0V/iW5suoM5UavnKG1g63C50dONshc4PdYX/P3X8o2SSGNN1vXq8p89DFClGJ2UvtPmfLMUNDcM79yMtdleK+L08OcNRcYEoU8lyUEjFu28Xd3CiIQ1g4KkMr/0G4CkeVNBiMNuRVLp45CLPe/B+Eti5iwlLRaldgCXACRRnC0ZHhJeg2t7hJs5GOhTsFAfpVNrvMq58lyT48+63UhXX/TP3EnKGt1iq4siV+zYIWHPYgy2vuYca16ogpm7AvHrdhgiYVwI5IWQZmZBZV6XFvBVG+GKccsO48pZpjpNdrjFZB19a8VYsNeK9f9dY4TY8ywjxH4JZh2GvE+lhmcdrBjX0Oqhc/x3ntIAeKLEtYtT6Vpt67UZJvM+hnBVUe448c5x9bbhdFplVqzZgz9ib402Rlk3Zcy9RkHyp3Z5OT1uFwf2LkrteDMB4CAUK6NVD+L9WwEVeAUljqWR54IXl5Q+84iyyUcj4zny/O+/eh+BMyvYE/4SS4qpMU8OKZLAyXlIMhekp45LRa8i5IjdI2bpgCPpsCQM6W8QyPJ2jB1kpv0FMcl3f3qWlfkT5TxxpriAumNEyw5zOsNR96n+US2hETi88tYgDXYmva3KaoHQppUPeLurvt2vB+Z/EXJY3kJehj9zxgJX5ohtSFHXr/AXRsTqLWxH1GCFnv5fd5Uy7Q4krBB3+rBeSZE3xRhvdj07Pl7XrzRqIj2vmFPIHmDbebFfJ+cNW9mxROc/9ru1+gSMgk9fHmZIak5j4tqrqVJQ2437gVjdAoyR2m5JUXBj6feAWBJe0eqMWeJY+9dsztbHF93MNrixHDMew4gkwb3Wm7cxPtheGzX0G4oqMmlS2sbaRBhp5qBIMycehUMHRSGvbrTTP3d8ILYd7yX2N/62KEsjVv5rAgEr/2xP2XU/L93w6DqQwSj+jr1+Ysn1kT4Xp2oaN/oH9N4cW4b/0v/+CjH3LvMRZiijq79ty2lsZ1yA6L2xVlh2Z4cP9Z5pGs90+5G403j75X61l44ohJx+VsZiDPrFmLJX42vFcKmenBdxYKZgLJzm9NhHPd+EZ6CqWfG/gsZDrhX7xshvgUhdhCqZB1AAAAA==", Uj = "/Taskverse/assets/tnt-ce1c9626.png"; function zM(n, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r) } } function Gj(n, e, t) { return e && zM(n.prototype, e), t && zM(n, t), n }/*!
 * Observer 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Ks, S9, Fo, lh, uh, S3, fN, bd, qg, hN, qc, nu, dN, pN = function () { return Ks || typeof window < "u" && (Ks = window.gsap) && Ks.registerPlugin && Ks }, mN = 1, a3 = [], Nn = [], rc = [], Zg = Date.now, T9 = function (e, t) { return t }, Qj = function () { var e = qg.core, t = e.bridge || {}, r = e._scrollers, i = e._proxies; r.push.apply(r, Nn), i.push.apply(i, rc), Nn = r, rc = i, T9 = function (a, o) { return t[a](o) } }, _h = function (e, t) { return ~rc.indexOf(e) && rc[rc.indexOf(e) + 1][t] }, $g = function (e) { return !!~hN.indexOf(e) }, ba = function (e, t, r, i, s) { return e.addEventListener(t, r, { passive: !i, capture: !!s }) }, wa = function (e, t, r, i) { return e.removeEventListener(t, r, !!i) }, fv = "scrollLeft", hv = "scrollTop", w9 = function () { return qc && qc.isPressed || Nn.cache++ }, ty = function (e, t) { var r = function i(s) { if (s || s === 0) { mN && (Fo.history.scrollRestoration = "manual"); var a = qc && qc.isPressed; s = i.v = Math.round(s) || (qc && qc.iOS ? 1 : 0), e(s), i.cacheID = Nn.cache, a && T9("ss", s) } else (t || Nn.cache !== i.cacheID || T9("ref")) && (i.cacheID = Nn.cache, i.v = e()); return i.v + i.offset }; return r.offset = 0, e && r }, ka = { s: fv, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: ty(function (n) { return arguments.length ? Fo.scrollTo(n, ms.sc()) : Fo.pageXOffset || lh[fv] || uh[fv] || S3[fv] || 0 }) }, ms = { s: hv, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: ka, sc: ty(function (n) { return arguments.length ? Fo.scrollTo(ka.sc(), n) : Fo.pageYOffset || lh[hv] || uh[hv] || S3[hv] || 0 }) }, $a = function (e, t) { return (t && t._ctx && t._ctx.selector || Ks.utils.toArray)(e)[0] || (typeof e == "string" && Ks.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null) }, Dh = function (e, t) { var r = t.s, i = t.sc; $g(e) && (e = lh.scrollingElement || uh); var s = Nn.indexOf(e), a = i === ms.sc ? 1 : 2; !~s && (s = Nn.push(e) - 1), Nn[s + a] || ba(e, "scroll", w9); var o = Nn[s + a], l = o || (Nn[s + a] = ty(_h(e, r), !0) || ($g(e) ? i : ty(function (u) { return arguments.length ? e[r] = u : e[r] }))); return l.target = e, o || (l.smooth = Ks.getProperty(e, "scrollBehavior") === "smooth"), l }, I9 = function (e, t, r) { var i = e, s = e, a = Zg(), o = a, l = t || 50, u = Math.max(500, l * 3), c = function (g, v) { var y = Zg(); v || y - a > l ? (s = i, i = g, o = a, a = y) : r ? i += g : i = s + (g - s) / (y - o) * (a - o) }, h = function () { s = i = r ? 0 : i, o = a = 0 }, d = function (g) { var v = o, y = s, A = Zg(); return (g || g === 0) && g !== i && c(g), a === o || A - o > u ? 0 : (i + (r ? y : -y)) / ((r ? A : a) - v) * 1e3 }; return { update: c, reset: h, getVelocity: d } }, Jm = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, VM = function (e) { var t = Math.max.apply(Math, e), r = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(r) ? t : r }, gN = function () { qg = Ks.core.globals().ScrollTrigger, qg && qg.core && Qj() }, AN = function (e) { return Ks = e || pN(), Ks && typeof document < "u" && document.body && (Fo = window, lh = document, uh = lh.documentElement, S3 = lh.body, hN = [Fo, lh, uh, S3], Ks.utils.clamp, dN = Ks.core.context || function () { }, bd = "onpointerenter" in S3 ? "pointer" : "mouse", fN = ss.isTouch = Fo.matchMedia && Fo.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Fo || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, nu = ss.eventTypes = ("ontouchstart" in uh ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in uh ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return mN = 0 }, 500), gN(), S9 = 1), S9 }; ka.op = ms; Nn.cache = 0; var ss = function () { function n(t) { this.init(t) } var e = n.prototype; return e.init = function (r) { S9 || AN(Ks) || console.warn("Please gsap.registerPlugin(Observer)"), qg || gN(); var i = r.tolerance, s = r.dragMinimum, a = r.type, o = r.target, l = r.lineHeight, u = r.debounce, c = r.preventDefault, h = r.onStop, d = r.onStopDelay, m = r.ignore, g = r.wheelSpeed, v = r.event, y = r.onDragStart, A = r.onDragEnd, _ = r.onDrag, x = r.onPress, C = r.onRelease, T = r.onRight, I = r.onLeft, w = r.onUp, R = r.onDown, b = r.onChangeX, B = r.onChangeY, F = r.onChange, U = r.onToggleX, G = r.onToggleY, Y = r.onHover, Z = r.onHoverEnd, ne = r.onMove, $ = r.ignoreCheck, L = r.isNormalizer, Q = r.onGestureStart, D = r.onGestureEnd, V = r.onWheel, J = r.onEnable, Ee = r.onDisable, xe = r.onClick, Be = r.scrollSpeed, Fe = r.capture, we = r.allowClicks, ge = r.lockAxis, tt = r.onLockAxis; this.target = o = $a(o) || uh, this.vars = r, m && (m = Ks.utils.toArray(m)), i = i || 1e-9, s = s || 0, g = g || 1, Be = Be || 1, a = a || "wheel,touch,pointer", u = u !== !1, l || (l = parseFloat(Fo.getComputedStyle(S3).lineHeight) || 22); var je, Oe, K, de, Ce, Qe, De, ie = this, qe = 0, nt = 0, it = Dh(o, ka), xt = Dh(o, ms), mn = it(), X = xt(), O = ~a.indexOf("touch") && !~a.indexOf("pointer") && nu[0] === "pointerdown", fe = $g(o), Ne = o.ownerDocument || lh, Ue = [0, 0, 0], We = [0, 0, 0], ut = 0, Ge = function () { return ut = Zg() }, Ae = function ($e, Xt) { return (ie.event = $e) && m && ~m.indexOf($e.target) || Xt && O && $e.pointerType !== "touch" || $ && $($e, Xt) }, st = function () { ie._vx.reset(), ie._vy.reset(), Oe.pause(), h && h(ie) }, vt = function () { var $e = ie.deltaX = VM(Ue), Xt = ie.deltaY = VM(We), Qt = Math.abs($e) >= i, ft = Math.abs(Xt) >= i; F && (Qt || ft) && F(ie, $e, Xt, Ue, We), Qt && (T && ie.deltaX > 0 && T(ie), I && ie.deltaX < 0 && I(ie), b && b(ie), U && ie.deltaX < 0 != qe < 0 && U(ie), qe = ie.deltaX, Ue[0] = Ue[1] = Ue[2] = 0), ft && (R && ie.deltaY > 0 && R(ie), w && ie.deltaY < 0 && w(ie), B && B(ie), G && ie.deltaY < 0 != nt < 0 && G(ie), nt = ie.deltaY, We[0] = We[1] = We[2] = 0), (de || K) && (ne && ne(ie), K && (_(ie), K = !1), de = !1), Qe && !(Qe = !1) && tt && tt(ie), Ce && (V(ie), Ce = !1), je = 0 }, dt = function ($e, Xt, Qt) { Ue[Qt] += $e, We[Qt] += Xt, ie._vx.update($e), ie._vy.update(Xt), u ? je || (je = requestAnimationFrame(vt)) : vt() }, at = function ($e, Xt) { ge && !De && (ie.axis = De = Math.abs($e) > Math.abs(Xt) ? "x" : "y", Qe = !0), De !== "y" && (Ue[2] += $e, ie._vx.update($e, !0)), De !== "x" && (We[2] += Xt, ie._vy.update(Xt, !0)), u ? je || (je = requestAnimationFrame(vt)) : vt() }, ee = function ($e) { if (!Ae($e, 1)) { $e = Jm($e, c); var Xt = $e.clientX, Qt = $e.clientY, ft = Xt - ie.x, xn = Qt - ie.y, Vt = ie.isDragging; ie.x = Xt, ie.y = Qt, (Vt || Math.abs(ie.startX - Xt) >= s || Math.abs(ie.startY - Qt) >= s) && (_ && (K = !0), Vt || (ie.isDragging = !0), at(ft, xn), Vt || y && y(ie)) } }, Ie = ie.onPress = function (Dt) { Ae(Dt, 1) || Dt && Dt.button || (ie.axis = De = null, Oe.pause(), ie.isPressed = !0, Dt = Jm(Dt), qe = nt = 0, ie.startX = ie.x = Dt.clientX, ie.startY = ie.y = Dt.clientY, ie._vx.reset(), ie._vy.reset(), ba(L ? o : Ne, nu[1], ee, c, !0), ie.deltaX = ie.deltaY = 0, x && x(ie)) }, Ke = ie.onRelease = function (Dt) { if (!Ae(Dt, 1)) { wa(L ? o : Ne, nu[1], ee, !0); var $e = !isNaN(ie.y - ie.startY), Xt = ie.isDragging && (Math.abs(ie.x - ie.startX) > 3 || Math.abs(ie.y - ie.startY) > 3), Qt = Jm(Dt); !Xt && $e && (ie._vx.reset(), ie._vy.reset(), c && we && Ks.delayedCall(.08, function () { if (Zg() - ut > 300 && !Dt.defaultPrevented) { if (Dt.target.click) Dt.target.click(); else if (Ne.createEvent) { var ft = Ne.createEvent("MouseEvents"); ft.initMouseEvent("click", !0, !0, Fo, 1, Qt.screenX, Qt.screenY, Qt.clientX, Qt.clientY, !1, !1, !1, !1, 0, null), Dt.target.dispatchEvent(ft) } } })), ie.isDragging = ie.isGesturing = ie.isPressed = !1, h && !L && Oe.restart(!0), A && Xt && A(ie), C && C(ie, Xt) } }, j = function ($e) { return $e.touches && $e.touches.length > 1 && (ie.isGesturing = !0) && Q($e, ie.isDragging) }, Ve = function () { return (ie.isGesturing = !1) || D(ie) }, oe = function ($e) { if (!Ae($e)) { var Xt = it(), Qt = xt(); dt((Xt - mn) * Be, (Qt - X) * Be, 1), mn = Xt, X = Qt, h && Oe.restart(!0) } }, ze = function ($e) { if (!Ae($e)) { $e = Jm($e, c), V && (Ce = !0); var Xt = ($e.deltaMode === 1 ? l : $e.deltaMode === 2 ? Fo.innerHeight : 1) * g; dt($e.deltaX * Xt, $e.deltaY * Xt, 0), h && !L && Oe.restart(!0) } }, Ye = function ($e) { if (!Ae($e)) { var Xt = $e.clientX, Qt = $e.clientY, ft = Xt - ie.x, xn = Qt - ie.y; ie.x = Xt, ie.y = Qt, de = !0, (ft || xn) && at(ft, xn) } }, jt = function ($e) { ie.event = $e, Y(ie) }, ln = function ($e) { ie.event = $e, Z(ie) }, fn = function ($e) { return Ae($e) || Jm($e, c) && xe(ie) }; Oe = ie._dc = Ks.delayedCall(d || .25, st).pause(), ie.deltaX = ie.deltaY = 0, ie._vx = I9(0, 50, !0), ie._vy = I9(0, 50, !0), ie.scrollX = it, ie.scrollY = xt, ie.isDragging = ie.isGesturing = ie.isPressed = !1, dN(this), ie.enable = function (Dt) { return ie.isEnabled || (ba(fe ? Ne : o, "scroll", w9), a.indexOf("scroll") >= 0 && ba(fe ? Ne : o, "scroll", oe, c, Fe), a.indexOf("wheel") >= 0 && ba(o, "wheel", ze, c, Fe), (a.indexOf("touch") >= 0 && fN || a.indexOf("pointer") >= 0) && (ba(o, nu[0], Ie, c, Fe), ba(Ne, nu[2], Ke), ba(Ne, nu[3], Ke), we && ba(o, "click", Ge, !1, !0), xe && ba(o, "click", fn), Q && ba(Ne, "gesturestart", j), D && ba(Ne, "gestureend", Ve), Y && ba(o, bd + "enter", jt), Z && ba(o, bd + "leave", ln), ne && ba(o, bd + "move", Ye)), ie.isEnabled = !0, Dt && Dt.type && Ie(Dt), J && J(ie)), ie }, ie.disable = function () { ie.isEnabled && (a3.filter(function (Dt) { return Dt !== ie && $g(Dt.target) }).length || wa(fe ? Ne : o, "scroll", w9), ie.isPressed && (ie._vx.reset(), ie._vy.reset(), wa(L ? o : Ne, nu[1], ee, !0)), wa(fe ? Ne : o, "scroll", oe, Fe), wa(o, "wheel", ze, Fe), wa(o, nu[0], Ie, Fe), wa(Ne, nu[2], Ke), wa(Ne, nu[3], Ke), wa(o, "click", Ge, !0), wa(o, "click", fn), wa(Ne, "gesturestart", j), wa(Ne, "gestureend", Ve), wa(o, bd + "enter", jt), wa(o, bd + "leave", ln), wa(o, bd + "move", Ye), ie.isEnabled = ie.isPressed = ie.isDragging = !1, Ee && Ee(ie)) }, ie.kill = ie.revert = function () { ie.disable(); var Dt = a3.indexOf(ie); Dt >= 0 && a3.splice(Dt, 1), qc === ie && (qc = 0) }, a3.push(ie), L && $g(o) && (qc = ie), ie.enable(v) }, Gj(n, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), n }(); ss.version = "3.12.2"; ss.create = function (n) { return new ss(n) }; ss.register = AN; ss.getAll = function () { return a3.slice() }; ss.getById = function (n) { return a3.filter(function (e) { return e.vars.id === n })[0] }; pN() && Ks.registerPlugin(ss);/*!
 * ScrollTrigger 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Mt, U0, Yn, ci, lu, Zr, vN, ny, ry, o3, Z5, dv, ua, e8, M9, Da, WM, XM, G0, yN, Ex, xN, Mo, _N, EN, CN, Jf, b9, yS, T3, xS, Cx, pv = 1, Fa = Date.now, Sx = Fa(), Tl = 0, Ig = 0, YM = function (e, t, r) { var i = Ro(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1); return r["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e }, jM = function (e, t) { return t && (!Ro(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e }, Hj = function n() { return Ig && requestAnimationFrame(n) }, JM = function () { return e8 = 1 }, KM = function () { return e8 = 0 }, Xu = function (e) { return e }, Mg = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, SN = function () { return typeof window < "u" }, TN = function () { return Mt || SN() && (Mt = window.gsap) && Mt.registerPlugin && Mt }, Sp = function (e) { return !!~vN.indexOf(e) }, wN = function (e) { return (e === "Height" ? xS : Yn["inner" + e]) || lu["client" + e] || Zr["client" + e] }, IN = function (e) { return _h(e, "getBoundingClientRect") || (Sp(e) ? function () { return i6.width = Yn.innerWidth, i6.height = xS, i6 } : function () { return Yc(e) }) }, zj = function (e, t, r) { var i = r.d, s = r.d2, a = r.a; return (a = _h(e, "getBoundingClientRect")) ? function () { return a()[i] } : function () { return (t ? wN(s) : e["client" + s]) || 0 } }, Vj = function (e, t) { return !t || ~rc.indexOf(e) ? IN(e) : function () { return i6 } }, Zc = function (e, t) { var r = t.s, i = t.d2, s = t.d, a = t.a; return Math.max(0, (r = "scroll" + i) && (a = _h(e, r)) ? a() - IN(e)()[s] : Sp(e) ? (lu[r] || Zr[r]) - wN(i) : e[r] - e["offset" + i]) }, mv = function (e, t) { for (var r = 0; r < G0.length; r += 3)(!t || ~t.indexOf(G0[r + 1])) && e(G0[r], G0[r + 1], G0[r + 2]) }, Ro = function (e) { return typeof e == "string" }, Na = function (e) { return typeof e == "function" }, $5 = function (e) { return typeof e == "number" }, Bd = function (e) { return typeof e == "object" }, Km = function (e, t, r) { return e && e.progress(t ? 0 : 1) && r && e.pause() }, Tx = function (e, t) { if (e.enabled) { var r = t(e); r && r.totalTime && (e.callbackAnimation = r) } }, l0 = Math.abs, MN = "left", bN = "top", _S = "right", ES = "bottom", lp = "width", up = "height", eA = "Right", tA = "Left", nA = "Top", rA = "Bottom", ns = "padding", vl = "margin", J3 = "Width", CS = "Height", Xs = "px", yl = function (e) { return Yn.getComputedStyle(e) }, Wj = function (e) { var t = yl(e).position; e.style.position = t === "absolute" || t === "fixed" ? t : "relative" }, qM = function (e, t) { for (var r in t) r in e || (e[r] = t[r]); return e }, Yc = function (e, t) { var r = t && yl(e)[M9] !== "matrix(1, 0, 0, 1, 0, 0)" && Mt.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), i = e.getBoundingClientRect(); return r && r.progress(0).kill(), i }, B9 = function (e, t) { var r = t.d2; return e["offset" + r] || e["client" + r] || 0 }, BN = function (e) { var t = [], r = e.labels, i = e.duration(), s; for (s in r) t.push(r[s] / i); return t }, Xj = function (e) { return function (t) { return Mt.utils.snap(BN(e), t) } }, SS = function (e) { var t = Mt.utils.snap(e), r = Array.isArray(e) && e.slice(0).sort(function (i, s) { return i - s }); return r ? function (i, s, a) { a === void 0 && (a = .001); var o; if (!s) return t(i); if (s > 0) { for (i -= a, o = 0; o < r.length; o++)if (r[o] >= i) return r[o]; return r[o - 1] } else for (o = r.length, i += a; o--;)if (r[o] <= i) return r[o]; return r[0] } : function (i, s, a) { a === void 0 && (a = .001); var o = t(i); return !s || Math.abs(o - i) < a || o - i < 0 == s < 0 ? o : t(s < 0 ? i - e : i + e) } }, Yj = function (e) { return function (t, r) { return SS(BN(e))(t, r.direction) } }, gv = function (e, t, r, i) { return r.split(",").forEach(function (s) { return e(t, s, i) }) }, Ls = function (e, t, r, i, s) { return e.addEventListener(t, r, { passive: !i, capture: !!s }) }, Ds = function (e, t, r, i) { return e.removeEventListener(t, r, !!i) }, Av = function (e, t, r) { r = r && r.wheelHandler, r && (e(t, "wheel", r), e(t, "touchmove", r)) }, ZM = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, vv = { toggleActions: "play", anticipatePin: 0 }, iy = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, e6 = function (e, t) { if (Ro(e)) { var r = e.indexOf("="), i = ~r ? +(e.charAt(r - 1) + 1) * parseFloat(e.substr(r + 1)) : 0; ~r && (e.indexOf("%") > r && (i *= t / 100), e = e.substr(0, r - 1)), e = i + (e in iy ? iy[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, yv = function (e, t, r, i, s, a, o, l) { var u = s.startColor, c = s.endColor, h = s.fontSize, d = s.indent, m = s.fontWeight, g = ci.createElement("div"), v = Sp(r) || _h(r, "pinType") === "fixed", y = e.indexOf("scroller") !== -1, A = v ? Zr : r, _ = e.indexOf("start") !== -1, x = _ ? u : c, C = "border-color:" + x + ";font-size:" + h + ";color:" + x + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return C += "position:" + ((y || l) && v ? "fixed;" : "absolute;"), (y || l || !v) && (C += (i === ms ? _S : ES) + ":" + (a + parseFloat(d)) + "px;"), o && (C += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), g._isStart = _, g.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), g.style.cssText = C, g.innerText = t || t === 0 ? e + "-" + t : e, A.children[0] ? A.insertBefore(g, A.children[0]) : A.appendChild(g), g._offset = g["offset" + i.op.d2], t6(g, 0, i, _), g }, t6 = function (e, t, r, i) { var s = { display: "block" }, a = r[i ? "os2" : "p2"], o = r[i ? "p2" : "os2"]; e._isFlipped = i, s[r.a + "Percent"] = i ? -100 : 0, s[r.a] = i ? "1px" : 0, s["border" + a + J3] = 1, s["border" + o + J3] = 0, s[r.p] = t + "px", Mt.set(e, s) }, Bn = [], R9 = {}, WA, $M = function () { return Fa() - Tl > 34 && (WA || (WA = requestAnimationFrame(rf))) }, u0 = function () { (!Mo || !Mo.isPressed || Mo.startX > Zr.clientWidth) && (Nn.cache++, Mo ? WA || (WA = requestAnimationFrame(rf)) : rf(), Tl || wp("scrollStart"), Tl = Fa()) }, wx = function () { CN = Yn.innerWidth, EN = Yn.innerHeight }, bg = function () { Nn.cache++, !ua && !xN && !ci.fullscreenElement && !ci.webkitFullscreenElement && (!_N || CN !== Yn.innerWidth || Math.abs(Yn.innerHeight - EN) > Yn.innerHeight * .25) && ny.restart(!0) }, Tp = {}, jj = [], RN = function n() { return Ds(Qn, "scrollEnd", n) || jd(!0) }, wp = function (e) { return Tp[e] && Tp[e].map(function (t) { return t() }) || jj }, bo = [], PN = function (e) { for (var t = 0; t < bo.length; t += 5)(!e || bo[t + 4] && bo[t + 4].query === e) && (bo[t].style.cssText = bo[t + 1], bo[t].getBBox && bo[t].setAttribute("transform", bo[t + 2] || ""), bo[t + 3].uncache = 1) }, TS = function (e, t) { var r; for (Da = 0; Da < Bn.length; Da++)r = Bn[Da], r && (!t || r._ctx === t) && (e ? r.kill(1) : r.revert(!0, !0)); t && PN(t), t || wp("revert") }, DN = function (e, t) { Nn.cache++, (t || !La) && Nn.forEach(function (r) { return Na(r) && r.cacheID++ && (r.rec = 0) }), Ro(e) && (Yn.history.scrollRestoration = yS = e) }, La, cp = 0, eb, Jj = function () { if (eb !== cp) { var e = eb = cp; requestAnimationFrame(function () { return e === cp && jd(!0) }) } }, LN = function () { Zr.appendChild(T3), xS = T3.offsetHeight || Yn.innerHeight, Zr.removeChild(T3) }, jd = function (e, t) { if (Tl && !e) { Ls(Qn, "scrollEnd", RN); return } LN(), La = Qn.isRefreshing = !0, Nn.forEach(function (i) { return Na(i) && ++i.cacheID && (i.rec = i()) }); var r = wp("refreshInit"); yN && Qn.sort(), t || TS(), Nn.forEach(function (i) { Na(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0)) }), Bn.slice(0).forEach(function (i) { return i.refresh() }), Bn.forEach(function (i, s) { if (i._subPinOffset && i.pin) { var a = i.vars.horizontal ? "offsetWidth" : "offsetHeight", o = i.pin[a]; i.revert(!0, 1), i.adjustPinSpacing(i.pin[a] - o), i.refresh() } }), Bn.forEach(function (i) { var s = Zc(i.scroller, i._dir); (i.vars.end === "max" || i._endClamp && i.end > s) && i.setPositions(i.start, Math.max(i.start + 1, s), !0) }), r.forEach(function (i) { return i && i.render && i.render(-1) }), Nn.forEach(function (i) { Na(i) && (i.smooth && requestAnimationFrame(function () { return i.target.style.scrollBehavior = "smooth" }), i.rec && i(i.rec)) }), DN(yS, 1), ny.pause(), cp++, La = 2, rf(2), Bn.forEach(function (i) { return Na(i.vars.onRefresh) && i.vars.onRefresh(i) }), La = Qn.isRefreshing = !1, wp("refresh") }, P9 = 0, n6 = 1, iA, rf = function (e) { if (!La || e === 2) { Qn.isUpdating = !0, iA && iA.update(0); var t = Bn.length, r = Fa(), i = r - Sx >= 50, s = t && Bn[0].scroll(); if (n6 = P9 > s ? -1 : 1, La || (P9 = s), i && (Tl && !e8 && r - Tl > 200 && (Tl = 0, wp("scrollEnd")), Z5 = Sx, Sx = r), n6 < 0) { for (Da = t; Da-- > 0;)Bn[Da] && Bn[Da].update(0, i); n6 = 1 } else for (Da = 0; Da < t; Da++)Bn[Da] && Bn[Da].update(0, i); Qn.isUpdating = !1 } WA = 0 }, D9 = [MN, bN, ES, _S, vl + rA, vl + eA, vl + nA, vl + tA, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], r6 = D9.concat([lp, up, "boxSizing", "max" + J3, "max" + CS, "position", vl, ns, ns + nA, ns + eA, ns + rA, ns + tA]), Kj = function (e, t, r) { w3(r); var i = e._gsap; if (i.spacerIsNative) w3(i.spacerState); else if (e._gsap.swappedIn) { var s = t.parentNode; s && (s.insertBefore(e, t), s.removeChild(t)) } e._gsap.swappedIn = !1 }, Ix = function (e, t, r, i) { if (!e._gsap.swappedIn) { for (var s = D9.length, a = t.style, o = e.style, l; s--;)l = D9[s], a[l] = r[l]; a.position = r.position === "absolute" ? "absolute" : "relative", r.display === "inline" && (a.display = "inline-block"), o[ES] = o[_S] = "auto", a.flexBasis = r.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[lp] = B9(e, ka) + Xs, a[up] = B9(e, ms) + Xs, a[ns] = o[vl] = o[bN] = o[MN] = "0", w3(i), o[lp] = o["max" + J3] = r[lp], o[up] = o["max" + CS] = r[up], o[ns] = r[ns], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } }, qj = /([A-Z])/g, w3 = function (e) { if (e) { var t = e.t.style, r = e.length, i = 0, s, a; for ((e.t._gsap || Mt.core.getCache(e.t)).uncache = 1; i < r; i += 2)a = e[i + 1], s = e[i], a ? t[s] = a : t[s] && t.removeProperty(s.replace(qj, "-$1").toLowerCase()) } }, xv = function (e) { for (var t = r6.length, r = e.style, i = [], s = 0; s < t; s++)i.push(r6[s], r[r6[s]]); return i.t = e, i }, Zj = function (e, t, r) { for (var i = [], s = e.length, a = r ? 8 : 0, o; a < s; a += 2)o = e[a], i.push(o, o in t ? t[o] : e[a + 1]); return i.t = e.t, i }, i6 = { left: 0, top: 0 }, tb = function (e, t, r, i, s, a, o, l, u, c, h, d, m, g) { Na(e) && (e = e(l)), Ro(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? e6("0" + e.substr(3), r) : 0)); var v = m ? m.time() : 0, y, A, _; if (m && m.seek(0), isNaN(e) || (e = +e), $5(e)) m && (e = Mt.utils.mapRange(m.scrollTrigger.start, m.scrollTrigger.end, 0, d, e)), o && t6(o, r, i, !0); else { Na(t) && (t = t(l)); var x = (e || "0").split(" "), C, T, I, w; _ = $a(t, l) || Zr, C = Yc(_) || {}, (!C || !C.left && !C.top) && yl(_).display === "none" && (w = _.style.display, _.style.display = "block", C = Yc(_), w ? _.style.display = w : _.style.removeProperty("display")), T = e6(x[0], C[i.d]), I = e6(x[1] || "0", r), e = C[i.p] - u[i.p] - c + T + s - I, o && t6(o, I, i, r - I < 20 || o._isStart && I > 20), r -= r - I } if (g && (l[g] = e || -.001, e < 0 && (e = 0)), a) { var R = e + r, b = a._isStart; y = "scroll" + i.d2, t6(a, R, i, b && R > 20 || !b && (h ? Math.max(Zr[y], lu[y]) : a.parentNode[y]) <= R + 1), h && (u = Yc(o), h && (a.style[i.op.p] = u[i.op.p] - i.op.m - a._offset + Xs)) } return m && _ && (y = Yc(_), m.seek(d), A = Yc(_), m._caScrollDist = y[i.p] - A[i.p], e = e / m._caScrollDist * d), m && m.seek(v), m ? e : Math.round(e) }, $j = /(webkit|moz|length|cssText|inset)/i, nb = function (e, t, r, i) { if (e.parentNode !== t) { var s = e.style, a, o; if (t === Zr) { e._stOrig = s.cssText, o = yl(e); for (a in o) !+a && !$j.test(a) && o[a] && typeof s[a] == "string" && a !== "0" && (s[a] = o[a]); s.top = r, s.left = i } else s.cssText = e._stOrig; Mt.core.getCache(e).uncache = 1, t.appendChild(e) } }, FN = function (e, t, r) { var i = t, s = i; return function (a) { var o = Math.round(e()); return o !== i && o !== s && Math.abs(o - i) > 3 && Math.abs(o - s) > 3 && (a = o, r && r()), s = i, i = a, a } }, _v = function (e, t, r) { var i = {}; i[t.p] = "+=" + r, Mt.set(e, i) }, rb = function (e, t) { var r = Dh(e, t), i = "_scroll" + t.p2, s = function a(o, l, u, c, h) { var d = a.tween, m = l.onComplete, g = {}; u = u || r(); var v = FN(r, u, function () { d.kill(), a.tween = 0 }); return h = c && h || 0, c = c || o - u, d && d.kill(), l[i] = o, l.modifiers = g, g[i] = function () { return v(u + c * d.ratio + h * d.ratio * d.ratio) }, l.onUpdate = function () { Nn.cache++, rf() }, l.onComplete = function () { a.tween = 0, m && m.call(d) }, d = a.tween = Mt.to(e, l), d }; return e[i] = r, r.wheelHandler = function () { return s.tween && s.tween.kill() && (s.tween = 0) }, Ls(e, "wheel", r.wheelHandler), Qn.isTouch && Ls(e, "touchmove", r.wheelHandler), s }, Qn = function () { function n(t, r) { U0 || n.register(Mt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), b9(this), this.init(t, r) } var e = n.prototype; return e.init = function (r, i) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Ig) { this.update = this.refresh = this.kill = Xu; return } r = qM(Ro(r) || $5(r) || r.nodeType ? { trigger: r } : r, vv); var s = r, a = s.onUpdate, o = s.toggleClass, l = s.id, u = s.onToggle, c = s.onRefresh, h = s.scrub, d = s.trigger, m = s.pin, g = s.pinSpacing, v = s.invalidateOnRefresh, y = s.anticipatePin, A = s.onScrubComplete, _ = s.onSnapComplete, x = s.once, C = s.snap, T = s.pinReparent, I = s.pinSpacer, w = s.containerAnimation, R = s.fastScrollEnd, b = s.preventOverlaps, B = r.horizontal || r.containerAnimation && r.horizontal !== !1 ? ka : ms, F = !h && h !== 0, U = $a(r.scroller || Yn), G = Mt.core.getCache(U), Y = Sp(U), Z = ("pinType" in r ? r.pinType : _h(U, "pinType") || Y && "fixed") === "fixed", ne = [r.onEnter, r.onLeave, r.onEnterBack, r.onLeaveBack], $ = F && r.toggleActions.split(" "), L = "markers" in r ? r.markers : vv.markers, Q = Y ? 0 : parseFloat(yl(U)["border" + B.p2 + J3]) || 0, D = this, V = r.onRefreshInit && function () { return r.onRefreshInit(D) }, J = zj(U, Y, B), Ee = Vj(U, Y), xe = 0, Be = 0, Fe = 0, we = Dh(U, B), ge, tt, je, Oe, K, de, Ce, Qe, De, ie, qe, nt, it, xt, mn, X, O, fe, Ne, Ue, We, ut, Ge, Ae, st, vt, dt, at, ee, Ie, Ke, j, Ve, oe, ze, Ye, jt, ln, fn; if (D._startClamp = D._endClamp = !1, D._dir = B, y *= 45, D.scroller = U, D.scroll = w ? w.time.bind(w) : we, Oe = we(), D.vars = r, i = i || r.animation, "refreshPriority" in r && (yN = 1, r.refreshPriority === -9999 && (iA = D)), G.tweenScroll = G.tweenScroll || { top: rb(U, ms), left: rb(U, ka) }, D.tweenTo = ge = G.tweenScroll[B.p], D.scrubDuration = function (ft) { Ve = $5(ft) && ft, Ve ? j ? j.duration(ft) : j = Mt.to(i, { ease: "expo", totalProgress: "+=0", duration: Ve, paused: !0, onComplete: function () { return A && A(D) } }) : (j && j.progress(1).kill(), j = 0) }, i && (i.vars.lazy = !1, i._initted && !D.isReverted || i.vars.immediateRender !== !1 && r.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), D.animation = i.pause(), i.scrollTrigger = D, D.scrubDuration(h), Ie = 0, l || (l = i.vars.id)), C && ((!Bd(C) || C.push) && (C = { snapTo: C }), "scrollBehavior" in Zr.style && Mt.set(Y ? [Zr, lu] : U, { scrollBehavior: "auto" }), Nn.forEach(function (ft) { return Na(ft) && ft.target === (Y ? ci.scrollingElement || lu : U) && (ft.smooth = !1) }), je = Na(C.snapTo) ? C.snapTo : C.snapTo === "labels" ? Xj(i) : C.snapTo === "labelsDirectional" ? Yj(i) : C.directional !== !1 ? function (ft, xn) { return SS(C.snapTo)(ft, Fa() - Be < 500 ? 0 : xn.direction) } : Mt.utils.snap(C.snapTo), oe = C.duration || { min: .1, max: 2 }, oe = Bd(oe) ? o3(oe.min, oe.max) : o3(oe, oe), ze = Mt.delayedCall(C.delay || Ve / 2 || .1, function () { var ft = we(), xn = Fa() - Be < 500, Vt = ge.tween; if ((xn || Math.abs(D.getVelocity()) < 10) && !Vt && !e8 && xe !== ft) { var Yt = (ft - de) / xt, Mr = i && !F ? i.totalProgress() : Yt, sn = xn ? 0 : (Mr - Ke) / (Fa() - Z5) * 1e3 || 0, vr = Mt.utils.clamp(-Yt, 1 - Yt, l0(sn / 2) * sn / .185), Fi = Yt + (C.inertia === !1 ? 0 : vr), ur = o3(0, 1, je(Fi, D)), rr = Math.round(de + ur * xt), H = C, ae = H.onStart, ve = H.onInterrupt, he = H.onComplete; if (ft <= Ce && ft >= de && rr !== ft) { if (Vt && !Vt._initted && Vt.data <= l0(rr - ft)) return; C.inertia === !1 && (vr = ur - Yt), ge(rr, { duration: oe(l0(Math.max(l0(Fi - Mr), l0(ur - Mr)) * .185 / sn / .05 || 0)), ease: C.ease || "power3", data: l0(rr - ft), onInterrupt: function () { return ze.restart(!0) && ve && ve(D) }, onComplete: function () { D.update(), xe = we(), Ie = Ke = i && !F ? i.totalProgress() : D.progress, _ && _(D), he && he(D) } }, ft, vr * xt, rr - ft - vr * xt), ae && ae(D, ge.tween) } } else D.isActive && xe !== ft && ze.restart(!0) }).pause()), l && (R9[l] = D), d = D.trigger = $a(d || m !== !0 && m), fn = d && d._gsap && d._gsap.stRevert, fn && (fn = fn(D)), m = m === !0 ? d : $a(m), Ro(o) && (o = { targets: d, className: o }), m && (g === !1 || g === vl || (g = !g && m.parentNode && m.parentNode.style && yl(m.parentNode).display === "flex" ? !1 : ns), D.pin = m, tt = Mt.core.getCache(m), tt.spacer ? mn = tt.pinState : (I && (I = $a(I), I && !I.nodeType && (I = I.current || I.nativeElement), tt.spacerIsNative = !!I, I && (tt.spacerState = xv(I))), tt.spacer = fe = I || ci.createElement("div"), fe.classList.add("pin-spacer"), l && fe.classList.add("pin-spacer-" + l), tt.pinState = mn = xv(m)), r.force3D !== !1 && Mt.set(m, { force3D: !0 }), D.spacer = fe = tt.spacer, ee = yl(m), Ae = ee[g + B.os2], Ue = Mt.getProperty(m), We = Mt.quickSetter(m, B.a, Xs), Ix(m, fe, ee), O = xv(m)), L) { nt = Bd(L) ? qM(L, ZM) : ZM, ie = yv("scroller-start", l, U, B, nt, 0), qe = yv("scroller-end", l, U, B, nt, 0, ie), Ne = ie["offset" + B.op.d2]; var Dt = $a(_h(U, "content") || U); Qe = this.markerStart = yv("start", l, Dt, B, nt, Ne, 0, w), De = this.markerEnd = yv("end", l, Dt, B, nt, Ne, 0, w), w && (ln = Mt.quickSetter([Qe, De], B.a, Xs)), !Z && !(rc.length && _h(U, "fixedMarkers") === !0) && (Wj(Y ? Zr : U), Mt.set([ie, qe], { force3D: !0 }), vt = Mt.quickSetter(ie, B.a, Xs), at = Mt.quickSetter(qe, B.a, Xs)) } if (w) { var $e = w.vars.onUpdate, Xt = w.vars.onUpdateParams; w.eventCallback("onUpdate", function () { D.update(0, 0, 1), $e && $e.apply(w, Xt || []) }) } if (D.previous = function () { return Bn[Bn.indexOf(D) - 1] }, D.next = function () { return Bn[Bn.indexOf(D) + 1] }, D.revert = function (ft, xn) { if (!xn) return D.kill(!0); var Vt = ft !== !1 || !D.enabled, Yt = ua; Vt !== D.isReverted && (Vt && (Ye = Math.max(we(), D.scroll.rec || 0), Fe = D.progress, jt = i && i.progress()), Qe && [Qe, De, ie, qe].forEach(function (Mr) { return Mr.style.display = Vt ? "none" : "block" }), Vt && (ua = D, D.update(Vt)), m && (!T || !D.isActive) && (Vt ? Kj(m, fe, mn) : Ix(m, fe, yl(m), st)), Vt || D.update(Vt), ua = Yt, D.isReverted = Vt) }, D.refresh = function (ft, xn, Vt, Yt) { if (!((ua || !D.enabled) && !xn)) { if (m && ft && Tl) { Ls(n, "scrollEnd", RN); return } !La && V && V(D), ua = D, ge.tween && !Vt && (ge.tween.kill(), ge.tween = 0), j && j.pause(), v && i && i.revert({ kill: !1 }).invalidate(), D.isReverted || D.revert(!0, !0), D._subPinOffset = !1; var Mr = J(), sn = Ee(), vr = w ? w.duration() : Zc(U, B), Fi = xt <= .01, ur = 0, rr = Yt || 0, H = Bd(Vt) ? Vt.end : r.end, ae = r.endTrigger || d, ve = Bd(Vt) ? Vt.start : r.start || (r.start === 0 || !d ? 0 : m ? "0 0" : "0 100%"), he = D.pinnedContainer = r.pinnedContainer && $a(r.pinnedContainer, D), Te = d && Math.max(0, Bn.indexOf(D)) || 0, rt = Te, ct, Ct, Nt, nn, yt, pt, hn, Vn, oi, Vr, gn, gt, an; for (L && Bd(Vt) && (gt = Mt.getProperty(ie, B.p), an = Mt.getProperty(qe, B.p)); rt--;)pt = Bn[rt], pt.end || pt.refresh(0, 1) || (ua = D), hn = pt.pin, hn && (hn === d || hn === m || hn === he) && !pt.isReverted && (Vr || (Vr = []), Vr.unshift(pt), pt.revert(!0, !0)), pt !== Bn[rt] && (Te--, rt--); for (Na(ve) && (ve = ve(D)), ve = YM(ve, "start", D), de = tb(ve, d, Mr, B, we(), Qe, ie, D, sn, Q, Z, vr, w, D._startClamp && "_startClamp") || (m ? -.001 : 0), Na(H) && (H = H(D)), Ro(H) && !H.indexOf("+=") && (~H.indexOf(" ") ? H = (Ro(ve) ? ve.split(" ")[0] : "") + H : (ur = e6(H.substr(2), Mr), H = Ro(ve) ? ve : (w ? Mt.utils.mapRange(0, w.duration(), w.scrollTrigger.start, w.scrollTrigger.end, de) : de) + ur, ae = d)), H = YM(H, "end", D), Ce = Math.max(de, tb(H || (ae ? "100% 0" : vr), ae, Mr, B, we() + ur, De, qe, D, sn, Q, Z, vr, w, D._endClamp && "_endClamp")) || -.001, ur = 0, rt = Te; rt--;)pt = Bn[rt], hn = pt.pin, hn && pt.start - pt._pinPush <= de && !w && pt.end > 0 && (ct = pt.end - (D._startClamp ? Math.max(0, pt.start) : pt.start), (hn === d && pt.start - pt._pinPush < de || hn === he) && isNaN(ve) && (ur += ct * (1 - pt.progress)), hn === m && (rr += ct)); if (de += ur, Ce += ur, D._startClamp && (D._startClamp += ur), D._endClamp && !La && (D._endClamp = Ce || -.001, Ce = Math.min(Ce, Zc(U, B))), xt = Ce - de || (de -= .01) && .001, Fi && (Fe = Mt.utils.clamp(0, 1, Mt.utils.normalize(de, Ce, Ye))), D._pinPush = rr, Qe && ur && (ct = {}, ct[B.a] = "+=" + ur, he && (ct[B.p] = "-=" + we()), Mt.set([Qe, De], ct)), m) ct = yl(m), nn = B === ms, Nt = we(), ut = parseFloat(Ue(B.a)) + rr, !vr && Ce > 1 && (gn = (Y ? ci.scrollingElement || lu : U).style, gn = { style: gn, value: gn["overflow" + B.a.toUpperCase()] }, Y && yl(Zr)["overflow" + B.a.toUpperCase()] !== "scroll" && (gn.style["overflow" + B.a.toUpperCase()] = "scroll")), Ix(m, fe, ct), O = xv(m), Ct = Yc(m, !0), Vn = Z && Dh(U, nn ? ka : ms)(), g && (st = [g + B.os2, xt + rr + Xs], st.t = fe, rt = g === ns ? B9(m, B) + xt + rr : 0, rt && st.push(B.d, rt + Xs), w3(st), he && Bn.forEach(function (Lt) { Lt.pin === he && Lt.vars.pinSpacing !== !1 && (Lt._subPinOffset = !0) }), Z && we(Ye)), Z && (yt = { top: Ct.top + (nn ? Nt - de : Vn) + Xs, left: Ct.left + (nn ? Vn : Nt - de) + Xs, boxSizing: "border-box", position: "fixed" }, yt[lp] = yt["max" + J3] = Math.ceil(Ct.width) + Xs, yt[up] = yt["max" + CS] = Math.ceil(Ct.height) + Xs, yt[vl] = yt[vl + nA] = yt[vl + eA] = yt[vl + rA] = yt[vl + tA] = "0", yt[ns] = ct[ns], yt[ns + nA] = ct[ns + nA], yt[ns + eA] = ct[ns + eA], yt[ns + rA] = ct[ns + rA], yt[ns + tA] = ct[ns + tA], X = Zj(mn, yt, T), La && we(0)), i ? (oi = i._initted, Ex(1), i.render(i.duration(), !0, !0), Ge = Ue(B.a) - ut + xt + rr, dt = Math.abs(xt - Ge) > 1, Z && dt && X.splice(X.length - 2, 2), i.render(0, !0, !0), oi || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), Ex(0)) : Ge = xt, gn && (gn.value ? gn.style["overflow" + B.a.toUpperCase()] = gn.value : gn.style.removeProperty("overflow-" + B.a)); else if (d && we() && !w) for (Ct = d.parentNode; Ct && Ct !== Zr;)Ct._pinOffset && (de -= Ct._pinOffset, Ce -= Ct._pinOffset), Ct = Ct.parentNode; Vr && Vr.forEach(function (Lt) { return Lt.revert(!1, !0) }), D.start = de, D.end = Ce, Oe = K = La ? Ye : we(), !w && !La && (Oe < Ye && we(Ye), D.scroll.rec = 0), D.revert(!1, !0), Be = Fa(), ze && (xe = -1, ze.restart(!0)), ua = 0, i && F && (i._initted || jt) && i.progress() !== jt && i.progress(jt || 0, !0).render(i.time(), !0, !0), (Fi || Fe !== D.progress || w) && (i && !F && i.totalProgress(w && de < -.001 && !Fe ? Mt.utils.normalize(de, Ce, 0) : Fe, !0), D.progress = Fi || (Oe - de) / xt === Fe ? 0 : Fe), m && g && (fe._pinOffset = Math.round(D.progress * Ge)), j && j.invalidate(), isNaN(gt) || (gt -= Mt.getProperty(ie, B.p), an -= Mt.getProperty(qe, B.p), _v(ie, B, gt), _v(Qe, B, gt - (Yt || 0)), _v(qe, B, an), _v(De, B, an - (Yt || 0))), Fi && !La && D.update(), c && !La && !it && (it = !0, c(D), it = !1) } }, D.getVelocity = function () { return (we() - K) / (Fa() - Z5) * 1e3 || 0 }, D.endAnimation = function () { Km(D.callbackAnimation), i && (j ? j.progress(1) : i.paused() ? F || Km(i, D.direction < 0, 1) : Km(i, i.reversed())) }, D.labelToScroll = function (ft) { return i && i.labels && (de || D.refresh() || de) + i.labels[ft] / i.duration() * xt || 0 }, D.getTrailing = function (ft) { var xn = Bn.indexOf(D), Vt = D.direction > 0 ? Bn.slice(0, xn).reverse() : Bn.slice(xn + 1); return (Ro(ft) ? Vt.filter(function (Yt) { return Yt.vars.preventOverlaps === ft }) : Vt).filter(function (Yt) { return D.direction > 0 ? Yt.end <= de : Yt.start >= Ce }) }, D.update = function (ft, xn, Vt) { if (!(w && !Vt && !ft)) { var Yt = La === !0 ? Ye : D.scroll(), Mr = ft ? 0 : (Yt - de) / xt, sn = Mr < 0 ? 0 : Mr > 1 ? 1 : Mr || 0, vr = D.progress, Fi, ur, rr, H, ae, ve, he, Te; if (xn && (K = Oe, Oe = w ? we() : Yt, C && (Ke = Ie, Ie = i && !F ? i.totalProgress() : sn)), y && !sn && m && !ua && !pv && Tl && de < Yt + (Yt - K) / (Fa() - Z5) * y && (sn = 1e-4), sn !== vr && D.enabled) { if (Fi = D.isActive = !!sn && sn < 1, ur = !!vr && vr < 1, ve = Fi !== ur, ae = ve || !!sn != !!vr, D.direction = sn > vr ? 1 : -1, D.progress = sn, ae && !ua && (rr = sn && !vr ? 0 : sn === 1 ? 1 : vr === 1 ? 2 : 3, F && (H = !ve && $[rr + 1] !== "none" && $[rr + 1] || $[rr], Te = i && (H === "complete" || H === "reset" || H in i))), b && (ve || Te) && (Te || h || !i) && (Na(b) ? b(D) : D.getTrailing(b).forEach(function (Nt) { return Nt.endAnimation() })), F || (j && !ua && !pv ? (j._dp._time - j._start !== j._time && j.render(j._dp._time - j._start), j.resetTo ? j.resetTo("totalProgress", sn, i._tTime / i._tDur) : (j.vars.totalProgress = sn, j.invalidate().restart())) : i && i.totalProgress(sn, !!(ua && (Be || ft)))), m) { if (ft && g && (fe.style[g + B.os2] = Ae), !Z) We(Mg(ut + Ge * sn)); else if (ae) { if (he = !ft && sn > vr && Ce + 1 > Yt && Yt + 1 >= Zc(U, B), T) if (!ft && (Fi || he)) { var rt = Yc(m, !0), ct = Yt - de; nb(m, Zr, rt.top + (B === ms ? ct : 0) + Xs, rt.left + (B === ms ? 0 : ct) + Xs) } else nb(m, fe); w3(Fi || he ? X : O), dt && sn < 1 && Fi || We(ut + (sn === 1 && !he ? Ge : 0)) } } C && !ge.tween && !ua && !pv && ze.restart(!0), o && (ve || x && sn && (sn < 1 || !Cx)) && ry(o.targets).forEach(function (Nt) { return Nt.classList[Fi || x ? "add" : "remove"](o.className) }), a && !F && !ft && a(D), ae && !ua ? (F && (Te && (H === "complete" ? i.pause().totalProgress(1) : H === "reset" ? i.restart(!0).pause() : H === "restart" ? i.restart(!0) : i[H]()), a && a(D)), (ve || !Cx) && (u && ve && Tx(D, u), ne[rr] && Tx(D, ne[rr]), x && (sn === 1 ? D.kill(!1, 1) : ne[rr] = 0), ve || (rr = sn === 1 ? 1 : 3, ne[rr] && Tx(D, ne[rr]))), R && !Fi && Math.abs(D.getVelocity()) > ($5(R) ? R : 2500) && (Km(D.callbackAnimation), j ? j.progress(1) : Km(i, H === "reverse" ? 1 : !sn, 1))) : F && a && !ua && a(D) } if (at) { var Ct = w ? Yt / w.duration() * (w._caScrollDist || 0) : Yt; vt(Ct + (ie._isFlipped ? 1 : 0)), at(Ct) } ln && ln(-Yt / w.duration() * (w._caScrollDist || 0)) } }, D.enable = function (ft, xn) { D.enabled || (D.enabled = !0, Ls(U, "resize", bg), Y || Ls(U, "scroll", u0), V && Ls(n, "refreshInit", V), ft !== !1 && (D.progress = Fe = 0, Oe = K = xe = we()), xn !== !1 && D.refresh()) }, D.getTween = function (ft) { return ft && ge ? ge.tween : j }, D.setPositions = function (ft, xn, Vt, Yt) { if (w) { var Mr = w.scrollTrigger, sn = w.duration(), vr = Mr.end - Mr.start; ft = Mr.start + vr * ft / sn, xn = Mr.start + vr * xn / sn } D.refresh(!1, !1, { start: jM(ft, Vt && !!D._startClamp), end: jM(xn, Vt && !!D._endClamp) }, Yt), D.update() }, D.adjustPinSpacing = function (ft) { if (st && ft) { var xn = st.indexOf(B.d) + 1; st[xn] = parseFloat(st[xn]) + ft + Xs, st[1] = parseFloat(st[1]) + ft + Xs, w3(st) } }, D.disable = function (ft, xn) { if (D.enabled && (ft !== !1 && D.revert(!0, !0), D.enabled = D.isActive = !1, xn || j && j.pause(), Ye = 0, tt && (tt.uncache = 1), V && Ds(n, "refreshInit", V), ze && (ze.pause(), ge.tween && ge.tween.kill() && (ge.tween = 0)), !Y)) { for (var Vt = Bn.length; Vt--;)if (Bn[Vt].scroller === U && Bn[Vt] !== D) return; Ds(U, "resize", bg), Y || Ds(U, "scroll", u0) } }, D.kill = function (ft, xn) { D.disable(ft, xn), j && !xn && j.kill(), l && delete R9[l]; var Vt = Bn.indexOf(D); Vt >= 0 && Bn.splice(Vt, 1), Vt === Da && n6 > 0 && Da--, Vt = 0, Bn.forEach(function (Yt) { return Yt.scroller === D.scroller && (Vt = 1) }), Vt || La || (D.scroll.rec = 0), i && (i.scrollTrigger = null, ft && i.revert({ kill: !1 }), xn || i.kill()), Qe && [Qe, De, ie, qe].forEach(function (Yt) { return Yt.parentNode && Yt.parentNode.removeChild(Yt) }), iA === D && (iA = 0), m && (tt && (tt.uncache = 1), Vt = 0, Bn.forEach(function (Yt) { return Yt.pin === m && Vt++ }), Vt || (tt.spacer = 0)), r.onKill && r.onKill(D) }, Bn.push(D), D.enable(!1, !1), fn && fn(D), i && i.add && !xt) { var Qt = D.update; D.update = function () { D.update = Qt, de || Ce || D.refresh() }, Mt.delayedCall(.01, D.update), xt = .01, de = Ce = 0 } else D.refresh(); m && Jj() }, n.register = function (r) { return U0 || (Mt = r || TN(), SN() && window.document && n.enable(), U0 = Ig), U0 }, n.defaults = function (r) { if (r) for (var i in r) vv[i] = r[i]; return vv }, n.disable = function (r, i) { Ig = 0, Bn.forEach(function (a) { return a[i ? "kill" : "disable"](r) }), Ds(Yn, "wheel", u0), Ds(ci, "scroll", u0), clearInterval(dv), Ds(ci, "touchcancel", Xu), Ds(Zr, "touchstart", Xu), gv(Ds, ci, "pointerdown,touchstart,mousedown", JM), gv(Ds, ci, "pointerup,touchend,mouseup", KM), ny.kill(), mv(Ds); for (var s = 0; s < Nn.length; s += 3)Av(Ds, Nn[s], Nn[s + 1]), Av(Ds, Nn[s], Nn[s + 2]) }, n.enable = function () { if (Yn = window, ci = document, lu = ci.documentElement, Zr = ci.body, Mt && (ry = Mt.utils.toArray, o3 = Mt.utils.clamp, b9 = Mt.core.context || Xu, Ex = Mt.core.suppressOverwrites || Xu, yS = Yn.history.scrollRestoration || "auto", P9 = Yn.pageYOffset, Mt.core.globals("ScrollTrigger", n), Zr)) { Ig = 1, T3 = document.createElement("div"), T3.style.height = "100vh", T3.style.position = "absolute", LN(), Hj(), ss.register(Mt), n.isTouch = ss.isTouch, Jf = ss.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Ls(Yn, "wheel", u0), vN = [Yn, ci, lu, Zr], Mt.matchMedia ? (n.matchMedia = function (l) { var u = Mt.matchMedia(), c; for (c in l) u.add(c, l[c]); return u }, Mt.addEventListener("matchMediaInit", function () { return TS() }), Mt.addEventListener("matchMediaRevert", function () { return PN() }), Mt.addEventListener("matchMedia", function () { jd(0, 1), wp("matchMedia") }), Mt.matchMedia("(orientation: portrait)", function () { return wx(), wx })) : console.warn("Requires GSAP 3.11.0 or later"), wx(), Ls(ci, "scroll", u0); var r = Zr.style, i = r.borderTopStyle, s = Mt.core.Animation.prototype, a, o; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), r.borderTopStyle = "solid", a = Yc(Zr), ms.m = Math.round(a.top + ms.sc()) || 0, ka.m = Math.round(a.left + ka.sc()) || 0, i ? r.borderTopStyle = i : r.removeProperty("border-top-style"), dv = setInterval($M, 250), Mt.delayedCall(.5, function () { return pv = 0 }), Ls(ci, "touchcancel", Xu), Ls(Zr, "touchstart", Xu), gv(Ls, ci, "pointerdown,touchstart,mousedown", JM), gv(Ls, ci, "pointerup,touchend,mouseup", KM), M9 = Mt.utils.checkPrefix("transform"), r6.push(M9), U0 = Fa(), ny = Mt.delayedCall(.2, jd).pause(), G0 = [ci, "visibilitychange", function () { var l = Yn.innerWidth, u = Yn.innerHeight; ci.hidden ? (WM = l, XM = u) : (WM !== l || XM !== u) && bg() }, ci, "DOMContentLoaded", jd, Yn, "load", jd, Yn, "resize", bg], mv(Ls), Bn.forEach(function (l) { return l.enable(0, 1) }), o = 0; o < Nn.length; o += 3)Av(Ds, Nn[o], Nn[o + 1]), Av(Ds, Nn[o], Nn[o + 2]) } }, n.config = function (r) { "limitCallbacks" in r && (Cx = !!r.limitCallbacks); var i = r.syncInterval; i && clearInterval(dv) || (dv = i) && setInterval($M, i), "ignoreMobileResize" in r && (_N = n.isTouch === 1 && r.ignoreMobileResize), "autoRefreshEvents" in r && (mv(Ds) || mv(Ls, r.autoRefreshEvents || "none"), xN = (r.autoRefreshEvents + "").indexOf("resize") === -1) }, n.scrollerProxy = function (r, i) { var s = $a(r), a = Nn.indexOf(s), o = Sp(s); ~a && Nn.splice(a, o ? 6 : 2), i && (o ? rc.unshift(Yn, i, Zr, i, lu, i) : rc.unshift(s, i)) }, n.clearMatchMedia = function (r) { Bn.forEach(function (i) { return i._ctx && i._ctx.query === r && i._ctx.kill(!0, !0) }) }, n.isInViewport = function (r, i, s) { var a = (Ro(r) ? $a(r) : r).getBoundingClientRect(), o = a[s ? lp : up] * i || 0; return s ? a.right - o > 0 && a.left + o < Yn.innerWidth : a.bottom - o > 0 && a.top + o < Yn.innerHeight }, n.positionInViewport = function (r, i, s) { Ro(r) && (r = $a(r)); var a = r.getBoundingClientRect(), o = a[s ? lp : up], l = i == null ? o / 2 : i in iy ? iy[i] * o : ~i.indexOf("%") ? parseFloat(i) * o / 100 : parseFloat(i) || 0; return s ? (a.left + l) / Yn.innerWidth : (a.top + l) / Yn.innerHeight }, n.killAll = function (r) { if (Bn.slice(0).forEach(function (s) { return s.vars.id !== "ScrollSmoother" && s.kill() }), r !== !0) { var i = Tp.killAll || []; Tp = {}, i.forEach(function (s) { return s() }) } }, n }(); Qn.version = "3.12.2"; Qn.saveStyles = function (n) { return n ? ry(n).forEach(function (e) { if (e && e.style) { var t = bo.indexOf(e); t >= 0 && bo.splice(t, 5), bo.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Mt.core.getCache(e), b9()) } }) : bo }; Qn.revert = function (n, e) { return TS(!n, e) }; Qn.create = function (n, e) { return new Qn(n, e) }; Qn.refresh = function (n) { return n ? bg() : (U0 || Qn.register()) && jd(!0) }; Qn.update = function (n) { return ++Nn.cache && rf(n === !0 ? 2 : 0) }; Qn.clearScrollMemory = DN; Qn.maxScroll = function (n, e) { return Zc(n, e ? ka : ms) }; Qn.getScrollFunc = function (n, e) { return Dh($a(n), e ? ka : ms) }; Qn.getById = function (n) { return R9[n] }; Qn.getAll = function () { return Bn.filter(function (n) { return n.vars.id !== "ScrollSmoother" }) }; Qn.isScrolling = function () { return !!Tl }; Qn.snapDirectional = SS; Qn.addEventListener = function (n, e) { var t = Tp[n] || (Tp[n] = []); ~t.indexOf(e) || t.push(e) }; Qn.removeEventListener = function (n, e) { var t = Tp[n], r = t && t.indexOf(e); r >= 0 && t.splice(r, 1) }; Qn.batch = function (n, e) { var t = [], r = {}, i = e.interval || .016, s = e.batchMax || 1e9, a = function (u, c) { var h = [], d = [], m = Mt.delayedCall(i, function () { c(h, d), h = [], d = [] }).pause(); return function (g) { h.length || m.restart(!0), h.push(g.trigger), d.push(g), s <= h.length && m.progress(1) } }, o; for (o in e) r[o] = o.substr(0, 2) === "on" && Na(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o]; return Na(s) && (s = s(), Ls(Qn, "refresh", function () { return s = e.batchMax() })), ry(n).forEach(function (l) { var u = {}; for (o in r) u[o] = r[o]; u.trigger = l, t.push(Qn.create(u)) }), t }; var ib = function (e, t, r, i) { return t > i ? e(i) : t < 0 && e(0), r > i ? (i - t) / (r - t) : r < 0 ? t / (t - r) : 1 }, Mx = function n(e, t) { t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (ss.isTouch ? " pinch-zoom" : "") : "none", e === lu && n(Zr, t) }, Ev = { auto: 1, scroll: 1 }, eJ = function (e) { var t = e.event, r = e.target, i = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, a = s._gsap || Mt.core.getCache(s), o = Fa(), l; if (!a._isScrollT || o - a._isScrollT > 2e3) { for (; s && s !== Zr && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(Ev[(l = yl(s)).overflowY] || Ev[l.overflowX]));)s = s.parentNode; a._isScroll = s && s !== r && !Sp(s) && (Ev[(l = yl(s)).overflowY] || Ev[l.overflowX]), a._isScrollT = o } (a._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0) }, kN = function (e, t, r, i) { return ss.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: i = i && eJ, onPress: i, onDrag: i, onScroll: i, onEnable: function () { return r && Ls(ci, ss.eventTypes[0], ab, !1, !0) }, onDisable: function () { return Ds(ci, ss.eventTypes[0], ab, !0) } }) }, tJ = /(input|label|select|textarea)/i, sb, ab = function (e) { var t = tJ.test(e.target.tagName); (t || sb) && (e._gsapAllow = !0, sb = t) }, nJ = function (e) { Bd(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t = e, r = t.normalizeScrollX, i = t.momentum, s = t.allowNestedScroll, a = t.onRelease, o, l, u = $a(e.target) || lu, c = Mt.core.globals().ScrollSmoother, h = c && c.get(), d = Jf && (e.content && $a(e.content) || h && e.content !== !1 && !h.smooth() && h.content()), m = Dh(u, ms), g = Dh(u, ka), v = 1, y = (ss.isTouch && Yn.visualViewport ? Yn.visualViewport.scale * Yn.visualViewport.width : Yn.outerWidth) / Yn.innerWidth, A = 0, _ = Na(i) ? function () { return i(o) } : function () { return i || 2.8 }, x, C, T = kN(u, e.type, !0, s), I = function () { return C = !1 }, w = Xu, R = Xu, b = function () { l = Zc(u, ms), R = o3(Jf ? 1 : 0, l), r && (w = o3(0, Zc(u, ka))), x = cp }, B = function () { d._gsap.y = Mg(parseFloat(d._gsap.y) + m.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", m.offset = m.cacheID = 0 }, F = function () { if (C) { requestAnimationFrame(I); var L = Mg(o.deltaY / 2), Q = R(m.v - L); if (d && Q !== m.v + m.offset) { m.offset = Q - m.v; var D = Mg((parseFloat(d && d._gsap.y) || 0) - m.offset); d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + D + ", 0, 1)", d._gsap.y = D + "px", m.cacheID = Nn.cache, rf() } return !0 } m.offset && B(), C = !0 }, U, G, Y, Z, ne = function () { b(), U.isActive() && U.vars.scrollY > l && (m() > l ? U.progress(1) && m(l) : U.resetTo("scrollY", l)) }; return d && Mt.set(d, { y: "+=0" }), e.ignoreCheck = function ($) { return Jf && $.type === "touchmove" && F() || v > 1.05 && $.type !== "touchstart" || o.isGesturing || $.touches && $.touches.length > 1 }, e.onPress = function () { C = !1; var $ = v; v = Mg((Yn.visualViewport && Yn.visualViewport.scale || 1) / y), U.pause(), $ !== v && Mx(u, v > 1.01 ? !0 : r ? !1 : "x"), G = g(), Y = m(), b(), x = cp }, e.onRelease = e.onGestureStart = function ($, L) { if (m.offset && B(), !L) Z.restart(!0); else { Nn.cache++; var Q = _(), D, V; r && (D = g(), V = D + Q * .05 * -$.velocityX / .227, Q *= ib(g, D, V, Zc(u, ka)), U.vars.scrollX = w(V)), D = m(), V = D + Q * .05 * -$.velocityY / .227, Q *= ib(m, D, V, Zc(u, ms)), U.vars.scrollY = R(V), U.invalidate().duration(Q).play(.01), (Jf && U.vars.scrollY >= l || D >= l - 1) && Mt.to({}, { onUpdate: ne, duration: Q }) } a && a($) }, e.onWheel = function () { U._ts && U.pause(), Fa() - A > 1e3 && (x = 0, A = Fa()) }, e.onChange = function ($, L, Q, D, V) { if (cp !== x && b(), L && r && g(w(D[2] === L ? G + ($.startX - $.x) : g() + L - D[1])), Q) { m.offset && B(); var J = V[2] === Q, Ee = J ? Y + $.startY - $.y : m() + Q - V[1], xe = R(Ee); J && Ee !== xe && (Y += xe - Ee), m(xe) } (Q || L) && rf() }, e.onEnable = function () { Mx(u, r ? !1 : "x"), Qn.addEventListener("refresh", ne), Ls(Yn, "resize", ne), m.smooth && (m.target.style.scrollBehavior = "auto", m.smooth = g.smooth = !1), T.enable() }, e.onDisable = function () { Mx(u, !0), Ds(Yn, "resize", ne), Qn.removeEventListener("refresh", ne), T.kill() }, e.lockAxis = e.lockAxis !== !1, o = new ss(e), o.iOS = Jf, Jf && !m() && m(1), Jf && Mt.ticker.add(Xu), Z = o._dc, U = Mt.to(o, { ease: "power4", paused: !0, scrollX: r ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: FN(m, m(), function () { return U.pause() }) }, onUpdate: rf, onComplete: Z.vars.onComplete }), o }; Qn.sort = function (n) { return Bn.sort(n || function (e, t) { return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6) }) }; Qn.observe = function (n) { return new ss(n) }; Qn.normalizeScroll = function (n) { if (typeof n > "u") return Mo; if (n === !0 && Mo) return Mo.enable(); if (n === !1) return Mo && Mo.kill(); var e = n instanceof ss ? n : nJ(n); return Mo && Mo.target === e.target && Mo.kill(), Sp(e.target) && (Mo = e), e }; Qn.core = { _getVelocityProp: I9, _inputObserver: kN, _scrollers: Nn, _proxies: rc, bridge: { ss: function () { Tl || wp("scrollStart"), Tl = Fa() }, ref: function () { return ua } } }; TN() && Mt.registerPlugin(Qn); const rJ = () => { const n = [ue.useRef(null), ue.useRef(null), ue.useRef(null), ue.useRef(null), ue.useRef(null), ue.useRef(null), ue.useRef(null)]; function e() { document.querySelectorAll(".c1").forEach(i => { i.classList.toggle("edcard") }) } function t() { document.querySelectorAll(".c2").forEach(i => { i.classList.toggle("edcard") }) } return ue.useEffect(() => { pr.registerPlugin(Qn); const r = window.innerWidth; let i = pr.context(() => { let s = pr.timeline({ scrollTrigger: { trigger: n[0].current, start: "top 60%", end: "top 60%" } }), a = pr.timeline({ scrollTrigger: { trigger: n[3].current, start: "top 70%", end: "top 70%" } }); pr.timeline(), r > 992 ? (s.addLabel("flayer").from(n[0].current, { opacity: 0, x: -50, y: -50, duration: .7 }, "flayer").from(n[1].current, { opacity: 0, y: -50, duration: .7 }, "flayer").from(n[2].current, { opacity: 0, x: 50, y: -50, duration: .7 }, "flayer").add(() => e()), a.addLabel("slayer").from(n[3].current, { opacity: 0, x: -50, y: 50, duration: .7 }, "slayer").from(n[4].current, { opacity: 0, y: 50, duration: .7 }, "slayer").from(n[5].current, { opacity: 0, x: 50, y: 50, duration: .7 }, "slayer").add(() => t())) : (pr.from(n[0].current, { scrollTrigger: { trigger: n[0].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[1].current, { scrollTrigger: { trigger: n[1].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[2].current, { scrollTrigger: { trigger: n[2].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[3].current, { scrollTrigger: { trigger: n[3].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[4].current, { scrollTrigger: { trigger: n[4].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[5].current, { scrollTrigger: { trigger: n[5].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 }), pr.from(n[6].current, { scrollTrigger: { trigger: n[6].current, start: "top 60%", end: "top 60%" }, opacity: 0, scale: .5 })) }); return () => { i.revert() } }, []), re.jsx("div", { className: "App gamemods", children: re.jsxs("div", { className: "modes-con", children: [re.jsx(cN, { highlight: "TaskVerse", text: "Game mods" }), re.jsxs("div", { className: "layer-1 layer", children: [re.jsxs("div", { ref: n[0], className: "card c1", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: Fj, alt: "" }) }), re.jsx("h3", { className: "ht", children: "Survival" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.18.2"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 20 Online Player"] }) })] }), re.jsxs("div", { ref: n[1], className: "card c1", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: kj, alt: "" }) }), re.jsx("h3", { className: "ht", children: "PvP" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.16.4"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 45 Online Player"] }) })] }), re.jsxs("div", { ref: n[2], className: "card c1", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: Nj, alt: "" }) }), re.jsx("h3", { className: "ht", children: "SkyBlock" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.8.9"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 20 Online Player"] }) })] }), re.jsxs("div", { ref: n[6], className: "card c2 bed-t", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: HM, alt: "" }) }), re.jsx("h3", { className: "ht", children: "BedWars" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.8.9"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 20 Online Player"] }) })] })] }), re.jsxs("div", { className: "layer-2 rr layer", children: [re.jsxs("div", { ref: n[3], className: "card c2", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: Oj, alt: "" }) }), re.jsx("h3", { className: "ht", children: "Creative" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.8.9"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), "  20 Online Player"] }) })] }), re.jsxs("div", { ref: n[4], className: "card c2", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: Uj, alt: "" }) }), re.jsx("h3", { className: "ht", children: "TNT Run" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.8.9"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 20 Online Player"] }) })] }), re.jsxs("div", { ref: n[5], className: "card c2 bed-m", children: [re.jsx("div", { children: re.jsx("img", { className: "cri", src: HM, alt: "" }) }), re.jsx("h3", { className: "ht", children: "BedWars" }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { className: "fts", icon: dd }), " 1.8.9"] }) }), re.jsx("div", { children: re.jsxs("span", { className: "teen", children: [re.jsx(si, { icon: Vc }), " 20 Online Player"] }) })] })] })] }) }) }, iJ = () => { const n = ue.useRef(null), e = ue.useRef(null); return ue.useEffect(() => { let t = pr.context(() => { pr.timeline({ scrollTrigger: { trigger: n.current, start: "top 60%", end: "top 60%" } }).addLabel("sm").from(n.current, { delay: .7, scale: .5, opacity: 0, ease: i9.easeOut.config(1.7) }, "sm").from(e.current, { delay: 1, scale: .5, opacity: 0, ease: i9.easeOut.config(1.7) }, "sm") }); return () => t.revert() }, []), re.jsxs("div", { className: "txt-con", children: [re.jsx(cN, { highlight: "Taskify" }), re.jsx("h2", { ref: n, className: "tasktitle", children: "Empowering Digital Excellence: Taskify's Web Development Expertise" }), re.jsx("p", { ref: e, children: "Taskify is a dynamic team of seasoned web development experts committed to crafting high-performance, feature-rich websites. With a relentless dedication to excellence, we transform visionary concepts into sleek, user-centric digital solutions. Our agile approach and diverse skill set enable us to tackle even the most complex projects with precision, delivering results that exceed expectations. At Taskify, we merge innovation with expertise to empower businesses and individuals through the limitless potential of the web. Join us on the journey to redefine digital experiences." })] }) }, sJ = "/Taskverse/assets/taskifysaturn-f451f4df.png", aJ = () => { const n = ue.useRef(null); return ue.useEffect(() => { let e = pr.context(() => { pr.from(n.current, { scrollTrigger: { trigger: n.current, start: "top 60%", end: "top 60%" }, scale: .5, opacity: 0, ease: i9.easeOut.config(1.7) }) }); return () => e.revert() }, []), re.jsx("div", { className: "task-con", children: re.jsx("img", { ref: n, className: "sat", src: sJ, alt: "" }) }) }, oJ = () => re.jsx(re.Fragment, { children: re.jsx("div", { className: "about abts", children: re.jsx("div", { className: "app ", children: re.jsxs("div", { className: "intro", children: [re.jsx(iJ, {}), re.jsx(aJ, {})] }) }) }) });/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Su = "156", Rd = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Pd = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, NN = 0, L9 = 1, ON = 2, lJ = 3, UN = 0, t8 = 1, sA = 2, iu = 3, pc = 0, pa = 1, cu = 2, uJ = 2, On = 0, ic = 1, XA = 2, F9 = 3, k9 = 4, YA = 5, ko = 100, GN = 101, QN = 102, N9 = 103, O9 = 104, K3 = 200, HN = 201, zN = 202, VN = 203, jA = 204, JA = 205, n8 = 206, WN = 207, r8 = 208, XN = 209, YN = 210, jN = 0, JN = 1, KN = 2, sy = 3, qN = 4, ZN = 5, $N = 6, eO = 7, B1 = 0, tO = 1, nO = 2, wl = 0, rO = 1, iO = 2, sO = 3, wS = 4, aO = 5, i8 = 300, gf = 301, Lh = 302, KA = 303, qA = 304, Am = 306, Pl = 1e3, pi = 1001, q3 = 1002, cn = 1003, ZA = 1004, cJ = 1004, I3 = 1005, fJ = 1005, wr = 1006, s8 = 1007, hJ = 1007, Dl = 1008, dJ = 1008, As = 1009, oO = 1010, lO = 1011, Np = 1012, IS = 1013, $c = 1014, Oa = 1015, Wi = 1016, MS = 1017, bS = 1018, sf = 1020, uO = 1021, Ri = 1023, BS = 1024, cO = 1025, Eh = 1026, Fh = 1027, Jd = 1028, RS = 1029, l3 = 1030, PS = 1031, DS = 1033, M3 = 33776, s6 = 33777, a6 = 33778, b3 = 33779, $A = 35840, U9 = 35841, e1 = 35842, G9 = 35843, a8 = 36196, t1 = 37492, n1 = 37496, r1 = 37808, Q9 = 37809, H9 = 37810, z9 = 37811, V9 = 37812, W9 = 37813, X9 = 37814, Y9 = 37815, j9 = 37816, J9 = 37817, K9 = 37818, q9 = 37819, Z9 = 37820, $9 = 37821, B3 = 36492, e7 = 36494, t7 = 36495, fO = 36283, n7 = 36284, r7 = 36285, i7 = 36286, hO = 2200, dO = 2201, pO = 2202, Z3 = 2300, Ip = 2301, o6 = 2302, Kd = 2400, qd = 2401, i1 = 2402, o8 = 2500, LS = 2501, mO = 0, FS = 1, ay = 2, kS = 3e3, Ch = 3001, gO = 3200, NS = 3201, Yh = 0, AO = 1, Sh = "", Ur = "srgb", yu = "srgb-linear", R1 = "display-p3", pJ = "display-p3-linear", mJ = 0, l6 = 7680, gJ = 7681, AJ = 7682, vJ = 7683, yJ = 34055, xJ = 34056, _J = 5386, EJ = 512, CJ = 513, SJ = 514, TJ = 515, wJ = 516, IJ = 517, MJ = 518, vO = 519, yO = 512, xO = 513, _O = 514, EO = 515, CO = 516, SO = 517, TO = 518, wO = 519, s1 = 35044, sc = 35048, bJ = 35040, BJ = 35045, RJ = 35049, PJ = 35041, DJ = 35046, LJ = 35050, FJ = 35042, kJ = "100", s7 = "300 es", oy = 1035, Zu = 2e3, a1 = 2001; class mc { addEventListener(e, t) { this._listeners === void 0 && (this._listeners = {}); const r = this._listeners; r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t) } hasEventListener(e, t) { if (this._listeners === void 0) return !1; const r = this._listeners; return r[e] !== void 0 && r[e].indexOf(t) !== -1 } removeEventListener(e, t) { if (this._listeners === void 0) return; const i = this._listeners[e]; if (i !== void 0) { const s = i.indexOf(t); s !== -1 && i.splice(s, 1) } } dispatchEvent(e) { if (this._listeners === void 0) return; const r = this._listeners[e.type]; if (r !== void 0) { e.target = this; const i = r.slice(0); for (let s = 0, a = i.length; s < a; s++)i[s].call(this, e); e.target = null } } } const oa = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]; let ob = 1234567; const fp = Math.PI / 180, $3 = 180 / Math.PI; function Qo() { const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0; return (oa[n & 255] + oa[n >> 8 & 255] + oa[n >> 16 & 255] + oa[n >> 24 & 255] + "-" + oa[e & 255] + oa[e >> 8 & 255] + "-" + oa[e >> 16 & 15 | 64] + oa[e >> 24 & 255] + "-" + oa[t & 63 | 128] + oa[t >> 8 & 255] + "-" + oa[t >> 16 & 255] + oa[t >> 24 & 255] + oa[r & 255] + oa[r >> 8 & 255] + oa[r >> 16 & 255] + oa[r >> 24 & 255]).toLowerCase() } function bi(n, e, t) { return Math.max(e, Math.min(t, n)) } function OS(n, e) { return (n % e + e) % e } function NJ(n, e, t, r, i) { return r + (n - e) * (i - r) / (t - e) } function OJ(n, e, t) { return n !== e ? (t - n) / (e - n) : 0 } function aA(n, e, t) { return (1 - t) * n + t * e } function UJ(n, e, t, r) { return aA(n, e, 1 - Math.exp(-t * r)) } function GJ(n, e = 1) { return e - Math.abs(OS(n, e * 2) - e) } function QJ(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n)) } function HJ(n, e, t) { return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10)) } function zJ(n, e) { return n + Math.floor(Math.random() * (e - n + 1)) } function VJ(n, e) { return n + Math.random() * (e - n) } function WJ(n) { return n * (.5 - Math.random()) } function XJ(n) { n !== void 0 && (ob = n); let e = ob += 1831565813; return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296 } function YJ(n) { return n * fp } function jJ(n) { return n * $3 } function a7(n) { return (n & n - 1) === 0 && n !== 0 } function IO(n) { return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2)) } function ly(n) { return Math.pow(2, Math.floor(Math.log(n) / Math.LN2)) } function JJ(n, e, t, r, i) { const s = Math.cos, a = Math.sin, o = s(t / 2), l = a(t / 2), u = s((e + r) / 2), c = a((e + r) / 2), h = s((e - r) / 2), d = a((e - r) / 2), m = s((r - e) / 2), g = a((r - e) / 2); switch (i) { case "XYX": n.set(o * c, l * h, l * d, o * u); break; case "YZY": n.set(l * d, o * c, l * h, o * u); break; case "ZXZ": n.set(l * h, l * d, o * c, o * u); break; case "XZX": n.set(o * c, l * g, l * m, o * u); break; case "YXY": n.set(l * m, o * c, l * g, o * u); break; case "ZYZ": n.set(l * g, l * m, o * c, o * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } function ro(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint32Array: return n / 4294967295; case Uint16Array: return n / 65535; case Uint8Array: return n / 255; case Int32Array: return Math.max(n / 2147483647, -1); case Int16Array: return Math.max(n / 32767, -1); case Int8Array: return Math.max(n / 127, -1); default: throw new Error("Invalid component type.") } } function Sn(n, e) { switch (e.constructor) { case Float32Array: return n; case Uint32Array: return Math.round(n * 4294967295); case Uint16Array: return Math.round(n * 65535); case Uint8Array: return Math.round(n * 255); case Int32Array: return Math.round(n * 2147483647); case Int16Array: return Math.round(n * 32767); case Int8Array: return Math.round(n * 127); default: throw new Error("Invalid component type.") } } const hp = { DEG2RAD: fp, RAD2DEG: $3, generateUUID: Qo, clamp: bi, euclideanModulo: OS, mapLinear: NJ, inverseLerp: OJ, lerp: aA, damp: UJ, pingpong: GJ, smoothstep: QJ, smootherstep: HJ, randInt: zJ, randFloat: VJ, randFloatSpread: WJ, seededRandom: XJ, degToRad: YJ, radToDeg: jJ, isPowerOfTwo: a7, ceilPowerOfTwo: IO, floorPowerOfTwo: ly, setQuaternionFromProperEuler: JJ, normalize: Sn, denormalize: ro }; class Se { constructor(e = 0, t = 0) { Se.prototype.isVector2 = !0, this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e) { return this.x += e.x, this.y += e.y, this } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, r = this.y, i = e.elements; return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const r = this.dot(e) / t; return Math.acos(bi(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, r = this.y - e.y; return t * t + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const r = Math.cos(t), i = Math.sin(t), s = this.x - e.x, a = this.y - e.y; return this.x = s * r - a * i + e.x, this.y = s * i + a * r + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } class In { constructor(e, t, r, i, s, a, o, l, u) { In.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, r, i, s, a, o, l, u) } set(e, t, r, i, s, a, o, l, u) { const c = this.elements; return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = s, c[5] = l, c[6] = r, c[7] = a, c[8] = u, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, r = e.elements; return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this } extractBasis(e, t, r) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const r = e.elements, i = t.elements, s = this.elements, a = r[0], o = r[3], l = r[6], u = r[1], c = r[4], h = r[7], d = r[2], m = r[5], g = r[8], v = i[0], y = i[3], A = i[6], _ = i[1], x = i[4], C = i[7], T = i[2], I = i[5], w = i[8]; return s[0] = a * v + o * _ + l * T, s[3] = a * y + o * x + l * I, s[6] = a * A + o * C + l * w, s[1] = u * v + c * _ + h * T, s[4] = u * y + c * x + h * I, s[7] = u * A + c * C + h * w, s[2] = d * v + m * _ + g * T, s[5] = d * y + m * x + g * I, s[8] = d * A + m * C + g * w, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8]; return t * a * c - t * o * u - r * s * c + r * o * l + i * s * u - i * a * l } invert() { const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = c * a - o * u, d = o * l - c * s, m = u * s - a * l, g = t * h + r * d + i * m; if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const v = 1 / g; return e[0] = h * v, e[1] = (i * u - c * r) * v, e[2] = (o * r - i * a) * v, e[3] = d * v, e[4] = (c * t - i * l) * v, e[5] = (i * s - o * t) * v, e[6] = m * v, e[7] = (r * l - u * t) * v, e[8] = (a * t - r * s) * v, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, r, i, s, a, o) { const l = Math.cos(s), u = Math.sin(s); return this.set(r * l, r * u, -r * (l * a + u * o) + a + e, -i * u, i * l, -i * (-u * a + l * o) + o + t, 0, 0, 1), this } scale(e, t) { return this.premultiply(bx.makeScale(e, t)), this } rotate(e) { return this.premultiply(bx.makeRotation(-e)), this } translate(e, t) { return this.premultiply(bx.makeTranslation(e, t)), this } makeTranslation(e, t) { return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this } makeRotation(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this } makeScale(e, t) { return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this } equals(e) { const t = this.elements, r = e.elements; for (let i = 0; i < 9; i++)if (t[i] !== r[i]) return !1; return !0 } fromArray(e, t = 0) { for (let r = 0; r < 9; r++)this.elements[r] = e[r + t]; return this } toArray(e = [], t = 0) { const r = this.elements; return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e } clone() { return new this.constructor().fromArray(this.elements) } } const bx = new In; function MO(n) { for (let e = n.length - 1; e >= 0; --e)if (n[e] >= 65535) return !0; return !1 } const KJ = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function u3(n, e) { return new KJ[n](e) } function o1(n) { return document.createElementNS("http://www.w3.org/1999/xhtml", n) } function bO() { const n = o1("canvas"); return n.style.display = "block", n } const lb = {}; function oA(n) { n in lb || (lb[n] = !0, console.warn(n)) } function R3(n) { return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4) } function Bx(n) { return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055 } const qJ = new In().fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]), ZJ = new In().fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]); function $J(n) { return n.convertSRGBToLinear().applyMatrix3(ZJ) } function eK(n) { return n.applyMatrix3(qJ).convertLinearToSRGB() } const tK = { [yu]: n => n, [Ur]: n => n.convertSRGBToLinear(), [R1]: $J }, nK = { [yu]: n => n, [Ur]: n => n.convertLinearToSRGB(), [R1]: eK }, fl = { enabled: !0, get legacyMode() { return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled }, set legacyMode(n) { console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !n }, get workingColorSpace() { return yu }, set workingColorSpace(n) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (n, e, t) { if (this.enabled === !1 || e === t || !e || !t) return n; const r = tK[e], i = nK[t]; if (r === void 0 || i === void 0) throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`); return i(r(n)) }, fromWorkingColorSpace: function (n, e) { return this.convert(n, this.workingColorSpace, e) }, toWorkingColorSpace: function (n, e) { return this.convert(n, e, this.workingColorSpace) } }; let c0; class US { static getDataURL(e) { if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { c0 === void 0 && (c0 = o1("canvas")), c0.width = e.width, c0.height = e.height; const r = c0.getContext("2d"); e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = c0 } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) { const t = o1("canvas"); t.width = e.width, t.height = e.height; const r = t.getContext("2d"); r.drawImage(e, 0, 0, e.width, e.height); const i = r.getImageData(0, 0, e.width, e.height), s = i.data; for (let a = 0; a < s.length; a++)s[a] = R3(s[a] / 255) * 255; return r.putImageData(i, 0, 0), t } else if (e.data) { const t = e.data.slice(0); for (let r = 0; r < t.length; r++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(R3(t[r] / 255) * 255) : t[r] = R3(t[r]); return { data: t, width: e.width, height: e.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } let rK = 0; class Zd { constructor(e = null) { this.isSource = !0, Object.defineProperty(this, "id", { value: rK++ }), this.uuid = Qo(), this.data = e, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid]; const r = { uuid: this.uuid, url: "" }, i = this.data; if (i !== null) { let s; if (Array.isArray(i)) { s = []; for (let a = 0, o = i.length; a < o; a++)i[a].isDataTexture ? s.push(Rx(i[a].image)) : s.push(Rx(i[a])) } else s = Rx(i); r.url = s } return t || (e.images[this.uuid] = r), r } } function Rx(n) { return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? US.getDataURL(n) : n.data ? { data: Array.from(n.data), width: n.width, height: n.height, type: n.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } let iK = 0; class ri extends mc { constructor(e = ri.DEFAULT_IMAGE, t = ri.DEFAULT_MAPPING, r = pi, i = pi, s = wr, a = Dl, o = Ri, l = As, u = ri.DEFAULT_ANISOTROPY, c = Sh) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: iK++ }), this.uuid = Qo(), this.name = "", this.source = new Zd(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = r, this.wrapT = i, this.magFilter = s, this.minFilter = a, this.anisotropy = u, this.format = o, this.internalFormat = null, this.type = l, this.offset = new Se(0, 0), this.repeat = new Se(1, 1), this.center = new Se(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new In, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof c == "string" ? this.colorSpace = c : (oA("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c === Ch ? Ur : Sh), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e = null) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return new this.constructor().copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = e === void 0 || typeof e == "string"; if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]; const r = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== i8) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case Pl: e.x = e.x - Math.floor(e.x); break; case pi: e.x = e.x < 0 ? 0 : 1; break; case q3: Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x); break }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case Pl: e.y = e.y - Math.floor(e.y); break; case pi: e.y = e.y < 0 ? 0 : 1; break; case q3: Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y); break }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { e === !0 && (this.version++, this.source.needsUpdate = !0) } get encoding() { return oA("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Ur ? Ch : kS } set encoding(e) { oA("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Ch ? Ur : Sh } } ri.DEFAULT_IMAGE = null; ri.DEFAULT_MAPPING = i8; ri.DEFAULT_ANISOTROPY = 1; class Jn { constructor(e = 0, t = 0, r = 0, i = 1) { Jn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, r, i) { return this.x = e, this.y = t, this.z = r, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, r = this.y, i = this.z, s = this.w, a = e.elements; return this.x = a[0] * t + a[4] * r + a[8] * i + a[12] * s, this.y = a[1] * t + a[5] * r + a[9] * i + a[13] * s, this.z = a[2] * t + a[6] * r + a[10] * i + a[14] * s, this.w = a[3] * t + a[7] * r + a[11] * i + a[15] * s, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, r, i, s; const l = e.elements, u = l[0], c = l[4], h = l[8], d = l[1], m = l[5], g = l[9], v = l[2], y = l[6], A = l[10]; if (Math.abs(c - d) < .01 && Math.abs(h - v) < .01 && Math.abs(g - y) < .01) { if (Math.abs(c + d) < .1 && Math.abs(h + v) < .1 && Math.abs(g + y) < .1 && Math.abs(u + m + A - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const x = (u + 1) / 2, C = (m + 1) / 2, T = (A + 1) / 2, I = (c + d) / 4, w = (h + v) / 4, R = (g + y) / 4; return x > C && x > T ? x < .01 ? (r = 0, i = .707106781, s = .707106781) : (r = Math.sqrt(x), i = I / r, s = w / r) : C > T ? C < .01 ? (r = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(C), r = I / i, s = R / i) : T < .01 ? (r = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(T), r = w / s, i = R / s), this.set(r, i, s, t), this } let _ = Math.sqrt((y - g) * (y - g) + (h - v) * (h - v) + (d - c) * (d - c)); return Math.abs(_) < .001 && (_ = 1), this.x = (y - g) / _, this.y = (h - v) / _, this.z = (d - c) / _, this.w = Math.acos((u + m + A - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } class BO extends mc { constructor(e = 1, t = 1, r = {}) { super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Jn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Jn(0, 0, e, t); const i = { width: e, height: t, depth: 1 }; r.encoding !== void 0 && (oA("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), r.colorSpace = r.encoding === Ch ? Ur : Sh), this.texture = new ri(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : wr, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0 } setSize(e, t, r = 1) { (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return new this.constructor().copy(this) } copy(e) { this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0; const t = Object.assign({}, e.texture.image); return this.texture.source = new Zd(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Ir extends BO { constructor(e = 1, t = 1, r = {}) { super(e, t, r), this.isWebGLRenderTarget = !0 } } class l8 extends ri { constructor(e = null, t = 1, r = 1, i = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = cn, this.minFilter = cn, this.wrapR = pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } class sK extends Ir { constructor(e = 1, t = 1, r = 1) { super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new l8(null, e, t, r), this.texture.isRenderTargetTexture = !0 } } let GS = class extends ri { constructor(e = null, t = 1, r = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = cn, this.minFilter = cn, this.wrapR = pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } }; class aK extends Ir { constructor(e = 1, t = 1, r = 1) { super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new GS(null, e, t, r), this.texture.isRenderTargetTexture = !0 } } class oK extends Ir { constructor(e = 1, t = 1, r = 1, i = {}) { super(e, t, i), this.isWebGLMultipleRenderTargets = !0; const s = this.texture; this.texture = []; for (let a = 0; a < r; a++)this.texture[a] = s.clone(), this.texture[a].isRenderTargetTexture = !0 } setSize(e, t, r = 1) { if (this.width !== e || this.height !== t || this.depth !== r) { this.width = e, this.height = t, this.depth = r; for (let i = 0, s = this.texture.length; i < s; i++)this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = r; this.dispose() } this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0; for (let t = 0, r = e.texture.length; t < r; t++)this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0; return this } } class xs { constructor(e = 0, t = 0, r = 0, i = 1) { this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i } static slerpFlat(e, t, r, i, s, a, o) { let l = r[i + 0], u = r[i + 1], c = r[i + 2], h = r[i + 3]; const d = s[a + 0], m = s[a + 1], g = s[a + 2], v = s[a + 3]; if (o === 0) { e[t + 0] = l, e[t + 1] = u, e[t + 2] = c, e[t + 3] = h; return } if (o === 1) { e[t + 0] = d, e[t + 1] = m, e[t + 2] = g, e[t + 3] = v; return } if (h !== v || l !== d || u !== m || c !== g) { let y = 1 - o; const A = l * d + u * m + c * g + h * v, _ = A >= 0 ? 1 : -1, x = 1 - A * A; if (x > Number.EPSILON) { const T = Math.sqrt(x), I = Math.atan2(T, A * _); y = Math.sin(y * I) / T, o = Math.sin(o * I) / T } const C = o * _; if (l = l * y + d * C, u = u * y + m * C, c = c * y + g * C, h = h * y + v * C, y === 1 - o) { const T = 1 / Math.sqrt(l * l + u * u + c * c + h * h); l *= T, u *= T, c *= T, h *= T } } e[t] = l, e[t + 1] = u, e[t + 2] = c, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, r, i, s, a) { const o = r[i], l = r[i + 1], u = r[i + 2], c = r[i + 3], h = s[a], d = s[a + 1], m = s[a + 2], g = s[a + 3]; return e[t] = o * g + c * h + l * m - u * d, e[t + 1] = l * g + c * d + u * h - o * m, e[t + 2] = u * g + c * m + o * d - l * h, e[t + 3] = c * g - o * h - l * d - u * m, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, r, i) { return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { const r = e._x, i = e._y, s = e._z, a = e._order, o = Math.cos, l = Math.sin, u = o(r / 2), c = o(i / 2), h = o(s / 2), d = l(r / 2), m = l(i / 2), g = l(s / 2); switch (a) { case "XYZ": this._x = d * c * h + u * m * g, this._y = u * m * h - d * c * g, this._z = u * c * g + d * m * h, this._w = u * c * h - d * m * g; break; case "YXZ": this._x = d * c * h + u * m * g, this._y = u * m * h - d * c * g, this._z = u * c * g - d * m * h, this._w = u * c * h + d * m * g; break; case "ZXY": this._x = d * c * h - u * m * g, this._y = u * m * h + d * c * g, this._z = u * c * g + d * m * h, this._w = u * c * h - d * m * g; break; case "ZYX": this._x = d * c * h - u * m * g, this._y = u * m * h + d * c * g, this._z = u * c * g - d * m * h, this._w = u * c * h + d * m * g; break; case "YZX": this._x = d * c * h + u * m * g, this._y = u * m * h + d * c * g, this._z = u * c * g - d * m * h, this._w = u * c * h - d * m * g; break; case "XZY": this._x = d * c * h - u * m * g, this._y = u * m * h - d * c * g, this._z = u * c * g + d * m * h, this._w = u * c * h + d * m * g; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return t !== !1 && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const r = t / 2, i = Math.sin(r); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, r = t[0], i = t[4], s = t[8], a = t[1], o = t[5], l = t[9], u = t[2], c = t[6], h = t[10], d = r + o + h; if (d > 0) { const m = .5 / Math.sqrt(d + 1); this._w = .25 / m, this._x = (c - l) * m, this._y = (s - u) * m, this._z = (a - i) * m } else if (r > o && r > h) { const m = 2 * Math.sqrt(1 + r - o - h); this._w = (c - l) / m, this._x = .25 * m, this._y = (i + a) / m, this._z = (s + u) / m } else if (o > h) { const m = 2 * Math.sqrt(1 + o - r - h); this._w = (s - u) / m, this._x = (i + a) / m, this._y = .25 * m, this._z = (l + c) / m } else { const m = 2 * Math.sqrt(1 + h - r - o); this._w = (a - i) / m, this._x = (s + u) / m, this._y = (l + c) / m, this._z = .25 * m } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let r = e.dot(t) + 1; return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(bi(this.dot(e), -1, 1))) } rotateTowards(e, t) { const r = this.angleTo(e); if (r === 0) return this; const i = Math.min(1, t / r); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e) { return this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const r = e._x, i = e._y, s = e._z, a = e._w, o = t._x, l = t._y, u = t._z, c = t._w; return this._x = r * c + a * o + i * u - s * l, this._y = i * c + a * l + s * o - r * u, this._z = s * c + a * u + r * l - i * o, this._w = a * c - r * o - i * l - s * u, this._onChangeCallback(), this } slerp(e, t) { if (t === 0) return this; if (t === 1) return this.copy(e); const r = this._x, i = this._y, s = this._z, a = this._w; let o = a * e._w + r * e._x + i * e._y + s * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = r, this._y = i, this._z = s, this; const l = 1 - o * o; if (l <= Number.EPSILON) { const m = 1 - t; return this._w = m * a + t * this._w, this._x = m * r + t * this._x, this._y = m * i + t * this._y, this._z = m * s + t * this._z, this.normalize(), this._onChangeCallback(), this } const u = Math.sqrt(l), c = Math.atan2(u, o), h = Math.sin((1 - t) * c) / u, d = Math.sin(t * c) / u; return this._w = a * h + this._w * d, this._x = r * h + this._x * d, this._y = i * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this } slerpQuaternions(e, t, r) { return this.copy(e).slerp(t, r) } random() { const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), i = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(i), r * Math.sin(s), r * Math.cos(s), t * Math.sin(i)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } toJSON() { return this.toArray() } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._w } } class N { constructor(e = 0, t = 0, r = 0) { N.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r } set(e, t, r) { return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e) { return this.x += e.x, this.y += e.y, this.z += e.z, this } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e) { return this.x -= e.x, this.y -= e.y, this.z -= e.z, this } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return this.applyQuaternion(ub.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(ub.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, r = this.y, i = this.z, s = e.elements; return this.x = s[0] * t + s[3] * r + s[6] * i, this.y = s[1] * t + s[4] * r + s[7] * i, this.z = s[2] * t + s[5] * r + s[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, r = this.y, i = this.z, s = e.elements, a = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]); return this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * a, this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * a, this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * a, this } applyQuaternion(e) { const t = this.x, r = this.y, i = this.z, s = e.x, a = e.y, o = e.z, l = e.w, u = l * t + a * i - o * r, c = l * r + o * t - s * i, h = l * i + s * r - a * t, d = -s * t - a * r - o * i; return this.x = u * l + d * -s + c * -o - h * -a, this.y = c * l + d * -a + h * -s - u * -o, this.z = h * l + d * -o + u * -a - c * -s, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, r = this.y, i = this.z, s = e.elements; return this.x = s[0] * t + s[4] * r + s[8] * i, this.y = s[1] * t + s[5] * r + s[9] * i, this.z = s[2] * t + s[6] * r + s[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const r = this.length(); return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, r) { return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this } cross(e) { return this.crossVectors(this, e) } crossVectors(e, t) { const r = e.x, i = e.y, s = e.z, a = t.x, o = t.y, l = t.z; return this.x = i * l - s * o, this.y = s * a - r * l, this.z = r * o - i * a, this } projectOnVector(e) { const t = e.lengthSq(); if (t === 0) return this.set(0, 0, 0); const r = e.dot(this) / t; return this.copy(e).multiplyScalar(r) } projectOnPlane(e) { return Px.copy(this).projectOnVector(e), this.sub(Px) } reflect(e) { return this.sub(Px.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (t === 0) return Math.PI / 2; const r = this.dot(e) / t; return Math.acos(bi(r, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z; return t * t + r * r + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, r) { const i = Math.sin(t) * e; return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, r) { return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = r, this.z = i, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, t * 4) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, t * 3) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } setFromColor(e) { return this.x = e.r, this.y = e.g, this.z = e.b, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t) { return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = (Math.random() - .5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2); return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } const Px = new N, ub = new xs; class Tu { constructor(e = new N(1 / 0, 1 / 0, 1 / 0), t = new N(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t += 3)this.expandByPoint(Dc.fromArray(e, t)); return this } setFromBufferAttribute(e) { this.makeEmpty(); for (let t = 0, r = e.count; t < r; t++)this.expandByPoint(Dc.fromBufferAttribute(e, t)); return this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const r = Dc.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { if (e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0) e.boundingBox === null && e.computeBoundingBox(), f0.copy(e.boundingBox), f0.applyMatrix4(e.matrixWorld), this.union(f0); else { const i = e.geometry; if (i !== void 0) if (t && i.attributes !== void 0 && i.attributes.position !== void 0) { const s = i.attributes.position; for (let a = 0, o = s.count; a < o; a++)Dc.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld), this.expandByPoint(Dc) } else i.boundingBox === null && i.computeBoundingBox(), f0.copy(i.boundingBox), f0.applyMatrix4(e.matrixWorld), this.union(f0) } const r = e.children; for (let i = 0, s = r.length; i < s; i++)this.expandByObject(r[i], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, Dc), Dc.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, r; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(qm), Cv.subVectors(this.max, qm), h0.subVectors(e.a, qm), d0.subVectors(e.b, qm), p0.subVectors(e.c, qm), Uf.subVectors(d0, h0), Gf.subVectors(p0, d0), pd.subVectors(h0, p0); let t = [0, -Uf.z, Uf.y, 0, -Gf.z, Gf.y, 0, -pd.z, pd.y, Uf.z, 0, -Uf.x, Gf.z, 0, -Gf.x, pd.z, 0, -pd.x, -Uf.y, Uf.x, 0, -Gf.y, Gf.x, 0, -pd.y, pd.x, 0]; return !Dx(t, h0, d0, p0, Cv) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Dx(t, h0, d0, p0, Cv)) ? !1 : (Sv.crossVectors(Uf, Gf), t = [Sv.x, Sv.y, Sv.z], Dx(t, h0, d0, p0, Cv)) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, Dc).distanceTo(e) } getBoundingSphere(e) { return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Dc).length() * .5), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() ? this : (Pc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Pc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Pc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Pc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Pc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Pc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Pc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Pc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Pc), this) } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const Pc = [new N, new N, new N, new N, new N, new N, new N, new N], Dc = new N, f0 = new Tu, h0 = new N, d0 = new N, p0 = new N, Uf = new N, Gf = new N, pd = new N, qm = new N, Cv = new N, Sv = new N, md = new N; function Dx(n, e, t, r, i) { for (let s = 0, a = n.length - 3; s <= a; s += 3) { md.fromArray(n, s); const o = i.x * Math.abs(md.x) + i.y * Math.abs(md.y) + i.z * Math.abs(md.z), l = e.dot(md), u = t.dot(md), c = r.dot(md); if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > o) return !1 } return !0 } const lK = new Tu, Zm = new N, Lx = new N; class kl { constructor(e = new N, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const r = this.center; t !== void 0 ? r.copy(t) : lK.setFromPoints(e).getCenter(r); let i = 0; for (let s = 0, a = e.length; s < a; s++)i = Math.max(i, r.distanceToSquared(e[s])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const r = this.center.distanceToSquared(e); return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this; Zm.subVectors(e, this.center); const t = Zm.lengthSq(); if (t > this.radius * this.radius) { const r = Math.sqrt(t), i = (r - this.radius) * .5; this.center.addScaledVector(Zm, i / r), this.radius += i } return this } union(e) { return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Lx.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Zm.copy(e.center).add(Lx)), this.expandByPoint(Zm.copy(e.center).sub(Lx))), this) } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return new this.constructor().copy(this) } } const Lc = new N, Fx = new N, Tv = new N, Qf = new N, kx = new N, wv = new N, Nx = new N; class Op { constructor(e = new N, t = new N(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.origin).addScaledVector(this.direction, e) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, Lc)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const r = t.dot(this.direction); return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = Lc.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (Lc.copy(this.origin).addScaledVector(this.direction, t), Lc.distanceToSquared(e)) } distanceSqToSegment(e, t, r, i) { Fx.copy(e).add(t).multiplyScalar(.5), Tv.copy(t).sub(e).normalize(), Qf.copy(this.origin).sub(Fx); const s = e.distanceTo(t) * .5, a = -this.direction.dot(Tv), o = Qf.dot(this.direction), l = -Qf.dot(Tv), u = Qf.lengthSq(), c = Math.abs(1 - a * a); let h, d, m, g; if (c > 0) if (h = a * l - o, d = a * o - l, g = s * c, h >= 0) if (d >= -g) if (d <= g) { const v = 1 / c; h *= v, d *= v, m = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + u } else d = s, h = Math.max(0, -(a * d + o)), m = -h * h + d * (d + 2 * l) + u; else d = -s, h = Math.max(0, -(a * d + o)), m = -h * h + d * (d + 2 * l) + u; else d <= -g ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -h * h + d * (d + 2 * l) + u) : d <= g ? (h = 0, d = Math.min(Math.max(-s, -l), s), m = d * (d + 2 * l) + u) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), m = -h * h + d * (d + 2 * l) + u); else d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), m = -h * h + d * (d + 2 * l) + u; return r && r.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(Fx).addScaledVector(Tv, d), m } intersectSphere(e, t) { Lc.subVectors(e.center, this.origin); const r = Lc.dot(this.direction), i = Lc.dot(Lc) - r * r, s = e.radius * e.radius; if (i > s) return null; const a = Math.sqrt(s - i), o = r - a, l = r + a; return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null; const r = -(this.origin.dot(e.normal) + e.constant) / t; return r >= 0 ? r : null } intersectPlane(e, t) { const r = this.distanceToPlane(e); return r === null ? null : this.at(r, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return t === 0 || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let r, i, s, a, o, l; const u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin; return u >= 0 ? (r = (e.min.x - d.x) * u, i = (e.max.x - d.x) * u) : (r = (e.max.x - d.x) * u, i = (e.min.x - d.x) * u), c >= 0 ? (s = (e.min.y - d.y) * c, a = (e.max.y - d.y) * c) : (s = (e.max.y - d.y) * c, a = (e.min.y - d.y) * c), r > a || s > i || ((s > r || isNaN(r)) && (r = s), (a < i || isNaN(i)) && (i = a), h >= 0 ? (o = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (o = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), r > l || o > i) || ((o > r || r !== r) && (r = o), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(r >= 0 ? r : i, t) } intersectsBox(e) { return this.intersectBox(e, Lc) !== null } intersectTriangle(e, t, r, i, s) { kx.subVectors(t, e), wv.subVectors(r, e), Nx.crossVectors(kx, wv); let a = this.direction.dot(Nx), o; if (a > 0) { if (i) return null; o = 1 } else if (a < 0) o = -1, a = -a; else return null; Qf.subVectors(this.origin, e); const l = o * this.direction.dot(wv.crossVectors(Qf, wv)); if (l < 0) return null; const u = o * this.direction.dot(kx.cross(Qf)); if (u < 0 || l + u > a) return null; const c = -o * Qf.dot(Nx); return c < 0 ? null : this.at(c / a, s) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return new this.constructor().copy(this) } } class bt { constructor(e, t, r, i, s, a, o, l, u, c, h, d, m, g, v, y) { bt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, r, i, s, a, o, l, u, c, h, d, m, g, v, y) } set(e, t, r, i, s, a, o, l, u, c, h, d, m, g, v, y) { const A = this.elements; return A[0] = e, A[4] = t, A[8] = r, A[12] = i, A[1] = s, A[5] = a, A[9] = o, A[13] = l, A[2] = u, A[6] = c, A[10] = h, A[14] = d, A[3] = m, A[7] = g, A[11] = v, A[15] = y, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return new bt().fromArray(this.elements) } copy(e) { const t = this.elements, r = e.elements; return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this } copyPosition(e) { const t = this.elements, r = e.elements; return t[12] = r[12], t[13] = r[13], t[14] = r[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, r) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this } makeBasis(e, t, r) { return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, r = e.elements, i = 1 / m0.setFromMatrixColumn(e, 0).length(), s = 1 / m0.setFromMatrixColumn(e, 1).length(), a = 1 / m0.setFromMatrixColumn(e, 2).length(); return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * a, t[9] = r[9] * a, t[10] = r[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { const t = this.elements, r = e.x, i = e.y, s = e.z, a = Math.cos(r), o = Math.sin(r), l = Math.cos(i), u = Math.sin(i), c = Math.cos(s), h = Math.sin(s); if (e.order === "XYZ") { const d = a * c, m = a * h, g = o * c, v = o * h; t[0] = l * c, t[4] = -l * h, t[8] = u, t[1] = m + g * u, t[5] = d - v * u, t[9] = -o * l, t[2] = v - d * u, t[6] = g + m * u, t[10] = a * l } else if (e.order === "YXZ") { const d = l * c, m = l * h, g = u * c, v = u * h; t[0] = d + v * o, t[4] = g * o - m, t[8] = a * u, t[1] = a * h, t[5] = a * c, t[9] = -o, t[2] = m * o - g, t[6] = v + d * o, t[10] = a * l } else if (e.order === "ZXY") { const d = l * c, m = l * h, g = u * c, v = u * h; t[0] = d - v * o, t[4] = -a * h, t[8] = g + m * o, t[1] = m + g * o, t[5] = a * c, t[9] = v - d * o, t[2] = -a * u, t[6] = o, t[10] = a * l } else if (e.order === "ZYX") { const d = a * c, m = a * h, g = o * c, v = o * h; t[0] = l * c, t[4] = g * u - m, t[8] = d * u + v, t[1] = l * h, t[5] = v * u + d, t[9] = m * u - g, t[2] = -u, t[6] = o * l, t[10] = a * l } else if (e.order === "YZX") { const d = a * l, m = a * u, g = o * l, v = o * u; t[0] = l * c, t[4] = v - d * h, t[8] = g * h + m, t[1] = h, t[5] = a * c, t[9] = -o * c, t[2] = -u * c, t[6] = m * h + g, t[10] = d - v * h } else if (e.order === "XZY") { const d = a * l, m = a * u, g = o * l, v = o * u; t[0] = l * c, t[4] = -h, t[8] = u * c, t[1] = d * h + v, t[5] = a * c, t[9] = m * h - g, t[2] = g * h - m, t[6] = o * c, t[10] = v * h + d } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(uK, e, cK) } lookAt(e, t, r) { const i = this.elements; return wo.subVectors(e, t), wo.lengthSq() === 0 && (wo.z = 1), wo.normalize(), Hf.crossVectors(r, wo), Hf.lengthSq() === 0 && (Math.abs(r.z) === 1 ? wo.x += 1e-4 : wo.z += 1e-4, wo.normalize(), Hf.crossVectors(r, wo)), Hf.normalize(), Iv.crossVectors(wo, Hf), i[0] = Hf.x, i[4] = Iv.x, i[8] = wo.x, i[1] = Hf.y, i[5] = Iv.y, i[9] = wo.y, i[2] = Hf.z, i[6] = Iv.z, i[10] = wo.z, this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const r = e.elements, i = t.elements, s = this.elements, a = r[0], o = r[4], l = r[8], u = r[12], c = r[1], h = r[5], d = r[9], m = r[13], g = r[2], v = r[6], y = r[10], A = r[14], _ = r[3], x = r[7], C = r[11], T = r[15], I = i[0], w = i[4], R = i[8], b = i[12], B = i[1], F = i[5], U = i[9], G = i[13], Y = i[2], Z = i[6], ne = i[10], $ = i[14], L = i[3], Q = i[7], D = i[11], V = i[15]; return s[0] = a * I + o * B + l * Y + u * L, s[4] = a * w + o * F + l * Z + u * Q, s[8] = a * R + o * U + l * ne + u * D, s[12] = a * b + o * G + l * $ + u * V, s[1] = c * I + h * B + d * Y + m * L, s[5] = c * w + h * F + d * Z + m * Q, s[9] = c * R + h * U + d * ne + m * D, s[13] = c * b + h * G + d * $ + m * V, s[2] = g * I + v * B + y * Y + A * L, s[6] = g * w + v * F + y * Z + A * Q, s[10] = g * R + v * U + y * ne + A * D, s[14] = g * b + v * G + y * $ + A * V, s[3] = _ * I + x * B + C * Y + T * L, s[7] = _ * w + x * F + C * Z + T * Q, s[11] = _ * R + x * U + C * ne + T * D, s[15] = _ * b + x * G + C * $ + T * V, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], r = e[4], i = e[8], s = e[12], a = e[1], o = e[5], l = e[9], u = e[13], c = e[2], h = e[6], d = e[10], m = e[14], g = e[3], v = e[7], y = e[11], A = e[15]; return g * (+s * l * h - i * u * h - s * o * d + r * u * d + i * o * m - r * l * m) + v * (+t * l * m - t * u * d + s * a * d - i * a * m + i * u * c - s * l * c) + y * (+t * u * h - t * o * m - s * a * h + r * a * m + s * o * c - r * u * c) + A * (-i * o * c - t * l * h + t * o * d + i * a * h - r * a * d + r * l * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, r) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this } invert() { const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], d = e[10], m = e[11], g = e[12], v = e[13], y = e[14], A = e[15], _ = h * y * u - v * d * u + v * l * m - o * y * m - h * l * A + o * d * A, x = g * d * u - c * y * u - g * l * m + a * y * m + c * l * A - a * d * A, C = c * v * u - g * h * u + g * o * m - a * v * m - c * o * A + a * h * A, T = g * h * l - c * v * l - g * o * d + a * v * d + c * o * y - a * h * y, I = t * _ + r * x + i * C + s * T; if (I === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const w = 1 / I; return e[0] = _ * w, e[1] = (v * d * s - h * y * s - v * i * m + r * y * m + h * i * A - r * d * A) * w, e[2] = (o * y * s - v * l * s + v * i * u - r * y * u - o * i * A + r * l * A) * w, e[3] = (h * l * s - o * d * s - h * i * u + r * d * u + o * i * m - r * l * m) * w, e[4] = x * w, e[5] = (c * y * s - g * d * s + g * i * m - t * y * m - c * i * A + t * d * A) * w, e[6] = (g * l * s - a * y * s - g * i * u + t * y * u + a * i * A - t * l * A) * w, e[7] = (a * d * s - c * l * s + c * i * u - t * d * u - a * i * m + t * l * m) * w, e[8] = C * w, e[9] = (g * h * s - c * v * s - g * r * m + t * v * m + c * r * A - t * h * A) * w, e[10] = (a * v * s - g * o * s + g * r * u - t * v * u - a * r * A + t * o * A) * w, e[11] = (c * o * s - a * h * s - c * r * u + t * h * u + a * r * m - t * o * m) * w, e[12] = T * w, e[13] = (c * v * i - g * h * i + g * r * d - t * v * d - c * r * y + t * h * y) * w, e[14] = (g * o * i - a * v * i - g * r * l + t * v * l + a * r * y - t * o * y) * w, e[15] = (a * h * i - c * o * i + c * r * l - t * h * l - a * r * d + t * o * d) * w, this } scale(e) { const t = this.elements, r = e.x, i = e.y, s = e.z; return t[0] *= r, t[4] *= i, t[8] *= s, t[1] *= r, t[5] *= i, t[9] *= s, t[2] *= r, t[6] *= i, t[10] *= s, t[3] *= r, t[7] *= i, t[11] *= s, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, r, i)) } makeTranslation(e, t, r) { return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), r = Math.sin(e); return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const r = Math.cos(t), i = Math.sin(t), s = 1 - r, a = e.x, o = e.y, l = e.z, u = s * a, c = s * o; return this.set(u * a + r, u * o - i * l, u * l + i * o, 0, u * o + i * l, c * o + r, c * l - i * a, 0, u * l - i * o, c * l + i * a, s * l * l + r, 0, 0, 0, 0, 1), this } makeScale(e, t, r) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this } makeShear(e, t, r, i, s, a) { return this.set(1, r, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this } compose(e, t, r) { const i = this.elements, s = t._x, a = t._y, o = t._z, l = t._w, u = s + s, c = a + a, h = o + o, d = s * u, m = s * c, g = s * h, v = a * c, y = a * h, A = o * h, _ = l * u, x = l * c, C = l * h, T = r.x, I = r.y, w = r.z; return i[0] = (1 - (v + A)) * T, i[1] = (m + C) * T, i[2] = (g - x) * T, i[3] = 0, i[4] = (m - C) * I, i[5] = (1 - (d + A)) * I, i[6] = (y + _) * I, i[7] = 0, i[8] = (g + x) * w, i[9] = (y - _) * w, i[10] = (1 - (d + v)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, t, r) { const i = this.elements; let s = m0.set(i[0], i[1], i[2]).length(); const a = m0.set(i[4], i[5], i[6]).length(), o = m0.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], $l.copy(this); const u = 1 / s, c = 1 / a, h = 1 / o; return $l.elements[0] *= u, $l.elements[1] *= u, $l.elements[2] *= u, $l.elements[4] *= c, $l.elements[5] *= c, $l.elements[6] *= c, $l.elements[8] *= h, $l.elements[9] *= h, $l.elements[10] *= h, t.setFromRotationMatrix($l), r.x = s, r.y = a, r.z = o, this } makePerspective(e, t, r, i, s, a, o = Zu) { const l = this.elements, u = 2 * s / (t - e), c = 2 * s / (r - i), h = (t + e) / (t - e), d = (r + i) / (r - i); let m, g; if (o === Zu) m = -(a + s) / (a - s), g = -2 * a * s / (a - s); else if (o === a1) m = -a / (a - s), g = -a * s / (a - s); else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o); return l[0] = u, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = c, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this } makeOrthographic(e, t, r, i, s, a, o = Zu) { const l = this.elements, u = 1 / (t - e), c = 1 / (r - i), h = 1 / (a - s), d = (t + e) * u, m = (r + i) * c; let g, v; if (o === Zu) g = (a + s) * h, v = -2 * h; else if (o === a1) g = s * h, v = -1 * h; else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o); return l[0] = 2 * u, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = v, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this } equals(e) { const t = this.elements, r = e.elements; for (let i = 0; i < 16; i++)if (t[i] !== r[i]) return !1; return !0 } fromArray(e, t = 0) { for (let r = 0; r < 16; r++)this.elements[r] = e[r + t]; return this } toArray(e = [], t = 0) { const r = this.elements; return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e } } const m0 = new N, $l = new bt, uK = new N(0, 0, 0), cK = new N(1, 1, 1), Hf = new N, Iv = new N, wo = new N, cb = new bt, fb = new xs; class P1 { constructor(e = 0, t = 0, r = 0, i = P1.DEFAULT_ORDER) { this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, r, i = this._order) { return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, r = !0) { const i = e.elements, s = i[0], a = i[4], o = i[8], l = i[1], u = i[5], c = i[9], h = i[2], d = i[6], m = i[10]; switch (t) { case "XYZ": this._y = Math.asin(bi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, m), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, u), this._z = 0); break; case "YXZ": this._x = Math.asin(-bi(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, m), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-h, s), this._z = 0); break; case "ZXY": this._x = Math.asin(bi(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, m), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(l, s)); break; case "ZYX": this._y = Math.asin(-bi(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, u)); break; case "YZX": this._z = Math.asin(bi(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, m)); break; case "XZY": this._z = Math.asin(-bi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-c, m), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, r === !0 && this._onChangeCallback(), this } setFromQuaternion(e, t, r) { return cb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(cb, t, r) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return fb.setFromEuler(this), this.setFromQuaternion(fb, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } *[Symbol.iterator]() { yield this._x, yield this._y, yield this._z, yield this._order } } P1.DEFAULT_ORDER = "XYZ"; class dp { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return (this.mask & e.mask) !== 0 } isEnabled(e) { return (this.mask & (1 << e | 0)) !== 0 } } let fK = 0; const hb = new N, g0 = new xs, Fc = new bt, Mv = new N, $m = new N, hK = new N, dK = new xs, db = new N(1, 0, 0), pb = new N(0, 1, 0), mb = new N(0, 0, 1), pK = { type: "added" }, mK = { type: "removed" }; class Hn extends mc { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: fK++ }), this.uuid = Qo(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Hn.DEFAULT_UP.clone(); const e = new N, t = new P1, r = new xs, i = new N(1, 1, 1); function s() { r.setFromEuler(t, !1) } function a() { t.setFromQuaternion(r, void 0, !1) } t._onChange(s), r._onChange(a), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: r }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new bt }, normalMatrix: { value: new In } }), this.matrix = new bt, this.matrixWorld = new bt, this.matrixAutoUpdate = Hn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = Hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new dp, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return g0.setFromAxisAngle(e, t), this.quaternion.multiply(g0), this } rotateOnWorldAxis(e, t) { return g0.setFromAxisAngle(e, t), this.quaternion.premultiply(g0), this } rotateX(e) { return this.rotateOnAxis(db, e) } rotateY(e) { return this.rotateOnAxis(pb, e) } rotateZ(e) { return this.rotateOnAxis(mb, e) } translateOnAxis(e, t) { return hb.copy(e).applyQuaternion(this.quaternion), this.position.add(hb.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(db, e) } translateY(e) { return this.translateOnAxis(pb, e) } translateZ(e) { return this.translateOnAxis(mb, e) } localToWorld(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Fc.copy(this.matrixWorld).invert()) } lookAt(e, t, r) { e.isVector3 ? Mv.copy(e) : Mv.set(e, t, r); const i = this.parent; this.updateWorldMatrix(!0, !1), $m.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fc.lookAt($m, Mv, this.up) : Fc.lookAt(Mv, $m, this.up), this.quaternion.setFromRotationMatrix(Fc), i && (Fc.extractRotation(i.matrixWorld), g0.setFromRotationMatrix(Fc), this.quaternion.premultiply(g0.invert())) } add(e) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(pK)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let r = 0; r < arguments.length; r++)this.remove(arguments[r]); return this } const t = this.children.indexOf(e); return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(mK)), this } removeFromParent() { const e = this.parent; return e !== null && e.remove(this), this } clear() { return this.remove(...this.children) } attach(e) { return this.updateWorldMatrix(!0, !1), Fc.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Fc.multiply(e.parent.matrixWorld)), e.applyMatrix4(Fc), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let r = 0, i = this.children.length; r < i; r++) { const a = this.children[r].getObjectByProperty(e, t); if (a !== void 0) return a } } getObjectsByProperty(e, t) { let r = []; this[e] === t && r.push(this); for (let i = 0, s = this.children.length; i < s; i++) { const a = this.children[i].getObjectsByProperty(e, t); a.length > 0 && (r = r.concat(a)) } return r } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($m, e, hK), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($m, dK, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let r = 0, i = t.length; r < i; r++)t[r].traverse(e) } traverseVisible(e) { if (this.visible === !1) return; e(this); const t = this.children; for (let r = 0, i = t.length; r < i; r++)t[r].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; t !== null && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let r = 0, i = t.length; r < i; r++) { const s = t[r]; (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e) } } updateWorldMatrix(e, t) { const r = this.parent; if (e === !0 && r !== null && r.matrixWorldAutoUpdate === !0 && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) { const i = this.children; for (let s = 0, a = i.length; s < a; s++) { const o = i[s]; o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0) } } } toJSON(e) { const t = e === void 0 || typeof e == "string", r = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, r.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" }); const i = {}; i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())); function s(o, l) { return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = s(e.geometries, this.geometry); const o = this.geometry.parameters; if (o !== void 0 && o.shapes !== void 0) { const l = o.shapes; if (Array.isArray(l)) for (let u = 0, c = l.length; u < c; u++) { const h = l[u]; s(e.shapes, h) } else s(e.shapes, l) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { const o = []; for (let l = 0, u = this.material.length; l < u; l++)o.push(s(e.materials, this.material[l])); i.material = o } else i.material = s(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let o = 0; o < this.children.length; o++)i.children.push(this.children[o].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let o = 0; o < this.animations.length; o++) { const l = this.animations[o]; i.animations.push(s(e.animations, l)) } } if (t) { const o = a(e.geometries), l = a(e.materials), u = a(e.textures), c = a(e.images), h = a(e.shapes), d = a(e.skeletons), m = a(e.animations), g = a(e.nodes); o.length > 0 && (r.geometries = o), l.length > 0 && (r.materials = l), u.length > 0 && (r.textures = u), c.length > 0 && (r.images = c), h.length > 0 && (r.shapes = h), d.length > 0 && (r.skeletons = d), m.length > 0 && (r.animations = m), g.length > 0 && (r.nodes = g) } return r.object = i, r; function a(o) { const l = []; for (const u in o) { const c = o[u]; delete c.metadata, l.push(c) } return l } } clone(e) { return new this.constructor().copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0) for (let r = 0; r < e.children.length; r++) { const i = e.children[r]; this.add(i.clone()) } return this } } Hn.DEFAULT_UP = new N(0, 1, 0); Hn.DEFAULT_MATRIX_AUTO_UPDATE = !0; Hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; const eu = new N, kc = new N, Ox = new N, Nc = new N, A0 = new N, v0 = new N, gb = new N, Ux = new N, Gx = new N, Qx = new N; let bv = !1; class to { constructor(e = new N, t = new N, r = new N) { this.a = e, this.b = t, this.c = r } static getNormal(e, t, r, i) { i.subVectors(r, t), eu.subVectors(e, t), i.cross(eu); const s = i.lengthSq(); return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0) } static getBarycoord(e, t, r, i, s) { eu.subVectors(i, t), kc.subVectors(r, t), Ox.subVectors(e, t); const a = eu.dot(eu), o = eu.dot(kc), l = eu.dot(Ox), u = kc.dot(kc), c = kc.dot(Ox), h = a * u - o * o; if (h === 0) return s.set(-2, -1, -1); const d = 1 / h, m = (u * l - o * c) * d, g = (a * c - o * l) * d; return s.set(1 - m - g, g, m) } static containsPoint(e, t, r, i) { return this.getBarycoord(e, t, r, i, Nc), Nc.x >= 0 && Nc.y >= 0 && Nc.x + Nc.y <= 1 } static getUV(e, t, r, i, s, a, o, l) { return bv === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), bv = !0), this.getInterpolation(e, t, r, i, s, a, o, l) } static getInterpolation(e, t, r, i, s, a, o, l) { return this.getBarycoord(e, t, r, i, Nc), l.setScalar(0), l.addScaledVector(s, Nc.x), l.addScaledVector(a, Nc.y), l.addScaledVector(o, Nc.z), l } static isFrontFacing(e, t, r, i) { return eu.subVectors(r, t), kc.subVectors(e, t), eu.cross(kc).dot(i) < 0 } set(e, t, r) { return this.a.copy(e), this.b.copy(t), this.c.copy(r), this } setFromPointsAndIndices(e, t, r, i) { return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this } setFromAttributeAndIndices(e, t, r, i) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return eu.subVectors(this.c, this.b), kc.subVectors(this.a, this.b), eu.cross(kc).length() * .5 } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return to.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return to.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, r, i, s) { return bv === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), bv = !0), to.getInterpolation(e, this.a, this.b, this.c, t, r, i, s) } getInterpolation(e, t, r, i, s) { return to.getInterpolation(e, this.a, this.b, this.c, t, r, i, s) } containsPoint(e) { return to.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return to.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const r = this.a, i = this.b, s = this.c; let a, o; A0.subVectors(i, r), v0.subVectors(s, r), Ux.subVectors(e, r); const l = A0.dot(Ux), u = v0.dot(Ux); if (l <= 0 && u <= 0) return t.copy(r); Gx.subVectors(e, i); const c = A0.dot(Gx), h = v0.dot(Gx); if (c >= 0 && h <= c) return t.copy(i); const d = l * h - c * u; if (d <= 0 && l >= 0 && c <= 0) return a = l / (l - c), t.copy(r).addScaledVector(A0, a); Qx.subVectors(e, s); const m = A0.dot(Qx), g = v0.dot(Qx); if (g >= 0 && m <= g) return t.copy(s); const v = m * u - l * g; if (v <= 0 && u >= 0 && g <= 0) return o = u / (u - g), t.copy(r).addScaledVector(v0, o); const y = c * g - m * h; if (y <= 0 && h - c >= 0 && m - g >= 0) return gb.subVectors(s, i), o = (h - c) / (h - c + (m - g)), t.copy(i).addScaledVector(gb, o); const A = 1 / (y + v + d); return a = v * A, o = d * A, t.copy(r).addScaledVector(A0, a).addScaledVector(v0, o) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let gK = 0; class as extends mc { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: gK++ }), this.uuid = Qo(), this.name = "", this.type = "Material", this.blending = ic, this.side = pc, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = jA, this.blendDst = JA, this.blendEquation = ko, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = sy, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = vO, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = l6, this.stencilZFail = l6, this.stencilZPass = l6, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (e !== void 0) for (const t in e) { const r = e[t]; if (r === void 0) { console.warn(`THREE.Material: parameter '${t}' has value of undefined.`); continue } const i = this[t]; if (i === void 0) { console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`); continue } i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r } } toJSON(e) { const t = e === void 0 || typeof e == "string"; t && (e = { textures: {}, images: {} }); const r = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } }; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== ic && (r.blending = this.blending), this.side !== pc && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaHash === !0 && (r.alphaHash = this.alphaHash), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (r.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), Object.keys(this.userData).length > 0 && (r.userData = this.userData); function i(s) { const a = []; for (const o in s) { const l = s[o]; delete l.metadata, a.push(l) } return a } if (t) { const s = i(e.textures), a = i(e.images); s.length > 0 && (r.textures = s), a.length > 0 && (r.images = a) } return r } clone() { return new this.constructor().copy(this) } copy(e) { this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let r = null; if (t !== null) { const i = t.length; r = new Array(i); for (let s = 0; s !== i; ++s)r[s] = t[s].clone() } return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { e === !0 && this.version++ } } const RO = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, tu = { h: 0, s: 0, l: 0 }, Bv = { h: 0, s: 0, l: 0 }; function Hx(n, e, t) { return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n } class Je { constructor(e, t, r) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, r) } set(e, t, r) { if (t === void 0 && r === void 0) { const i = e; i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i) } else this.setRGB(e, t, r); return this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e, t = Ur) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, fl.toWorkingColorSpace(this, t), this } setRGB(e, t, r, i = fl.workingColorSpace) { return this.r = e, this.g = t, this.b = r, fl.toWorkingColorSpace(this, i), this } setHSL(e, t, r, i = fl.workingColorSpace) { if (e = OS(e, 1), t = bi(t, 0, 1), r = bi(r, 0, 1), t === 0) this.r = this.g = this.b = r; else { const s = r <= .5 ? r * (1 + t) : r + t - r * t, a = 2 * r - s; this.r = Hx(a, s, e + 1 / 3), this.g = Hx(a, s, e), this.b = Hx(a, s, e - 1 / 3) } return fl.toWorkingColorSpace(this, i), this } setStyle(e, t = Ur) { function r(s) { s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let i; if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) { let s; const a = i[1], o = i[2]; switch (a) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t); if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t); break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t); break; default: console.warn("THREE.Color: Unknown color model " + e) } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { const s = i[1], a = s.length; if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t); if (a === 6) return this.setHex(parseInt(s, 16), t); console.warn("THREE.Color: Invalid hex color " + e) } else if (e && e.length > 0) return this.setColorName(e, t); return this } setColorName(e, t = Ur) { const r = RO[e.toLowerCase()]; return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = R3(e.r), this.g = R3(e.g), this.b = R3(e.b), this } copyLinearToSRGB(e) { return this.r = Bx(e.r), this.g = Bx(e.g), this.b = Bx(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex(e = Ur) { return fl.fromWorkingColorSpace(la.copy(this), e), Math.round(bi(la.r * 255, 0, 255)) * 65536 + Math.round(bi(la.g * 255, 0, 255)) * 256 + Math.round(bi(la.b * 255, 0, 255)) } getHexString(e = Ur) { return ("000000" + this.getHex(e).toString(16)).slice(-6) } getHSL(e, t = fl.workingColorSpace) { fl.fromWorkingColorSpace(la.copy(this), t); const r = la.r, i = la.g, s = la.b, a = Math.max(r, i, s), o = Math.min(r, i, s); let l, u; const c = (o + a) / 2; if (o === a) l = 0, u = 0; else { const h = a - o; switch (u = c <= .5 ? h / (a + o) : h / (2 - a - o), a) { case r: l = (i - s) / h + (i < s ? 6 : 0); break; case i: l = (s - r) / h + 2; break; case s: l = (r - i) / h + 4; break }l /= 6 } return e.h = l, e.s = u, e.l = c, e } getRGB(e, t = fl.workingColorSpace) { return fl.fromWorkingColorSpace(la.copy(this), t), e.r = la.r, e.g = la.g, e.b = la.b, e } getStyle(e = Ur) { fl.fromWorkingColorSpace(la.copy(this), e); const t = la.r, r = la.g, i = la.b; return e !== Ur ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(i * 255)})` } offsetHSL(e, t, r) { return this.getHSL(tu), tu.h += e, tu.s += t, tu.l += r, this.setHSL(tu.h, tu.s, tu.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, r) { return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this } lerpHSL(e, t) { this.getHSL(tu), e.getHSL(Bv); const r = aA(tu.h, Bv.h, t), i = aA(tu.s, Bv.s, t), s = aA(tu.l, Bv.l, t); return this.setHSL(r, i, s), this } setFromVector3(e) { return this.r = e.x, this.g = e.y, this.b = e.z, this } applyMatrix3(e) { const t = this.r, r = this.g, i = this.b, s = e.elements; return this.r = s[0] * t + s[3] * r + s[6] * i, this.g = s[1] * t + s[4] * r + s[7] * i, this.b = s[2] * t + s[5] * r + s[8] * i, this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this } toJSON() { return this.getHex() } *[Symbol.iterator]() { yield this.r, yield this.g, yield this.b } } const la = new Je; Je.NAMES = RO; class qs extends as { constructor(e) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = B1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } const jc = AK(); function AK() { const n = new ArrayBuffer(4), e = new Float32Array(n), t = new Uint32Array(n), r = new Uint32Array(512), i = new Uint32Array(512); for (let l = 0; l < 256; ++l) { const u = l - 127; u < -27 ? (r[l] = 0, r[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : u < -14 ? (r[l] = 1024 >> -u - 14, r[l | 256] = 1024 >> -u - 14 | 32768, i[l] = -u - 1, i[l | 256] = -u - 1) : u <= 15 ? (r[l] = u + 15 << 10, r[l | 256] = u + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : u < 128 ? (r[l] = 31744, r[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (r[l] = 31744, r[l | 256] = 64512, i[l] = 13, i[l | 256] = 13) } const s = new Uint32Array(2048), a = new Uint32Array(64), o = new Uint32Array(64); for (let l = 1; l < 1024; ++l) { let u = l << 13, c = 0; for (; !(u & 8388608);)u <<= 1, c -= 8388608; u &= -8388609, c += 947912704, s[l] = u | c } for (let l = 1024; l < 2048; ++l)s[l] = 939524096 + (l - 1024 << 13); for (let l = 1; l < 31; ++l)a[l] = l << 23; a[31] = 1199570944, a[32] = 2147483648; for (let l = 33; l < 63; ++l)a[l] = 2147483648 + (l - 32 << 23); a[63] = 3347054592; for (let l = 1; l < 64; ++l)l !== 32 && (o[l] = 1024); return { floatView: e, uint32View: t, baseTable: r, shiftTable: i, mantissaTable: s, exponentTable: a, offsetTable: o } } function Za(n) { Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = bi(n, -65504, 65504), jc.floatView[0] = n; const e = jc.uint32View[0], t = e >> 23 & 511; return jc.baseTable[t] + ((e & 8388607) >> jc.shiftTable[t]) } function Bg(n) { const e = n >> 10; return jc.uint32View[0] = jc.mantissaTable[jc.offsetTable[e] + (n & 1023)] + jc.exponentTable[e], jc.floatView[0] } const vK = { toHalfFloat: Za, fromHalfFloat: Bg }, ts = new N, Rv = new Se; class lr { constructor(e, t, r = !1) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r, this.usage = s1, this.updateRange = { offset: 0, count: -1 }, this.gpuType = Oa, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this } copyAt(e, t, r) { e *= this.itemSize, r *= t.itemSize; for (let i = 0, s = this.itemSize; i < s; i++)this.array[e + i] = t.array[r + i]; return this } copyArray(e) { return this.array.set(e), this } applyMatrix3(e) { if (this.itemSize === 2) for (let t = 0, r = this.count; t < r; t++)Rv.fromBufferAttribute(this, t), Rv.applyMatrix3(e), this.setXY(t, Rv.x, Rv.y); else if (this.itemSize === 3) for (let t = 0, r = this.count; t < r; t++)ts.fromBufferAttribute(this, t), ts.applyMatrix3(e), this.setXYZ(t, ts.x, ts.y, ts.z); return this } applyMatrix4(e) { for (let t = 0, r = this.count; t < r; t++)ts.fromBufferAttribute(this, t), ts.applyMatrix4(e), this.setXYZ(t, ts.x, ts.y, ts.z); return this } applyNormalMatrix(e) { for (let t = 0, r = this.count; t < r; t++)ts.fromBufferAttribute(this, t), ts.applyNormalMatrix(e), this.setXYZ(t, ts.x, ts.y, ts.z); return this } transformDirection(e) { for (let t = 0, r = this.count; t < r; t++)ts.fromBufferAttribute(this, t), ts.transformDirection(e), this.setXYZ(t, ts.x, ts.y, ts.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getComponent(e, t) { let r = this.array[e * this.itemSize + t]; return this.normalized && (r = ro(r, this.array)), r } setComponent(e, t, r) { return this.normalized && (r = Sn(r, this.array)), this.array[e * this.itemSize + t] = r, this } getX(e) { let t = this.array[e * this.itemSize]; return this.normalized && (t = ro(t, this.array)), t } setX(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize] = t, this } getY(e) { let t = this.array[e * this.itemSize + 1]; return this.normalized && (t = ro(t, this.array)), t } setY(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 1] = t, this } getZ(e) { let t = this.array[e * this.itemSize + 2]; return this.normalized && (t = ro(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 2] = t, this } getW(e) { let t = this.array[e * this.itemSize + 3]; return this.normalized && (t = ro(t, this.array)), t } setW(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 3] = t, this } setXY(e, t, r) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this } setXYZ(e, t, r, i) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this } setXYZW(e, t, r, i, s) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array), s = Sn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = s, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (e.name = this.name), this.usage !== s1 && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e } } class yK extends lr { constructor(e, t, r) { super(new Int8Array(e), t, r) } } class xK extends lr { constructor(e, t, r) { super(new Uint8Array(e), t, r) } } class _K extends lr { constructor(e, t, r) { super(new Uint8ClampedArray(e), t, r) } } class EK extends lr { constructor(e, t, r) { super(new Int16Array(e), t, r) } } class QS extends lr { constructor(e, t, r) { super(new Uint16Array(e), t, r) } } class CK extends lr { constructor(e, t, r) { super(new Int32Array(e), t, r) } } class u8 extends lr { constructor(e, t, r) { super(new Uint32Array(e), t, r) } } class SK extends lr { constructor(e, t, r) { super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0 } getX(e) { let t = Bg(this.array[e * this.itemSize]); return this.normalized && (t = ro(t, this.array)), t } setX(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize] = Za(t), this } getY(e) { let t = Bg(this.array[e * this.itemSize + 1]); return this.normalized && (t = ro(t, this.array)), t } setY(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 1] = Za(t), this } getZ(e) { let t = Bg(this.array[e * this.itemSize + 2]); return this.normalized && (t = ro(t, this.array)), t } setZ(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 2] = Za(t), this } getW(e) { let t = Bg(this.array[e * this.itemSize + 3]); return this.normalized && (t = ro(t, this.array)), t } setW(e, t) { return this.normalized && (t = Sn(t, this.array)), this.array[e * this.itemSize + 3] = Za(t), this } setXY(e, t, r) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array)), this.array[e + 0] = Za(t), this.array[e + 1] = Za(r), this } setXYZ(e, t, r, i) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array)), this.array[e + 0] = Za(t), this.array[e + 1] = Za(r), this.array[e + 2] = Za(i), this } setXYZW(e, t, r, i, s) { return e *= this.itemSize, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array), s = Sn(s, this.array)), this.array[e + 0] = Za(t), this.array[e + 1] = Za(r), this.array[e + 2] = Za(i), this.array[e + 3] = Za(s), this } } class Pt extends lr { constructor(e, t, r) { super(new Float32Array(e), t, r) } } class TK extends lr { constructor(e, t, r) { super(new Float64Array(e), t, r) } } let wK = 0; const ul = new bt, zx = new Hn, y0 = new N, Io = new Tu, eg = new Tu, Ps = new N; class pn extends mc { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: wK++ }), this.uuid = Qo(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (MO(e) ? u8 : QS)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return this.attributes[e] !== void 0 } addGroup(e, t, r = 0) { this.groups.push({ start: e, count: t, materialIndex: r }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0); const r = this.attributes.normal; if (r !== void 0) { const s = new In().getNormalMatrix(e); r.applyNormalMatrix(s), r.needsUpdate = !0 } const i = this.attributes.tangent; return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion(e) { return ul.makeRotationFromQuaternion(e), this.applyMatrix4(ul), this } rotateX(e) { return ul.makeRotationX(e), this.applyMatrix4(ul), this } rotateY(e) { return ul.makeRotationY(e), this.applyMatrix4(ul), this } rotateZ(e) { return ul.makeRotationZ(e), this.applyMatrix4(ul), this } translate(e, t, r) { return ul.makeTranslation(e, t, r), this.applyMatrix4(ul), this } scale(e, t, r) { return ul.makeScale(e, t, r), this.applyMatrix4(ul), this } lookAt(e) { return zx.lookAt(e), zx.updateMatrix(), this.applyMatrix4(zx.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(y0).negate(), this.translate(y0.x, y0.y, y0.z), this } setFromPoints(e) { const t = []; for (let r = 0, i = e.length; r < i; r++) { const s = e[r]; t.push(s.x, s.y, s.z || 0) } return this.setAttribute("position", new Pt(t, 3)), this } computeBoundingBox() { this.boundingBox === null && (this.boundingBox = new Tu); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new N(-1 / 0, -1 / 0, -1 / 0), new N(1 / 0, 1 / 0, 1 / 0)); return } if (e !== void 0) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let r = 0, i = t.length; r < i; r++) { const s = t[r]; Io.setFromBufferAttribute(s), this.morphTargetsRelative ? (Ps.addVectors(this.boundingBox.min, Io.min), this.boundingBox.expandByPoint(Ps), Ps.addVectors(this.boundingBox.max, Io.max), this.boundingBox.expandByPoint(Ps)) : (this.boundingBox.expandByPoint(Io.min), this.boundingBox.expandByPoint(Io.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { this.boundingSphere === null && (this.boundingSphere = new kl); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new N, 1 / 0); return } if (e) { const r = this.boundingSphere.center; if (Io.setFromBufferAttribute(e), t) for (let s = 0, a = t.length; s < a; s++) { const o = t[s]; eg.setFromBufferAttribute(o), this.morphTargetsRelative ? (Ps.addVectors(Io.min, eg.min), Io.expandByPoint(Ps), Ps.addVectors(Io.max, eg.max), Io.expandByPoint(Ps)) : (Io.expandByPoint(eg.min), Io.expandByPoint(eg.max)) } Io.getCenter(r); let i = 0; for (let s = 0, a = e.count; s < a; s++)Ps.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(Ps)); if (t) for (let s = 0, a = t.length; s < a; s++) { const o = t[s], l = this.morphTargetsRelative; for (let u = 0, c = o.count; u < c; u++)Ps.fromBufferAttribute(o, u), l && (y0.fromBufferAttribute(e, u), Ps.add(y0)), i = Math.max(i, r.distanceToSquared(Ps)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } const r = e.array, i = t.position.array, s = t.normal.array, a = t.uv.array, o = i.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new lr(new Float32Array(4 * o), 4)); const l = this.getAttribute("tangent").array, u = [], c = []; for (let B = 0; B < o; B++)u[B] = new N, c[B] = new N; const h = new N, d = new N, m = new N, g = new Se, v = new Se, y = new Se, A = new N, _ = new N; function x(B, F, U) { h.fromArray(i, B * 3), d.fromArray(i, F * 3), m.fromArray(i, U * 3), g.fromArray(a, B * 2), v.fromArray(a, F * 2), y.fromArray(a, U * 2), d.sub(h), m.sub(h), v.sub(g), y.sub(g); const G = 1 / (v.x * y.y - y.x * v.y); isFinite(G) && (A.copy(d).multiplyScalar(y.y).addScaledVector(m, -v.y).multiplyScalar(G), _.copy(m).multiplyScalar(v.x).addScaledVector(d, -y.x).multiplyScalar(G), u[B].add(A), u[F].add(A), u[U].add(A), c[B].add(_), c[F].add(_), c[U].add(_)) } let C = this.groups; C.length === 0 && (C = [{ start: 0, count: r.length }]); for (let B = 0, F = C.length; B < F; ++B) { const U = C[B], G = U.start, Y = U.count; for (let Z = G, ne = G + Y; Z < ne; Z += 3)x(r[Z + 0], r[Z + 1], r[Z + 2]) } const T = new N, I = new N, w = new N, R = new N; function b(B) { w.fromArray(s, B * 3), R.copy(w); const F = u[B]; T.copy(F), T.sub(w.multiplyScalar(w.dot(F))).normalize(), I.crossVectors(R, F); const G = I.dot(c[B]) < 0 ? -1 : 1; l[B * 4] = T.x, l[B * 4 + 1] = T.y, l[B * 4 + 2] = T.z, l[B * 4 + 3] = G } for (let B = 0, F = C.length; B < F; ++B) { const U = C[B], G = U.start, Y = U.count; for (let Z = G, ne = G + Y; Z < ne; Z += 3)b(r[Z + 0]), b(r[Z + 1]), b(r[Z + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (t !== void 0) { let r = this.getAttribute("normal"); if (r === void 0) r = new lr(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r); else for (let d = 0, m = r.count; d < m; d++)r.setXYZ(d, 0, 0, 0); const i = new N, s = new N, a = new N, o = new N, l = new N, u = new N, c = new N, h = new N; if (e) for (let d = 0, m = e.count; d < m; d += 3) { const g = e.getX(d + 0), v = e.getX(d + 1), y = e.getX(d + 2); i.fromBufferAttribute(t, g), s.fromBufferAttribute(t, v), a.fromBufferAttribute(t, y), c.subVectors(a, s), h.subVectors(i, s), c.cross(h), o.fromBufferAttribute(r, g), l.fromBufferAttribute(r, v), u.fromBufferAttribute(r, y), o.add(c), l.add(c), u.add(c), r.setXYZ(g, o.x, o.y, o.z), r.setXYZ(v, l.x, l.y, l.z), r.setXYZ(y, u.x, u.y, u.z) } else for (let d = 0, m = t.count; d < m; d += 3)i.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), c.subVectors(a, s), h.subVectors(i, s), c.cross(h), r.setXYZ(d + 0, c.x, c.y, c.z), r.setXYZ(d + 1, c.x, c.y, c.z), r.setXYZ(d + 2, c.x, c.y, c.z); this.normalizeNormals(), r.needsUpdate = !0 } } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, r = e.count; t < r; t++)Ps.fromBufferAttribute(e, t), Ps.normalize(), e.setXYZ(t, Ps.x, Ps.y, Ps.z) } toNonIndexed() { function e(o, l) { const u = o.array, c = o.itemSize, h = o.normalized, d = new u.constructor(l.length * c); let m = 0, g = 0; for (let v = 0, y = l.length; v < y; v++) { o.isInterleavedBufferAttribute ? m = l[v] * o.data.stride + o.offset : m = l[v] * c; for (let A = 0; A < c; A++)d[g++] = u[m++] } return new lr(d, c, h) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new pn, r = this.index.array, i = this.attributes; for (const o in i) { const l = i[o], u = e(l, r); t.setAttribute(o, u) } const s = this.morphAttributes; for (const o in s) { const l = [], u = s[o]; for (let c = 0, h = u.length; c < h; c++) { const d = u[c], m = e(d, r); l.push(m) } t.morphAttributes[o] = l } t.morphTargetsRelative = this.morphTargetsRelative; const a = this.groups; for (let o = 0, l = a.length; o < l; o++) { const u = a[o]; t.addGroup(u.start, u.count, u.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) { const l = this.parameters; for (const u in l) l[u] !== void 0 && (e[u] = l[u]); return e } e.data = { attributes: {} }; const t = this.index; t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const r = this.attributes; for (const l in r) { const u = r[l]; e.data.attributes[l] = u.toJSON(e.data) } const i = {}; let s = !1; for (const l in this.morphAttributes) { const u = this.morphAttributes[l], c = []; for (let h = 0, d = u.length; h < d; h++) { const m = u[h]; c.push(m.toJSON(e.data)) } c.length > 0 && (i[l] = c, s = !0) } s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups; a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a))); const o = this.boundingSphere; return o !== null && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e } clone() { return new this.constructor().copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const r = e.index; r !== null && this.setIndex(r.clone(t)); const i = e.attributes; for (const u in i) { const c = i[u]; this.setAttribute(u, c.clone(t)) } const s = e.morphAttributes; for (const u in s) { const c = [], h = s[u]; for (let d = 0, m = h.length; d < m; d++)c.push(h[d].clone(t)); this.morphAttributes[u] = c } this.morphTargetsRelative = e.morphTargetsRelative; const a = e.groups; for (let u = 0, c = a.length; u < c; u++) { const h = a[u]; this.addGroup(h.start, h.count, h.materialIndex) } const o = e.boundingBox; o !== null && (this.boundingBox = o.clone()); const l = e.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } const Ab = new bt, gd = new Op, Pv = new kl, vb = new N, x0 = new N, _0 = new N, E0 = new N, Vx = new N, Dv = new N, Lv = new Se, Fv = new Se, kv = new Se, yb = new N, xb = new N, _b = new N, Nv = new N, Ov = new N; class gr extends Hn { constructor(e = new pn, t = new qs) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, a = i.length; s < a; s++) { const o = i[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s } } } } getVertexPosition(e, t) { const r = this.geometry, i = r.attributes.position, s = r.morphAttributes.position, a = r.morphTargetsRelative; t.fromBufferAttribute(i, e); const o = this.morphTargetInfluences; if (s && o) { Dv.set(0, 0, 0); for (let l = 0, u = s.length; l < u; l++) { const c = o[l], h = s[l]; c !== 0 && (Vx.fromBufferAttribute(h, e), a ? Dv.addScaledVector(Vx, c) : Dv.addScaledVector(Vx.sub(t), c)) } t.add(Dv) } return t } raycast(e, t) { const r = this.geometry, i = this.material, s = this.matrixWorld; i !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(), Pv.copy(r.boundingSphere), Pv.applyMatrix4(s), gd.copy(e.ray).recast(e.near), !(Pv.containsPoint(gd.origin) === !1 && (gd.intersectSphere(Pv, vb) === null || gd.origin.distanceToSquared(vb) > (e.far - e.near) ** 2)) && (Ab.copy(s).invert(), gd.copy(e.ray).applyMatrix4(Ab), !(r.boundingBox !== null && gd.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, gd))) } _computeIntersections(e, t, r) { let i; const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, h = s.attributes.normal, d = s.groups, m = s.drawRange; if (o !== null) if (Array.isArray(a)) for (let g = 0, v = d.length; g < v; g++) { const y = d[g], A = a[y.materialIndex], _ = Math.max(y.start, m.start), x = Math.min(o.count, Math.min(y.start + y.count, m.start + m.count)); for (let C = _, T = x; C < T; C += 3) { const I = o.getX(C), w = o.getX(C + 1), R = o.getX(C + 2); i = Uv(this, A, e, r, u, c, h, I, w, R), i && (i.faceIndex = Math.floor(C / 3), i.face.materialIndex = y.materialIndex, t.push(i)) } } else { const g = Math.max(0, m.start), v = Math.min(o.count, m.start + m.count); for (let y = g, A = v; y < A; y += 3) { const _ = o.getX(y), x = o.getX(y + 1), C = o.getX(y + 2); i = Uv(this, a, e, r, u, c, h, _, x, C), i && (i.faceIndex = Math.floor(y / 3), t.push(i)) } } else if (l !== void 0) if (Array.isArray(a)) for (let g = 0, v = d.length; g < v; g++) { const y = d[g], A = a[y.materialIndex], _ = Math.max(y.start, m.start), x = Math.min(l.count, Math.min(y.start + y.count, m.start + m.count)); for (let C = _, T = x; C < T; C += 3) { const I = C, w = C + 1, R = C + 2; i = Uv(this, A, e, r, u, c, h, I, w, R), i && (i.faceIndex = Math.floor(C / 3), i.face.materialIndex = y.materialIndex, t.push(i)) } } else { const g = Math.max(0, m.start), v = Math.min(l.count, m.start + m.count); for (let y = g, A = v; y < A; y += 3) { const _ = y, x = y + 1, C = y + 2; i = Uv(this, a, e, r, u, c, h, _, x, C), i && (i.faceIndex = Math.floor(y / 3), t.push(i)) } } } } function IK(n, e, t, r, i, s, a, o) { let l; if (e.side === pa ? l = r.intersectTriangle(a, s, i, !0, o) : l = r.intersectTriangle(i, s, a, e.side === pc, o), l === null) return null; Ov.copy(o), Ov.applyMatrix4(n.matrixWorld); const u = t.ray.origin.distanceTo(Ov); return u < t.near || u > t.far ? null : { distance: u, point: Ov.clone(), object: n } } function Uv(n, e, t, r, i, s, a, o, l, u) { n.getVertexPosition(o, x0), n.getVertexPosition(l, _0), n.getVertexPosition(u, E0); const c = IK(n, e, t, r, x0, _0, E0, Nv); if (c) { i && (Lv.fromBufferAttribute(i, o), Fv.fromBufferAttribute(i, l), kv.fromBufferAttribute(i, u), c.uv = to.getInterpolation(Nv, x0, _0, E0, Lv, Fv, kv, new Se)), s && (Lv.fromBufferAttribute(s, o), Fv.fromBufferAttribute(s, l), kv.fromBufferAttribute(s, u), c.uv1 = to.getInterpolation(Nv, x0, _0, E0, Lv, Fv, kv, new Se), c.uv2 = c.uv1), a && (yb.fromBufferAttribute(a, o), xb.fromBufferAttribute(a, l), _b.fromBufferAttribute(a, u), c.normal = to.getInterpolation(Nv, x0, _0, E0, yb, xb, _b, new N), c.normal.dot(r.direction) > 0 && c.normal.multiplyScalar(-1)); const h = { a: o, b: l, c: u, normal: new N, materialIndex: 0 }; to.getNormal(x0, _0, E0, h.normal), c.face = h } return c } class jh extends pn { constructor(e = 1, t = 1, r = 1, i = 1, s = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: r, widthSegments: i, heightSegments: s, depthSegments: a }; const o = this; i = Math.floor(i), s = Math.floor(s), a = Math.floor(a); const l = [], u = [], c = [], h = []; let d = 0, m = 0; g("z", "y", "x", -1, -1, r, t, e, a, s, 0), g("z", "y", "x", 1, -1, r, t, -e, a, s, 1), g("x", "z", "y", 1, 1, e, r, t, i, a, 2), g("x", "z", "y", 1, -1, e, r, -t, i, a, 3), g("x", "y", "z", 1, -1, e, t, r, i, s, 4), g("x", "y", "z", -1, -1, e, t, -r, i, s, 5), this.setIndex(l), this.setAttribute("position", new Pt(u, 3)), this.setAttribute("normal", new Pt(c, 3)), this.setAttribute("uv", new Pt(h, 2)); function g(v, y, A, _, x, C, T, I, w, R, b) { const B = C / w, F = T / R, U = C / 2, G = T / 2, Y = I / 2, Z = w + 1, ne = R + 1; let $ = 0, L = 0; const Q = new N; for (let D = 0; D < ne; D++) { const V = D * F - G; for (let J = 0; J < Z; J++) { const Ee = J * B - U; Q[v] = Ee * _, Q[y] = V * x, Q[A] = Y, u.push(Q.x, Q.y, Q.z), Q[v] = 0, Q[y] = 0, Q[A] = I > 0 ? 1 : -1, c.push(Q.x, Q.y, Q.z), h.push(J / w), h.push(1 - D / R), $ += 1 } } for (let D = 0; D < R; D++)for (let V = 0; V < w; V++) { const J = d + V + Z * D, Ee = d + V + Z * (D + 1), xe = d + (V + 1) + Z * (D + 1), Be = d + (V + 1) + Z * D; l.push(J, Ee, Be), l.push(Ee, xe, Be), L += 6 } o.addGroup(m, L, b), m += L, d += $ } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new jh(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function em(n) { const e = {}; for (const t in n) { e[t] = {}; for (const r in n[t]) { const i = n[t][r]; i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][r] = null) : e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i } } return e } function Ra(n) { const e = {}; for (let t = 0; t < n.length; t++) { const r = em(n[t]); for (const i in r) e[i] = r[i] } return e } function MK(n) { const e = []; for (let t = 0; t < n.length; t++)e.push(n[t].clone()); return e } function PO(n) { return n.getRenderTarget() === null ? n.outputColorSpace : yu } const mi = { clone: em, merge: Ra }; var bK = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, BK = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`; class tr extends as { constructor(e) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = bK, this.fragmentShader = BK, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = em(e.uniforms), this.uniformsGroups = MK(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const i in this.uniforms) { const a = this.uniforms[i].value; a && a.isTexture ? t.uniforms[i] = { type: "t", value: a.toJSON(e).uuid } : a && a.isColor ? t.uniforms[i] = { type: "c", value: a.getHex() } : a && a.isVector2 ? t.uniforms[i] = { type: "v2", value: a.toArray() } : a && a.isVector3 ? t.uniforms[i] = { type: "v3", value: a.toArray() } : a && a.isVector4 ? t.uniforms[i] = { type: "v4", value: a.toArray() } : a && a.isMatrix3 ? t.uniforms[i] = { type: "m3", value: a.toArray() } : a && a.isMatrix4 ? t.uniforms[i] = { type: "m4", value: a.toArray() } : t.uniforms[i] = { value: a } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping; const r = {}; for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0); return Object.keys(r).length > 0 && (t.extensions = r), t } } class D1 extends Hn { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new bt, this.projectionMatrix = new bt, this.projectionMatrixInverse = new bt, this.coordinateSystem = Zu } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return new this.constructor().copy(this) } } class Gr extends D1 { constructor(e = 50, t = 1, r = .1, i = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = $3 * 2 * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(fp * .5 * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return $3 * 2 * Math.atan(Math.tan(fp * .5 * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, r, i, s, a) { this.aspect = e / t, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(fp * .5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, s = -.5 * i; const a = this.view; if (this.view !== null && this.view.enabled) { const l = a.fullWidth, u = a.fullHeight; s += a.offsetX * i / l, t -= a.offsetY * r / u, i *= a.width / l, r *= a.height / u } const o = this.filmOffset; o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - r, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } const C0 = -90, S0 = 1; class HS extends Hn { constructor(e, t, r) { super(), this.type = "CubeCamera", this.renderTarget = r, this.coordinateSystem = null; const i = new Gr(C0, S0, e, t); i.layers = this.layers, this.add(i); const s = new Gr(C0, S0, e, t); s.layers = this.layers, this.add(s); const a = new Gr(C0, S0, e, t); a.layers = this.layers, this.add(a); const o = new Gr(C0, S0, e, t); o.layers = this.layers, this.add(o); const l = new Gr(C0, S0, e, t); l.layers = this.layers, this.add(l); const u = new Gr(C0, S0, e, t); u.layers = this.layers, this.add(u) } updateCoordinateSystem() { const e = this.coordinateSystem, t = this.children.concat(), [r, i, s, a, o, l] = t; for (const u of t) this.remove(u); if (e === Zu) r.up.set(0, 1, 0), r.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1); else if (e === a1) r.up.set(0, -1, 0), r.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1); else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e); for (const u of t) this.add(u), u.updateMatrixWorld() } update(e, t) { this.parent === null && this.updateMatrixWorld(); const r = this.renderTarget; this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem()); const [i, s, a, o, l, u] = this.children, c = e.getRenderTarget(), h = e.xr.enabled; e.xr.enabled = !1; const d = r.texture.generateMipmaps; r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, i), e.setRenderTarget(r, 1), e.render(t, s), e.setRenderTarget(r, 2), e.render(t, a), e.setRenderTarget(r, 3), e.render(t, o), e.setRenderTarget(r, 4), e.render(t, l), r.texture.generateMipmaps = d, e.setRenderTarget(r, 5), e.render(t, u), e.setRenderTarget(c), e.xr.enabled = h, r.texture.needsPMREMUpdate = !0 } } class L1 extends ri { constructor(e, t, r, i, s, a, o, l, u, c) { e = e !== void 0 ? e : [], t = t !== void 0 ? t : gf, super(e, t, r, i, s, a, o, l, u, c), this.isCubeTexture = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } class zS extends Ir {
		constructor(e = 1, t = {}) { super(e, e, t), this.isWebGLCubeRenderTarget = !0; const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r]; t.encoding !== void 0 && (oA("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Ch ? Ur : Sh), this.texture = new L1(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : wr } fromEquirectangularTexture(e, t) {
			this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const r = {
				uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, i = new jh(5, 5, 5), s = new tr({ name: "CubemapFromEquirect", uniforms: em(r.uniforms), vertexShader: r.vertexShader, fragmentShader: r.fragmentShader, side: pa, blending: On }); s.uniforms.tEquirect.value = t; const a = new gr(i, s), o = t.minFilter; return t.minFilter === Dl && (t.minFilter = wr), new HS(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this
		} clear(e, t, r, i) { const s = e.getRenderTarget(); for (let a = 0; a < 6; a++)e.setRenderTarget(this, a), e.clear(t, r, i); e.setRenderTarget(s) }
	} const Wx = new N, RK = new N, PK = new In; class Do { constructor(e = new N(1, 0, 0), t = 0) { this.isPlane = !0, this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, r, i) { return this.normal.set(e, t, r), this.constant = i, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, r) { const i = Wx.subVectors(r, t).cross(RK.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e)) } intersectLine(e, t) { const r = e.delta(Wx), i = this.normal.dot(r); if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null; const s = -(e.start.dot(this.normal) + this.constant) / i; return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s) } intersectsLine(e) { const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end); return t < 0 && r > 0 || r < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const r = t || PK.getNormalMatrix(e), i = this.coplanarPoint(Wx).applyMatrix4(e), s = this.normal.applyMatrix3(r).normalize(); return this.constant = -i.dot(s), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return new this.constructor().copy(this) } } const Ad = new kl, Gv = new N; class c8 { constructor(e = new Do, t = new Do, r = new Do, i = new Do, s = new Do, a = new Do) { this.planes = [e, t, r, i, s, a] } set(e, t, r, i, s, a) { const o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(r), o[3].copy(i), o[4].copy(s), o[5].copy(a), this } copy(e) { const t = this.planes; for (let r = 0; r < 6; r++)t[r].copy(e.planes[r]); return this } setFromProjectionMatrix(e, t = Zu) { const r = this.planes, i = e.elements, s = i[0], a = i[1], o = i[2], l = i[3], u = i[4], c = i[5], h = i[6], d = i[7], m = i[8], g = i[9], v = i[10], y = i[11], A = i[12], _ = i[13], x = i[14], C = i[15]; if (r[0].setComponents(l - s, d - u, y - m, C - A).normalize(), r[1].setComponents(l + s, d + u, y + m, C + A).normalize(), r[2].setComponents(l + a, d + c, y + g, C + _).normalize(), r[3].setComponents(l - a, d - c, y - g, C - _).normalize(), r[4].setComponents(l - o, d - h, y - v, C - x).normalize(), t === Zu) r[5].setComponents(l + o, d + h, y + v, C + x).normalize(); else if (t === a1) r[5].setComponents(o, h, v, x).normalize(); else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t); return this } intersectsObject(e) { if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Ad.copy(e.boundingSphere).applyMatrix4(e.matrixWorld); else { const t = e.geometry; t.boundingSphere === null && t.computeBoundingSphere(), Ad.copy(t.boundingSphere).applyMatrix4(e.matrixWorld) } return this.intersectsSphere(Ad) } intersectsSprite(e) { return Ad.center.set(0, 0, 0), Ad.radius = .7071067811865476, Ad.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ad) } intersectsSphere(e) { const t = this.planes, r = e.center, i = -e.radius; for (let s = 0; s < 6; s++)if (t[s].distanceToPoint(r) < i) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let r = 0; r < 6; r++) { const i = t[r]; if (Gv.x = i.normal.x > 0 ? e.max.x : e.min.x, Gv.y = i.normal.y > 0 ? e.max.y : e.min.y, Gv.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Gv) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let r = 0; r < 6; r++)if (t[r].distanceToPoint(e) < 0) return !1; return !0 } clone() { return new this.constructor().copy(this) } } function DO() { let n = null, e = !1, t = null, r = null; function i(s, a) { t(s, a), r = n.requestAnimationFrame(i) } return { start: function () { e !== !0 && t !== null && (r = n.requestAnimationFrame(i), e = !0) }, stop: function () { n.cancelAnimationFrame(r), e = !1 }, setAnimationLoop: function (s) { t = s }, setContext: function (s) { n = s } } } function DK(n, e) { const t = e.isWebGL2, r = new WeakMap; function i(u, c) { const h = u.array, d = u.usage, m = n.createBuffer(); n.bindBuffer(c, m), n.bufferData(c, h, d), u.onUploadCallback(); let g; if (h instanceof Float32Array) g = n.FLOAT; else if (h instanceof Uint16Array) if (u.isFloat16BufferAttribute) if (t) g = n.HALF_FLOAT; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else g = n.UNSIGNED_SHORT; else if (h instanceof Int16Array) g = n.SHORT; else if (h instanceof Uint32Array) g = n.UNSIGNED_INT; else if (h instanceof Int32Array) g = n.INT; else if (h instanceof Int8Array) g = n.BYTE; else if (h instanceof Uint8Array) g = n.UNSIGNED_BYTE; else if (h instanceof Uint8ClampedArray) g = n.UNSIGNED_BYTE; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h); return { buffer: m, type: g, bytesPerElement: h.BYTES_PER_ELEMENT, version: u.version } } function s(u, c, h) { const d = c.array, m = c.updateRange; n.bindBuffer(h, u), m.count === -1 ? n.bufferSubData(h, 0, d) : (t ? n.bufferSubData(h, m.offset * d.BYTES_PER_ELEMENT, d, m.offset, m.count) : n.bufferSubData(h, m.offset * d.BYTES_PER_ELEMENT, d.subarray(m.offset, m.offset + m.count)), m.count = -1), c.onUploadCallback() } function a(u) { return u.isInterleavedBufferAttribute && (u = u.data), r.get(u) } function o(u) { u.isInterleavedBufferAttribute && (u = u.data); const c = r.get(u); c && (n.deleteBuffer(c.buffer), r.delete(u)) } function l(u, c) { if (u.isGLBufferAttribute) { const d = r.get(u); (!d || d.version < u.version) && r.set(u, { buffer: u.buffer, type: u.type, bytesPerElement: u.elementSize, version: u.version }); return } u.isInterleavedBufferAttribute && (u = u.data); const h = r.get(u); h === void 0 ? r.set(u, i(u, c)) : h.version < u.version && (s(h.buffer, u, c), h.version = u.version) } return { get: a, remove: o, update: l } } class vm extends pn { constructor(e = 1, t = 1, r = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: r, heightSegments: i }; const s = e / 2, a = t / 2, o = Math.floor(r), l = Math.floor(i), u = o + 1, c = l + 1, h = e / o, d = t / l, m = [], g = [], v = [], y = []; for (let A = 0; A < c; A++) { const _ = A * d - a; for (let x = 0; x < u; x++) { const C = x * h - s; g.push(C, -_, 0), v.push(0, 0, 1), y.push(x / o), y.push(1 - A / l) } } for (let A = 0; A < l; A++)for (let _ = 0; _ < o; _++) { const x = _ + u * A, C = _ + u * (A + 1), T = _ + 1 + u * (A + 1), I = _ + 1 + u * A; m.push(x, C, I), m.push(C, T, I) } this.setIndex(m), this.setAttribute("position", new Pt(g, 3)), this.setAttribute("normal", new Pt(v, 3)), this.setAttribute("uv", new Pt(y, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new vm(e.width, e.height, e.widthSegments, e.heightSegments) } } var LK = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, FK = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, kK = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, NK = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, OK = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, UK = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, GK = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, QK = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, HK = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, zK = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, VK = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, WK = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, XK = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, YK = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, jK = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, JK = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, KK = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, qK = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, ZK = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, $K = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, eq = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, tq = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, nq = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, rq = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, iq = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, sq = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, aq = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, oq = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, lq = "gl_FragColor = linearToOutputTexel( gl_FragColor );", uq = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, cq = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, fq = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, hq = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, dq = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, pq = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, mq = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, gq = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Aq = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, vq = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, yq = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, xq = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, _q = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Eq = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Cq = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Sq = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Tq = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, wq = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Iq = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Mq = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, bq = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Bq = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`, Rq = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Pq = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Dq = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Lq = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, Fq = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, kq = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Nq = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Oq = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, Uq = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Gq = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Qq = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Hq = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, zq = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Vq = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Wq = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Xq = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Yq = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, jq = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Jq = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`, Kq = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, qq = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Zq = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, $q = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, eZ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, tZ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, nZ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, rZ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, iZ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, sZ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, aZ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, oZ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, lZ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, uZ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, cZ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, fZ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, hZ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, dZ = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, pZ = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, mZ = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, gZ = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, AZ = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, vZ = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, yZ = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, xZ = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, _Z = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, EZ = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, CZ = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, SZ = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, TZ = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, wZ = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, IZ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, MZ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, bZ = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, BZ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`; const RZ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, PZ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, DZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, LZ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, FZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, kZ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, NZ = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, OZ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, UZ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, GZ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, QZ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, HZ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, zZ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, VZ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, WZ = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, XZ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, YZ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, jZ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, JZ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, KZ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qZ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, ZZ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, $Z = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, e$ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, t$ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, n$ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, r$ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, i$ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, s$ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, a$ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, o$ = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, l$ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, u$ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, c$ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Cn = { alphahash_fragment: LK, alphahash_pars_fragment: FK, alphamap_fragment: kK, alphamap_pars_fragment: NK, alphatest_fragment: OK, alphatest_pars_fragment: UK, aomap_fragment: GK, aomap_pars_fragment: QK, begin_vertex: HK, beginnormal_vertex: zK, bsdfs: VK, iridescence_fragment: WK, bumpmap_pars_fragment: XK, clipping_planes_fragment: YK, clipping_planes_pars_fragment: jK, clipping_planes_pars_vertex: JK, clipping_planes_vertex: KK, color_fragment: qK, color_pars_fragment: ZK, color_pars_vertex: $K, color_vertex: eq, common: tq, cube_uv_reflection_fragment: nq, defaultnormal_vertex: rq, displacementmap_pars_vertex: iq, displacementmap_vertex: sq, emissivemap_fragment: aq, emissivemap_pars_fragment: oq, colorspace_fragment: lq, colorspace_pars_fragment: uq, envmap_fragment: cq, envmap_common_pars_fragment: fq, envmap_pars_fragment: hq, envmap_pars_vertex: dq, envmap_physical_pars_fragment: Tq, envmap_vertex: pq, fog_vertex: mq, fog_pars_vertex: gq, fog_fragment: Aq, fog_pars_fragment: vq, gradientmap_pars_fragment: yq, lightmap_fragment: xq, lightmap_pars_fragment: _q, lights_lambert_fragment: Eq, lights_lambert_pars_fragment: Cq, lights_pars_begin: Sq, lights_toon_fragment: wq, lights_toon_pars_fragment: Iq, lights_phong_fragment: Mq, lights_phong_pars_fragment: bq, lights_physical_fragment: Bq, lights_physical_pars_fragment: Rq, lights_fragment_begin: Pq, lights_fragment_maps: Dq, lights_fragment_end: Lq, logdepthbuf_fragment: Fq, logdepthbuf_pars_fragment: kq, logdepthbuf_pars_vertex: Nq, logdepthbuf_vertex: Oq, map_fragment: Uq, map_pars_fragment: Gq, map_particle_fragment: Qq, map_particle_pars_fragment: Hq, metalnessmap_fragment: zq, metalnessmap_pars_fragment: Vq, morphcolor_vertex: Wq, morphnormal_vertex: Xq, morphtarget_pars_vertex: Yq, morphtarget_vertex: jq, normal_fragment_begin: Jq, normal_fragment_maps: Kq, normal_pars_fragment: qq, normal_pars_vertex: Zq, normal_vertex: $q, normalmap_pars_fragment: eZ, clearcoat_normal_fragment_begin: tZ, clearcoat_normal_fragment_maps: nZ, clearcoat_pars_fragment: rZ, iridescence_pars_fragment: iZ, opaque_fragment: sZ, packing: aZ, premultiplied_alpha_fragment: oZ, project_vertex: lZ, dithering_fragment: uZ, dithering_pars_fragment: cZ, roughnessmap_fragment: fZ, roughnessmap_pars_fragment: hZ, shadowmap_pars_fragment: dZ, shadowmap_pars_vertex: pZ, shadowmap_vertex: mZ, shadowmask_pars_fragment: gZ, skinbase_vertex: AZ, skinning_pars_vertex: vZ, skinning_vertex: yZ, skinnormal_vertex: xZ, specularmap_fragment: _Z, specularmap_pars_fragment: EZ, tonemapping_fragment: CZ, tonemapping_pars_fragment: SZ, transmission_fragment: TZ, transmission_pars_fragment: wZ, uv_pars_fragment: IZ, uv_pars_vertex: MZ, uv_vertex: bZ, worldpos_vertex: BZ, background_vert: RZ, background_frag: PZ, backgroundCube_vert: DZ, backgroundCube_frag: LZ, cube_vert: FZ, cube_frag: kZ, depth_vert: NZ, depth_frag: OZ, distanceRGBA_vert: UZ, distanceRGBA_frag: GZ, equirect_vert: QZ, equirect_frag: HZ, linedashed_vert: zZ, linedashed_frag: VZ, meshbasic_vert: WZ, meshbasic_frag: XZ, meshlambert_vert: YZ, meshlambert_frag: jZ, meshmatcap_vert: JZ, meshmatcap_frag: KZ, meshnormal_vert: qZ, meshnormal_frag: ZZ, meshphong_vert: $Z, meshphong_frag: e$, meshphysical_vert: t$, meshphysical_frag: n$, meshtoon_vert: r$, meshtoon_frag: i$, points_vert: s$, points_frag: a$, shadow_vert: o$, shadow_frag: l$, sprite_vert: u$, sprite_frag: c$ }, ot = { common: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new In }, alphaMap: { value: null }, alphaMapTransform: { value: new In }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new In } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new In } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new In } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new In }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new In }, normalScale: { value: new Se(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new In }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new In } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new In } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new In } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Je(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new In }, alphaTest: { value: 0 }, uvTransform: { value: new In } }, sprite: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, center: { value: new Se(.5, .5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new In }, alphaMap: { value: null }, alphaMapTransform: { value: new In }, alphaTest: { value: 0 } } }, uu = { basic: { uniforms: Ra([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.fog]), vertexShader: Cn.meshbasic_vert, fragmentShader: Cn.meshbasic_frag }, lambert: { uniforms: Ra([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, ot.lights, { emissive: { value: new Je(0) } }]), vertexShader: Cn.meshlambert_vert, fragmentShader: Cn.meshlambert_frag }, phong: { uniforms: Ra([ot.common, ot.specularmap, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, ot.lights, { emissive: { value: new Je(0) }, specular: { value: new Je(1118481) }, shininess: { value: 30 } }]), vertexShader: Cn.meshphong_vert, fragmentShader: Cn.meshphong_frag }, standard: { uniforms: Ra([ot.common, ot.envmap, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.roughnessmap, ot.metalnessmap, ot.fog, ot.lights, { emissive: { value: new Je(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Cn.meshphysical_vert, fragmentShader: Cn.meshphysical_frag }, toon: { uniforms: Ra([ot.common, ot.aomap, ot.lightmap, ot.emissivemap, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.gradientmap, ot.fog, ot.lights, { emissive: { value: new Je(0) } }]), vertexShader: Cn.meshtoon_vert, fragmentShader: Cn.meshtoon_frag }, matcap: { uniforms: Ra([ot.common, ot.bumpmap, ot.normalmap, ot.displacementmap, ot.fog, { matcap: { value: null } }]), vertexShader: Cn.meshmatcap_vert, fragmentShader: Cn.meshmatcap_frag }, points: { uniforms: Ra([ot.points, ot.fog]), vertexShader: Cn.points_vert, fragmentShader: Cn.points_frag }, dashed: { uniforms: Ra([ot.common, ot.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Cn.linedashed_vert, fragmentShader: Cn.linedashed_frag }, depth: { uniforms: Ra([ot.common, ot.displacementmap]), vertexShader: Cn.depth_vert, fragmentShader: Cn.depth_frag }, normal: { uniforms: Ra([ot.common, ot.bumpmap, ot.normalmap, ot.displacementmap, { opacity: { value: 1 } }]), vertexShader: Cn.meshnormal_vert, fragmentShader: Cn.meshnormal_frag }, sprite: { uniforms: Ra([ot.sprite, ot.fog]), vertexShader: Cn.sprite_vert, fragmentShader: Cn.sprite_frag }, background: { uniforms: { uvTransform: { value: new In }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: Cn.background_vert, fragmentShader: Cn.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: Cn.backgroundCube_vert, fragmentShader: Cn.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: Cn.cube_vert, fragmentShader: Cn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Cn.equirect_vert, fragmentShader: Cn.equirect_frag }, distanceRGBA: { uniforms: Ra([ot.common, ot.displacementmap, { referencePosition: { value: new N }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Cn.distanceRGBA_vert, fragmentShader: Cn.distanceRGBA_frag }, shadow: { uniforms: Ra([ot.lights, ot.fog, { color: { value: new Je(0) }, opacity: { value: 1 } }]), vertexShader: Cn.shadow_vert, fragmentShader: Cn.shadow_frag } }; uu.physical = { uniforms: Ra([uu.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new In }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new In }, clearcoatNormalScale: { value: new Se(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new In }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new In }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new In }, sheen: { value: 0 }, sheenColor: { value: new Je(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new In }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new In }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new In }, transmissionSamplerSize: { value: new Se }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new In }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Je(0) }, specularColor: { value: new Je(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new In }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new In }, anisotropyVector: { value: new Se }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new In } }]), vertexShader: Cn.meshphysical_vert, fragmentShader: Cn.meshphysical_frag }; const Qv = { r: 0, b: 0, g: 0 }; function f$(n, e, t, r, i, s, a) { const o = new Je(0); let l = s === !0 ? 0 : 1, u, c, h = null, d = 0, m = null; function g(y, A) { let _ = !1, x = A.isScene === !0 ? A.background : null; x && x.isTexture && (x = (A.backgroundBlurriness > 0 ? t : e).get(x)), x === null ? v(o, l) : x && x.isColor && (v(x, 1), _ = !0); const C = n.xr.getEnvironmentBlendMode(); C === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, a) : C === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || _) && n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil), x && (x.isCubeTexture || x.mapping === Am) ? (c === void 0 && (c = new gr(new jh(1, 1, 1), new tr({ name: "BackgroundCubeMaterial", uniforms: em(uu.backgroundCube.uniforms), vertexShader: uu.backgroundCube.vertexShader, fragmentShader: uu.backgroundCube.fragmentShader, side: pa, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (T, I, w) { this.matrixWorld.copyPosition(w.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(c)), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = A.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, c.material.toneMapped = x.colorSpace !== Ur, (h !== x || d !== x.version || m !== n.toneMapping) && (c.material.needsUpdate = !0, h = x, d = x.version, m = n.toneMapping), c.layers.enableAll(), y.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new gr(new vm(2, 2), new tr({ name: "BackgroundMaterial", uniforms: em(uu.background.uniforms), vertexShader: uu.background.vertexShader, fragmentShader: uu.background.fragmentShader, side: pc, depthTest: !1, depthWrite: !1, fog: !1 })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = A.backgroundIntensity, u.material.toneMapped = x.colorSpace !== Ur, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (h !== x || d !== x.version || m !== n.toneMapping) && (u.material.needsUpdate = !0, h = x, d = x.version, m = n.toneMapping), u.layers.enableAll(), y.unshift(u, u.geometry, u.material, 0, 0, null)) } function v(y, A) { y.getRGB(Qv, PO(n)), r.buffers.color.setClear(Qv.r, Qv.g, Qv.b, A, a) } return { getClearColor: function () { return o }, setClearColor: function (y, A = 1) { o.set(y), l = A, v(o, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (y) { l = y, v(o, l) }, render: g } } function h$(n, e, t, r) { const i = n.getParameter(n.MAX_VERTEX_ATTRIBS), s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), a = r.isWebGL2 || s !== null, o = {}, l = y(null); let u = l, c = !1; function h(Y, Z, ne, $, L) { let Q = !1; if (a) { const D = v($, ne, Z); u !== D && (u = D, m(u.object)), Q = A(Y, $, ne, L), Q && _(Y, $, ne, L) } else { const D = Z.wireframe === !0; (u.geometry !== $.id || u.program !== ne.id || u.wireframe !== D) && (u.geometry = $.id, u.program = ne.id, u.wireframe = D, Q = !0) } L !== null && t.update(L, n.ELEMENT_ARRAY_BUFFER), (Q || c) && (c = !1, R(Y, Z, ne, $), L !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(L).buffer)) } function d() { return r.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES() } function m(Y) { return r.isWebGL2 ? n.bindVertexArray(Y) : s.bindVertexArrayOES(Y) } function g(Y) { return r.isWebGL2 ? n.deleteVertexArray(Y) : s.deleteVertexArrayOES(Y) } function v(Y, Z, ne) { const $ = ne.wireframe === !0; let L = o[Y.id]; L === void 0 && (L = {}, o[Y.id] = L); let Q = L[Z.id]; Q === void 0 && (Q = {}, L[Z.id] = Q); let D = Q[$]; return D === void 0 && (D = y(d()), Q[$] = D), D } function y(Y) { const Z = [], ne = [], $ = []; for (let L = 0; L < i; L++)Z[L] = 0, ne[L] = 0, $[L] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: Z, enabledAttributes: ne, attributeDivisors: $, object: Y, attributes: {}, index: null } } function A(Y, Z, ne, $) { const L = u.attributes, Q = Z.attributes; let D = 0; const V = ne.getAttributes(); for (const J in V) if (V[J].location >= 0) { const xe = L[J]; let Be = Q[J]; if (Be === void 0 && (J === "instanceMatrix" && Y.instanceMatrix && (Be = Y.instanceMatrix), J === "instanceColor" && Y.instanceColor && (Be = Y.instanceColor)), xe === void 0 || xe.attribute !== Be || Be && xe.data !== Be.data) return !0; D++ } return u.attributesNum !== D || u.index !== $ } function _(Y, Z, ne, $) { const L = {}, Q = Z.attributes; let D = 0; const V = ne.getAttributes(); for (const J in V) if (V[J].location >= 0) { let xe = Q[J]; xe === void 0 && (J === "instanceMatrix" && Y.instanceMatrix && (xe = Y.instanceMatrix), J === "instanceColor" && Y.instanceColor && (xe = Y.instanceColor)); const Be = {}; Be.attribute = xe, xe && xe.data && (Be.data = xe.data), L[J] = Be, D++ } u.attributes = L, u.attributesNum = D, u.index = $ } function x() { const Y = u.newAttributes; for (let Z = 0, ne = Y.length; Z < ne; Z++)Y[Z] = 0 } function C(Y) { T(Y, 0) } function T(Y, Z) { const ne = u.newAttributes, $ = u.enabledAttributes, L = u.attributeDivisors; ne[Y] = 1, $[Y] === 0 && (n.enableVertexAttribArray(Y), $[Y] = 1), L[Y] !== Z && ((r.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](Y, Z), L[Y] = Z) } function I() { const Y = u.newAttributes, Z = u.enabledAttributes; for (let ne = 0, $ = Z.length; ne < $; ne++)Z[ne] !== Y[ne] && (n.disableVertexAttribArray(ne), Z[ne] = 0) } function w(Y, Z, ne, $, L, Q, D) { D === !0 ? n.vertexAttribIPointer(Y, Z, ne, L, Q) : n.vertexAttribPointer(Y, Z, ne, $, L, Q) } function R(Y, Z, ne, $) { if (r.isWebGL2 === !1 && (Y.isInstancedMesh || $.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return; x(); const L = $.attributes, Q = ne.getAttributes(), D = Z.defaultAttributeValues; for (const V in Q) { const J = Q[V]; if (J.location >= 0) { let Ee = L[V]; if (Ee === void 0 && (V === "instanceMatrix" && Y.instanceMatrix && (Ee = Y.instanceMatrix), V === "instanceColor" && Y.instanceColor && (Ee = Y.instanceColor)), Ee !== void 0) { const xe = Ee.normalized, Be = Ee.itemSize, Fe = t.get(Ee); if (Fe === void 0) continue; const we = Fe.buffer, ge = Fe.type, tt = Fe.bytesPerElement, je = r.isWebGL2 === !0 && (ge === n.INT || ge === n.UNSIGNED_INT || Ee.gpuType === IS); if (Ee.isInterleavedBufferAttribute) { const Oe = Ee.data, K = Oe.stride, de = Ee.offset; if (Oe.isInstancedInterleavedBuffer) { for (let Ce = 0; Ce < J.locationSize; Ce++)T(J.location + Ce, Oe.meshPerAttribute); Y.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = Oe.meshPerAttribute * Oe.count) } else for (let Ce = 0; Ce < J.locationSize; Ce++)C(J.location + Ce); n.bindBuffer(n.ARRAY_BUFFER, we); for (let Ce = 0; Ce < J.locationSize; Ce++)w(J.location + Ce, Be / J.locationSize, ge, xe, K * tt, (de + Be / J.locationSize * Ce) * tt, je) } else { if (Ee.isInstancedBufferAttribute) { for (let Oe = 0; Oe < J.locationSize; Oe++)T(J.location + Oe, Ee.meshPerAttribute); Y.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = Ee.meshPerAttribute * Ee.count) } else for (let Oe = 0; Oe < J.locationSize; Oe++)C(J.location + Oe); n.bindBuffer(n.ARRAY_BUFFER, we); for (let Oe = 0; Oe < J.locationSize; Oe++)w(J.location + Oe, Be / J.locationSize, ge, xe, Be * tt, Be / J.locationSize * Oe * tt, je) } } else if (D !== void 0) { const xe = D[V]; if (xe !== void 0) switch (xe.length) { case 2: n.vertexAttrib2fv(J.location, xe); break; case 3: n.vertexAttrib3fv(J.location, xe); break; case 4: n.vertexAttrib4fv(J.location, xe); break; default: n.vertexAttrib1fv(J.location, xe) } } } } I() } function b() { U(); for (const Y in o) { const Z = o[Y]; for (const ne in Z) { const $ = Z[ne]; for (const L in $) g($[L].object), delete $[L]; delete Z[ne] } delete o[Y] } } function B(Y) { if (o[Y.id] === void 0) return; const Z = o[Y.id]; for (const ne in Z) { const $ = Z[ne]; for (const L in $) g($[L].object), delete $[L]; delete Z[ne] } delete o[Y.id] } function F(Y) { for (const Z in o) { const ne = o[Z]; if (ne[Y.id] === void 0) continue; const $ = ne[Y.id]; for (const L in $) g($[L].object), delete $[L]; delete ne[Y.id] } } function U() { G(), c = !0, u !== l && (u = l, m(u.object)) } function G() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: h, reset: U, resetDefaultState: G, dispose: b, releaseStatesOfGeometry: B, releaseStatesOfProgram: F, initAttributes: x, enableAttribute: C, disableUnusedAttributes: I } } function d$(n, e, t, r) { const i = r.isWebGL2; let s; function a(u) { s = u } function o(u, c) { n.drawArrays(s, u, c), t.update(c, s, 1) } function l(u, c, h) { if (h === 0) return; let d, m; if (i) d = n, m = "drawArraysInstanced"; else if (d = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", d === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } d[m](s, u, c, h), t.update(c, s, h) } this.setMode = a, this.render = o, this.renderInstances = l } function p$(n, e, t) { let r; function i() { if (r !== void 0) return r; if (e.has("EXT_texture_filter_anisotropic") === !0) { const w = e.get("EXT_texture_filter_anisotropic"); r = n.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r } function s(w) { if (w === "highp") { if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp"; w = "mediump" } return w === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } const a = typeof WebGL2RenderingContext < "u" && n.constructor.name === "WebGL2RenderingContext"; let o = t.precision !== void 0 ? t.precision : "highp"; const l = s(o); l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l); const u = a || e.has("WEBGL_draw_buffers"), c = t.logarithmicDepthBuffer === !0, h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = n.getParameter(n.MAX_TEXTURE_SIZE), g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), v = n.getParameter(n.MAX_VERTEX_ATTRIBS), y = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), A = n.getParameter(n.MAX_VARYING_VECTORS), _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), x = d > 0, C = a || e.has("OES_texture_float"), T = x && C, I = a ? n.getParameter(n.MAX_SAMPLES) : 0; return { isWebGL2: a, drawBuffers: u, getMaxAnisotropy: i, getMaxPrecision: s, precision: o, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: d, maxTextureSize: m, maxCubemapSize: g, maxAttributes: v, maxVertexUniforms: y, maxVaryings: A, maxFragmentUniforms: _, vertexTextures: x, floatFragmentTextures: C, floatVertexTextures: T, maxSamples: I } } function m$(n) { const e = this; let t = null, r = 0, i = !1, s = !1; const a = new Do, o = new In, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (h, d) { const m = h.length !== 0 || d || r !== 0 || i; return i = d, r = h.length, m }, this.beginShadows = function () { s = !0, c(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (h, d) { t = c(h, d, 0) }, this.setState = function (h, d, m) { const g = h.clippingPlanes, v = h.clipIntersection, y = h.clipShadows, A = n.get(h); if (!i || g === null || g.length === 0 || s && !y) s ? c(null) : u(); else { const _ = s ? 0 : r, x = _ * 4; let C = A.clippingState || null; l.value = C, C = c(g, d, x, m); for (let T = 0; T !== x; ++T)C[T] = t[T]; A.clippingState = C, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += _ } }; function u() { l.value !== t && (l.value = t, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0 } function c(h, d, m, g) { const v = h !== null ? h.length : 0; let y = null; if (v !== 0) { if (y = l.value, g !== !0 || y === null) { const A = m + v * 4, _ = d.matrixWorldInverse; o.getNormalMatrix(_), (y === null || y.length < A) && (y = new Float32Array(A)); for (let x = 0, C = m; x !== v; ++x, C += 4)a.copy(h[x]).applyMatrix4(_, o), a.normal.toArray(y, C), y[C + 3] = a.constant } l.value = y, l.needsUpdate = !0 } return e.numPlanes = v, e.numIntersection = 0, y } } function g$(n) { let e = new WeakMap; function t(a, o) { return o === KA ? a.mapping = gf : o === qA && (a.mapping = Lh), a } function r(a) { if (a && a.isTexture && a.isRenderTargetTexture === !1) { const o = a.mapping; if (o === KA || o === qA) if (e.has(a)) { const l = e.get(a).texture; return t(l, a.mapping) } else { const l = a.image; if (l && l.height > 0) { const u = new zS(l.height / 2); return u.fromEquirectangularTexture(n, a), e.set(a, u), a.addEventListener("dispose", i), t(u.texture, a.mapping) } else return null } } return a } function i(a) { const o = a.target; o.removeEventListener("dispose", i); const l = e.get(o); l !== void 0 && (e.delete(o), l.dispose()) } function s() { e = new WeakMap } return { get: r, dispose: s } } class hu extends D1 { constructor(e = -1, t = 1, r = 1, i = -1, s = .1, a = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = s, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this } setViewOffset(e, t, r, i, s, a) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let s = r - e, a = r + e, o = i + t, l = i - t; if (this.view !== null && this.view.enabled) { const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s += u * this.view.offsetX, a = s + u * this.view.width, o -= c * this.view.offsetY, l = o - c * this.view.height } this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } } const c3 = 4, Eb = [.125, .215, .35, .446, .526, .582], Ud = 20, Xx = new hu, Cb = new Je; let Yx = null; const Dd = (1 + Math.sqrt(5)) / 2, T0 = 1 / Dd, Sb = [new N(1, 1, 1), new N(-1, 1, 1), new N(1, 1, -1), new N(-1, 1, -1), new N(0, Dd, T0), new N(0, Dd, -T0), new N(T0, 0, Dd), new N(-T0, 0, Dd), new N(Dd, T0, 0), new N(-Dd, T0, 0)]; class o7 { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, r = .1, i = 100) { Yx = this._renderer.getRenderTarget(), this._setSize(256); const s = this._allocateTargets(); return s.depthBuffer = !0, this._sceneToCubeUV(e, r, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { this._cubemapMaterial === null && (this._cubemapMaterial = Ib(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { this._equirectMaterial === null && (this._equirectMaterial = wb(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(Yx), e.scissorTest = !1, Hv(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === gf || e.mapping === Lh ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Yx = this._renderer.getRenderTarget(); const r = t || this._allocateTargets(); return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = { magFilter: wr, minFilter: wr, generateMipmaps: !1, type: Wi, format: Ri, colorSpace: yu, depthBuffer: !1 }, i = Tb(e, t, r); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Tb(e, t, r); const { _lodMax: s } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = A$(s)), this._blurMaterial = v$(s, e, t) } return i } _compileMaterial(e) { const t = new gr(this._lodPlanes[0], e); this._renderer.compile(t, Xx) } _sceneToCubeUV(e, t, r, i) { const o = new Gr(90, 1, t, r), l = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], c = this._renderer, h = c.autoClear, d = c.toneMapping; c.getClearColor(Cb), c.toneMapping = wl, c.autoClear = !1; const m = new qs({ name: "PMREM.Background", side: pa, depthWrite: !1, depthTest: !1 }), g = new gr(new jh, m); let v = !1; const y = e.background; y ? y.isColor && (m.color.copy(y), e.background = null, v = !0) : (m.color.copy(Cb), v = !0); for (let A = 0; A < 6; A++) { const _ = A % 3; _ === 0 ? (o.up.set(0, l[A], 0), o.lookAt(u[A], 0, 0)) : _ === 1 ? (o.up.set(0, 0, l[A]), o.lookAt(0, u[A], 0)) : (o.up.set(0, l[A], 0), o.lookAt(0, 0, u[A])); const x = this._cubeSize; Hv(i, _ * x, A > 2 ? x : 0, x, x), c.setRenderTarget(i), v && c.render(g, o), c.render(e, o) } g.geometry.dispose(), g.material.dispose(), c.toneMapping = d, c.autoClear = h, e.background = y } _textureToCubeUV(e, t) { const r = this._renderer, i = e.mapping === gf || e.mapping === Lh; i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ib()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = wb()); const s = i ? this._cubemapMaterial : this._equirectMaterial, a = new gr(this._lodPlanes[0], s), o = s.uniforms; o.envMap.value = e; const l = this._cubeSize; Hv(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(a, Xx) } _applyPMREM(e) { const t = this._renderer, r = t.autoClear; t.autoClear = !1; for (let i = 1; i < this._lodPlanes.length; i++) { const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), a = Sb[(i - 1) % Sb.length]; this._blur(e, i - 1, i, s, a) } t.autoClear = r } _blur(e, t, r, i, s) { const a = this._pingPongRenderTarget; this._halfBlur(e, a, t, r, i, "latitudinal", s), this._halfBlur(a, e, r, r, i, "longitudinal", s) } _halfBlur(e, t, r, i, s, a, o) { const l = this._renderer, u = this._blurMaterial; a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); const c = 3, h = new gr(this._lodPlanes[i], u), d = u.uniforms, m = this._sizeLods[r] - 1, g = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ud - 1), v = s / g, y = isFinite(s) ? 1 + Math.floor(c * v) : Ud; y > Ud && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Ud}`); const A = []; let _ = 0; for (let w = 0; w < Ud; ++w) { const R = w / v, b = Math.exp(-R * R / 2); A.push(b), w === 0 ? _ += b : w < y && (_ += 2 * b) } for (let w = 0; w < A.length; w++)A[w] = A[w] / _; d.envMap.value = e.texture, d.samples.value = y, d.weights.value = A, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o); const { _lodMax: x } = this; d.dTheta.value = g, d.mipInt.value = x - r; const C = this._sizeLods[i], T = 3 * C * (i > x - c3 ? i - x + c3 : 0), I = 4 * (this._cubeSize - C); Hv(t, T, I, 3 * C, 2 * C), l.setRenderTarget(t), l.render(h, Xx) } } function A$(n) { const e = [], t = [], r = []; let i = n; const s = n - c3 + 1 + Eb.length; for (let a = 0; a < s; a++) { const o = Math.pow(2, i); t.push(o); let l = 1 / o; a > n - c3 ? l = Eb[a - n + c3 - 1] : a === 0 && (l = 0), r.push(l); const u = 1 / (o - 2), c = -u, h = 1 + u, d = [c, c, h, c, h, h, c, c, h, h, c, h], m = 6, g = 6, v = 3, y = 2, A = 1, _ = new Float32Array(v * g * m), x = new Float32Array(y * g * m), C = new Float32Array(A * g * m); for (let I = 0; I < m; I++) { const w = I % 3 * 2 / 3 - 1, R = I > 2 ? 0 : -1, b = [w, R, 0, w + 2 / 3, R, 0, w + 2 / 3, R + 1, 0, w, R, 0, w + 2 / 3, R + 1, 0, w, R + 1, 0]; _.set(b, v * g * I), x.set(d, y * g * I); const B = [I, I, I, I, I, I]; C.set(B, A * g * I) } const T = new pn; T.setAttribute("position", new lr(_, v)), T.setAttribute("uv", new lr(x, y)), T.setAttribute("faceIndex", new lr(C, A)), e.push(T), i > c3 && i-- } return { lodPlanes: e, sizeLods: t, sigmas: r } } function Tb(n, e, t) { const r = new Ir(n, e, t); return r.texture.mapping = Am, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r } function Hv(n, e, t, r, i) { n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i) } function v$(n, e, t) {
		const r = new Float32Array(Ud), i = new N(0, 1, 0); return new tr({
			name: "SphericalGaussianBlur", defines: { n: Ud, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: r }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i } }, vertexShader: VS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: On, depthTest: !1, depthWrite: !1
		})
	} function wb() {
		return new tr({
			name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: VS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: On, depthTest: !1, depthWrite: !1
		})
	} function Ib() {
		return new tr({
			name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: VS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: On, depthTest: !1, depthWrite: !1
		})
	} function VS() {
		return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function y$(n) { let e = new WeakMap, t = null; function r(o) { if (o && o.isTexture) { const l = o.mapping, u = l === KA || l === qA, c = l === gf || l === Lh; if (u || c) if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) { o.needsPMREMUpdate = !1; let h = e.get(o); return t === null && (t = new o7(n)), h = u ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), e.set(o, h), h.texture } else { if (e.has(o)) return e.get(o).texture; { const h = o.image; if (u && h && h.height > 0 || c && h && i(h)) { t === null && (t = new o7(n)); const d = u ? t.fromEquirectangular(o) : t.fromCubemap(o); return e.set(o, d), o.addEventListener("dispose", s), d.texture } else return null } } } return o } function i(o) { let l = 0; const u = 6; for (let c = 0; c < u; c++)o[c] !== void 0 && l++; return l === u } function s(o) { const l = o.target; l.removeEventListener("dispose", s); const u = e.get(l); u !== void 0 && (e.delete(l), u.dispose()) } function a() { e = new WeakMap, t !== null && (t.dispose(), t = null) } return { get: r, dispose: a } } function x$(n) { const e = {}; function t(r) { if (e[r] !== void 0) return e[r]; let i; switch (r) { case "WEBGL_depth_texture": i = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = n.getExtension(r) }return e[r] = i, i } return { has: function (r) { return t(r) !== null }, init: function (r) { r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture") }, get: function (r) { const i = t(r); return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i } } } function _$(n, e, t, r) { const i = {}, s = new WeakMap; function a(h) { const d = h.target; d.index !== null && e.remove(d.index); for (const g in d.attributes) e.remove(d.attributes[g]); for (const g in d.morphAttributes) { const v = d.morphAttributes[g]; for (let y = 0, A = v.length; y < A; y++)e.remove(v[y]) } d.removeEventListener("dispose", a), delete i[d.id]; const m = s.get(d); m && (e.remove(m), s.delete(d)), r.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries-- } function o(h, d) { return i[d.id] === !0 || (d.addEventListener("dispose", a), i[d.id] = !0, t.memory.geometries++), d } function l(h) { const d = h.attributes; for (const g in d) e.update(d[g], n.ARRAY_BUFFER); const m = h.morphAttributes; for (const g in m) { const v = m[g]; for (let y = 0, A = v.length; y < A; y++)e.update(v[y], n.ARRAY_BUFFER) } } function u(h) { const d = [], m = h.index, g = h.attributes.position; let v = 0; if (m !== null) { const _ = m.array; v = m.version; for (let x = 0, C = _.length; x < C; x += 3) { const T = _[x + 0], I = _[x + 1], w = _[x + 2]; d.push(T, I, I, w, w, T) } } else if (g !== void 0) { const _ = g.array; v = g.version; for (let x = 0, C = _.length / 3 - 1; x < C; x += 3) { const T = x + 0, I = x + 1, w = x + 2; d.push(T, I, I, w, w, T) } } else return; const y = new (MO(d) ? u8 : QS)(d, 1); y.version = v; const A = s.get(h); A && e.remove(A), s.set(h, y) } function c(h) { const d = s.get(h); if (d) { const m = h.index; m !== null && d.version < m.version && u(h) } else u(h); return s.get(h) } return { get: o, update: l, getWireframeAttribute: c } } function E$(n, e, t, r) { const i = r.isWebGL2; let s; function a(d) { s = d } let o, l; function u(d) { o = d.type, l = d.bytesPerElement } function c(d, m) { n.drawElements(s, m, o, d * l), t.update(m, s, 1) } function h(d, m, g) { if (g === 0) return; let v, y; if (i) v = n, y = "drawElementsInstanced"; else if (v = e.get("ANGLE_instanced_arrays"), y = "drawElementsInstancedANGLE", v === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } v[y](s, m, o, d * l, g), t.update(m, s, g) } this.setMode = a, this.setIndex = u, this.render = c, this.renderInstances = h } function C$(n) { const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function r(s, a, o) { switch (t.calls++, a) { case n.TRIANGLES: t.triangles += o * (s / 3); break; case n.LINES: t.lines += o * (s / 2); break; case n.LINE_STRIP: t.lines += o * (s - 1); break; case n.LINE_LOOP: t.lines += o * s; break; case n.POINTS: t.points += o * s; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", a); break } } function i() { t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 } return { memory: e, render: t, programs: null, autoReset: !0, reset: i, update: r } } function S$(n, e) { return n[0] - e[0] } function T$(n, e) { return Math.abs(e[1]) - Math.abs(n[1]) } function w$(n, e, t) { const r = {}, i = new Float32Array(8), s = new WeakMap, a = new Jn, o = []; for (let u = 0; u < 8; u++)o[u] = [u, 0]; function l(u, c, h) { const d = u.morphTargetInfluences; if (e.isWebGL2 === !0) { const g = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, v = g !== void 0 ? g.length : 0; let y = s.get(c); if (y === void 0 || y.count !== v) { let Z = function () { G.dispose(), s.delete(c), c.removeEventListener("dispose", Z) }; var m = Z; y !== void 0 && y.texture.dispose(); const x = c.morphAttributes.position !== void 0, C = c.morphAttributes.normal !== void 0, T = c.morphAttributes.color !== void 0, I = c.morphAttributes.position || [], w = c.morphAttributes.normal || [], R = c.morphAttributes.color || []; let b = 0; x === !0 && (b = 1), C === !0 && (b = 2), T === !0 && (b = 3); let B = c.attributes.position.count * b, F = 1; B > e.maxTextureSize && (F = Math.ceil(B / e.maxTextureSize), B = e.maxTextureSize); const U = new Float32Array(B * F * 4 * v), G = new l8(U, B, F, v); G.type = Oa, G.needsUpdate = !0; const Y = b * 4; for (let ne = 0; ne < v; ne++) { const $ = I[ne], L = w[ne], Q = R[ne], D = B * F * 4 * ne; for (let V = 0; V < $.count; V++) { const J = V * Y; x === !0 && (a.fromBufferAttribute($, V), U[D + J + 0] = a.x, U[D + J + 1] = a.y, U[D + J + 2] = a.z, U[D + J + 3] = 0), C === !0 && (a.fromBufferAttribute(L, V), U[D + J + 4] = a.x, U[D + J + 5] = a.y, U[D + J + 6] = a.z, U[D + J + 7] = 0), T === !0 && (a.fromBufferAttribute(Q, V), U[D + J + 8] = a.x, U[D + J + 9] = a.y, U[D + J + 10] = a.z, U[D + J + 11] = Q.itemSize === 4 ? a.w : 1) } } y = { count: v, texture: G, size: new Se(B, F) }, s.set(c, y), c.addEventListener("dispose", Z) } let A = 0; for (let x = 0; x < d.length; x++)A += d[x]; const _ = c.morphTargetsRelative ? 1 : 1 - A; h.getUniforms().setValue(n, "morphTargetBaseInfluence", _), h.getUniforms().setValue(n, "morphTargetInfluences", d), h.getUniforms().setValue(n, "morphTargetsTexture", y.texture, t), h.getUniforms().setValue(n, "morphTargetsTextureSize", y.size) } else { const g = d === void 0 ? 0 : d.length; let v = r[c.id]; if (v === void 0 || v.length !== g) { v = []; for (let C = 0; C < g; C++)v[C] = [C, 0]; r[c.id] = v } for (let C = 0; C < g; C++) { const T = v[C]; T[0] = C, T[1] = d[C] } v.sort(T$); for (let C = 0; C < 8; C++)C < g && v[C][1] ? (o[C][0] = v[C][0], o[C][1] = v[C][1]) : (o[C][0] = Number.MAX_SAFE_INTEGER, o[C][1] = 0); o.sort(S$); const y = c.morphAttributes.position, A = c.morphAttributes.normal; let _ = 0; for (let C = 0; C < 8; C++) { const T = o[C], I = T[0], w = T[1]; I !== Number.MAX_SAFE_INTEGER && w ? (y && c.getAttribute("morphTarget" + C) !== y[I] && c.setAttribute("morphTarget" + C, y[I]), A && c.getAttribute("morphNormal" + C) !== A[I] && c.setAttribute("morphNormal" + C, A[I]), i[C] = w, _ += w) : (y && c.hasAttribute("morphTarget" + C) === !0 && c.deleteAttribute("morphTarget" + C), A && c.hasAttribute("morphNormal" + C) === !0 && c.deleteAttribute("morphNormal" + C), i[C] = 0) } const x = c.morphTargetsRelative ? 1 : 1 - _; h.getUniforms().setValue(n, "morphTargetBaseInfluence", x), h.getUniforms().setValue(n, "morphTargetInfluences", i) } } return { update: l } } function I$(n, e, t, r) { let i = new WeakMap; function s(l) { const u = r.render.frame, c = l.geometry, h = e.get(l, c); if (i.get(h) !== u && (e.update(h), i.set(h, u)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), i.get(l) !== u && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), i.set(l, u))), l.isSkinnedMesh) { const d = l.skeleton; i.get(d) !== u && (d.update(), i.set(d, u)) } return h } function a() { i = new WeakMap } function o(l) { const u = l.target; u.removeEventListener("dispose", o), t.remove(u.instanceMatrix), u.instanceColor !== null && t.remove(u.instanceColor) } return { update: s, dispose: a } } const LO = new ri, FO = new l8, kO = new GS, NO = new L1, Mb = [], bb = [], Bb = new Float32Array(16), Rb = new Float32Array(9), Pb = new Float32Array(4); function ym(n, e, t) { const r = n[0]; if (r <= 0 || r > 0) return n; const i = e * t; let s = Mb[i]; if (s === void 0 && (s = new Float32Array(i), Mb[i] = s), e !== 0) { r.toArray(s, 0); for (let a = 1, o = 0; a !== e; ++a)o += t, n[a].toArray(s, o) } return s } function Cs(n, e) { if (n.length !== e.length) return !1; for (let t = 0, r = n.length; t < r; t++)if (n[t] !== e[t]) return !1; return !0 } function Ss(n, e) { for (let t = 0, r = e.length; t < r; t++)n[t] = e[t] } function f8(n, e) { let t = bb[e]; t === void 0 && (t = new Int32Array(e), bb[e] = t); for (let r = 0; r !== e; ++r)t[r] = n.allocateTextureUnit(); return t } function M$(n, e) { const t = this.cache; t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e) } function b$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Cs(t, e)) return; n.uniform2fv(this.addr, e), Ss(t, e) } } function B$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b); else { if (Cs(t, e)) return; n.uniform3fv(this.addr, e), Ss(t, e) } } function R$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Cs(t, e)) return; n.uniform4fv(this.addr, e), Ss(t, e) } } function P$(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (Cs(t, e)) return; n.uniformMatrix2fv(this.addr, !1, e), Ss(t, e) } else { if (Cs(t, r)) return; Pb.set(r), n.uniformMatrix2fv(this.addr, !1, Pb), Ss(t, r) } } function D$(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (Cs(t, e)) return; n.uniformMatrix3fv(this.addr, !1, e), Ss(t, e) } else { if (Cs(t, r)) return; Rb.set(r), n.uniformMatrix3fv(this.addr, !1, Rb), Ss(t, r) } } function L$(n, e) { const t = this.cache, r = e.elements; if (r === void 0) { if (Cs(t, e)) return; n.uniformMatrix4fv(this.addr, !1, e), Ss(t, e) } else { if (Cs(t, r)) return; Bb.set(r), n.uniformMatrix4fv(this.addr, !1, Bb), Ss(t, r) } } function F$(n, e) { const t = this.cache; t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e) } function k$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Cs(t, e)) return; n.uniform2iv(this.addr, e), Ss(t, e) } } function N$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (Cs(t, e)) return; n.uniform3iv(this.addr, e), Ss(t, e) } } function O$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Cs(t, e)) return; n.uniform4iv(this.addr, e), Ss(t, e) } } function U$(n, e) { const t = this.cache; t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e) } function G$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y); else { if (Cs(t, e)) return; n.uniform2uiv(this.addr, e), Ss(t, e) } } function Q$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z); else { if (Cs(t, e)) return; n.uniform3uiv(this.addr, e), Ss(t, e) } } function H$(n, e) { const t = this.cache; if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w); else { if (Cs(t, e)) return; n.uniform4uiv(this.addr, e), Ss(t, e) } } function z$(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2D(e || LO, i) } function V$(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || kO, i) } function W$(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || NO, i) } function X$(n, e, t) { const r = this.cache, i = t.allocateTextureUnit(); r[0] !== i && (n.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || FO, i) } function Y$(n) { switch (n) { case 5126: return M$; case 35664: return b$; case 35665: return B$; case 35666: return R$; case 35674: return P$; case 35675: return D$; case 35676: return L$; case 5124: case 35670: return F$; case 35667: case 35671: return k$; case 35668: case 35672: return N$; case 35669: case 35673: return O$; case 5125: return U$; case 36294: return G$; case 36295: return Q$; case 36296: return H$; case 35678: case 36198: case 36298: case 36306: case 35682: return z$; case 35679: case 36299: case 36307: return V$; case 35680: case 36300: case 36308: case 36293: return W$; case 36289: case 36303: case 36311: case 36292: return X$ } } function j$(n, e) { n.uniform1fv(this.addr, e) } function J$(n, e) { const t = ym(e, this.size, 2); n.uniform2fv(this.addr, t) } function K$(n, e) { const t = ym(e, this.size, 3); n.uniform3fv(this.addr, t) } function q$(n, e) { const t = ym(e, this.size, 4); n.uniform4fv(this.addr, t) } function Z$(n, e) { const t = ym(e, this.size, 4); n.uniformMatrix2fv(this.addr, !1, t) } function $$(n, e) { const t = ym(e, this.size, 9); n.uniformMatrix3fv(this.addr, !1, t) } function eee(n, e) { const t = ym(e, this.size, 16); n.uniformMatrix4fv(this.addr, !1, t) } function tee(n, e) { n.uniform1iv(this.addr, e) } function nee(n, e) { n.uniform2iv(this.addr, e) } function ree(n, e) { n.uniform3iv(this.addr, e) } function iee(n, e) { n.uniform4iv(this.addr, e) } function see(n, e) { n.uniform1uiv(this.addr, e) } function aee(n, e) { n.uniform2uiv(this.addr, e) } function oee(n, e) { n.uniform3uiv(this.addr, e) } function lee(n, e) { n.uniform4uiv(this.addr, e) } function uee(n, e, t) { const r = this.cache, i = e.length, s = f8(t, i); Cs(r, s) || (n.uniform1iv(this.addr, s), Ss(r, s)); for (let a = 0; a !== i; ++a)t.setTexture2D(e[a] || LO, s[a]) } function cee(n, e, t) { const r = this.cache, i = e.length, s = f8(t, i); Cs(r, s) || (n.uniform1iv(this.addr, s), Ss(r, s)); for (let a = 0; a !== i; ++a)t.setTexture3D(e[a] || kO, s[a]) } function fee(n, e, t) { const r = this.cache, i = e.length, s = f8(t, i); Cs(r, s) || (n.uniform1iv(this.addr, s), Ss(r, s)); for (let a = 0; a !== i; ++a)t.setTextureCube(e[a] || NO, s[a]) } function hee(n, e, t) { const r = this.cache, i = e.length, s = f8(t, i); Cs(r, s) || (n.uniform1iv(this.addr, s), Ss(r, s)); for (let a = 0; a !== i; ++a)t.setTexture2DArray(e[a] || FO, s[a]) } function dee(n) { switch (n) { case 5126: return j$; case 35664: return J$; case 35665: return K$; case 35666: return q$; case 35674: return Z$; case 35675: return $$; case 35676: return eee; case 5124: case 35670: return tee; case 35667: case 35671: return nee; case 35668: case 35672: return ree; case 35669: case 35673: return iee; case 5125: return see; case 36294: return aee; case 36295: return oee; case 36296: return lee; case 35678: case 36198: case 36298: case 36306: case 35682: return uee; case 35679: case 36299: case 36307: return cee; case 35680: case 36300: case 36308: case 36293: return fee; case 36289: case 36303: case 36311: case 36292: return hee } } class pee { constructor(e, t, r) { this.id = e, this.addr = r, this.cache = [], this.setValue = Y$(t.type) } } class mee { constructor(e, t, r) { this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = dee(t.type) } } class gee { constructor(e) { this.id = e, this.seq = [], this.map = {} } setValue(e, t, r) { const i = this.seq; for (let s = 0, a = i.length; s !== a; ++s) { const o = i[s]; o.setValue(e, t[o.id], r) } } } const jx = /(\w+)(\])?(\[|\.)?/g; function Db(n, e) { n.seq.push(e), n.map[e.id] = e } function Aee(n, e, t) { const r = n.name, i = r.length; for (jx.lastIndex = 0; ;) { const s = jx.exec(r), a = jx.lastIndex; let o = s[1]; const l = s[2] === "]", u = s[3]; if (l && (o = o | 0), u === void 0 || u === "[" && a + 2 === i) { Db(t, u === void 0 ? new pee(o, n, e) : new mee(o, n, e)); break } else { let h = t.map[o]; h === void 0 && (h = new gee(o), Db(t, h)), t = h } } } class u6 { constructor(e, t) { this.seq = [], this.map = {}; const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let i = 0; i < r; ++i) { const s = e.getActiveUniform(t, i), a = e.getUniformLocation(t, s.name); Aee(s, a, this) } } setValue(e, t, r, i) { const s = this.map[t]; s !== void 0 && s.setValue(e, r, i) } setOptional(e, t, r) { const i = t[r]; i !== void 0 && this.setValue(e, r, i) } static upload(e, t, r, i) { for (let s = 0, a = t.length; s !== a; ++s) { const o = t[s], l = r[o.id]; l.needsUpdate !== !1 && o.setValue(e, l.value, i) } } static seqWithValue(e, t) { const r = []; for (let i = 0, s = e.length; i !== s; ++i) { const a = e[i]; a.id in t && r.push(a) } return r } } function Lb(n, e, t) { const r = n.createShader(e); return n.shaderSource(r, t), n.compileShader(r), r } let vee = 0; function yee(n, e) {
		const t = n.split(`
`), r = [], i = Math.max(e - 6, 0), s = Math.min(e + 6, t.length); for (let a = i; a < s; a++) { const o = a + 1; r.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`) } return r.join(`
`)
	} function xee(n) { switch (n) { case yu: return ["Linear", "( value )"]; case Ur: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported color space:", n), ["Linear", "( value )"] } } function Fb(n, e, t) {
		const r = n.getShaderParameter(e, n.COMPILE_STATUS), i = n.getShaderInfoLog(e).trim(); if (r && i === "") return ""; const s = /ERROR: 0:(\d+)/.exec(i); if (s) {
			const a = parseInt(s[1]); return t.toUpperCase() + `

`+ i + `

`+ yee(n.getShaderSource(e), a)
		} else return i
	} function _ee(n, e) { const t = xee(e); return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }" } function Eee(n, e) { let t; switch (e) { case rO: t = "Linear"; break; case iO: t = "Reinhard"; break; case sO: t = "OptimizedCineon"; break; case wS: t = "ACESFilmic"; break; case aO: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }" } function Cee(n) {
		return [n.extensionDerivatives || n.envMapCubeUVHeight || n.bumpMap || n.normalMapTangentSpace || n.clearcoatNormalMap || n.flatShading || n.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Rg).join(`
`)
	} function See(n) {
		const e = []; for (const t in n) { const r = n[t]; r !== !1 && e.push("#define " + t + " " + r) } return e.join(`
`)
	} function Tee(n, e) { const t = {}, r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES); for (let i = 0; i < r; i++) { const s = n.getActiveAttrib(e, i), a = s.name; let o = 1; s.type === n.FLOAT_MAT2 && (o = 2), s.type === n.FLOAT_MAT3 && (o = 3), s.type === n.FLOAT_MAT4 && (o = 4), t[a] = { type: s.type, location: n.getAttribLocation(e, a), locationSize: o } } return t } function Rg(n) { return n !== "" } function kb(n, e) { const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps; return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function Nb(n, e) { return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const wee = /^[ \t]*#include +<([\w\d./]+)>/gm; function l7(n) { return n.replace(wee, Mee) } const Iee = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]); function Mee(n, e) { let t = Cn[e]; if (t === void 0) { const r = Iee.get(e); if (r !== void 0) t = Cn[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r); else throw new Error("Can not resolve #include <" + e + ">") } return l7(t) } const bee = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function Ob(n) { return n.replace(bee, Bee) } function Bee(n, e, t, r) { let i = ""; for (let s = parseInt(e); s < parseInt(t); s++)i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return i } function Ub(n) {
		let e = "precision " + n.precision + ` float;
precision `+ n.precision + " int;"; return n.precision === "highp" ? e += `
#define HIGH_PRECISION`: n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION`: n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
	} function Ree(n) { let e = "SHADOWMAP_TYPE_BASIC"; return n.shadowMapType === t8 ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === sA ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === iu && (e = "SHADOWMAP_TYPE_VSM"), e } function Pee(n) { let e = "ENVMAP_TYPE_CUBE"; if (n.envMap) switch (n.envMapMode) { case gf: case Lh: e = "ENVMAP_TYPE_CUBE"; break; case Am: e = "ENVMAP_TYPE_CUBE_UV"; break }return e } function Dee(n) { let e = "ENVMAP_MODE_REFLECTION"; if (n.envMap) switch (n.envMapMode) { case Lh: e = "ENVMAP_MODE_REFRACTION"; break }return e } function Lee(n) { let e = "ENVMAP_BLENDING_NONE"; if (n.envMap) switch (n.combine) { case B1: e = "ENVMAP_BLENDING_MULTIPLY"; break; case tO: e = "ENVMAP_BLENDING_MIX"; break; case nO: e = "ENVMAP_BLENDING_ADD"; break }return e } function Fee(n) { const e = n.envMapCubeUVHeight; if (e === null) return null; const t = Math.log2(e) - 2, r = 1 / e; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t } } function kee(n, e, t, r) {
		const i = n.getContext(), s = t.defines; let a = t.vertexShader, o = t.fragmentShader; const l = Ree(t), u = Pee(t), c = Dee(t), h = Lee(t), d = Fee(t), m = t.isWebGL2 ? "" : Cee(t), g = See(s), v = i.createProgram(); let y, A, _ = t.glslVersion ? "#version " + t.glslVersion + `
`: ""; t.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(Rg).join(`
`), y.length > 0 && (y += `
`), A = [m, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(Rg).join(`
`), A.length > 0 && (A += `
`)) : (y = [Ub(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Rg).join(`
`), A = [m, Ub(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== wl ? "#define TONE_MAPPING" : "", t.toneMapping !== wl ? Cn.tonemapping_pars_fragment : "", t.toneMapping !== wl ? Eee("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Cn.colorspace_pars_fragment, _ee("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Rg).join(`
`)), a = l7(a), a = kb(a, t), a = Nb(a, t), o = l7(o), o = kb(o, t), o = Nb(o, t), a = Ob(a), o = Ob(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
`, y = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ y, A = ["#define varying in", t.glslVersion === s7 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === s7 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ A); const x = _ + y + a, C = _ + A + o, T = Lb(i, i.VERTEX_SHADER, x), I = Lb(i, i.FRAGMENT_SHADER, C); if (i.attachShader(v, T), i.attachShader(v, I), t.index0AttributeName !== void 0 ? i.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(v, 0, "position"), i.linkProgram(v), n.debug.checkShaderErrors) {
			const b = i.getProgramInfoLog(v).trim(), B = i.getShaderInfoLog(T).trim(), F = i.getShaderInfoLog(I).trim(); let U = !0, G = !0; if (i.getProgramParameter(v, i.LINK_STATUS) === !1) if (U = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(i, v, T, I); else {
				const Y = Fb(i, T, "vertex"), Z = Fb(i, I, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(v, i.VALIDATE_STATUS) + `

Program Info Log: `+ b + `
`+ Y + `
`+ Z)
			} else b !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", b) : (B === "" || F === "") && (G = !1); G && (this.diagnostics = { runnable: U, programLog: b, vertexShader: { log: B, prefix: y }, fragmentShader: { log: F, prefix: A } })
		} i.deleteShader(T), i.deleteShader(I); let w; this.getUniforms = function () { return w === void 0 && (w = new u6(i, v)), w }; let R; return this.getAttributes = function () { return R === void 0 && (R = Tee(i, v)), R }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(v), this.program = void 0 }, this.type = t.shaderType, this.name = t.shaderName, this.id = vee++, this.cacheKey = e, this.usedTimes = 1, this.program = v, this.vertexShader = T, this.fragmentShader = I, this
	} let Nee = 0; class Oee { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), s = this._getShaderStage(r), a = this._getShaderCacheForMaterial(e); return a.has(i) === !1 && (a.add(i), i.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const r of t) r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; let r = t.get(e); return r === void 0 && (r = new Set, t.set(e, r)), r } _getShaderStage(e) { const t = this.shaderCache; let r = t.get(e); return r === void 0 && (r = new Uee(e), t.set(e, r)), r } } class Uee { constructor(e) { this.id = Nee++, this.code = e, this.usedTimes = 0 } } function Gee(n, e, t, r, i, s, a) { const o = new dp, l = new Oee, u = [], c = i.isWebGL2, h = i.logarithmicDepthBuffer, d = i.vertexTextures; let m = i.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function v(b) { return b === 0 ? "uv" : `uv${b}` } function y(b, B, F, U, G) { const Y = U.fog, Z = G.geometry, ne = b.isMeshStandardMaterial ? U.environment : null, $ = (b.isMeshStandardMaterial ? t : e).get(b.envMap || ne), L = $ && $.mapping === Am ? $.image.height : null, Q = g[b.type]; b.precision !== null && (m = i.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead.")); const D = Z.morphAttributes.position || Z.morphAttributes.normal || Z.morphAttributes.color, V = D !== void 0 ? D.length : 0; let J = 0; Z.morphAttributes.position !== void 0 && (J = 1), Z.morphAttributes.normal !== void 0 && (J = 2), Z.morphAttributes.color !== void 0 && (J = 3); let Ee, xe, Be, Fe; if (Q) { const $e = uu[Q]; Ee = $e.vertexShader, xe = $e.fragmentShader } else Ee = b.vertexShader, xe = b.fragmentShader, l.update(b), Be = l.getVertexShaderID(b), Fe = l.getFragmentShaderID(b); const we = n.getRenderTarget(), ge = G.isInstancedMesh === !0, tt = !!b.map, je = !!b.matcap, Oe = !!$, K = !!b.aoMap, de = !!b.lightMap, Ce = !!b.bumpMap, Qe = !!b.normalMap, De = !!b.displacementMap, ie = !!b.emissiveMap, qe = !!b.metalnessMap, nt = !!b.roughnessMap, it = b.anisotropy > 0, xt = b.clearcoat > 0, mn = b.iridescence > 0, X = b.sheen > 0, O = b.transmission > 0, fe = it && !!b.anisotropyMap, Ne = xt && !!b.clearcoatMap, Ue = xt && !!b.clearcoatNormalMap, We = xt && !!b.clearcoatRoughnessMap, ut = mn && !!b.iridescenceMap, Ge = mn && !!b.iridescenceThicknessMap, Ae = X && !!b.sheenColorMap, st = X && !!b.sheenRoughnessMap, vt = !!b.specularMap, dt = !!b.specularColorMap, at = !!b.specularIntensityMap, ee = O && !!b.transmissionMap, Ie = O && !!b.thicknessMap, Ke = !!b.gradientMap, j = !!b.alphaMap, Ve = b.alphaTest > 0, oe = !!b.alphaHash, ze = !!b.extensions, Ye = !!Z.attributes.uv1, jt = !!Z.attributes.uv2, ln = !!Z.attributes.uv3; let fn = wl; return b.toneMapped && (we === null || we.isXRRenderTarget === !0) && (fn = n.toneMapping), { isWebGL2: c, shaderID: Q, shaderType: b.type, shaderName: b.name, vertexShader: Ee, fragmentShader: xe, defines: b.defines, customVertexShaderID: Be, customFragmentShaderID: Fe, isRawShaderMaterial: b.isRawShaderMaterial === !0, glslVersion: b.glslVersion, precision: m, instancing: ge, instancingColor: ge && G.instanceColor !== null, supportsVertexTextures: d, outputColorSpace: we === null ? n.outputColorSpace : we.isXRRenderTarget === !0 ? we.texture.colorSpace : yu, map: tt, matcap: je, envMap: Oe, envMapMode: Oe && $.mapping, envMapCubeUVHeight: L, aoMap: K, lightMap: de, bumpMap: Ce, normalMap: Qe, displacementMap: d && De, emissiveMap: ie, normalMapObjectSpace: Qe && b.normalMapType === AO, normalMapTangentSpace: Qe && b.normalMapType === Yh, metalnessMap: qe, roughnessMap: nt, anisotropy: it, anisotropyMap: fe, clearcoat: xt, clearcoatMap: Ne, clearcoatNormalMap: Ue, clearcoatRoughnessMap: We, iridescence: mn, iridescenceMap: ut, iridescenceThicknessMap: Ge, sheen: X, sheenColorMap: Ae, sheenRoughnessMap: st, specularMap: vt, specularColorMap: dt, specularIntensityMap: at, transmission: O, transmissionMap: ee, thicknessMap: Ie, gradientMap: Ke, opaque: b.transparent === !1 && b.blending === ic, alphaMap: j, alphaTest: Ve, alphaHash: oe, combine: b.combine, mapUv: tt && v(b.map.channel), aoMapUv: K && v(b.aoMap.channel), lightMapUv: de && v(b.lightMap.channel), bumpMapUv: Ce && v(b.bumpMap.channel), normalMapUv: Qe && v(b.normalMap.channel), displacementMapUv: De && v(b.displacementMap.channel), emissiveMapUv: ie && v(b.emissiveMap.channel), metalnessMapUv: qe && v(b.metalnessMap.channel), roughnessMapUv: nt && v(b.roughnessMap.channel), anisotropyMapUv: fe && v(b.anisotropyMap.channel), clearcoatMapUv: Ne && v(b.clearcoatMap.channel), clearcoatNormalMapUv: Ue && v(b.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: We && v(b.clearcoatRoughnessMap.channel), iridescenceMapUv: ut && v(b.iridescenceMap.channel), iridescenceThicknessMapUv: Ge && v(b.iridescenceThicknessMap.channel), sheenColorMapUv: Ae && v(b.sheenColorMap.channel), sheenRoughnessMapUv: st && v(b.sheenRoughnessMap.channel), specularMapUv: vt && v(b.specularMap.channel), specularColorMapUv: dt && v(b.specularColorMap.channel), specularIntensityMapUv: at && v(b.specularIntensityMap.channel), transmissionMapUv: ee && v(b.transmissionMap.channel), thicknessMapUv: Ie && v(b.thicknessMap.channel), alphaMapUv: j && v(b.alphaMap.channel), vertexTangents: !!Z.attributes.tangent && (Qe || it), vertexColors: b.vertexColors, vertexAlphas: b.vertexColors === !0 && !!Z.attributes.color && Z.attributes.color.itemSize === 4, vertexUv1s: Ye, vertexUv2s: jt, vertexUv3s: ln, pointsUvs: G.isPoints === !0 && !!Z.attributes.uv && (tt || j), fog: !!Y, useFog: b.fog === !0, fogExp2: Y && Y.isFogExp2, flatShading: b.flatShading === !0, sizeAttenuation: b.sizeAttenuation === !0, logarithmicDepthBuffer: h, skinning: G.isSkinnedMesh === !0, morphTargets: Z.morphAttributes.position !== void 0, morphNormals: Z.morphAttributes.normal !== void 0, morphColors: Z.morphAttributes.color !== void 0, morphTargetsCount: V, morphTextureStride: J, numDirLights: B.directional.length, numPointLights: B.point.length, numSpotLights: B.spot.length, numSpotLightMaps: B.spotLightMap.length, numRectAreaLights: B.rectArea.length, numHemiLights: B.hemi.length, numDirLightShadows: B.directionalShadowMap.length, numPointLightShadows: B.pointShadowMap.length, numSpotLightShadows: B.spotShadowMap.length, numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: b.dithering, shadowMapEnabled: n.shadowMap.enabled && F.length > 0, shadowMapType: n.shadowMap.type, toneMapping: fn, useLegacyLights: n._useLegacyLights, decodeVideoTexture: tt && b.map.isVideoTexture === !0 && b.map.colorSpace === Ur, premultipliedAlpha: b.premultipliedAlpha, doubleSided: b.side === cu, flipSided: b.side === pa, useDepthPacking: b.depthPacking >= 0, depthPacking: b.depthPacking || 0, index0AttributeName: b.index0AttributeName, extensionDerivatives: ze && b.extensions.derivatives === !0, extensionFragDepth: ze && b.extensions.fragDepth === !0, extensionDrawBuffers: ze && b.extensions.drawBuffers === !0, extensionShaderTextureLOD: ze && b.extensions.shaderTextureLOD === !0, rendererExtensionFragDepth: c || r.has("EXT_frag_depth"), rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"), customProgramCacheKey: b.customProgramCacheKey() } } function A(b) { const B = []; if (b.shaderID ? B.push(b.shaderID) : (B.push(b.customVertexShaderID), B.push(b.customFragmentShaderID)), b.defines !== void 0) for (const F in b.defines) B.push(F), B.push(b.defines[F]); return b.isRawShaderMaterial === !1 && (_(B, b), x(B, b), B.push(n.outputColorSpace)), B.push(b.customProgramCacheKey), B.join() } function _(b, B) { b.push(B.precision), b.push(B.outputColorSpace), b.push(B.envMapMode), b.push(B.envMapCubeUVHeight), b.push(B.mapUv), b.push(B.alphaMapUv), b.push(B.lightMapUv), b.push(B.aoMapUv), b.push(B.bumpMapUv), b.push(B.normalMapUv), b.push(B.displacementMapUv), b.push(B.emissiveMapUv), b.push(B.metalnessMapUv), b.push(B.roughnessMapUv), b.push(B.anisotropyMapUv), b.push(B.clearcoatMapUv), b.push(B.clearcoatNormalMapUv), b.push(B.clearcoatRoughnessMapUv), b.push(B.iridescenceMapUv), b.push(B.iridescenceThicknessMapUv), b.push(B.sheenColorMapUv), b.push(B.sheenRoughnessMapUv), b.push(B.specularMapUv), b.push(B.specularColorMapUv), b.push(B.specularIntensityMapUv), b.push(B.transmissionMapUv), b.push(B.thicknessMapUv), b.push(B.combine), b.push(B.fogExp2), b.push(B.sizeAttenuation), b.push(B.morphTargetsCount), b.push(B.morphAttributeCount), b.push(B.numDirLights), b.push(B.numPointLights), b.push(B.numSpotLights), b.push(B.numSpotLightMaps), b.push(B.numHemiLights), b.push(B.numRectAreaLights), b.push(B.numDirLightShadows), b.push(B.numPointLightShadows), b.push(B.numSpotLightShadows), b.push(B.numSpotLightShadowsWithMaps), b.push(B.shadowMapType), b.push(B.toneMapping), b.push(B.numClippingPlanes), b.push(B.numClipIntersection), b.push(B.depthPacking) } function x(b, B) { o.disableAll(), B.isWebGL2 && o.enable(0), B.supportsVertexTextures && o.enable(1), B.instancing && o.enable(2), B.instancingColor && o.enable(3), B.matcap && o.enable(4), B.envMap && o.enable(5), B.normalMapObjectSpace && o.enable(6), B.normalMapTangentSpace && o.enable(7), B.clearcoat && o.enable(8), B.iridescence && o.enable(9), B.alphaTest && o.enable(10), B.vertexColors && o.enable(11), B.vertexAlphas && o.enable(12), B.vertexUv1s && o.enable(13), B.vertexUv2s && o.enable(14), B.vertexUv3s && o.enable(15), B.vertexTangents && o.enable(16), B.anisotropy && o.enable(17), b.push(o.mask), o.disableAll(), B.fog && o.enable(0), B.useFog && o.enable(1), B.flatShading && o.enable(2), B.logarithmicDepthBuffer && o.enable(3), B.skinning && o.enable(4), B.morphTargets && o.enable(5), B.morphNormals && o.enable(6), B.morphColors && o.enable(7), B.premultipliedAlpha && o.enable(8), B.shadowMapEnabled && o.enable(9), B.useLegacyLights && o.enable(10), B.doubleSided && o.enable(11), B.flipSided && o.enable(12), B.useDepthPacking && o.enable(13), B.dithering && o.enable(14), B.transmission && o.enable(15), B.sheen && o.enable(16), B.opaque && o.enable(17), B.pointsUvs && o.enable(18), B.decodeVideoTexture && o.enable(19), b.push(o.mask) } function C(b) { const B = g[b.type]; let F; if (B) { const U = uu[B]; F = mi.clone(U.uniforms) } else F = b.uniforms; return F } function T(b, B) { let F; for (let U = 0, G = u.length; U < G; U++) { const Y = u[U]; if (Y.cacheKey === B) { F = Y, ++F.usedTimes; break } } return F === void 0 && (F = new kee(n, B, b, s), u.push(F)), F } function I(b) { if (--b.usedTimes === 0) { const B = u.indexOf(b); u[B] = u[u.length - 1], u.pop(), b.destroy() } } function w(b) { l.remove(b) } function R() { l.dispose() } return { getParameters: y, getProgramCacheKey: A, getUniforms: C, acquireProgram: T, releaseProgram: I, releaseShaderCache: w, programs: u, dispose: R } } function Qee() { let n = new WeakMap; function e(s) { let a = n.get(s); return a === void 0 && (a = {}, n.set(s, a)), a } function t(s) { n.delete(s) } function r(s, a, o) { n.get(s)[a] = o } function i() { n = new WeakMap } return { get: e, remove: t, update: r, dispose: i } } function Hee(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id } function Gb(n, e) { return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id } function Qb() { const n = []; let e = 0; const t = [], r = [], i = []; function s() { e = 0, t.length = 0, r.length = 0, i.length = 0 } function a(h, d, m, g, v, y) { let A = n[e]; return A === void 0 ? (A = { id: h.id, object: h, geometry: d, material: m, groupOrder: g, renderOrder: h.renderOrder, z: v, group: y }, n[e] = A) : (A.id = h.id, A.object = h, A.geometry = d, A.material = m, A.groupOrder = g, A.renderOrder = h.renderOrder, A.z = v, A.group = y), e++, A } function o(h, d, m, g, v, y) { const A = a(h, d, m, g, v, y); m.transmission > 0 ? r.push(A) : m.transparent === !0 ? i.push(A) : t.push(A) } function l(h, d, m, g, v, y) { const A = a(h, d, m, g, v, y); m.transmission > 0 ? r.unshift(A) : m.transparent === !0 ? i.unshift(A) : t.unshift(A) } function u(h, d) { t.length > 1 && t.sort(h || Hee), r.length > 1 && r.sort(d || Gb), i.length > 1 && i.sort(d || Gb) } function c() { for (let h = e, d = n.length; h < d; h++) { const m = n[h]; if (m.id === null) break; m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null } } return { opaque: t, transmissive: r, transparent: i, init: s, push: o, unshift: l, finish: c, sort: u } } function zee() { let n = new WeakMap; function e(r, i) { const s = n.get(r); let a; return s === void 0 ? (a = new Qb, n.set(r, [a])) : i >= s.length ? (a = new Qb, s.push(a)) : a = s[i], a } function t() { n = new WeakMap } return { get: e, dispose: t } } function Vee() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new N, color: new Je }; break; case "SpotLight": t = { position: new N, direction: new N, color: new Je, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new N, color: new Je, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new N, skyColor: new Je, groundColor: new Je }; break; case "RectAreaLight": t = { color: new Je, position: new N, halfWidth: new N, halfHeight: new N }; break }return n[e.id] = t, t } } } function Wee() { const n = {}; return { get: function (e) { if (n[e.id] !== void 0) return n[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se }; break; case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Se, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return n[e.id] = t, t } } } let Xee = 0; function Yee(n, e) { return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0) } function jee(n, e) { const t = new Vee, r = Wee(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let c = 0; c < 9; c++)i.probe.push(new N); const s = new N, a = new bt, o = new bt; function l(c, h) { let d = 0, m = 0, g = 0; for (let F = 0; F < 9; F++)i.probe[F].set(0, 0, 0); let v = 0, y = 0, A = 0, _ = 0, x = 0, C = 0, T = 0, I = 0, w = 0, R = 0; c.sort(Yee); const b = h === !0 ? Math.PI : 1; for (let F = 0, U = c.length; F < U; F++) { const G = c[F], Y = G.color, Z = G.intensity, ne = G.distance, $ = G.shadow && G.shadow.map ? G.shadow.map.texture : null; if (G.isAmbientLight) d += Y.r * Z * b, m += Y.g * Z * b, g += Y.b * Z * b; else if (G.isLightProbe) for (let L = 0; L < 9; L++)i.probe[L].addScaledVector(G.sh.coefficients[L], Z); else if (G.isDirectionalLight) { const L = t.get(G); if (L.color.copy(G.color).multiplyScalar(G.intensity * b), G.castShadow) { const Q = G.shadow, D = r.get(G); D.shadowBias = Q.bias, D.shadowNormalBias = Q.normalBias, D.shadowRadius = Q.radius, D.shadowMapSize = Q.mapSize, i.directionalShadow[v] = D, i.directionalShadowMap[v] = $, i.directionalShadowMatrix[v] = G.shadow.matrix, C++ } i.directional[v] = L, v++ } else if (G.isSpotLight) { const L = t.get(G); L.position.setFromMatrixPosition(G.matrixWorld), L.color.copy(Y).multiplyScalar(Z * b), L.distance = ne, L.coneCos = Math.cos(G.angle), L.penumbraCos = Math.cos(G.angle * (1 - G.penumbra)), L.decay = G.decay, i.spot[A] = L; const Q = G.shadow; if (G.map && (i.spotLightMap[w] = G.map, w++, Q.updateMatrices(G), G.castShadow && R++), i.spotLightMatrix[A] = Q.matrix, G.castShadow) { const D = r.get(G); D.shadowBias = Q.bias, D.shadowNormalBias = Q.normalBias, D.shadowRadius = Q.radius, D.shadowMapSize = Q.mapSize, i.spotShadow[A] = D, i.spotShadowMap[A] = $, I++ } A++ } else if (G.isRectAreaLight) { const L = t.get(G); L.color.copy(Y).multiplyScalar(Z), L.halfWidth.set(G.width * .5, 0, 0), L.halfHeight.set(0, G.height * .5, 0), i.rectArea[_] = L, _++ } else if (G.isPointLight) { const L = t.get(G); if (L.color.copy(G.color).multiplyScalar(G.intensity * b), L.distance = G.distance, L.decay = G.decay, G.castShadow) { const Q = G.shadow, D = r.get(G); D.shadowBias = Q.bias, D.shadowNormalBias = Q.normalBias, D.shadowRadius = Q.radius, D.shadowMapSize = Q.mapSize, D.shadowCameraNear = Q.camera.near, D.shadowCameraFar = Q.camera.far, i.pointShadow[y] = D, i.pointShadowMap[y] = $, i.pointShadowMatrix[y] = G.shadow.matrix, T++ } i.point[y] = L, y++ } else if (G.isHemisphereLight) { const L = t.get(G); L.skyColor.copy(G.color).multiplyScalar(Z * b), L.groundColor.copy(G.groundColor).multiplyScalar(Z * b), i.hemi[x] = L, x++ } } _ > 0 && (e.isWebGL2 || n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ot.LTC_FLOAT_1, i.rectAreaLTC2 = ot.LTC_FLOAT_2) : n.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = ot.LTC_HALF_1, i.rectAreaLTC2 = ot.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = d, i.ambient[1] = m, i.ambient[2] = g; const B = i.hash; (B.directionalLength !== v || B.pointLength !== y || B.spotLength !== A || B.rectAreaLength !== _ || B.hemiLength !== x || B.numDirectionalShadows !== C || B.numPointShadows !== T || B.numSpotShadows !== I || B.numSpotMaps !== w) && (i.directional.length = v, i.spot.length = A, i.rectArea.length = _, i.point.length = y, i.hemi.length = x, i.directionalShadow.length = C, i.directionalShadowMap.length = C, i.pointShadow.length = T, i.pointShadowMap.length = T, i.spotShadow.length = I, i.spotShadowMap.length = I, i.directionalShadowMatrix.length = C, i.pointShadowMatrix.length = T, i.spotLightMatrix.length = I + w - R, i.spotLightMap.length = w, i.numSpotLightShadowsWithMaps = R, B.directionalLength = v, B.pointLength = y, B.spotLength = A, B.rectAreaLength = _, B.hemiLength = x, B.numDirectionalShadows = C, B.numPointShadows = T, B.numSpotShadows = I, B.numSpotMaps = w, i.version = Xee++) } function u(c, h) { let d = 0, m = 0, g = 0, v = 0, y = 0; const A = h.matrixWorldInverse; for (let _ = 0, x = c.length; _ < x; _++) { const C = c[_]; if (C.isDirectionalLight) { const T = i.directional[d]; T.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(A), d++ } else if (C.isSpotLight) { const T = i.spot[g]; T.position.setFromMatrixPosition(C.matrixWorld), T.position.applyMatrix4(A), T.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), T.direction.sub(s), T.direction.transformDirection(A), g++ } else if (C.isRectAreaLight) { const T = i.rectArea[v]; T.position.setFromMatrixPosition(C.matrixWorld), T.position.applyMatrix4(A), o.identity(), a.copy(C.matrixWorld), a.premultiply(A), o.extractRotation(a), T.halfWidth.set(C.width * .5, 0, 0), T.halfHeight.set(0, C.height * .5, 0), T.halfWidth.applyMatrix4(o), T.halfHeight.applyMatrix4(o), v++ } else if (C.isPointLight) { const T = i.point[m]; T.position.setFromMatrixPosition(C.matrixWorld), T.position.applyMatrix4(A), m++ } else if (C.isHemisphereLight) { const T = i.hemi[y]; T.direction.setFromMatrixPosition(C.matrixWorld), T.direction.transformDirection(A), y++ } } } return { setup: l, setupView: u, state: i } } function Hb(n, e) { const t = new jee(n, e), r = [], i = []; function s() { r.length = 0, i.length = 0 } function a(h) { r.push(h) } function o(h) { i.push(h) } function l(h) { t.setup(r, h) } function u(h) { t.setupView(r, h) } return { init: s, state: { lightsArray: r, shadowsArray: i, lights: t }, setupLights: l, setupLightsView: u, pushLight: a, pushShadow: o } } function Jee(n, e) { let t = new WeakMap; function r(s, a = 0) { const o = t.get(s); let l; return o === void 0 ? (l = new Hb(n, e), t.set(s, [l])) : a >= o.length ? (l = new Hb(n, e), o.push(l)) : l = o[a], l } function i() { t = new WeakMap } return { get: r, dispose: i } } class h8 extends as { constructor(e) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = gO, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } class WS extends as { constructor(e) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e) } copy(e) { return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } const Kee = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, qee = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function Zee(n, e, t) { let r = new c8; const i = new Se, s = new Se, a = new Jn, o = new h8({ depthPacking: NS }), l = new WS, u = {}, c = t.maxTextureSize, h = { [pc]: pa, [pa]: pc, [cu]: cu }, d = new tr({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Se }, radius: { value: 4 } }, vertexShader: Kee, fragmentShader: qee }), m = d.clone(); m.defines.HORIZONTAL_PASS = 1; const g = new pn; g.setAttribute("position", new lr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const v = new gr(g, d), y = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = t8; let A = this.type; this.render = function (T, I, w) { if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || T.length === 0) return; const R = n.getRenderTarget(), b = n.getActiveCubeFace(), B = n.getActiveMipmapLevel(), F = n.state; F.setBlending(On), F.buffers.color.setClear(1, 1, 1, 1), F.buffers.depth.setTest(!0), F.setScissorTest(!1); const U = A !== iu && this.type === iu, G = A === iu && this.type !== iu; for (let Y = 0, Z = T.length; Y < Z; Y++) { const ne = T[Y], $ = ne.shadow; if ($ === void 0) { console.warn("THREE.WebGLShadowMap:", ne, "has no shadow."); continue } if ($.autoUpdate === !1 && $.needsUpdate === !1) continue; i.copy($.mapSize); const L = $.getFrameExtents(); if (i.multiply(L), s.copy($.mapSize), (i.x > c || i.y > c) && (i.x > c && (s.x = Math.floor(c / L.x), i.x = s.x * L.x, $.mapSize.x = s.x), i.y > c && (s.y = Math.floor(c / L.y), i.y = s.y * L.y, $.mapSize.y = s.y)), $.map === null || U === !0 || G === !0) { const D = this.type !== iu ? { minFilter: cn, magFilter: cn } : {}; $.map !== null && $.map.dispose(), $.map = new Ir(i.x, i.y, D), $.map.texture.name = ne.name + ".shadowMap", $.camera.updateProjectionMatrix() } n.setRenderTarget($.map), n.clear(); const Q = $.getViewportCount(); for (let D = 0; D < Q; D++) { const V = $.getViewport(D); a.set(s.x * V.x, s.y * V.y, s.x * V.z, s.y * V.w), F.viewport(a), $.updateMatrices(ne, D), r = $.getFrustum(), C(I, w, $.camera, ne, this.type) } $.isPointLightShadow !== !0 && this.type === iu && _($, w), $.needsUpdate = !1 } A = this.type, y.needsUpdate = !1, n.setRenderTarget(R, b, B) }; function _(T, I) { const w = e.update(v); d.defines.VSM_SAMPLES !== T.blurSamples && (d.defines.VSM_SAMPLES = T.blurSamples, m.defines.VSM_SAMPLES = T.blurSamples, d.needsUpdate = !0, m.needsUpdate = !0), T.mapPass === null && (T.mapPass = new Ir(i.x, i.y)), d.uniforms.shadow_pass.value = T.map.texture, d.uniforms.resolution.value = T.mapSize, d.uniforms.radius.value = T.radius, n.setRenderTarget(T.mapPass), n.clear(), n.renderBufferDirect(I, null, w, d, v, null), m.uniforms.shadow_pass.value = T.mapPass.texture, m.uniforms.resolution.value = T.mapSize, m.uniforms.radius.value = T.radius, n.setRenderTarget(T.map), n.clear(), n.renderBufferDirect(I, null, w, m, v, null) } function x(T, I, w, R) { let b = null; const B = w.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial; if (B !== void 0) b = B; else if (b = w.isPointLight === !0 ? l : o, n.localClippingEnabled && I.clipShadows === !0 && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0) { const F = b.uuid, U = I.uuid; let G = u[F]; G === void 0 && (G = {}, u[F] = G); let Y = G[U]; Y === void 0 && (Y = b.clone(), G[U] = Y), b = Y } if (b.visible = I.visible, b.wireframe = I.wireframe, R === iu ? b.side = I.shadowSide !== null ? I.shadowSide : I.side : b.side = I.shadowSide !== null ? I.shadowSide : h[I.side], b.alphaMap = I.alphaMap, b.alphaTest = I.alphaTest, b.map = I.map, b.clipShadows = I.clipShadows, b.clippingPlanes = I.clippingPlanes, b.clipIntersection = I.clipIntersection, b.displacementMap = I.displacementMap, b.displacementScale = I.displacementScale, b.displacementBias = I.displacementBias, b.wireframeLinewidth = I.wireframeLinewidth, b.linewidth = I.linewidth, w.isPointLight === !0 && b.isMeshDistanceMaterial === !0) { const F = n.properties.get(b); F.light = w } return b } function C(T, I, w, R, b) { if (T.visible === !1) return; if (T.layers.test(I.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && b === iu) && (!T.frustumCulled || r.intersectsObject(T))) { T.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, T.matrixWorld); const U = e.update(T), G = T.material; if (Array.isArray(G)) { const Y = U.groups; for (let Z = 0, ne = Y.length; Z < ne; Z++) { const $ = Y[Z], L = G[$.materialIndex]; if (L && L.visible) { const Q = x(T, L, R, b); n.renderBufferDirect(w, null, U, Q, T, $) } } } else if (G.visible) { const Y = x(T, G, R, b); n.renderBufferDirect(w, null, U, Y, T, null) } } const F = T.children; for (let U = 0, G = F.length; U < G; U++)C(F[U], I, w, R, b) } } function $ee(n, e, t) { const r = t.isWebGL2; function i() { let j = !1; const Ve = new Jn; let oe = null; const ze = new Jn(0, 0, 0, 0); return { setMask: function (Ye) { oe !== Ye && !j && (n.colorMask(Ye, Ye, Ye, Ye), oe = Ye) }, setLocked: function (Ye) { j = Ye }, setClear: function (Ye, jt, ln, fn, Dt) { Dt === !0 && (Ye *= fn, jt *= fn, ln *= fn), Ve.set(Ye, jt, ln, fn), ze.equals(Ve) === !1 && (n.clearColor(Ye, jt, ln, fn), ze.copy(Ve)) }, reset: function () { j = !1, oe = null, ze.set(-1, 0, 0, 0) } } } function s() { let j = !1, Ve = null, oe = null, ze = null; return { setTest: function (Ye) { Ye ? we(n.DEPTH_TEST) : ge(n.DEPTH_TEST) }, setMask: function (Ye) { Ve !== Ye && !j && (n.depthMask(Ye), Ve = Ye) }, setFunc: function (Ye) { if (oe !== Ye) { switch (Ye) { case jN: n.depthFunc(n.NEVER); break; case JN: n.depthFunc(n.ALWAYS); break; case KN: n.depthFunc(n.LESS); break; case sy: n.depthFunc(n.LEQUAL); break; case qN: n.depthFunc(n.EQUAL); break; case ZN: n.depthFunc(n.GEQUAL); break; case $N: n.depthFunc(n.GREATER); break; case eO: n.depthFunc(n.NOTEQUAL); break; default: n.depthFunc(n.LEQUAL) }oe = Ye } }, setLocked: function (Ye) { j = Ye }, setClear: function (Ye) { ze !== Ye && (n.clearDepth(Ye), ze = Ye) }, reset: function () { j = !1, Ve = null, oe = null, ze = null } } } function a() { let j = !1, Ve = null, oe = null, ze = null, Ye = null, jt = null, ln = null, fn = null, Dt = null; return { setTest: function ($e) { j || ($e ? we(n.STENCIL_TEST) : ge(n.STENCIL_TEST)) }, setMask: function ($e) { Ve !== $e && !j && (n.stencilMask($e), Ve = $e) }, setFunc: function ($e, Xt, Qt) { (oe !== $e || ze !== Xt || Ye !== Qt) && (n.stencilFunc($e, Xt, Qt), oe = $e, ze = Xt, Ye = Qt) }, setOp: function ($e, Xt, Qt) { (jt !== $e || ln !== Xt || fn !== Qt) && (n.stencilOp($e, Xt, Qt), jt = $e, ln = Xt, fn = Qt) }, setLocked: function ($e) { j = $e }, setClear: function ($e) { Dt !== $e && (n.clearStencil($e), Dt = $e) }, reset: function () { j = !1, Ve = null, oe = null, ze = null, Ye = null, jt = null, ln = null, fn = null, Dt = null } } } const o = new i, l = new s, u = new a, c = new WeakMap, h = new WeakMap; let d = {}, m = {}, g = new WeakMap, v = [], y = null, A = !1, _ = null, x = null, C = null, T = null, I = null, w = null, R = null, b = !1, B = null, F = null, U = null, G = null, Y = null; const Z = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let ne = !1, $ = 0; const L = n.getParameter(n.VERSION); L.indexOf("WebGL") !== -1 ? ($ = parseFloat(/^WebGL (\d)/.exec(L)[1]), ne = $ >= 1) : L.indexOf("OpenGL ES") !== -1 && ($ = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), ne = $ >= 2); let Q = null, D = {}; const V = n.getParameter(n.SCISSOR_BOX), J = n.getParameter(n.VIEWPORT), Ee = new Jn().fromArray(V), xe = new Jn().fromArray(J); function Be(j, Ve, oe, ze) { const Ye = new Uint8Array(4), jt = n.createTexture(); n.bindTexture(j, jt), n.texParameteri(j, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(j, n.TEXTURE_MAG_FILTER, n.NEAREST); for (let ln = 0; ln < oe; ln++)r && (j === n.TEXTURE_3D || j === n.TEXTURE_2D_ARRAY) ? n.texImage3D(Ve, 0, n.RGBA, 1, 1, ze, 0, n.RGBA, n.UNSIGNED_BYTE, Ye) : n.texImage2D(Ve + ln, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Ye); return jt } const Fe = {}; Fe[n.TEXTURE_2D] = Be(n.TEXTURE_2D, n.TEXTURE_2D, 1), Fe[n.TEXTURE_CUBE_MAP] = Be(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r && (Fe[n.TEXTURE_2D_ARRAY] = Be(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), Fe[n.TEXTURE_3D] = Be(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), we(n.DEPTH_TEST), l.setFunc(sy), De(!1), ie(L9), we(n.CULL_FACE), Ce(On); function we(j) { d[j] !== !0 && (n.enable(j), d[j] = !0) } function ge(j) { d[j] !== !1 && (n.disable(j), d[j] = !1) } function tt(j, Ve) { return m[j] !== Ve ? (n.bindFramebuffer(j, Ve), m[j] = Ve, r && (j === n.DRAW_FRAMEBUFFER && (m[n.FRAMEBUFFER] = Ve), j === n.FRAMEBUFFER && (m[n.DRAW_FRAMEBUFFER] = Ve)), !0) : !1 } function je(j, Ve) { let oe = v, ze = !1; if (j) if (oe = g.get(Ve), oe === void 0 && (oe = [], g.set(Ve, oe)), j.isWebGLMultipleRenderTargets) { const Ye = j.texture; if (oe.length !== Ye.length || oe[0] !== n.COLOR_ATTACHMENT0) { for (let jt = 0, ln = Ye.length; jt < ln; jt++)oe[jt] = n.COLOR_ATTACHMENT0 + jt; oe.length = Ye.length, ze = !0 } } else oe[0] !== n.COLOR_ATTACHMENT0 && (oe[0] = n.COLOR_ATTACHMENT0, ze = !0); else oe[0] !== n.BACK && (oe[0] = n.BACK, ze = !0); ze && (t.isWebGL2 ? n.drawBuffers(oe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(oe)) } function Oe(j) { return y !== j ? (n.useProgram(j), y = j, !0) : !1 } const K = { [ko]: n.FUNC_ADD, [GN]: n.FUNC_SUBTRACT, [QN]: n.FUNC_REVERSE_SUBTRACT }; if (r) K[N9] = n.MIN, K[O9] = n.MAX; else { const j = e.get("EXT_blend_minmax"); j !== null && (K[N9] = j.MIN_EXT, K[O9] = j.MAX_EXT) } const de = { [K3]: n.ZERO, [HN]: n.ONE, [zN]: n.SRC_COLOR, [jA]: n.SRC_ALPHA, [YN]: n.SRC_ALPHA_SATURATE, [r8]: n.DST_COLOR, [n8]: n.DST_ALPHA, [VN]: n.ONE_MINUS_SRC_COLOR, [JA]: n.ONE_MINUS_SRC_ALPHA, [XN]: n.ONE_MINUS_DST_COLOR, [WN]: n.ONE_MINUS_DST_ALPHA }; function Ce(j, Ve, oe, ze, Ye, jt, ln, fn) { if (j === On) { A === !0 && (ge(n.BLEND), A = !1); return } if (A === !1 && (we(n.BLEND), A = !0), j !== YA) { if (j !== _ || fn !== b) { if ((x !== ko || I !== ko) && (n.blendEquation(n.FUNC_ADD), x = ko, I = ko), fn) switch (j) { case ic: n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA); break; case XA: n.blendFunc(n.ONE, n.ONE); break; case F9: n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE); break; case k9: n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", j); break } else switch (j) { case ic: n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA); break; case XA: n.blendFunc(n.SRC_ALPHA, n.ONE); break; case F9: n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE); break; case k9: n.blendFunc(n.ZERO, n.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", j); break }C = null, T = null, w = null, R = null, _ = j, b = fn } return } Ye = Ye || Ve, jt = jt || oe, ln = ln || ze, (Ve !== x || Ye !== I) && (n.blendEquationSeparate(K[Ve], K[Ye]), x = Ve, I = Ye), (oe !== C || ze !== T || jt !== w || ln !== R) && (n.blendFuncSeparate(de[oe], de[ze], de[jt], de[ln]), C = oe, T = ze, w = jt, R = ln), _ = j, b = !1 } function Qe(j, Ve) { j.side === cu ? ge(n.CULL_FACE) : we(n.CULL_FACE); let oe = j.side === pa; Ve && (oe = !oe), De(oe), j.blending === ic && j.transparent === !1 ? Ce(On) : Ce(j.blending, j.blendEquation, j.blendSrc, j.blendDst, j.blendEquationAlpha, j.blendSrcAlpha, j.blendDstAlpha, j.premultipliedAlpha), l.setFunc(j.depthFunc), l.setTest(j.depthTest), l.setMask(j.depthWrite), o.setMask(j.colorWrite); const ze = j.stencilWrite; u.setTest(ze), ze && (u.setMask(j.stencilWriteMask), u.setFunc(j.stencilFunc, j.stencilRef, j.stencilFuncMask), u.setOp(j.stencilFail, j.stencilZFail, j.stencilZPass)), nt(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits), j.alphaToCoverage === !0 ? we(n.SAMPLE_ALPHA_TO_COVERAGE) : ge(n.SAMPLE_ALPHA_TO_COVERAGE) } function De(j) { B !== j && (j ? n.frontFace(n.CW) : n.frontFace(n.CCW), B = j) } function ie(j) { j !== NN ? (we(n.CULL_FACE), j !== F && (j === L9 ? n.cullFace(n.BACK) : j === ON ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : ge(n.CULL_FACE), F = j } function qe(j) { j !== U && (ne && n.lineWidth(j), U = j) } function nt(j, Ve, oe) { j ? (we(n.POLYGON_OFFSET_FILL), (G !== Ve || Y !== oe) && (n.polygonOffset(Ve, oe), G = Ve, Y = oe)) : ge(n.POLYGON_OFFSET_FILL) } function it(j) { j ? we(n.SCISSOR_TEST) : ge(n.SCISSOR_TEST) } function xt(j) { j === void 0 && (j = n.TEXTURE0 + Z - 1), Q !== j && (n.activeTexture(j), Q = j) } function mn(j, Ve, oe) { oe === void 0 && (Q === null ? oe = n.TEXTURE0 + Z - 1 : oe = Q); let ze = D[oe]; ze === void 0 && (ze = { type: void 0, texture: void 0 }, D[oe] = ze), (ze.type !== j || ze.texture !== Ve) && (Q !== oe && (n.activeTexture(oe), Q = oe), n.bindTexture(j, Ve || Fe[j]), ze.type = j, ze.texture = Ve) } function X() { const j = D[Q]; j !== void 0 && j.type !== void 0 && (n.bindTexture(j.type, null), j.type = void 0, j.texture = void 0) } function O() { try { n.compressedTexImage2D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function fe() { try { n.compressedTexImage3D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function Ne() { try { n.texSubImage2D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function Ue() { try { n.texSubImage3D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function We() { try { n.compressedTexSubImage2D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function ut() { try { n.compressedTexSubImage3D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function Ge() { try { n.texStorage2D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function Ae() { try { n.texStorage3D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function st() { try { n.texImage2D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function vt() { try { n.texImage3D.apply(n, arguments) } catch (j) { console.error("THREE.WebGLState:", j) } } function dt(j) { Ee.equals(j) === !1 && (n.scissor(j.x, j.y, j.z, j.w), Ee.copy(j)) } function at(j) { xe.equals(j) === !1 && (n.viewport(j.x, j.y, j.z, j.w), xe.copy(j)) } function ee(j, Ve) { let oe = h.get(Ve); oe === void 0 && (oe = new WeakMap, h.set(Ve, oe)); let ze = oe.get(j); ze === void 0 && (ze = n.getUniformBlockIndex(Ve, j.name), oe.set(j, ze)) } function Ie(j, Ve) { const ze = h.get(Ve).get(j); c.get(Ve) !== ze && (n.uniformBlockBinding(Ve, ze, j.__bindingPointIndex), c.set(Ve, ze)) } function Ke() { n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), r === !0 && (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null)), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), d = {}, Q = null, D = {}, m = {}, g = new WeakMap, v = [], y = null, A = !1, _ = null, x = null, C = null, T = null, I = null, w = null, R = null, b = !1, B = null, F = null, U = null, G = null, Y = null, Ee.set(0, 0, n.canvas.width, n.canvas.height), xe.set(0, 0, n.canvas.width, n.canvas.height), o.reset(), l.reset(), u.reset() } return { buffers: { color: o, depth: l, stencil: u }, enable: we, disable: ge, bindFramebuffer: tt, drawBuffers: je, useProgram: Oe, setBlending: Ce, setMaterial: Qe, setFlipSided: De, setCullFace: ie, setLineWidth: qe, setPolygonOffset: nt, setScissorTest: it, activeTexture: xt, bindTexture: mn, unbindTexture: X, compressedTexImage2D: O, compressedTexImage3D: fe, texImage2D: st, texImage3D: vt, updateUBOMapping: ee, uniformBlockBinding: Ie, texStorage2D: Ge, texStorage3D: Ae, texSubImage2D: Ne, texSubImage3D: Ue, compressedTexSubImage2D: We, compressedTexSubImage3D: ut, scissor: dt, viewport: at, reset: Ke } } function ete(n, e, t, r, i, s, a) { const o = i.isWebGL2, l = i.maxTextures, u = i.maxCubemapSize, c = i.maxTextureSize, h = i.maxSamples, d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), g = new WeakMap; let v; const y = new WeakMap; let A = !1; try { A = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function _(X, O) { return A ? new OffscreenCanvas(X, O) : o1("canvas") } function x(X, O, fe, Ne) { let Ue = 1; if ((X.width > Ne || X.height > Ne) && (Ue = Ne / Math.max(X.width, X.height)), Ue < 1 || O === !0) if (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && X instanceof ImageBitmap) { const We = O ? ly : Math.floor, ut = We(Ue * X.width), Ge = We(Ue * X.height); v === void 0 && (v = _(ut, Ge)); const Ae = fe ? _(ut, Ge) : v; return Ae.width = ut, Ae.height = Ge, Ae.getContext("2d").drawImage(X, 0, 0, ut, Ge), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + X.width + "x" + X.height + ") to (" + ut + "x" + Ge + ")."), Ae } else return "data" in X && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + X.width + "x" + X.height + ")."), X; return X } function C(X) { return a7(X.width) && a7(X.height) } function T(X) { return o ? !1 : X.wrapS !== pi || X.wrapT !== pi || X.minFilter !== cn && X.minFilter !== wr } function I(X, O) { return X.generateMipmaps && O && X.minFilter !== cn && X.minFilter !== wr } function w(X) { n.generateMipmap(X) } function R(X, O, fe, Ne, Ue = !1) { if (o === !1) return O; if (X !== null) { if (n[X] !== void 0) return n[X]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + X + "'") } let We = O; return O === n.RED && (fe === n.FLOAT && (We = n.R32F), fe === n.HALF_FLOAT && (We = n.R16F), fe === n.UNSIGNED_BYTE && (We = n.R8)), O === n.RED_INTEGER && (fe === n.UNSIGNED_BYTE && (We = n.R8UI), fe === n.UNSIGNED_SHORT && (We = n.R16UI), fe === n.UNSIGNED_INT && (We = n.R32UI), fe === n.BYTE && (We = n.R8I), fe === n.SHORT && (We = n.R16I), fe === n.INT && (We = n.R32I)), O === n.RG && (fe === n.FLOAT && (We = n.RG32F), fe === n.HALF_FLOAT && (We = n.RG16F), fe === n.UNSIGNED_BYTE && (We = n.RG8)), O === n.RGBA && (fe === n.FLOAT && (We = n.RGBA32F), fe === n.HALF_FLOAT && (We = n.RGBA16F), fe === n.UNSIGNED_BYTE && (We = Ne === Ur && Ue === !1 ? n.SRGB8_ALPHA8 : n.RGBA8), fe === n.UNSIGNED_SHORT_4_4_4_4 && (We = n.RGBA4), fe === n.UNSIGNED_SHORT_5_5_5_1 && (We = n.RGB5_A1)), (We === n.R16F || We === n.R32F || We === n.RG16F || We === n.RG32F || We === n.RGBA16F || We === n.RGBA32F) && e.get("EXT_color_buffer_float"), We } function b(X, O, fe) { return I(X, fe) === !0 || X.isFramebufferTexture && X.minFilter !== cn && X.minFilter !== wr ? Math.log2(Math.max(O.width, O.height)) + 1 : X.mipmaps !== void 0 && X.mipmaps.length > 0 ? X.mipmaps.length : X.isCompressedTexture && Array.isArray(X.image) ? O.mipmaps.length : 1 } function B(X) { return X === cn || X === ZA || X === I3 ? n.NEAREST : n.LINEAR } function F(X) { const O = X.target; O.removeEventListener("dispose", F), G(O), O.isVideoTexture && g.delete(O) } function U(X) { const O = X.target; O.removeEventListener("dispose", U), Z(O) } function G(X) { const O = r.get(X); if (O.__webglInit === void 0) return; const fe = X.source, Ne = y.get(fe); if (Ne) { const Ue = Ne[O.__cacheKey]; Ue.usedTimes--, Ue.usedTimes === 0 && Y(X), Object.keys(Ne).length === 0 && y.delete(fe) } r.remove(X) } function Y(X) { const O = r.get(X); n.deleteTexture(O.__webglTexture); const fe = X.source, Ne = y.get(fe); delete Ne[O.__cacheKey], a.memory.textures-- } function Z(X) { const O = X.texture, fe = r.get(X), Ne = r.get(O); if (Ne.__webglTexture !== void 0 && (n.deleteTexture(Ne.__webglTexture), a.memory.textures--), X.depthTexture && X.depthTexture.dispose(), X.isWebGLCubeRenderTarget) for (let Ue = 0; Ue < 6; Ue++) { if (Array.isArray(fe.__webglFramebuffer[Ue])) for (let We = 0; We < fe.__webglFramebuffer[Ue].length; We++)n.deleteFramebuffer(fe.__webglFramebuffer[Ue][We]); else n.deleteFramebuffer(fe.__webglFramebuffer[Ue]); fe.__webglDepthbuffer && n.deleteRenderbuffer(fe.__webglDepthbuffer[Ue]) } else { if (Array.isArray(fe.__webglFramebuffer)) for (let Ue = 0; Ue < fe.__webglFramebuffer.length; Ue++)n.deleteFramebuffer(fe.__webglFramebuffer[Ue]); else n.deleteFramebuffer(fe.__webglFramebuffer); if (fe.__webglDepthbuffer && n.deleteRenderbuffer(fe.__webglDepthbuffer), fe.__webglMultisampledFramebuffer && n.deleteFramebuffer(fe.__webglMultisampledFramebuffer), fe.__webglColorRenderbuffer) for (let Ue = 0; Ue < fe.__webglColorRenderbuffer.length; Ue++)fe.__webglColorRenderbuffer[Ue] && n.deleteRenderbuffer(fe.__webglColorRenderbuffer[Ue]); fe.__webglDepthRenderbuffer && n.deleteRenderbuffer(fe.__webglDepthRenderbuffer) } if (X.isWebGLMultipleRenderTargets) for (let Ue = 0, We = O.length; Ue < We; Ue++) { const ut = r.get(O[Ue]); ut.__webglTexture && (n.deleteTexture(ut.__webglTexture), a.memory.textures--), r.remove(O[Ue]) } r.remove(O), r.remove(X) } let ne = 0; function $() { ne = 0 } function L() { const X = ne; return X >= l && console.warn("THREE.WebGLTextures: Trying to use " + X + " texture units while this GPU supports only " + l), ne += 1, X } function Q(X) { const O = []; return O.push(X.wrapS), O.push(X.wrapT), O.push(X.wrapR || 0), O.push(X.magFilter), O.push(X.minFilter), O.push(X.anisotropy), O.push(X.internalFormat), O.push(X.format), O.push(X.type), O.push(X.generateMipmaps), O.push(X.premultiplyAlpha), O.push(X.flipY), O.push(X.unpackAlignment), O.push(X.colorSpace), O.join() } function D(X, O) { const fe = r.get(X); if (X.isVideoTexture && xt(X), X.isRenderTargetTexture === !1 && X.version > 0 && fe.__version !== X.version) { const Ne = X.image; if (Ne === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (Ne.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { tt(fe, X, O); return } } t.bindTexture(n.TEXTURE_2D, fe.__webglTexture, n.TEXTURE0 + O) } function V(X, O) { const fe = r.get(X); if (X.version > 0 && fe.__version !== X.version) { tt(fe, X, O); return } t.bindTexture(n.TEXTURE_2D_ARRAY, fe.__webglTexture, n.TEXTURE0 + O) } function J(X, O) { const fe = r.get(X); if (X.version > 0 && fe.__version !== X.version) { tt(fe, X, O); return } t.bindTexture(n.TEXTURE_3D, fe.__webglTexture, n.TEXTURE0 + O) } function Ee(X, O) { const fe = r.get(X); if (X.version > 0 && fe.__version !== X.version) { je(fe, X, O); return } t.bindTexture(n.TEXTURE_CUBE_MAP, fe.__webglTexture, n.TEXTURE0 + O) } const xe = { [Pl]: n.REPEAT, [pi]: n.CLAMP_TO_EDGE, [q3]: n.MIRRORED_REPEAT }, Be = { [cn]: n.NEAREST, [ZA]: n.NEAREST_MIPMAP_NEAREST, [I3]: n.NEAREST_MIPMAP_LINEAR, [wr]: n.LINEAR, [s8]: n.LINEAR_MIPMAP_NEAREST, [Dl]: n.LINEAR_MIPMAP_LINEAR }, Fe = { [yO]: n.NEVER, [wO]: n.ALWAYS, [xO]: n.LESS, [EO]: n.LEQUAL, [_O]: n.EQUAL, [TO]: n.GEQUAL, [CO]: n.GREATER, [SO]: n.NOTEQUAL }; function we(X, O, fe) { if (fe ? (n.texParameteri(X, n.TEXTURE_WRAP_S, xe[O.wrapS]), n.texParameteri(X, n.TEXTURE_WRAP_T, xe[O.wrapT]), (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY) && n.texParameteri(X, n.TEXTURE_WRAP_R, xe[O.wrapR]), n.texParameteri(X, n.TEXTURE_MAG_FILTER, Be[O.magFilter]), n.texParameteri(X, n.TEXTURE_MIN_FILTER, Be[O.minFilter])) : (n.texParameteri(X, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(X, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY) && n.texParameteri(X, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE), (O.wrapS !== pi || O.wrapT !== pi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n.texParameteri(X, n.TEXTURE_MAG_FILTER, B(O.magFilter)), n.texParameteri(X, n.TEXTURE_MIN_FILTER, B(O.minFilter)), O.minFilter !== cn && O.minFilter !== wr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), O.compareFunction && (n.texParameteri(X, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(X, n.TEXTURE_COMPARE_FUNC, Fe[O.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) { const Ne = e.get("EXT_texture_filter_anisotropic"); if (O.magFilter === cn || O.minFilter !== I3 && O.minFilter !== Dl || O.type === Oa && e.has("OES_texture_float_linear") === !1 || o === !1 && O.type === Wi && e.has("OES_texture_half_float_linear") === !1) return; (O.anisotropy > 1 || r.get(O).__currentAnisotropy) && (n.texParameterf(X, Ne.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, i.getMaxAnisotropy())), r.get(O).__currentAnisotropy = O.anisotropy) } } function ge(X, O) { let fe = !1; X.__webglInit === void 0 && (X.__webglInit = !0, O.addEventListener("dispose", F)); const Ne = O.source; let Ue = y.get(Ne); Ue === void 0 && (Ue = {}, y.set(Ne, Ue)); const We = Q(O); if (We !== X.__cacheKey) { Ue[We] === void 0 && (Ue[We] = { texture: n.createTexture(), usedTimes: 0 }, a.memory.textures++, fe = !0), Ue[We].usedTimes++; const ut = Ue[X.__cacheKey]; ut !== void 0 && (Ue[X.__cacheKey].usedTimes--, ut.usedTimes === 0 && Y(O)), X.__cacheKey = We, X.__webglTexture = Ue[We].texture } return fe } function tt(X, O, fe) { let Ne = n.TEXTURE_2D; (O.isDataArrayTexture || O.isCompressedArrayTexture) && (Ne = n.TEXTURE_2D_ARRAY), O.isData3DTexture && (Ne = n.TEXTURE_3D); const Ue = ge(X, O), We = O.source; t.bindTexture(Ne, X.__webglTexture, n.TEXTURE0 + fe); const ut = r.get(We); if (We.version !== ut.__version || Ue === !0) { t.activeTexture(n.TEXTURE0 + fe), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, O.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, O.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE); const Ge = T(O) && C(O.image) === !1; let Ae = x(O.image, Ge, !1, c); Ae = mn(O, Ae); const st = C(Ae) || o, vt = s.convert(O.format, O.colorSpace); let dt = s.convert(O.type), at = R(O.internalFormat, vt, dt, O.colorSpace, O.isVideoTexture); we(Ne, O, st); let ee; const Ie = O.mipmaps, Ke = o && O.isVideoTexture !== !0, j = ut.__version === void 0 || Ue === !0, Ve = b(O, Ae, st); if (O.isDepthTexture) at = n.DEPTH_COMPONENT, o ? O.type === Oa ? at = n.DEPTH_COMPONENT32F : O.type === $c ? at = n.DEPTH_COMPONENT24 : O.type === sf ? at = n.DEPTH24_STENCIL8 : at = n.DEPTH_COMPONENT16 : O.type === Oa && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), O.format === Eh && at === n.DEPTH_COMPONENT && O.type !== Np && O.type !== $c && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), O.type = $c, dt = s.convert(O.type)), O.format === Fh && at === n.DEPTH_COMPONENT && (at = n.DEPTH_STENCIL, O.type !== sf && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), O.type = sf, dt = s.convert(O.type))), j && (Ke ? t.texStorage2D(n.TEXTURE_2D, 1, at, Ae.width, Ae.height) : t.texImage2D(n.TEXTURE_2D, 0, at, Ae.width, Ae.height, 0, vt, dt, null)); else if (O.isDataTexture) if (Ie.length > 0 && st) { Ke && j && t.texStorage2D(n.TEXTURE_2D, Ve, at, Ie[0].width, Ie[0].height); for (let oe = 0, ze = Ie.length; oe < ze; oe++)ee = Ie[oe], Ke ? t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, ee.width, ee.height, vt, dt, ee.data) : t.texImage2D(n.TEXTURE_2D, oe, at, ee.width, ee.height, 0, vt, dt, ee.data); O.generateMipmaps = !1 } else Ke ? (j && t.texStorage2D(n.TEXTURE_2D, Ve, at, Ae.width, Ae.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ae.width, Ae.height, vt, dt, Ae.data)) : t.texImage2D(n.TEXTURE_2D, 0, at, Ae.width, Ae.height, 0, vt, dt, Ae.data); else if (O.isCompressedTexture) if (O.isCompressedArrayTexture) { Ke && j && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ve, at, Ie[0].width, Ie[0].height, Ae.depth); for (let oe = 0, ze = Ie.length; oe < ze; oe++)ee = Ie[oe], O.format !== Ri ? vt !== null ? Ke ? t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, oe, 0, 0, 0, ee.width, ee.height, Ae.depth, vt, ee.data, 0, 0) : t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, oe, at, ee.width, ee.height, Ae.depth, 0, ee.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? t.texSubImage3D(n.TEXTURE_2D_ARRAY, oe, 0, 0, 0, ee.width, ee.height, Ae.depth, vt, dt, ee.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, oe, at, ee.width, ee.height, Ae.depth, 0, vt, dt, ee.data) } else { Ke && j && t.texStorage2D(n.TEXTURE_2D, Ve, at, Ie[0].width, Ie[0].height); for (let oe = 0, ze = Ie.length; oe < ze; oe++)ee = Ie[oe], O.format !== Ri ? vt !== null ? Ke ? t.compressedTexSubImage2D(n.TEXTURE_2D, oe, 0, 0, ee.width, ee.height, vt, ee.data) : t.compressedTexImage2D(n.TEXTURE_2D, oe, at, ee.width, ee.height, 0, ee.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, ee.width, ee.height, vt, dt, ee.data) : t.texImage2D(n.TEXTURE_2D, oe, at, ee.width, ee.height, 0, vt, dt, ee.data) } else if (O.isDataArrayTexture) Ke ? (j && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ve, at, Ae.width, Ae.height, Ae.depth), t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ae.width, Ae.height, Ae.depth, vt, dt, Ae.data)) : t.texImage3D(n.TEXTURE_2D_ARRAY, 0, at, Ae.width, Ae.height, Ae.depth, 0, vt, dt, Ae.data); else if (O.isData3DTexture) Ke ? (j && t.texStorage3D(n.TEXTURE_3D, Ve, at, Ae.width, Ae.height, Ae.depth), t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Ae.width, Ae.height, Ae.depth, vt, dt, Ae.data)) : t.texImage3D(n.TEXTURE_3D, 0, at, Ae.width, Ae.height, Ae.depth, 0, vt, dt, Ae.data); else if (O.isFramebufferTexture) { if (j) if (Ke) t.texStorage2D(n.TEXTURE_2D, Ve, at, Ae.width, Ae.height); else { let oe = Ae.width, ze = Ae.height; for (let Ye = 0; Ye < Ve; Ye++)t.texImage2D(n.TEXTURE_2D, Ye, at, oe, ze, 0, vt, dt, null), oe >>= 1, ze >>= 1 } } else if (Ie.length > 0 && st) { Ke && j && t.texStorage2D(n.TEXTURE_2D, Ve, at, Ie[0].width, Ie[0].height); for (let oe = 0, ze = Ie.length; oe < ze; oe++)ee = Ie[oe], Ke ? t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, vt, dt, ee) : t.texImage2D(n.TEXTURE_2D, oe, at, vt, dt, ee); O.generateMipmaps = !1 } else Ke ? (j && t.texStorage2D(n.TEXTURE_2D, Ve, at, Ae.width, Ae.height), t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, vt, dt, Ae)) : t.texImage2D(n.TEXTURE_2D, 0, at, vt, dt, Ae); I(O, st) && w(Ne), ut.__version = We.version, O.onUpdate && O.onUpdate(O) } X.__version = O.version } function je(X, O, fe) { if (O.image.length !== 6) return; const Ne = ge(X, O), Ue = O.source; t.bindTexture(n.TEXTURE_CUBE_MAP, X.__webglTexture, n.TEXTURE0 + fe); const We = r.get(Ue); if (Ue.version !== We.__version || Ne === !0) { t.activeTexture(n.TEXTURE0 + fe), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, O.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, O.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE); const ut = O.isCompressedTexture || O.image[0].isCompressedTexture, Ge = O.image[0] && O.image[0].isDataTexture, Ae = []; for (let oe = 0; oe < 6; oe++)!ut && !Ge ? Ae[oe] = x(O.image[oe], !1, !0, u) : Ae[oe] = Ge ? O.image[oe].image : O.image[oe], Ae[oe] = mn(O, Ae[oe]); const st = Ae[0], vt = C(st) || o, dt = s.convert(O.format, O.colorSpace), at = s.convert(O.type), ee = R(O.internalFormat, dt, at, O.colorSpace), Ie = o && O.isVideoTexture !== !0, Ke = We.__version === void 0 || Ne === !0; let j = b(O, st, vt); we(n.TEXTURE_CUBE_MAP, O, vt); let Ve; if (ut) { Ie && Ke && t.texStorage2D(n.TEXTURE_CUBE_MAP, j, ee, st.width, st.height); for (let oe = 0; oe < 6; oe++) { Ve = Ae[oe].mipmaps; for (let ze = 0; ze < Ve.length; ze++) { const Ye = Ve[ze]; O.format !== Ri ? dt !== null ? Ie ? t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze, 0, 0, Ye.width, Ye.height, dt, Ye.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze, ee, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ie ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze, 0, 0, Ye.width, Ye.height, dt, at, Ye.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze, ee, Ye.width, Ye.height, 0, dt, at, Ye.data) } } } else { Ve = O.mipmaps, Ie && Ke && (Ve.length > 0 && j++, t.texStorage2D(n.TEXTURE_CUBE_MAP, j, ee, Ae[0].width, Ae[0].height)); for (let oe = 0; oe < 6; oe++)if (Ge) { Ie ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0, 0, 0, Ae[oe].width, Ae[oe].height, dt, at, Ae[oe].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0, ee, Ae[oe].width, Ae[oe].height, 0, dt, at, Ae[oe].data); for (let ze = 0; ze < Ve.length; ze++) { const jt = Ve[ze].image[oe].image; Ie ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze + 1, 0, 0, jt.width, jt.height, dt, at, jt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze + 1, ee, jt.width, jt.height, 0, dt, at, jt.data) } } else { Ie ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0, 0, 0, dt, at, Ae[oe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0, ee, dt, at, Ae[oe]); for (let ze = 0; ze < Ve.length; ze++) { const Ye = Ve[ze]; Ie ? t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze + 1, 0, 0, dt, at, Ye.image[oe]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + oe, ze + 1, ee, dt, at, Ye.image[oe]) } } } I(O, vt) && w(n.TEXTURE_CUBE_MAP), We.__version = Ue.version, O.onUpdate && O.onUpdate(O) } X.__version = O.version } function Oe(X, O, fe, Ne, Ue, We) { const ut = s.convert(fe.format, fe.colorSpace), Ge = s.convert(fe.type), Ae = R(fe.internalFormat, ut, Ge, fe.colorSpace); if (!r.get(O).__hasExternalTextures) { const vt = Math.max(1, O.width >> We), dt = Math.max(1, O.height >> We); Ue === n.TEXTURE_3D || Ue === n.TEXTURE_2D_ARRAY ? t.texImage3D(Ue, We, Ae, vt, dt, O.depth, 0, ut, Ge, null) : t.texImage2D(Ue, We, Ae, vt, dt, 0, ut, Ge, null) } t.bindFramebuffer(n.FRAMEBUFFER, X), it(O) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Ne, Ue, r.get(fe).__webglTexture, 0, nt(O)) : (Ue === n.TEXTURE_2D || Ue >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Ue <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Ne, Ue, r.get(fe).__webglTexture, We), t.bindFramebuffer(n.FRAMEBUFFER, null) } function K(X, O, fe) { if (n.bindRenderbuffer(n.RENDERBUFFER, X), O.depthBuffer && !O.stencilBuffer) { let Ne = n.DEPTH_COMPONENT16; if (fe || it(O)) { const Ue = O.depthTexture; Ue && Ue.isDepthTexture && (Ue.type === Oa ? Ne = n.DEPTH_COMPONENT32F : Ue.type === $c && (Ne = n.DEPTH_COMPONENT24)); const We = nt(O); it(O) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, We, Ne, O.width, O.height) : n.renderbufferStorageMultisample(n.RENDERBUFFER, We, Ne, O.width, O.height) } else n.renderbufferStorage(n.RENDERBUFFER, Ne, O.width, O.height); n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, X) } else if (O.depthBuffer && O.stencilBuffer) { const Ne = nt(O); fe && it(O) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ne, n.DEPTH24_STENCIL8, O.width, O.height) : it(O) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ne, n.DEPTH24_STENCIL8, O.width, O.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, O.width, O.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, X) } else { const Ne = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture]; for (let Ue = 0; Ue < Ne.length; Ue++) { const We = Ne[Ue], ut = s.convert(We.format, We.colorSpace), Ge = s.convert(We.type), Ae = R(We.internalFormat, ut, Ge, We.colorSpace), st = nt(O); fe && it(O) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, st, Ae, O.width, O.height) : it(O) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, st, Ae, O.width, O.height) : n.renderbufferStorage(n.RENDERBUFFER, Ae, O.width, O.height) } } n.bindRenderbuffer(n.RENDERBUFFER, null) } function de(X, O) { if (O && O.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(n.FRAMEBUFFER, X), !(O.depthTexture && O.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!r.get(O.depthTexture).__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = !0), D(O.depthTexture, 0); const Ne = r.get(O.depthTexture).__webglTexture, Ue = nt(O); if (O.depthTexture.format === Eh) it(O) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Ne, 0, Ue) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Ne, 0); else if (O.depthTexture.format === Fh) it(O) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Ne, 0, Ue) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Ne, 0); else throw new Error("Unknown depthTexture format") } function Ce(X) { const O = r.get(X), fe = X.isWebGLCubeRenderTarget === !0; if (X.depthTexture && !O.__autoAllocateDepthBuffer) { if (fe) throw new Error("target.depthTexture not supported in Cube render targets"); de(O.__webglFramebuffer, X) } else if (fe) { O.__webglDepthbuffer = []; for (let Ne = 0; Ne < 6; Ne++)t.bindFramebuffer(n.FRAMEBUFFER, O.__webglFramebuffer[Ne]), O.__webglDepthbuffer[Ne] = n.createRenderbuffer(), K(O.__webglDepthbuffer[Ne], X, !1) } else t.bindFramebuffer(n.FRAMEBUFFER, O.__webglFramebuffer), O.__webglDepthbuffer = n.createRenderbuffer(), K(O.__webglDepthbuffer, X, !1); t.bindFramebuffer(n.FRAMEBUFFER, null) } function Qe(X, O, fe) { const Ne = r.get(X); O !== void 0 && Oe(Ne.__webglFramebuffer, X, X.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), fe !== void 0 && Ce(X) } function De(X) { const O = X.texture, fe = r.get(X), Ne = r.get(O); X.addEventListener("dispose", U), X.isWebGLMultipleRenderTargets !== !0 && (Ne.__webglTexture === void 0 && (Ne.__webglTexture = n.createTexture()), Ne.__version = O.version, a.memory.textures++); const Ue = X.isWebGLCubeRenderTarget === !0, We = X.isWebGLMultipleRenderTargets === !0, ut = C(X) || o; if (Ue) { fe.__webglFramebuffer = []; for (let Ge = 0; Ge < 6; Ge++)if (o && O.mipmaps && O.mipmaps.length > 0) { fe.__webglFramebuffer[Ge] = []; for (let Ae = 0; Ae < O.mipmaps.length; Ae++)fe.__webglFramebuffer[Ge][Ae] = n.createFramebuffer() } else fe.__webglFramebuffer[Ge] = n.createFramebuffer() } else { if (o && O.mipmaps && O.mipmaps.length > 0) { fe.__webglFramebuffer = []; for (let Ge = 0; Ge < O.mipmaps.length; Ge++)fe.__webglFramebuffer[Ge] = n.createFramebuffer() } else fe.__webglFramebuffer = n.createFramebuffer(); if (We) if (i.drawBuffers) { const Ge = X.texture; for (let Ae = 0, st = Ge.length; Ae < st; Ae++) { const vt = r.get(Ge[Ae]); vt.__webglTexture === void 0 && (vt.__webglTexture = n.createTexture(), a.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (o && X.samples > 0 && it(X) === !1) { const Ge = We ? O : [O]; fe.__webglMultisampledFramebuffer = n.createFramebuffer(), fe.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, fe.__webglMultisampledFramebuffer); for (let Ae = 0; Ae < Ge.length; Ae++) { const st = Ge[Ae]; fe.__webglColorRenderbuffer[Ae] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, fe.__webglColorRenderbuffer[Ae]); const vt = s.convert(st.format, st.colorSpace), dt = s.convert(st.type), at = R(st.internalFormat, vt, dt, st.colorSpace, X.isXRRenderTarget === !0), ee = nt(X); n.renderbufferStorageMultisample(n.RENDERBUFFER, ee, at, X.width, X.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.RENDERBUFFER, fe.__webglColorRenderbuffer[Ae]) } n.bindRenderbuffer(n.RENDERBUFFER, null), X.depthBuffer && (fe.__webglDepthRenderbuffer = n.createRenderbuffer(), K(fe.__webglDepthRenderbuffer, X, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null) } } if (Ue) { t.bindTexture(n.TEXTURE_CUBE_MAP, Ne.__webglTexture), we(n.TEXTURE_CUBE_MAP, O, ut); for (let Ge = 0; Ge < 6; Ge++)if (o && O.mipmaps && O.mipmaps.length > 0) for (let Ae = 0; Ae < O.mipmaps.length; Ae++)Oe(fe.__webglFramebuffer[Ge][Ae], X, O, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ae); else Oe(fe.__webglFramebuffer[Ge], X, O, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0); I(O, ut) && w(n.TEXTURE_CUBE_MAP), t.unbindTexture() } else if (We) { const Ge = X.texture; for (let Ae = 0, st = Ge.length; Ae < st; Ae++) { const vt = Ge[Ae], dt = r.get(vt); t.bindTexture(n.TEXTURE_2D, dt.__webglTexture), we(n.TEXTURE_2D, vt, ut), Oe(fe.__webglFramebuffer, X, vt, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, 0), I(vt, ut) && w(n.TEXTURE_2D) } t.unbindTexture() } else { let Ge = n.TEXTURE_2D; if ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) && (o ? Ge = X.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Ge, Ne.__webglTexture), we(Ge, O, ut), o && O.mipmaps && O.mipmaps.length > 0) for (let Ae = 0; Ae < O.mipmaps.length; Ae++)Oe(fe.__webglFramebuffer[Ae], X, O, n.COLOR_ATTACHMENT0, Ge, Ae); else Oe(fe.__webglFramebuffer, X, O, n.COLOR_ATTACHMENT0, Ge, 0); I(O, ut) && w(Ge), t.unbindTexture() } X.depthBuffer && Ce(X) } function ie(X) { const O = C(X) || o, fe = X.isWebGLMultipleRenderTargets === !0 ? X.texture : [X.texture]; for (let Ne = 0, Ue = fe.length; Ne < Ue; Ne++) { const We = fe[Ne]; if (I(We, O)) { const ut = X.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D, Ge = r.get(We).__webglTexture; t.bindTexture(ut, Ge), w(ut), t.unbindTexture() } } } function qe(X) { if (o && X.samples > 0 && it(X) === !1) { const O = X.isWebGLMultipleRenderTargets ? X.texture : [X.texture], fe = X.width, Ne = X.height; let Ue = n.COLOR_BUFFER_BIT; const We = [], ut = X.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Ge = r.get(X), Ae = X.isWebGLMultipleRenderTargets === !0; if (Ae) for (let st = 0; st < O.length; st++)t.bindFramebuffer(n.FRAMEBUFFER, Ge.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + st, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Ge.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + st, n.TEXTURE_2D, null, 0); t.bindFramebuffer(n.READ_FRAMEBUFFER, Ge.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ge.__webglFramebuffer); for (let st = 0; st < O.length; st++) { We.push(n.COLOR_ATTACHMENT0 + st), X.depthBuffer && We.push(ut); const vt = Ge.__ignoreDepthValues !== void 0 ? Ge.__ignoreDepthValues : !1; if (vt === !1 && (X.depthBuffer && (Ue |= n.DEPTH_BUFFER_BIT), X.stencilBuffer && (Ue |= n.STENCIL_BUFFER_BIT)), Ae && n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ge.__webglColorRenderbuffer[st]), vt === !0 && (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [ut]), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [ut])), Ae) { const dt = r.get(O[st]).__webglTexture; n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, dt, 0) } n.blitFramebuffer(0, 0, fe, Ne, 0, 0, fe, Ne, Ue, n.NEAREST), m && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, We) } if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), Ae) for (let st = 0; st < O.length; st++) { t.bindFramebuffer(n.FRAMEBUFFER, Ge.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + st, n.RENDERBUFFER, Ge.__webglColorRenderbuffer[st]); const vt = r.get(O[st]).__webglTexture; t.bindFramebuffer(n.FRAMEBUFFER, Ge.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + st, n.TEXTURE_2D, vt, 0) } t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ge.__webglMultisampledFramebuffer) } } function nt(X) { return Math.min(h, X.samples) } function it(X) { const O = r.get(X); return o && X.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && O.__useRenderToTexture !== !1 } function xt(X) { const O = a.render.frame; g.get(X) !== O && (g.set(X, O), X.update()) } function mn(X, O) { const fe = X.colorSpace, Ne = X.format, Ue = X.type; return X.isCompressedTexture === !0 || X.isVideoTexture === !0 || X.format === oy || fe !== yu && fe !== Sh && (fe === Ur || fe === R1 ? o === !1 ? e.has("EXT_sRGB") === !0 && Ne === Ri ? (X.format = oy, X.minFilter = wr, X.generateMipmaps = !1) : O = US.sRGBToLinear(O) : (Ne !== Ri || Ue !== As) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", fe)), O } this.allocateTextureUnit = L, this.resetTextureUnits = $, this.setTexture2D = D, this.setTexture2DArray = V, this.setTexture3D = J, this.setTextureCube = Ee, this.rebindTextures = Qe, this.setupRenderTarget = De, this.updateRenderTargetMipmap = ie, this.updateMultisampleRenderTarget = qe, this.setupDepthRenderbuffer = Ce, this.setupFrameBufferTexture = Oe, this.useMultisampledRTT = it } const tte = 0, hs = 1; function OO(n, e, t) { const r = t.isWebGL2; function i(s, a = Sh) { let o; const l = a === Ur || a === R1 ? hs : tte; if (s === As) return n.UNSIGNED_BYTE; if (s === MS) return n.UNSIGNED_SHORT_4_4_4_4; if (s === bS) return n.UNSIGNED_SHORT_5_5_5_1; if (s === oO) return n.BYTE; if (s === lO) return n.SHORT; if (s === Np) return n.UNSIGNED_SHORT; if (s === IS) return n.INT; if (s === $c) return n.UNSIGNED_INT; if (s === Oa) return n.FLOAT; if (s === Wi) return r ? n.HALF_FLOAT : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null); if (s === uO) return n.ALPHA; if (s === Ri) return n.RGBA; if (s === BS) return n.LUMINANCE; if (s === cO) return n.LUMINANCE_ALPHA; if (s === Eh) return n.DEPTH_COMPONENT; if (s === Fh) return n.DEPTH_STENCIL; if (s === oy) return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null; if (s === Jd) return n.RED; if (s === RS) return n.RED_INTEGER; if (s === l3) return n.RG; if (s === PS) return n.RG_INTEGER; if (s === DS) return n.RGBA_INTEGER; if (s === M3 || s === s6 || s === a6 || s === b3) if (l === hs) if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) { if (s === M3) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === s6) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === a6) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === b3) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) { if (s === M3) return o.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === s6) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === a6) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === b3) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === $A || s === U9 || s === e1 || s === G9) if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) { if (s === $A) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === U9) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === e1) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === G9) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === a8) return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null; if (s === t1 || s === n1) if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) { if (s === t1) return l === hs ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2; if (s === n1) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === r1 || s === Q9 || s === H9 || s === z9 || s === V9 || s === W9 || s === X9 || s === Y9 || s === j9 || s === J9 || s === K9 || s === q9 || s === Z9 || s === $9) if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) { if (s === r1) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === Q9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === H9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === z9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === V9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === W9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === X9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === Y9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === j9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === J9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === K9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === q9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === Z9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === $9) return l === hs ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === B3 || s === e7 || s === t7) if (o = e.get("EXT_texture_compression_bptc"), o !== null) { if (s === B3) return l === hs ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT; if (s === e7) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT; if (s === t7) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT } else return null; if (s === fO || s === n7 || s === r7 || s === i7) if (o = e.get("EXT_texture_compression_rgtc"), o !== null) { if (s === B3) return o.COMPRESSED_RED_RGTC1_EXT; if (s === n7) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === r7) return o.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === i7) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === sf ? r ? n.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : n[s] !== void 0 ? n[s] : null } return { convert: i } } class UO extends Gr { constructor(e = []) { super(), this.isArrayCamera = !0, this.cameras = e } } class ef extends Hn { constructor() { super(), this.isGroup = !0, this.type = "Group" } } const nte = { type: "move" }; class Jx { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return this._hand === null && (this._hand = new ef, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return this._targetRay === null && (this._targetRay = new ef, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new N, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new N), this._targetRay } getGripSpace() { return this._grip === null && (this._grip = new ef, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new N, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new N), this._grip } dispatchEvent(e) { return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this } connect(e) { if (e && e.hand) { const t = this._hand; if (t) for (const r of e.hand.values()) this._getHandJoint(t, r) } return this.dispatchEvent({ type: "connected", data: e }), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update(e, t, r) { let i = null, s = null, a = null; const o = this._targetRay, l = this._grip, u = this._hand; if (e && t.session.visibilityState !== "visible-blurred") { if (u && e.hand) { a = !0; for (const v of e.hand.values()) { const y = t.getJointPose(v, r), A = this._getHandJoint(u, v); y !== null && (A.matrix.fromArray(y.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.matrixWorldNeedsUpdate = !0, A.jointRadius = y.radius), A.visible = y !== null } const c = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], d = c.position.distanceTo(h.position), m = .02, g = .005; u.inputState.pinching && d > m + g ? (u.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !u.inputState.pinching && d <= m - g && (u.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1)); o !== null && (i = t.getPose(e.targetRaySpace, r), i === null && s !== null && (i = s), i !== null && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(i.linearVelocity)) : o.hasLinearVelocity = !1, i.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(i.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(nte))) } return o !== null && (o.visible = i !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = a !== null), this } _getHandJoint(e, t) { if (e.joints[t.jointName] === void 0) { const r = new ef; r.matrixAutoUpdate = !1, r.visible = !1, e.joints[t.jointName] = r, e.add(r) } return e.joints[t.jointName] } } class xm extends ri { constructor(e, t, r, i, s, a, o, l, u, c) { if (c = c !== void 0 ? c : Eh, c !== Eh && c !== Fh) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); r === void 0 && c === Eh && (r = $c), r === void 0 && c === Fh && (r = sf), super(null, i, s, a, o, l, c, r, u), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = o !== void 0 ? o : cn, this.minFilter = l !== void 0 ? l : cn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null } copy(e) { return super.copy(e), this.compareFunction = e.compareFunction, this } toJSON(e) { const t = super.toJSON(e); return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t } } class rte extends mc { constructor(e, t) { super(); const r = this; let i = null, s = 1, a = null, o = "local-floor", l = 1, u = null, c = null, h = null, d = null, m = null, g = null; const v = t.getContextAttributes(); let y = null, A = null; const _ = [], x = [], C = new Gr; C.layers.enable(1), C.viewport = new Jn; const T = new Gr; T.layers.enable(2), T.viewport = new Jn; const I = [C, T], w = new UO; w.layers.enable(1), w.layers.enable(2); let R = null, b = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (V) { let J = _[V]; return J === void 0 && (J = new Jx, _[V] = J), J.getTargetRaySpace() }, this.getControllerGrip = function (V) { let J = _[V]; return J === void 0 && (J = new Jx, _[V] = J), J.getGripSpace() }, this.getHand = function (V) { let J = _[V]; return J === void 0 && (J = new Jx, _[V] = J), J.getHandSpace() }; function B(V) { const J = x.indexOf(V.inputSource); if (J === -1) return; const Ee = _[J]; Ee !== void 0 && (Ee.update(V.inputSource, V.frame, u || a), Ee.dispatchEvent({ type: V.type, data: V.inputSource })) } function F() { i.removeEventListener("select", B), i.removeEventListener("selectstart", B), i.removeEventListener("selectend", B), i.removeEventListener("squeeze", B), i.removeEventListener("squeezestart", B), i.removeEventListener("squeezeend", B), i.removeEventListener("end", F), i.removeEventListener("inputsourceschange", U); for (let V = 0; V < _.length; V++) { const J = x[V]; J !== null && (x[V] = null, _[V].disconnect(J)) } R = null, b = null, e.setRenderTarget(y), m = null, d = null, h = null, i = null, A = null, D.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (V) { s = V, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (V) { o = V, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return u || a }, this.setReferenceSpace = function (V) { u = V }, this.getBaseLayer = function () { return d !== null ? d : m }, this.getBinding = function () { return h }, this.getFrame = function () { return g }, this.getSession = function () { return i }, this.setSession = async function (V) { if (i = V, i !== null) { if (y = e.getRenderTarget(), i.addEventListener("select", B), i.addEventListener("selectstart", B), i.addEventListener("selectend", B), i.addEventListener("squeeze", B), i.addEventListener("squeezestart", B), i.addEventListener("squeezeend", B), i.addEventListener("end", F), i.addEventListener("inputsourceschange", U), v.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) { const J = { antialias: i.renderState.layers === void 0 ? v.antialias : !0, alpha: !0, depth: v.depth, stencil: v.stencil, framebufferScaleFactor: s }; m = new XRWebGLLayer(i, t, J), i.updateRenderState({ baseLayer: m }), A = new Ir(m.framebufferWidth, m.framebufferHeight, { format: Ri, type: As, colorSpace: e.outputColorSpace, stencilBuffer: v.stencil }) } else { let J = null, Ee = null, xe = null; v.depth && (xe = v.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, J = v.stencil ? Fh : Eh, Ee = v.stencil ? sf : $c); const Be = { colorFormat: t.RGBA8, depthFormat: xe, scaleFactor: s }; h = new XRWebGLBinding(i, t), d = h.createProjectionLayer(Be), i.updateRenderState({ layers: [d] }), A = new Ir(d.textureWidth, d.textureHeight, { format: Ri, type: As, depthTexture: new xm(d.textureWidth, d.textureHeight, Ee, void 0, void 0, void 0, void 0, void 0, void 0, J), stencilBuffer: v.stencil, colorSpace: e.outputColorSpace, samples: v.antialias ? 4 : 0 }); const Fe = e.properties.get(A); Fe.__ignoreDepthValues = d.ignoreDepthValues } A.isXRRenderTarget = !0, this.setFoveation(l), u = null, a = await i.requestReferenceSpace(o), D.setContext(i), D.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } }, this.getEnvironmentBlendMode = function () { if (i !== null) return i.environmentBlendMode }; function U(V) { for (let J = 0; J < V.removed.length; J++) { const Ee = V.removed[J], xe = x.indexOf(Ee); xe >= 0 && (x[xe] = null, _[xe].disconnect(Ee)) } for (let J = 0; J < V.added.length; J++) { const Ee = V.added[J]; let xe = x.indexOf(Ee); if (xe === -1) { for (let Fe = 0; Fe < _.length; Fe++)if (Fe >= x.length) { x.push(Ee), xe = Fe; break } else if (x[Fe] === null) { x[Fe] = Ee, xe = Fe; break } if (xe === -1) break } const Be = _[xe]; Be && Be.connect(Ee) } } const G = new N, Y = new N; function Z(V, J, Ee) { G.setFromMatrixPosition(J.matrixWorld), Y.setFromMatrixPosition(Ee.matrixWorld); const xe = G.distanceTo(Y), Be = J.projectionMatrix.elements, Fe = Ee.projectionMatrix.elements, we = Be[14] / (Be[10] - 1), ge = Be[14] / (Be[10] + 1), tt = (Be[9] + 1) / Be[5], je = (Be[9] - 1) / Be[5], Oe = (Be[8] - 1) / Be[0], K = (Fe[8] + 1) / Fe[0], de = we * Oe, Ce = we * K, Qe = xe / (-Oe + K), De = Qe * -Oe; J.matrixWorld.decompose(V.position, V.quaternion, V.scale), V.translateX(De), V.translateZ(Qe), V.matrixWorld.compose(V.position, V.quaternion, V.scale), V.matrixWorldInverse.copy(V.matrixWorld).invert(); const ie = we + Qe, qe = ge + Qe, nt = de - De, it = Ce + (xe - De), xt = tt * ge / qe * ie, mn = je * ge / qe * ie; V.projectionMatrix.makePerspective(nt, it, xt, mn, ie, qe), V.projectionMatrixInverse.copy(V.projectionMatrix).invert() } function ne(V, J) { J === null ? V.matrixWorld.copy(V.matrix) : V.matrixWorld.multiplyMatrices(J.matrixWorld, V.matrix), V.matrixWorldInverse.copy(V.matrixWorld).invert() } this.updateCamera = function (V) { if (i === null) return; w.near = T.near = C.near = V.near, w.far = T.far = C.far = V.far, (R !== w.near || b !== w.far) && (i.updateRenderState({ depthNear: w.near, depthFar: w.far }), R = w.near, b = w.far); const J = V.parent, Ee = w.cameras; ne(w, J); for (let xe = 0; xe < Ee.length; xe++)ne(Ee[xe], J); Ee.length === 2 ? Z(w, C, T) : w.projectionMatrix.copy(C.projectionMatrix), $(V, w, J) }; function $(V, J, Ee) { Ee === null ? V.matrix.copy(J.matrixWorld) : (V.matrix.copy(Ee.matrixWorld), V.matrix.invert(), V.matrix.multiply(J.matrixWorld)), V.matrix.decompose(V.position, V.quaternion, V.scale), V.updateMatrixWorld(!0), V.projectionMatrix.copy(J.projectionMatrix), V.projectionMatrixInverse.copy(J.projectionMatrixInverse), V.isPerspectiveCamera && (V.fov = $3 * 2 * Math.atan(1 / V.projectionMatrix.elements[5]), V.zoom = 1) } this.getCamera = function () { return w }, this.getFoveation = function () { if (!(d === null && m === null)) return l }, this.setFoveation = function (V) { l = V, d !== null && (d.fixedFoveation = V), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = V) }; let L = null; function Q(V, J) { if (c = J.getViewerPose(u || a), g = J, c !== null) { const Ee = c.views; m !== null && (e.setRenderTargetFramebuffer(A, m.framebuffer), e.setRenderTarget(A)); let xe = !1; Ee.length !== w.cameras.length && (w.cameras.length = 0, xe = !0); for (let Be = 0; Be < Ee.length; Be++) { const Fe = Ee[Be]; let we = null; if (m !== null) we = m.getViewport(Fe); else { const tt = h.getViewSubImage(d, Fe); we = tt.viewport, Be === 0 && (e.setRenderTargetTextures(A, tt.colorTexture, d.ignoreDepthValues ? void 0 : tt.depthStencilTexture), e.setRenderTarget(A)) } let ge = I[Be]; ge === void 0 && (ge = new Gr, ge.layers.enable(Be), ge.viewport = new Jn, I[Be] = ge), ge.matrix.fromArray(Fe.transform.matrix), ge.matrix.decompose(ge.position, ge.quaternion, ge.scale), ge.projectionMatrix.fromArray(Fe.projectionMatrix), ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert(), ge.viewport.set(we.x, we.y, we.width, we.height), Be === 0 && (w.matrix.copy(ge.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), xe === !0 && w.cameras.push(ge) } } for (let Ee = 0; Ee < _.length; Ee++) { const xe = x[Ee], Be = _[Ee]; xe !== null && Be !== void 0 && Be.update(xe, J, u || a) } L && L(V, J), J.detectedPlanes && r.dispatchEvent({ type: "planesdetected", data: J }), g = null } const D = new DO; D.setAnimationLoop(Q), this.setAnimationLoop = function (V) { L = V }, this.dispose = function () { } } } function ite(n, e) { function t(y, A) { y.matrixAutoUpdate === !0 && y.updateMatrix(), A.value.copy(y.matrix) } function r(y, A) { A.color.getRGB(y.fogColor.value, PO(n)), A.isFog ? (y.fogNear.value = A.near, y.fogFar.value = A.far) : A.isFogExp2 && (y.fogDensity.value = A.density) } function i(y, A, _, x, C) { A.isMeshBasicMaterial || A.isMeshLambertMaterial ? s(y, A) : A.isMeshToonMaterial ? (s(y, A), h(y, A)) : A.isMeshPhongMaterial ? (s(y, A), c(y, A)) : A.isMeshStandardMaterial ? (s(y, A), d(y, A), A.isMeshPhysicalMaterial && m(y, A, C)) : A.isMeshMatcapMaterial ? (s(y, A), g(y, A)) : A.isMeshDepthMaterial ? s(y, A) : A.isMeshDistanceMaterial ? (s(y, A), v(y, A)) : A.isMeshNormalMaterial ? s(y, A) : A.isLineBasicMaterial ? (a(y, A), A.isLineDashedMaterial && o(y, A)) : A.isPointsMaterial ? l(y, A, _, x) : A.isSpriteMaterial ? u(y, A) : A.isShadowMaterial ? (y.color.value.copy(A.color), y.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = !1) } function s(y, A) { y.opacity.value = A.opacity, A.color && y.diffuse.value.copy(A.color), A.emissive && y.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (y.map.value = A.map, t(A.map, y.mapTransform)), A.alphaMap && (y.alphaMap.value = A.alphaMap, t(A.alphaMap, y.alphaMapTransform)), A.bumpMap && (y.bumpMap.value = A.bumpMap, t(A.bumpMap, y.bumpMapTransform), y.bumpScale.value = A.bumpScale, A.side === pa && (y.bumpScale.value *= -1)), A.normalMap && (y.normalMap.value = A.normalMap, t(A.normalMap, y.normalMapTransform), y.normalScale.value.copy(A.normalScale), A.side === pa && y.normalScale.value.negate()), A.displacementMap && (y.displacementMap.value = A.displacementMap, t(A.displacementMap, y.displacementMapTransform), y.displacementScale.value = A.displacementScale, y.displacementBias.value = A.displacementBias), A.emissiveMap && (y.emissiveMap.value = A.emissiveMap, t(A.emissiveMap, y.emissiveMapTransform)), A.specularMap && (y.specularMap.value = A.specularMap, t(A.specularMap, y.specularMapTransform)), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest); const _ = e.get(A).envMap; if (_ && (y.envMap.value = _, y.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = A.reflectivity, y.ior.value = A.ior, y.refractionRatio.value = A.refractionRatio), A.lightMap) { y.lightMap.value = A.lightMap; const x = n._useLegacyLights === !0 ? Math.PI : 1; y.lightMapIntensity.value = A.lightMapIntensity * x, t(A.lightMap, y.lightMapTransform) } A.aoMap && (y.aoMap.value = A.aoMap, y.aoMapIntensity.value = A.aoMapIntensity, t(A.aoMap, y.aoMapTransform)) } function a(y, A) { y.diffuse.value.copy(A.color), y.opacity.value = A.opacity, A.map && (y.map.value = A.map, t(A.map, y.mapTransform)) } function o(y, A) { y.dashSize.value = A.dashSize, y.totalSize.value = A.dashSize + A.gapSize, y.scale.value = A.scale } function l(y, A, _, x) { y.diffuse.value.copy(A.color), y.opacity.value = A.opacity, y.size.value = A.size * _, y.scale.value = x * .5, A.map && (y.map.value = A.map, t(A.map, y.uvTransform)), A.alphaMap && (y.alphaMap.value = A.alphaMap, t(A.alphaMap, y.alphaMapTransform)), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest) } function u(y, A) { y.diffuse.value.copy(A.color), y.opacity.value = A.opacity, y.rotation.value = A.rotation, A.map && (y.map.value = A.map, t(A.map, y.mapTransform)), A.alphaMap && (y.alphaMap.value = A.alphaMap, t(A.alphaMap, y.alphaMapTransform)), A.alphaTest > 0 && (y.alphaTest.value = A.alphaTest) } function c(y, A) { y.specular.value.copy(A.specular), y.shininess.value = Math.max(A.shininess, 1e-4) } function h(y, A) { A.gradientMap && (y.gradientMap.value = A.gradientMap) } function d(y, A) { y.metalness.value = A.metalness, A.metalnessMap && (y.metalnessMap.value = A.metalnessMap, t(A.metalnessMap, y.metalnessMapTransform)), y.roughness.value = A.roughness, A.roughnessMap && (y.roughnessMap.value = A.roughnessMap, t(A.roughnessMap, y.roughnessMapTransform)), e.get(A).envMap && (y.envMapIntensity.value = A.envMapIntensity) } function m(y, A, _) { y.ior.value = A.ior, A.sheen > 0 && (y.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), y.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (y.sheenColorMap.value = A.sheenColorMap, t(A.sheenColorMap, y.sheenColorMapTransform)), A.sheenRoughnessMap && (y.sheenRoughnessMap.value = A.sheenRoughnessMap, t(A.sheenRoughnessMap, y.sheenRoughnessMapTransform))), A.clearcoat > 0 && (y.clearcoat.value = A.clearcoat, y.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (y.clearcoatMap.value = A.clearcoatMap, t(A.clearcoatMap, y.clearcoatMapTransform)), A.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, t(A.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (y.clearcoatNormalMap.value = A.clearcoatNormalMap, t(A.clearcoatNormalMap, y.clearcoatNormalMapTransform), y.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A.side === pa && y.clearcoatNormalScale.value.negate())), A.iridescence > 0 && (y.iridescence.value = A.iridescence, y.iridescenceIOR.value = A.iridescenceIOR, y.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (y.iridescenceMap.value = A.iridescenceMap, t(A.iridescenceMap, y.iridescenceMapTransform)), A.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = A.iridescenceThicknessMap, t(A.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))), A.transmission > 0 && (y.transmission.value = A.transmission, y.transmissionSamplerMap.value = _.texture, y.transmissionSamplerSize.value.set(_.width, _.height), A.transmissionMap && (y.transmissionMap.value = A.transmissionMap, t(A.transmissionMap, y.transmissionMapTransform)), y.thickness.value = A.thickness, A.thicknessMap && (y.thicknessMap.value = A.thicknessMap, t(A.thicknessMap, y.thicknessMapTransform)), y.attenuationDistance.value = A.attenuationDistance, y.attenuationColor.value.copy(A.attenuationColor)), A.anisotropy > 0 && (y.anisotropyVector.value.set(A.anisotropy * Math.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (y.anisotropyMap.value = A.anisotropyMap, t(A.anisotropyMap, y.anisotropyMapTransform))), y.specularIntensity.value = A.specularIntensity, y.specularColor.value.copy(A.specularColor), A.specularColorMap && (y.specularColorMap.value = A.specularColorMap, t(A.specularColorMap, y.specularColorMapTransform)), A.specularIntensityMap && (y.specularIntensityMap.value = A.specularIntensityMap, t(A.specularIntensityMap, y.specularIntensityMapTransform)) } function g(y, A) { A.matcap && (y.matcap.value = A.matcap) } function v(y, A) { const _ = e.get(A).light; y.referencePosition.value.setFromMatrixPosition(_.matrixWorld), y.nearDistance.value = _.shadow.camera.near, y.farDistance.value = _.shadow.camera.far } return { refreshFogUniforms: r, refreshMaterialUniforms: i } } function ste(n, e, t, r) { let i = {}, s = {}, a = []; const o = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0; function l(_, x) { const C = x.program; r.uniformBlockBinding(_, C) } function u(_, x) { let C = i[_.id]; C === void 0 && (g(_), C = c(_), i[_.id] = C, _.addEventListener("dispose", y)); const T = x.program; r.updateUBOMapping(_, T); const I = e.render.frame; s[_.id] !== I && (d(_), s[_.id] = I) } function c(_) { const x = h(); _.__bindingPointIndex = x; const C = n.createBuffer(), T = _.__size, I = _.usage; return n.bindBuffer(n.UNIFORM_BUFFER, C), n.bufferData(n.UNIFORM_BUFFER, T, I), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, x, C), C } function h() { for (let _ = 0; _ < o; _++)if (a.indexOf(_) === -1) return a.push(_), _; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function d(_) { const x = i[_.id], C = _.uniforms, T = _.__cache; n.bindBuffer(n.UNIFORM_BUFFER, x); for (let I = 0, w = C.length; I < w; I++) { const R = C[I]; if (m(R, I, T) === !0) { const b = R.__offset, B = Array.isArray(R.value) ? R.value : [R.value]; let F = 0; for (let U = 0; U < B.length; U++) { const G = B[U], Y = v(G); typeof G == "number" ? (R.__data[0] = G, n.bufferSubData(n.UNIFORM_BUFFER, b + F, R.__data)) : G.isMatrix3 ? (R.__data[0] = G.elements[0], R.__data[1] = G.elements[1], R.__data[2] = G.elements[2], R.__data[3] = G.elements[0], R.__data[4] = G.elements[3], R.__data[5] = G.elements[4], R.__data[6] = G.elements[5], R.__data[7] = G.elements[0], R.__data[8] = G.elements[6], R.__data[9] = G.elements[7], R.__data[10] = G.elements[8], R.__data[11] = G.elements[0]) : (G.toArray(R.__data, F), F += Y.storage / Float32Array.BYTES_PER_ELEMENT) } n.bufferSubData(n.UNIFORM_BUFFER, b, R.__data) } } n.bindBuffer(n.UNIFORM_BUFFER, null) } function m(_, x, C) { const T = _.value; if (C[x] === void 0) { if (typeof T == "number") C[x] = T; else { const I = Array.isArray(T) ? T : [T], w = []; for (let R = 0; R < I.length; R++)w.push(I[R].clone()); C[x] = w } return !0 } else if (typeof T == "number") { if (C[x] !== T) return C[x] = T, !0 } else { const I = Array.isArray(C[x]) ? C[x] : [C[x]], w = Array.isArray(T) ? T : [T]; for (let R = 0; R < I.length; R++) { const b = I[R]; if (b.equals(w[R]) === !1) return b.copy(w[R]), !0 } } return !1 } function g(_) { const x = _.uniforms; let C = 0; const T = 16; let I = 0; for (let w = 0, R = x.length; w < R; w++) { const b = x[w], B = { boundary: 0, storage: 0 }, F = Array.isArray(b.value) ? b.value : [b.value]; for (let U = 0, G = F.length; U < G; U++) { const Y = F[U], Z = v(Y); B.boundary += Z.boundary, B.storage += Z.storage } if (b.__data = new Float32Array(B.storage / Float32Array.BYTES_PER_ELEMENT), b.__offset = C, w > 0) { I = C % T; const U = T - I; I !== 0 && U - B.boundary < 0 && (C += T - I, b.__offset = C) } C += B.storage } return I = C % T, I > 0 && (C += T - I), _.__size = C, _.__cache = {}, this } function v(_) { const x = { boundary: 0, storage: 0 }; return typeof _ == "number" ? (x.boundary = 4, x.storage = 4) : _.isVector2 ? (x.boundary = 8, x.storage = 8) : _.isVector3 || _.isColor ? (x.boundary = 16, x.storage = 12) : _.isVector4 ? (x.boundary = 16, x.storage = 16) : _.isMatrix3 ? (x.boundary = 48, x.storage = 48) : _.isMatrix4 ? (x.boundary = 64, x.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), x } function y(_) { const x = _.target; x.removeEventListener("dispose", y); const C = a.indexOf(x.__bindingPointIndex); a.splice(C, 1), n.deleteBuffer(i[x.id]), delete i[x.id], delete s[x.id] } function A() { for (const _ in i) n.deleteBuffer(i[_]); a = [], i = {}, s = {} } return { bind: l, update: u, dispose: A } } class XS { constructor(e = {}) { const { canvas: t = bO(), context: r = null, depth: i = !0, stencil: s = !0, alpha: a = !1, antialias: o = !1, premultipliedAlpha: l = !0, preserveDrawingBuffer: u = !1, powerPreference: c = "default", failIfMajorPerformanceCaveat: h = !1 } = e; this.isWebGLRenderer = !0; let d; r !== null ? d = r.getContextAttributes().alpha : d = a; const m = new Uint32Array(4), g = new Int32Array(4); let v = null, y = null; const A = [], _ = []; this.domElement = t, this.debug = { checkShaderErrors: !0, onShaderError: null }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = Ur, this._useLegacyLights = !1, this.toneMapping = wl, this.toneMappingExposure = 1; const x = this; let C = !1, T = 0, I = 0, w = null, R = -1, b = null; const B = new Jn, F = new Jn; let U = null; const G = new Je(0); let Y = 0, Z = t.width, ne = t.height, $ = 1, L = null, Q = null; const D = new Jn(0, 0, Z, ne), V = new Jn(0, 0, Z, ne); let J = !1; const Ee = new c8; let xe = !1, Be = !1, Fe = null; const we = new bt, ge = new Se, tt = new N, je = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function Oe() { return w === null ? $ : 1 } let K = r; function de(H, ae) { for (let ve = 0; ve < H.length; ve++) { const he = H[ve], Te = t.getContext(he, ae); if (Te !== null) return Te } return null } try { const H = { alpha: !0, depth: i, stencil: s, antialias: o, premultipliedAlpha: l, preserveDrawingBuffer: u, powerPreference: c, failIfMajorPerformanceCaveat: h }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Su}`), t.addEventListener("webglcontextlost", Ve, !1), t.addEventListener("webglcontextrestored", oe, !1), t.addEventListener("webglcontextcreationerror", ze, !1), K === null) { const ae = ["webgl2", "webgl", "experimental-webgl"]; if (x.isWebGL1Renderer === !0 && ae.shift(), K = de(ae, H), K === null) throw de(ae) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } typeof WebGLRenderingContext < "u" && K instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (H) { throw console.error("THREE.WebGLRenderer: " + H.message), H } let Ce, Qe, De, ie, qe, nt, it, xt, mn, X, O, fe, Ne, Ue, We, ut, Ge, Ae, st, vt, dt, at, ee, Ie; function Ke() { Ce = new x$(K), Qe = new p$(K, Ce, e), Ce.init(Qe), at = new OO(K, Ce, Qe), De = new $ee(K, Ce, Qe), ie = new C$(K), qe = new Qee, nt = new ete(K, Ce, De, qe, Qe, at, ie), it = new g$(x), xt = new y$(x), mn = new DK(K, Qe), ee = new h$(K, Ce, mn, Qe), X = new _$(K, mn, ie, ee), O = new I$(K, X, mn, ie), st = new w$(K, Qe, nt), ut = new m$(qe), fe = new Gee(x, it, xt, Ce, Qe, ee, ut), Ne = new ite(x, qe), Ue = new zee, We = new Jee(Ce, Qe), Ae = new f$(x, it, xt, De, O, d, l), Ge = new Zee(x, O, Qe), Ie = new ste(K, ie, Qe, De), vt = new d$(K, Ce, ie, Qe), dt = new E$(K, Ce, ie, Qe), ie.programs = fe.programs, x.capabilities = Qe, x.extensions = Ce, x.properties = qe, x.renderLists = Ue, x.shadowMap = Ge, x.state = De, x.info = ie } Ke(); const j = new rte(x, K); this.xr = j, this.getContext = function () { return K }, this.getContextAttributes = function () { return K.getContextAttributes() }, this.forceContextLoss = function () { const H = Ce.get("WEBGL_lose_context"); H && H.loseContext() }, this.forceContextRestore = function () { const H = Ce.get("WEBGL_lose_context"); H && H.restoreContext() }, this.getPixelRatio = function () { return $ }, this.setPixelRatio = function (H) { H !== void 0 && ($ = H, this.setSize(Z, ne, !1)) }, this.getSize = function (H) { return H.set(Z, ne) }, this.setSize = function (H, ae, ve = !0) { if (j.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } Z = H, ne = ae, t.width = Math.floor(H * $), t.height = Math.floor(ae * $), ve === !0 && (t.style.width = H + "px", t.style.height = ae + "px"), this.setViewport(0, 0, H, ae) }, this.getDrawingBufferSize = function (H) { return H.set(Z * $, ne * $).floor() }, this.setDrawingBufferSize = function (H, ae, ve) { Z = H, ne = ae, $ = ve, t.width = Math.floor(H * ve), t.height = Math.floor(ae * ve), this.setViewport(0, 0, H, ae) }, this.getCurrentViewport = function (H) { return H.copy(B) }, this.getViewport = function (H) { return H.copy(D) }, this.setViewport = function (H, ae, ve, he) { H.isVector4 ? D.set(H.x, H.y, H.z, H.w) : D.set(H, ae, ve, he), De.viewport(B.copy(D).multiplyScalar($).floor()) }, this.getScissor = function (H) { return H.copy(V) }, this.setScissor = function (H, ae, ve, he) { H.isVector4 ? V.set(H.x, H.y, H.z, H.w) : V.set(H, ae, ve, he), De.scissor(F.copy(V).multiplyScalar($).floor()) }, this.getScissorTest = function () { return J }, this.setScissorTest = function (H) { De.setScissorTest(J = H) }, this.setOpaqueSort = function (H) { L = H }, this.setTransparentSort = function (H) { Q = H }, this.getClearColor = function (H) { return H.copy(Ae.getClearColor()) }, this.setClearColor = function () { Ae.setClearColor.apply(Ae, arguments) }, this.getClearAlpha = function () { return Ae.getClearAlpha() }, this.setClearAlpha = function () { Ae.setClearAlpha.apply(Ae, arguments) }, this.clear = function (H = !0, ae = !0, ve = !0) { let he = 0; if (H) { let Te = !1; if (w !== null) { const rt = w.texture.format; Te = rt === DS || rt === PS || rt === RS } if (Te) { const rt = w.texture.type, ct = rt === As || rt === $c || rt === Np || rt === sf || rt === MS || rt === bS, Ct = Ae.getClearColor(), Nt = Ae.getClearAlpha(), nn = Ct.r, yt = Ct.g, pt = Ct.b; ct ? (m[0] = nn, m[1] = yt, m[2] = pt, m[3] = Nt, K.clearBufferuiv(K.COLOR, 0, m)) : (g[0] = nn, g[1] = yt, g[2] = pt, g[3] = Nt, K.clearBufferiv(K.COLOR, 0, g)) } else he |= K.COLOR_BUFFER_BIT } ae && (he |= K.DEPTH_BUFFER_BIT), ve && (he |= K.STENCIL_BUFFER_BIT), K.clear(he) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", Ve, !1), t.removeEventListener("webglcontextrestored", oe, !1), t.removeEventListener("webglcontextcreationerror", ze, !1), Ue.dispose(), We.dispose(), qe.dispose(), it.dispose(), xt.dispose(), O.dispose(), ee.dispose(), Ie.dispose(), fe.dispose(), j.dispose(), j.removeEventListener("sessionstart", $e), j.removeEventListener("sessionend", Xt), Fe && (Fe.dispose(), Fe = null), Qt.stop() }; function Ve(H) { H.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0 } function oe() { console.log("THREE.WebGLRenderer: Context Restored."), C = !1; const H = ie.autoReset, ae = Ge.enabled, ve = Ge.autoUpdate, he = Ge.needsUpdate, Te = Ge.type; Ke(), ie.autoReset = H, Ge.enabled = ae, Ge.autoUpdate = ve, Ge.needsUpdate = he, Ge.type = Te } function ze(H) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", H.statusMessage) } function Ye(H) { const ae = H.target; ae.removeEventListener("dispose", Ye), jt(ae) } function jt(H) { ln(H), qe.remove(H) } function ln(H) { const ae = qe.get(H).programs; ae !== void 0 && (ae.forEach(function (ve) { fe.releaseProgram(ve) }), H.isShaderMaterial && fe.releaseShaderCache(H)) } this.renderBufferDirect = function (H, ae, ve, he, Te, rt) { ae === null && (ae = je); const ct = Te.isMesh && Te.matrixWorld.determinant() < 0, Ct = Fi(H, ae, ve, he, Te); De.setMaterial(he, ct); let Nt = ve.index, nn = 1; if (he.wireframe === !0) { if (Nt = X.getWireframeAttribute(ve), Nt === void 0) return; nn = 2 } const yt = ve.drawRange, pt = ve.attributes.position; let hn = yt.start * nn, Vn = (yt.start + yt.count) * nn; rt !== null && (hn = Math.max(hn, rt.start * nn), Vn = Math.min(Vn, (rt.start + rt.count) * nn)), Nt !== null ? (hn = Math.max(hn, 0), Vn = Math.min(Vn, Nt.count)) : pt != null && (hn = Math.max(hn, 0), Vn = Math.min(Vn, pt.count)); const oi = Vn - hn; if (oi < 0 || oi === 1 / 0) return; ee.setup(Te, he, Ct, ve, Nt); let Vr, gn = vt; if (Nt !== null && (Vr = mn.get(Nt), gn = dt, gn.setIndex(Vr)), Te.isMesh) he.wireframe === !0 ? (De.setLineWidth(he.wireframeLinewidth * Oe()), gn.setMode(K.LINES)) : gn.setMode(K.TRIANGLES); else if (Te.isLine) { let gt = he.linewidth; gt === void 0 && (gt = 1), De.setLineWidth(gt * Oe()), Te.isLineSegments ? gn.setMode(K.LINES) : Te.isLineLoop ? gn.setMode(K.LINE_LOOP) : gn.setMode(K.LINE_STRIP) } else Te.isPoints ? gn.setMode(K.POINTS) : Te.isSprite && gn.setMode(K.TRIANGLES); if (Te.isInstancedMesh) gn.renderInstances(hn, oi, Te.count); else if (ve.isInstancedBufferGeometry) { const gt = ve._maxInstanceCount !== void 0 ? ve._maxInstanceCount : 1 / 0, an = Math.min(ve.instanceCount, gt); gn.renderInstances(hn, oi, an) } else gn.render(hn, oi) }, this.compile = function (H, ae) { function ve(he, Te, rt) { he.transparent === !0 && he.side === cu && he.forceSinglePass === !1 ? (he.side = pa, he.needsUpdate = !0, sn(he, Te, rt), he.side = pc, he.needsUpdate = !0, sn(he, Te, rt), he.side = cu) : sn(he, Te, rt) } y = We.get(H), y.init(), _.push(y), H.traverseVisible(function (he) { he.isLight && he.layers.test(ae.layers) && (y.pushLight(he), he.castShadow && y.pushShadow(he)) }), y.setupLights(x._useLegacyLights), H.traverse(function (he) { const Te = he.material; if (Te) if (Array.isArray(Te)) for (let rt = 0; rt < Te.length; rt++) { const ct = Te[rt]; ve(ct, H, he) } else ve(Te, H, he) }), _.pop(), y = null }; let fn = null; function Dt(H) { fn && fn(H) } function $e() { Qt.stop() } function Xt() { Qt.start() } const Qt = new DO; Qt.setAnimationLoop(Dt), typeof self < "u" && Qt.setContext(self), this.setAnimationLoop = function (H) { fn = H, j.setAnimationLoop(H), H === null ? Qt.stop() : Qt.start() }, j.addEventListener("sessionstart", $e), j.addEventListener("sessionend", Xt), this.render = function (H, ae) { if (ae !== void 0 && ae.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (C === !0) return; H.matrixWorldAutoUpdate === !0 && H.updateMatrixWorld(), ae.parent === null && ae.matrixWorldAutoUpdate === !0 && ae.updateMatrixWorld(), j.enabled === !0 && j.isPresenting === !0 && (j.cameraAutoUpdate === !0 && j.updateCamera(ae), ae = j.getCamera()), H.isScene === !0 && H.onBeforeRender(x, H, ae, w), y = We.get(H, _.length), y.init(), _.push(y), we.multiplyMatrices(ae.projectionMatrix, ae.matrixWorldInverse), Ee.setFromProjectionMatrix(we), Be = this.localClippingEnabled, xe = ut.init(this.clippingPlanes, Be), v = Ue.get(H, A.length), v.init(), A.push(v), ft(H, ae, 0, x.sortObjects), v.finish(), x.sortObjects === !0 && v.sort(L, Q), this.info.render.frame++, xe === !0 && ut.beginShadows(); const ve = y.state.shadowsArray; if (Ge.render(ve, H, ae), xe === !0 && ut.endShadows(), this.info.autoReset === !0 && this.info.reset(), Ae.render(v, H), y.setupLights(x._useLegacyLights), ae.isArrayCamera) { const he = ae.cameras; for (let Te = 0, rt = he.length; Te < rt; Te++) { const ct = he[Te]; xn(v, H, ct, ct.viewport) } } else xn(v, H, ae); w !== null && (nt.updateMultisampleRenderTarget(w), nt.updateRenderTargetMipmap(w)), H.isScene === !0 && H.onAfterRender(x, H, ae), ee.resetDefaultState(), R = -1, b = null, _.pop(), _.length > 0 ? y = _[_.length - 1] : y = null, A.pop(), A.length > 0 ? v = A[A.length - 1] : v = null }; function ft(H, ae, ve, he) { if (H.visible === !1) return; if (H.layers.test(ae.layers)) { if (H.isGroup) ve = H.renderOrder; else if (H.isLOD) H.autoUpdate === !0 && H.update(ae); else if (H.isLight) y.pushLight(H), H.castShadow && y.pushShadow(H); else if (H.isSprite) { if (!H.frustumCulled || Ee.intersectsSprite(H)) { he && tt.setFromMatrixPosition(H.matrixWorld).applyMatrix4(we); const ct = O.update(H), Ct = H.material; Ct.visible && v.push(H, ct, Ct, ve, tt.z, null) } } else if ((H.isMesh || H.isLine || H.isPoints) && (!H.frustumCulled || Ee.intersectsObject(H))) { const ct = O.update(H), Ct = H.material; if (he && (H.boundingSphere !== void 0 ? (H.boundingSphere === null && H.computeBoundingSphere(), tt.copy(H.boundingSphere.center)) : (ct.boundingSphere === null && ct.computeBoundingSphere(), tt.copy(ct.boundingSphere.center)), tt.applyMatrix4(H.matrixWorld).applyMatrix4(we)), Array.isArray(Ct)) { const Nt = ct.groups; for (let nn = 0, yt = Nt.length; nn < yt; nn++) { const pt = Nt[nn], hn = Ct[pt.materialIndex]; hn && hn.visible && v.push(H, ct, hn, ve, tt.z, pt) } } else Ct.visible && v.push(H, ct, Ct, ve, tt.z, null) } } const rt = H.children; for (let ct = 0, Ct = rt.length; ct < Ct; ct++)ft(rt[ct], ae, ve, he) } function xn(H, ae, ve, he) { const Te = H.opaque, rt = H.transmissive, ct = H.transparent; y.setupLightsView(ve), xe === !0 && ut.setGlobalState(x.clippingPlanes, ve), rt.length > 0 && Vt(Te, rt, ae, ve), he && De.viewport(B.copy(he)), Te.length > 0 && Yt(Te, ae, ve), rt.length > 0 && Yt(rt, ae, ve), ct.length > 0 && Yt(ct, ae, ve), De.buffers.depth.setTest(!0), De.buffers.depth.setMask(!0), De.buffers.color.setMask(!0), De.setPolygonOffset(!1) } function Vt(H, ae, ve, he) { const Te = Qe.isWebGL2; Fe === null && (Fe = new Ir(1, 1, { generateMipmaps: !0, type: Ce.has("EXT_color_buffer_half_float") ? Wi : As, minFilter: Dl, samples: Te ? 4 : 0 })), x.getDrawingBufferSize(ge), Te ? Fe.setSize(ge.x, ge.y) : Fe.setSize(ly(ge.x), ly(ge.y)); const rt = x.getRenderTarget(); x.setRenderTarget(Fe), x.getClearColor(G), Y = x.getClearAlpha(), Y < 1 && x.setClearColor(16777215, .5), x.clear(); const ct = x.toneMapping; x.toneMapping = wl, Yt(H, ve, he), nt.updateMultisampleRenderTarget(Fe), nt.updateRenderTargetMipmap(Fe); let Ct = !1; for (let Nt = 0, nn = ae.length; Nt < nn; Nt++) { const yt = ae[Nt], pt = yt.object, hn = yt.geometry, Vn = yt.material, oi = yt.group; if (Vn.side === cu && pt.layers.test(he.layers)) { const Vr = Vn.side; Vn.side = pa, Vn.needsUpdate = !0, Mr(pt, ve, he, hn, Vn, oi), Vn.side = Vr, Vn.needsUpdate = !0, Ct = !0 } } Ct === !0 && (nt.updateMultisampleRenderTarget(Fe), nt.updateRenderTargetMipmap(Fe)), x.setRenderTarget(rt), x.setClearColor(G, Y), x.toneMapping = ct } function Yt(H, ae, ve) { const he = ae.isScene === !0 ? ae.overrideMaterial : null; for (let Te = 0, rt = H.length; Te < rt; Te++) { const ct = H[Te], Ct = ct.object, Nt = ct.geometry, nn = he === null ? ct.material : he, yt = ct.group; Ct.layers.test(ve.layers) && Mr(Ct, ae, ve, Nt, nn, yt) } } function Mr(H, ae, ve, he, Te, rt) { H.onBeforeRender(x, ae, ve, he, Te, rt), H.modelViewMatrix.multiplyMatrices(ve.matrixWorldInverse, H.matrixWorld), H.normalMatrix.getNormalMatrix(H.modelViewMatrix), Te.onBeforeRender(x, ae, ve, he, H, rt), Te.transparent === !0 && Te.side === cu && Te.forceSinglePass === !1 ? (Te.side = pa, Te.needsUpdate = !0, x.renderBufferDirect(ve, ae, he, Te, H, rt), Te.side = pc, Te.needsUpdate = !0, x.renderBufferDirect(ve, ae, he, Te, H, rt), Te.side = cu) : x.renderBufferDirect(ve, ae, he, Te, H, rt), H.onAfterRender(x, ae, ve, he, Te, rt) } function sn(H, ae, ve) { ae.isScene !== !0 && (ae = je); const he = qe.get(H), Te = y.state.lights, rt = y.state.shadowsArray, ct = Te.state.version, Ct = fe.getParameters(H, Te.state, rt, ae, ve), Nt = fe.getProgramCacheKey(Ct); let nn = he.programs; he.environment = H.isMeshStandardMaterial ? ae.environment : null, he.fog = ae.fog, he.envMap = (H.isMeshStandardMaterial ? xt : it).get(H.envMap || he.environment), nn === void 0 && (H.addEventListener("dispose", Ye), nn = new Map, he.programs = nn); let yt = nn.get(Nt); if (yt !== void 0) { if (he.currentProgram === yt && he.lightsStateVersion === ct) return vr(H, Ct), yt } else Ct.uniforms = fe.getUniforms(H), H.onBuild(ve, Ct, x), H.onBeforeCompile(Ct, x), yt = fe.acquireProgram(Ct, Nt), nn.set(Nt, yt), he.uniforms = Ct.uniforms; const pt = he.uniforms; (!H.isShaderMaterial && !H.isRawShaderMaterial || H.clipping === !0) && (pt.clippingPlanes = ut.uniform), vr(H, Ct), he.needsLights = rr(H), he.lightsStateVersion = ct, he.needsLights && (pt.ambientLightColor.value = Te.state.ambient, pt.lightProbe.value = Te.state.probe, pt.directionalLights.value = Te.state.directional, pt.directionalLightShadows.value = Te.state.directionalShadow, pt.spotLights.value = Te.state.spot, pt.spotLightShadows.value = Te.state.spotShadow, pt.rectAreaLights.value = Te.state.rectArea, pt.ltc_1.value = Te.state.rectAreaLTC1, pt.ltc_2.value = Te.state.rectAreaLTC2, pt.pointLights.value = Te.state.point, pt.pointLightShadows.value = Te.state.pointShadow, pt.hemisphereLights.value = Te.state.hemi, pt.directionalShadowMap.value = Te.state.directionalShadowMap, pt.directionalShadowMatrix.value = Te.state.directionalShadowMatrix, pt.spotShadowMap.value = Te.state.spotShadowMap, pt.spotLightMatrix.value = Te.state.spotLightMatrix, pt.spotLightMap.value = Te.state.spotLightMap, pt.pointShadowMap.value = Te.state.pointShadowMap, pt.pointShadowMatrix.value = Te.state.pointShadowMatrix); const hn = yt.getUniforms(), Vn = u6.seqWithValue(hn.seq, pt); return he.currentProgram = yt, he.uniformsList = Vn, yt } function vr(H, ae) { const ve = qe.get(H); ve.outputColorSpace = ae.outputColorSpace, ve.instancing = ae.instancing, ve.instancingColor = ae.instancingColor, ve.skinning = ae.skinning, ve.morphTargets = ae.morphTargets, ve.morphNormals = ae.morphNormals, ve.morphColors = ae.morphColors, ve.morphTargetsCount = ae.morphTargetsCount, ve.numClippingPlanes = ae.numClippingPlanes, ve.numIntersection = ae.numClipIntersection, ve.vertexAlphas = ae.vertexAlphas, ve.vertexTangents = ae.vertexTangents, ve.toneMapping = ae.toneMapping } function Fi(H, ae, ve, he, Te) { ae.isScene !== !0 && (ae = je), nt.resetTextureUnits(); const rt = ae.fog, ct = he.isMeshStandardMaterial ? ae.environment : null, Ct = w === null ? x.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : yu, Nt = (he.isMeshStandardMaterial ? xt : it).get(he.envMap || ct), nn = he.vertexColors === !0 && !!ve.attributes.color && ve.attributes.color.itemSize === 4, yt = !!ve.attributes.tangent && (!!he.normalMap || he.anisotropy > 0), pt = !!ve.morphAttributes.position, hn = !!ve.morphAttributes.normal, Vn = !!ve.morphAttributes.color; let oi = wl; he.toneMapped && (w === null || w.isXRRenderTarget === !0) && (oi = x.toneMapping); const Vr = ve.morphAttributes.position || ve.morphAttributes.normal || ve.morphAttributes.color, gn = Vr !== void 0 ? Vr.length : 0, gt = qe.get(he), an = y.state.lights; if (xe === !0 && (Be === !0 || H !== b)) { const os = H === b && he.id === R; ut.setState(he, H, os) } let Lt = !1; he.version === gt.__version ? (gt.needsLights && gt.lightsStateVersion !== an.state.version || gt.outputColorSpace !== Ct || Te.isInstancedMesh && gt.instancing === !1 || !Te.isInstancedMesh && gt.instancing === !0 || Te.isSkinnedMesh && gt.skinning === !1 || !Te.isSkinnedMesh && gt.skinning === !0 || Te.isInstancedMesh && gt.instancingColor === !0 && Te.instanceColor === null || Te.isInstancedMesh && gt.instancingColor === !1 && Te.instanceColor !== null || gt.envMap !== Nt || he.fog === !0 && gt.fog !== rt || gt.numClippingPlanes !== void 0 && (gt.numClippingPlanes !== ut.numPlanes || gt.numIntersection !== ut.numIntersection) || gt.vertexAlphas !== nn || gt.vertexTangents !== yt || gt.morphTargets !== pt || gt.morphNormals !== hn || gt.morphColors !== Vn || gt.toneMapping !== oi || Qe.isWebGL2 === !0 && gt.morphTargetsCount !== gn) && (Lt = !0) : (Lt = !0, gt.__version = he.version); let Xi = gt.currentProgram; Lt === !0 && (Xi = sn(he, ae, Te)); let Rn = !1, $n = !1, go = !1; const Wr = Xi.getUniforms(), ir = gt.uniforms; if (De.useProgram(Xi.program) && (Rn = !0, $n = !0, go = !0), he.id !== R && (R = he.id, $n = !0), Rn || b !== H) { Wr.setValue(K, "projectionMatrix", H.projectionMatrix), Wr.setValue(K, "viewMatrix", H.matrixWorldInverse); const os = Wr.map.cameraPosition; os !== void 0 && os.setValue(K, tt.setFromMatrixPosition(H.matrixWorld)), Qe.logarithmicDepthBuffer && Wr.setValue(K, "logDepthBufFC", 2 / (Math.log(H.far + 1) / Math.LN2)), (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial) && Wr.setValue(K, "isOrthographic", H.isOrthographicCamera === !0), b !== H && (b = H, $n = !0, go = !0) } if (Te.isSkinnedMesh) { Wr.setOptional(K, Te, "bindMatrix"), Wr.setOptional(K, Te, "bindMatrixInverse"); const os = Te.skeleton; os && (Qe.floatVertexTextures ? (os.boneTexture === null && os.computeBoneTexture(), Wr.setValue(K, "boneTexture", os.boneTexture, nt), Wr.setValue(K, "boneTextureSize", os.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } const $o = ve.morphAttributes; if (($o.position !== void 0 || $o.normal !== void 0 || $o.color !== void 0 && Qe.isWebGL2 === !0) && st.update(Te, ve, Xi), ($n || gt.receiveShadow !== Te.receiveShadow) && (gt.receiveShadow = Te.receiveShadow, Wr.setValue(K, "receiveShadow", Te.receiveShadow)), he.isMeshGouraudMaterial && he.envMap !== null && (ir.envMap.value = Nt, ir.flipEnvMap.value = Nt.isCubeTexture && Nt.isRenderTargetTexture === !1 ? -1 : 1), $n && (Wr.setValue(K, "toneMappingExposure", x.toneMappingExposure), gt.needsLights && ur(ir, go), rt && he.fog === !0 && Ne.refreshFogUniforms(ir, rt), Ne.refreshMaterialUniforms(ir, he, $, ne, Fe), u6.upload(K, gt.uniformsList, ir, nt)), he.isShaderMaterial && he.uniformsNeedUpdate === !0 && (u6.upload(K, gt.uniformsList, ir, nt), he.uniformsNeedUpdate = !1), he.isSpriteMaterial && Wr.setValue(K, "center", Te.center), Wr.setValue(K, "modelViewMatrix", Te.modelViewMatrix), Wr.setValue(K, "normalMatrix", Te.normalMatrix), Wr.setValue(K, "modelMatrix", Te.matrixWorld), he.isShaderMaterial || he.isRawShaderMaterial) { const os = he.uniformsGroups; for (let wf = 0, Lu = os.length; wf < Lu; wf++)if (Qe.isWebGL2) { const td = os[wf]; Ie.update(td, Xi), Ie.bind(td, Xi) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return Xi } function ur(H, ae) { H.ambientLightColor.needsUpdate = ae, H.lightProbe.needsUpdate = ae, H.directionalLights.needsUpdate = ae, H.directionalLightShadows.needsUpdate = ae, H.pointLights.needsUpdate = ae, H.pointLightShadows.needsUpdate = ae, H.spotLights.needsUpdate = ae, H.spotLightShadows.needsUpdate = ae, H.rectAreaLights.needsUpdate = ae, H.hemisphereLights.needsUpdate = ae } function rr(H) { return H.isMeshLambertMaterial || H.isMeshToonMaterial || H.isMeshPhongMaterial || H.isMeshStandardMaterial || H.isShadowMaterial || H.isShaderMaterial && H.lights === !0 } this.getActiveCubeFace = function () { return T }, this.getActiveMipmapLevel = function () { return I }, this.getRenderTarget = function () { return w }, this.setRenderTargetTextures = function (H, ae, ve) { qe.get(H.texture).__webglTexture = ae, qe.get(H.depthTexture).__webglTexture = ve; const he = qe.get(H); he.__hasExternalTextures = !0, he.__hasExternalTextures && (he.__autoAllocateDepthBuffer = ve === void 0, he.__autoAllocateDepthBuffer || Ce.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), he.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (H, ae) { const ve = qe.get(H); ve.__webglFramebuffer = ae, ve.__useDefaultFramebuffer = ae === void 0 }, this.setRenderTarget = function (H, ae = 0, ve = 0) { w = H, T = ae, I = ve; let he = !0, Te = null, rt = !1, ct = !1; if (H) { const Nt = qe.get(H); Nt.__useDefaultFramebuffer !== void 0 ? (De.bindFramebuffer(K.FRAMEBUFFER, null), he = !1) : Nt.__webglFramebuffer === void 0 ? nt.setupRenderTarget(H) : Nt.__hasExternalTextures && nt.rebindTextures(H, qe.get(H.texture).__webglTexture, qe.get(H.depthTexture).__webglTexture); const nn = H.texture; (nn.isData3DTexture || nn.isDataArrayTexture || nn.isCompressedArrayTexture) && (ct = !0); const yt = qe.get(H).__webglFramebuffer; H.isWebGLCubeRenderTarget ? (Array.isArray(yt[ae]) ? Te = yt[ae][ve] : Te = yt[ae], rt = !0) : Qe.isWebGL2 && H.samples > 0 && nt.useMultisampledRTT(H) === !1 ? Te = qe.get(H).__webglMultisampledFramebuffer : Array.isArray(yt) ? Te = yt[ve] : Te = yt, B.copy(H.viewport), F.copy(H.scissor), U = H.scissorTest } else B.copy(D).multiplyScalar($).floor(), F.copy(V).multiplyScalar($).floor(), U = J; if (De.bindFramebuffer(K.FRAMEBUFFER, Te) && Qe.drawBuffers && he && De.drawBuffers(H, Te), De.viewport(B), De.scissor(F), De.setScissorTest(U), rt) { const Nt = qe.get(H.texture); K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_CUBE_MAP_POSITIVE_X + ae, Nt.__webglTexture, ve) } else if (ct) { const Nt = qe.get(H.texture), nn = ae || 0; K.framebufferTextureLayer(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, Nt.__webglTexture, ve || 0, nn) } R = -1 }, this.readRenderTargetPixels = function (H, ae, ve, he, Te, rt, ct) { if (!(H && H.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let Ct = qe.get(H).__webglFramebuffer; if (H.isWebGLCubeRenderTarget && ct !== void 0 && (Ct = Ct[ct]), Ct) { De.bindFramebuffer(K.FRAMEBUFFER, Ct); try { const Nt = H.texture, nn = Nt.format, yt = Nt.type; if (nn !== Ri && at.convert(nn) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } const pt = yt === Wi && (Ce.has("EXT_color_buffer_half_float") || Qe.isWebGL2 && Ce.has("EXT_color_buffer_float")); if (yt !== As && at.convert(yt) !== K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) && !(yt === Oa && (Qe.isWebGL2 || Ce.has("OES_texture_float") || Ce.has("WEBGL_color_buffer_float"))) && !pt) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } ae >= 0 && ae <= H.width - he && ve >= 0 && ve <= H.height - Te && K.readPixels(ae, ve, he, Te, at.convert(nn), at.convert(yt), rt) } finally { const Nt = w !== null ? qe.get(w).__webglFramebuffer : null; De.bindFramebuffer(K.FRAMEBUFFER, Nt) } } }, this.copyFramebufferToTexture = function (H, ae, ve = 0) { const he = Math.pow(2, -ve), Te = Math.floor(ae.image.width * he), rt = Math.floor(ae.image.height * he); nt.setTexture2D(ae, 0), K.copyTexSubImage2D(K.TEXTURE_2D, ve, 0, 0, H.x, H.y, Te, rt), De.unbindTexture() }, this.copyTextureToTexture = function (H, ae, ve, he = 0) { const Te = ae.image.width, rt = ae.image.height, ct = at.convert(ve.format), Ct = at.convert(ve.type); nt.setTexture2D(ve, 0), K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, ve.flipY), K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), K.pixelStorei(K.UNPACK_ALIGNMENT, ve.unpackAlignment), ae.isDataTexture ? K.texSubImage2D(K.TEXTURE_2D, he, H.x, H.y, Te, rt, ct, Ct, ae.image.data) : ae.isCompressedTexture ? K.compressedTexSubImage2D(K.TEXTURE_2D, he, H.x, H.y, ae.mipmaps[0].width, ae.mipmaps[0].height, ct, ae.mipmaps[0].data) : K.texSubImage2D(K.TEXTURE_2D, he, H.x, H.y, ct, Ct, ae.image), he === 0 && ve.generateMipmaps && K.generateMipmap(K.TEXTURE_2D), De.unbindTexture() }, this.copyTextureToTexture3D = function (H, ae, ve, he, Te = 0) { if (x.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } const rt = H.max.x - H.min.x + 1, ct = H.max.y - H.min.y + 1, Ct = H.max.z - H.min.z + 1, Nt = at.convert(he.format), nn = at.convert(he.type); let yt; if (he.isData3DTexture) nt.setTexture3D(he, 0), yt = K.TEXTURE_3D; else if (he.isDataArrayTexture) nt.setTexture2DArray(he, 0), yt = K.TEXTURE_2D_ARRAY; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, he.flipY), K.pixelStorei(K.UNPACK_PREMULTIPLY_ALPHA_WEBGL, he.premultiplyAlpha), K.pixelStorei(K.UNPACK_ALIGNMENT, he.unpackAlignment); const pt = K.getParameter(K.UNPACK_ROW_LENGTH), hn = K.getParameter(K.UNPACK_IMAGE_HEIGHT), Vn = K.getParameter(K.UNPACK_SKIP_PIXELS), oi = K.getParameter(K.UNPACK_SKIP_ROWS), Vr = K.getParameter(K.UNPACK_SKIP_IMAGES), gn = ve.isCompressedTexture ? ve.mipmaps[0] : ve.image; K.pixelStorei(K.UNPACK_ROW_LENGTH, gn.width), K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, gn.height), K.pixelStorei(K.UNPACK_SKIP_PIXELS, H.min.x), K.pixelStorei(K.UNPACK_SKIP_ROWS, H.min.y), K.pixelStorei(K.UNPACK_SKIP_IMAGES, H.min.z), ve.isDataTexture || ve.isData3DTexture ? K.texSubImage3D(yt, Te, ae.x, ae.y, ae.z, rt, ct, Ct, Nt, nn, gn.data) : ve.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), K.compressedTexSubImage3D(yt, Te, ae.x, ae.y, ae.z, rt, ct, Ct, Nt, gn.data)) : K.texSubImage3D(yt, Te, ae.x, ae.y, ae.z, rt, ct, Ct, Nt, nn, gn), K.pixelStorei(K.UNPACK_ROW_LENGTH, pt), K.pixelStorei(K.UNPACK_IMAGE_HEIGHT, hn), K.pixelStorei(K.UNPACK_SKIP_PIXELS, Vn), K.pixelStorei(K.UNPACK_SKIP_ROWS, oi), K.pixelStorei(K.UNPACK_SKIP_IMAGES, Vr), Te === 0 && he.generateMipmaps && K.generateMipmap(yt), De.unbindTexture() }, this.initTexture = function (H) { H.isCubeTexture ? nt.setTextureCube(H, 0) : H.isData3DTexture ? nt.setTexture3D(H, 0) : H.isDataArrayTexture || H.isCompressedArrayTexture ? nt.setTexture2DArray(H, 0) : nt.setTexture2D(H, 0), De.unbindTexture() }, this.resetState = function () { T = 0, I = 0, w = null, De.reset(), ee.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } get coordinateSystem() { return Zu } get physicallyCorrectLights() { return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights } set physicallyCorrectLights(e) { console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e } get outputEncoding() { return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Ur ? Ch : kS } set outputEncoding(e) { console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Ch ? Ur : yu } get useLegacyLights() { return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights } set useLegacyLights(e) { console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e } } class GO extends XS { } GO.prototype.isWebGL1Renderer = !0; class d8 { constructor(e, t = 25e-5) { this.isFogExp2 = !0, this.name = "", this.color = new Je(e), this.density = t } clone() { return new d8(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } class p8 { constructor(e, t = 1, r = 1e3) { this.isFog = !0, this.name = "", this.color = new Je(e), this.near = t, this.far = r } clone() { return new p8(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } class uy extends Hn { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t } } class F1 { constructor(e, t) { this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = s1, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Qo() } onUploadCallback() { } set needsUpdate(e) { e === !0 && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, r) { e *= this.stride, r *= t.stride; for (let i = 0, s = this.stride; i < s; i++)this.array[e + i] = t.array[r + i]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Qo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride); return r.setUsage(this.usage), r } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Qo()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } const Ia = new N; class kh { constructor(e, t, r, i = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, r = this.data.count; t < r; t++)Ia.fromBufferAttribute(this, t), Ia.applyMatrix4(e), this.setXYZ(t, Ia.x, Ia.y, Ia.z); return this } applyNormalMatrix(e) { for (let t = 0, r = this.count; t < r; t++)Ia.fromBufferAttribute(this, t), Ia.applyNormalMatrix(e), this.setXYZ(t, Ia.x, Ia.y, Ia.z); return this } transformDirection(e) { for (let t = 0, r = this.count; t < r; t++)Ia.fromBufferAttribute(this, t), Ia.transformDirection(e), this.setXYZ(t, Ia.x, Ia.y, Ia.z); return this } setX(e, t) { return this.normalized && (t = Sn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.normalized && (t = Sn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.normalized && (t = Sn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.normalized && (t = Sn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { let t = this.data.array[e * this.data.stride + this.offset]; return this.normalized && (t = ro(t, this.array)), t } getY(e) { let t = this.data.array[e * this.data.stride + this.offset + 1]; return this.normalized && (t = ro(t, this.array)), t } getZ(e) { let t = this.data.array[e * this.data.stride + this.offset + 2]; return this.normalized && (t = ro(t, this.array)), t } getW(e) { let t = this.data.array[e * this.data.stride + this.offset + 3]; return this.normalized && (t = ro(t, this.array)), t } setXY(e, t, r) { return e = e * this.data.stride + this.offset, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this } setXYZ(e, t, r, i) { return e = e * this.data.stride + this.offset, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this } setXYZW(e, t, r, i, s) { return e = e * this.data.stride + this.offset, this.normalized && (t = Sn(t, this.array), r = Sn(r, this.array), i = Sn(i, this.array), s = Sn(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this } clone(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[i + s]) } return new lr(new this.array.constructor(t), this.itemSize, this.normalized) } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new kh(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (e === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); const t = []; for (let r = 0; r < this.count; r++) { const i = r * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)t.push(this.data.array[i + s]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } class YS extends as { constructor(e) { super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } let w0; const tg = new N, I0 = new N, M0 = new N, b0 = new Se, ng = new Se, QO = new bt, zv = new N, rg = new N, Vv = new N, zb = new Se, Kx = new Se, Vb = new Se; class HO extends Hn { constructor(e) { if (super(), this.isSprite = !0, this.type = "Sprite", w0 === void 0) { w0 = new pn; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), r = new F1(t, 5); w0.setIndex([0, 1, 2, 0, 2, 3]), w0.setAttribute("position", new kh(r, 3, 0, !1)), w0.setAttribute("uv", new kh(r, 2, 3, !1)) } this.geometry = w0, this.material = e !== void 0 ? e : new YS, this.center = new Se(.5, .5) } raycast(e, t) { e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), I0.setFromMatrixScale(this.matrixWorld), QO.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), M0.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && I0.multiplyScalar(-M0.z); const r = this.material.rotation; let i, s; r !== 0 && (s = Math.cos(r), i = Math.sin(r)); const a = this.center; Wv(zv.set(-.5, -.5, 0), M0, a, I0, i, s), Wv(rg.set(.5, -.5, 0), M0, a, I0, i, s), Wv(Vv.set(.5, .5, 0), M0, a, I0, i, s), zb.set(0, 0), Kx.set(1, 0), Vb.set(1, 1); let o = e.ray.intersectTriangle(zv, rg, Vv, !1, tg); if (o === null && (Wv(rg.set(-.5, .5, 0), M0, a, I0, i, s), Kx.set(0, 1), o = e.ray.intersectTriangle(zv, Vv, rg, !1, tg), o === null)) return; const l = e.ray.origin.distanceTo(tg); l < e.near || l > e.far || t.push({ distance: l, point: tg.clone(), uv: to.getInterpolation(tg, zv, rg, Vv, zb, Kx, Vb, new Se), face: null, object: this }) } copy(e, t) { return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this } } function Wv(n, e, t, r, i, s) { b0.subVectors(n, t).addScalar(.5).multiply(r), i !== void 0 ? (ng.x = s * b0.x - i * b0.y, ng.y = i * b0.x + s * b0.y) : ng.copy(b0), n.copy(e), n.x += ng.x, n.y += ng.y, n.applyMatrix4(QO) } const Xv = new N, Wb = new N; class zO extends Hn { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let r = 0, i = t.length; r < i; r++) { const s = t[r]; this.addLevel(s.object.clone(), s.distance, s.hysteresis) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0, r = 0) { t = Math.abs(t); const i = this.levels; let s; for (s = 0; s < i.length && !(t < i[s].distance); s++); return i.splice(s, 0, { distance: t, hysteresis: r, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let r, i; for (r = 1, i = t.length; r < i; r++) { let s = t[r].distance; if (t[r].object.visible && (s -= s * t[r].hysteresis), e < s) break } return t[r - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { Xv.setFromMatrixPosition(this.matrixWorld); const i = e.ray.origin.distanceTo(Xv); this.getObjectForDistance(i).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { Xv.setFromMatrixPosition(e.matrixWorld), Wb.setFromMatrixPosition(this.matrixWorld); const r = Xv.distanceTo(Wb) / e.zoom; t[0].object.visible = !0; let i, s; for (i = 1, s = t.length; i < s; i++) { let a = t[i].distance; if (t[i].object.visible && (a -= a * t[i].hysteresis), r >= a) t[i - 1].object.visible = !1, t[i].object.visible = !0; else break } for (this._currentLevel = i - 1; i < s; i++)t[i].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = []; const r = this.levels; for (let i = 0, s = r.length; i < s; i++) { const a = r[i]; t.object.levels.push({ object: a.object.uuid, distance: a.distance, hysteresis: a.hysteresis }) } return t } } const Xb = new N, Yb = new Jn, jb = new Jn, ate = new N, Jb = new bt, B0 = new N, qx = new kl, Kb = new bt, Zx = new Op; class jS extends gr { constructor(e, t) { super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new bt, this.bindMatrixInverse = new bt, this.boundingBox = null, this.boundingSphere = null } computeBoundingBox() { const e = this.geometry; this.boundingBox === null && (this.boundingBox = new Tu), this.boundingBox.makeEmpty(); const t = e.getAttribute("position"); for (let r = 0; r < t.count; r++)B0.fromBufferAttribute(t, r), this.applyBoneTransform(r, B0), this.boundingBox.expandByPoint(B0) } computeBoundingSphere() { const e = this.geometry; this.boundingSphere === null && (this.boundingSphere = new kl), this.boundingSphere.makeEmpty(); const t = e.getAttribute("position"); for (let r = 0; r < t.count; r++)B0.fromBufferAttribute(t, r), this.applyBoneTransform(r, B0), this.boundingSphere.expandByPoint(B0) } copy(e, t) { return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } raycast(e, t) { const r = this.material, i = this.matrixWorld; r !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), qx.copy(this.boundingSphere), qx.applyMatrix4(i), e.ray.intersectsSphere(qx) !== !1 && (Kb.copy(i).invert(), Zx.copy(e.ray).applyMatrix4(Kb), !(this.boundingBox !== null && Zx.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Zx))) } getVertexPosition(e, t) { return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t } bind(e, t) { this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Jn, t = this.geometry.attributes.skinWeight; for (let r = 0, i = t.count; r < i; r++) { e.fromBufferAttribute(t, r); const s = 1 / e.manhattanLength(); s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } applyBoneTransform(e, t) { const r = this.skeleton, i = this.geometry; Yb.fromBufferAttribute(i.attributes.skinIndex, e), jb.fromBufferAttribute(i.attributes.skinWeight, e), Xb.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let s = 0; s < 4; s++) { const a = jb.getComponent(s); if (a !== 0) { const o = Yb.getComponent(s); Jb.multiplyMatrices(r.bones[o].matrixWorld, r.boneInverses[o]), t.addScaledVector(ate.copy(Xb).applyMatrix4(Jb), a) } } return t.applyMatrix4(this.bindMatrixInverse) } boneTransform(e, t) { return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t) } } class m8 extends Hn { constructor() { super(), this.isBone = !0, this.type = "Bone" } } class ac extends ri { constructor(e = null, t = 1, r = 1, i, s, a, o, l, u = cn, c = cn, h, d) { super(null, a, o, l, u, c, i, s, h, d), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } const qb = new bt, ote = new bt; class k1 { constructor(e = [], t = []) { this.uuid = Qo(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let r = 0, i = this.bones.length; r < i; r++)this.boneInverses.push(new bt) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const r = new bt; this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && r.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale)) } } update() { const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture; for (let s = 0, a = e.length; s < a; s++) { const o = e[s] ? e[s].matrixWorld : ote; qb.multiplyMatrices(o, t[s]), qb.toArray(r, s * 16) } i !== null && (i.needsUpdate = !0) } clone() { return new k1(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(this.bones.length * 4); e = IO(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const r = new ac(t, e, e, Ri, Oa); return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, r = this.bones.length; t < r; t++) { const i = this.bones[t]; if (i.name === e) return i } } dispose() { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let r = 0, i = e.bones.length; r < i; r++) { const s = e.bones[r]; let a = t[s]; a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new m8), this.bones.push(a), this.boneInverses.push(new bt().fromArray(e.boneInverses[r])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, r = this.boneInverses; for (let i = 0, s = t.length; i < s; i++) { const a = t[i]; e.bones.push(a.uuid); const o = r[i]; e.boneInverses.push(o.toArray()) } return e } } class tm extends lr { constructor(e, t, r, i = 1) { super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } const R0 = new bt, Zb = new bt, Yv = [], $b = new Tu, lte = new bt, ig = new gr, sg = new kl; class JS extends gr { constructor(e, t, r) { super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new tm(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.boundingBox = null, this.boundingSphere = null; for (let i = 0; i < r; i++)this.setMatrixAt(i, lte) } computeBoundingBox() { const e = this.geometry, t = this.count; this.boundingBox === null && (this.boundingBox = new Tu), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty(); for (let r = 0; r < t; r++)this.getMatrixAt(r, R0), $b.copy(e.boundingBox).applyMatrix4(R0), this.boundingBox.union($b) } computeBoundingSphere() { const e = this.geometry, t = this.count; this.boundingSphere === null && (this.boundingSphere = new kl), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty(); for (let r = 0; r < t; r++)this.getMatrixAt(r, R0), sg.copy(e.boundingSphere).applyMatrix4(R0), this.boundingSphere.union(sg) } copy(e, t) { return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, e * 3) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, e * 16) } raycast(e, t) { const r = this.matrixWorld, i = this.count; if (ig.geometry = this.geometry, ig.material = this.material, ig.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), sg.copy(this.boundingSphere), sg.applyMatrix4(r), e.ray.intersectsSphere(sg) !== !1)) for (let s = 0; s < i; s++) { this.getMatrixAt(s, R0), Zb.multiplyMatrices(r, R0), ig.matrixWorld = Zb, ig.raycast(e, Yv); for (let a = 0, o = Yv.length; a < o; a++) { const l = Yv[a]; l.instanceId = s, l.object = this, t.push(l) } Yv.length = 0 } } setColorAt(e, t) { this.instanceColor === null && (this.instanceColor = new tm(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, e * 16) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } class Aa extends as { constructor(e) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Je(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this } } const eB = new N, tB = new N, nB = new bt, $x = new Op, jv = new kl; class Af extends Hn { constructor(e = new pn, t = new Aa) { super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, r = [0]; for (let i = 1, s = t.count; i < s; i++)eB.fromBufferAttribute(t, i - 1), tB.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += eB.distanceTo(tB); e.setAttribute("lineDistance", new Pt(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast(e, t) { const r = this.geometry, i = this.matrixWorld, s = e.params.Line.threshold, a = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), jv.copy(r.boundingSphere), jv.applyMatrix4(i), jv.radius += s, e.ray.intersectsSphere(jv) === !1) return; nB.copy(i).invert(), $x.copy(e.ray).applyMatrix4(nB); const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, u = new N, c = new N, h = new N, d = new N, m = this.isLineSegments ? 2 : 1, g = r.index, y = r.attributes.position; if (g !== null) { const A = Math.max(0, a.start), _ = Math.min(g.count, a.start + a.count); for (let x = A, C = _ - 1; x < C; x += m) { const T = g.getX(x), I = g.getX(x + 1); if (u.fromBufferAttribute(y, T), c.fromBufferAttribute(y, I), $x.distanceSqToSegment(u, c, d, h) > l) continue; d.applyMatrix4(this.matrixWorld); const R = e.ray.origin.distanceTo(d); R < e.near || R > e.far || t.push({ distance: R, point: h.clone().applyMatrix4(this.matrixWorld), index: x, face: null, faceIndex: null, object: this }) } } else { const A = Math.max(0, a.start), _ = Math.min(y.count, a.start + a.count); for (let x = A, C = _ - 1; x < C; x += m) { if (u.fromBufferAttribute(y, x), c.fromBufferAttribute(y, x + 1), $x.distanceSqToSegment(u, c, d, h) > l) continue; d.applyMatrix4(this.matrixWorld); const I = e.ray.origin.distanceTo(d); I < e.near || I > e.far || t.push({ distance: I, point: h.clone().applyMatrix4(this.matrixWorld), index: x, face: null, faceIndex: null, object: this }) } } } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, a = i.length; s < a; s++) { const o = i[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s } } } } } const rB = new N, iB = new N; class wu extends Af { constructor(e, t) { super(e, t), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.index === null) { const t = e.attributes.position, r = []; for (let i = 0, s = t.count; i < s; i += 2)rB.fromBufferAttribute(t, i), iB.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + rB.distanceTo(iB); e.setAttribute("lineDistance", new Pt(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } } class KS extends Af { constructor(e, t) { super(e, t), this.isLineLoop = !0, this.type = "LineLoop" } } class N1 extends as { constructor(e) { super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Je(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this } } const sB = new bt, u7 = new Op, Jv = new kl, Kv = new N; let g8 = class extends Hn { constructor(e = new pn, t = new N1) { super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e, t) { return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this } raycast(e, t) { const r = this.geometry, i = this.matrixWorld, s = e.params.Points.threshold, a = r.drawRange; if (r.boundingSphere === null && r.computeBoundingSphere(), Jv.copy(r.boundingSphere), Jv.applyMatrix4(i), Jv.radius += s, e.ray.intersectsSphere(Jv) === !1) return; sB.copy(i).invert(), u7.copy(e.ray).applyMatrix4(sB); const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, u = r.index, h = r.attributes.position; if (u !== null) { const d = Math.max(0, a.start), m = Math.min(u.count, a.start + a.count); for (let g = d, v = m; g < v; g++) { const y = u.getX(g); Kv.fromBufferAttribute(h, y), aB(Kv, y, l, i, e, t, this) } } else { const d = Math.max(0, a.start), m = Math.min(h.count, a.start + a.count); for (let g = d, v = m; g < v; g++)Kv.fromBufferAttribute(h, g), aB(Kv, g, l, i, e, t, this) } } updateMorphTargets() { const t = this.geometry.morphAttributes, r = Object.keys(t); if (r.length > 0) { const i = t[r[0]]; if (i !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, a = i.length; s < a; s++) { const o = i[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s } } } } }; function aB(n, e, t, r, i, s, a) { const o = u7.distanceSqToPoint(n); if (o < t) { const l = new N; u7.closestPointToPoint(n, l), l.applyMatrix4(r); const u = i.ray.origin.distanceTo(l); if (u < i.near || u > i.far) return; s.push({ distance: u, distanceToRay: Math.sqrt(o), point: l, index: e, face: null, object: a }) } } class ute extends ri { constructor(e, t, r, i, s, a, o, l, u) { super(e, t, r, i, s, a, o, l, u), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : wr, this.magFilter = s !== void 0 ? s : wr, this.generateMipmaps = !1; const c = this; function h() { c.needsUpdate = !0, e.requestVideoFrameCallback(h) } "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class cte extends ri { constructor(e, t) { super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = cn, this.minFilter = cn, this.generateMipmaps = !1, this.needsUpdate = !0 } } class Nh extends ri { constructor(e, t, r, i, s, a, o, l, u, c, h, d) { super(null, a, o, l, u, c, i, s, h, d), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } let fte = class extends Nh { constructor(e, t, r, i, s, a) { super(e, t, r, s, a), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = pi } }; class hte extends Nh { constructor(e, t, r) { super(void 0, e[0].width, e[0].height, t, r, gf), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e } } class dte extends ri { constructor(e, t, r, i, s, a, o, l, u) { super(e, t, r, i, s, a, o, l, u), this.isCanvasTexture = !0, this.needsUpdate = !0 } } class Iu { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const r = this.getUtoTmapping(e); return this.getPoint(r, t) } getPoints(e = 5) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPoint(r / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPointAt(r / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let r, i = this.getPoint(0), s = 0; t.push(0); for (let a = 1; a <= e; a++)r = this.getPoint(a / e), s += r.distanceTo(i), t.push(s), i = r; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const r = this.getLengths(); let i = 0; const s = r.length; let a; t ? a = t : a = e * r[s - 1]; let o = 0, l = s - 1, u; for (; o <= l;)if (i = Math.floor(o + (l - o) / 2), u = r[i] - a, u < 0) o = i + 1; else if (u > 0) l = i - 1; else { l = i; break } if (i = l, r[i] === a) return i / (s - 1); const c = r[i], d = r[i + 1] - c, m = (a - c) / d; return (i + m) / (s - 1) } getTangent(e, t) { let i = e - 1e-4, s = e + 1e-4; i < 0 && (i = 0), s > 1 && (s = 1); const a = this.getPoint(i), o = this.getPoint(s), l = t || (a.isVector2 ? new Se : new N); return l.copy(o).sub(a).normalize(), l } getTangentAt(e, t) { const r = this.getUtoTmapping(e); return this.getTangent(r, t) } computeFrenetFrames(e, t) { const r = new N, i = [], s = [], a = [], o = new N, l = new bt; for (let m = 0; m <= e; m++) { const g = m / e; i[m] = this.getTangentAt(g, new N) } s[0] = new N, a[0] = new N; let u = Number.MAX_VALUE; const c = Math.abs(i[0].x), h = Math.abs(i[0].y), d = Math.abs(i[0].z); c <= u && (u = c, r.set(1, 0, 0)), h <= u && (u = h, r.set(0, 1, 0)), d <= u && r.set(0, 0, 1), o.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], o), a[0].crossVectors(i[0], s[0]); for (let m = 1; m <= e; m++) { if (s[m] = s[m - 1].clone(), a[m] = a[m - 1].clone(), o.crossVectors(i[m - 1], i[m]), o.length() > Number.EPSILON) { o.normalize(); const g = Math.acos(bi(i[m - 1].dot(i[m]), -1, 1)); s[m].applyMatrix4(l.makeRotationAxis(o, g)) } a[m].crossVectors(i[m], s[m]) } if (t === !0) { let m = Math.acos(bi(s[0].dot(s[e]), -1, 1)); m /= e, i[0].dot(o.crossVectors(s[0], s[e])) > 0 && (m = -m); for (let g = 1; g <= e; g++)s[g].applyMatrix4(l.makeRotationAxis(i[g], m * g)), a[g].crossVectors(i[g], s[g]) } return { tangents: i, normals: s, binormals: a } } clone() { return new this.constructor().copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class A8 extends Iu { constructor(e = 0, t = 0, r = 1, i = 1, s = 0, a = Math.PI * 2, o = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l } getPoint(e, t) { const r = t || new Se, i = Math.PI * 2; let s = this.aEndAngle - this.aStartAngle; const a = Math.abs(s) < Number.EPSILON; for (; s < 0;)s += i; for (; s > i;)s -= i; s < Number.EPSILON && (a ? s = 0 : s = i), this.aClockwise === !0 && !a && (s === i ? s = -i : s = s - i); const o = this.aStartAngle + e * s; let l = this.aX + this.xRadius * Math.cos(o), u = this.aY + this.yRadius * Math.sin(o); if (this.aRotation !== 0) { const c = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, m = u - this.aY; l = d * c - m * h + this.aX, u = d * h + m * c + this.aY } return r.set(l, u) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } class VO extends A8 { constructor(e, t, r, i, s, a) { super(e, t, r, r, i, s, a), this.isArcCurve = !0, this.type = "ArcCurve" } } function qS() { let n = 0, e = 0, t = 0, r = 0; function i(s, a, o, l) { n = s, e = o, t = -3 * s + 3 * a - 2 * o - l, r = 2 * s - 2 * a + o + l } return { initCatmullRom: function (s, a, o, l, u) { i(a, o, u * (o - s), u * (l - a)) }, initNonuniformCatmullRom: function (s, a, o, l, u, c, h) { let d = (a - s) / u - (o - s) / (u + c) + (o - a) / c, m = (o - a) / c - (l - a) / (c + h) + (l - o) / h; d *= c, m *= c, i(a, o, d, m) }, calc: function (s) { const a = s * s, o = a * s; return n + e * s + t * a + r * o } } } const qv = new N, e_ = new qS, t_ = new qS, n_ = new qS; class WO extends Iu { constructor(e = [], t = !1, r = "centripetal", i = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i } getPoint(e, t = new N) { const r = t, i = this.points, s = i.length, a = (s - (this.closed ? 0 : 1)) * e; let o = Math.floor(a), l = a - o; this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : l === 0 && o === s - 1 && (o = s - 2, l = 1); let u, c; this.closed || o > 0 ? u = i[(o - 1) % s] : (qv.subVectors(i[0], i[1]).add(i[0]), u = qv); const h = i[o % s], d = i[(o + 1) % s]; if (this.closed || o + 2 < s ? c = i[(o + 2) % s] : (qv.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), c = qv), this.curveType === "centripetal" || this.curveType === "chordal") { const m = this.curveType === "chordal" ? .5 : .25; let g = Math.pow(u.distanceToSquared(h), m), v = Math.pow(h.distanceToSquared(d), m), y = Math.pow(d.distanceToSquared(c), m); v < 1e-4 && (v = 1), g < 1e-4 && (g = v), y < 1e-4 && (y = v), e_.initNonuniformCatmullRom(u.x, h.x, d.x, c.x, g, v, y), t_.initNonuniformCatmullRom(u.y, h.y, d.y, c.y, g, v, y), n_.initNonuniformCatmullRom(u.z, h.z, d.z, c.z, g, v, y) } else this.curveType === "catmullrom" && (e_.initCatmullRom(u.x, h.x, d.x, c.x, this.tension), t_.initCatmullRom(u.y, h.y, d.y, c.y, this.tension), n_.initCatmullRom(u.z, h.z, d.z, c.z, this.tension)); return r.set(e_.calc(l), t_.calc(l), n_.calc(l)), r } copy(e) { super.copy(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, r = this.points.length; t < r; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(new N().fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function oB(n, e, t, r, i) { const s = (r - e) * .5, a = (i - t) * .5, o = n * n, l = n * o; return (2 * t - 2 * r + s + a) * l + (-3 * t + 3 * r - 2 * s - a) * o + s * n + t } function pte(n, e) { const t = 1 - n; return t * t * e } function mte(n, e) { return 2 * (1 - n) * n * e } function gte(n, e) { return n * n * e } function lA(n, e, t, r) { return pte(n, e) + mte(n, t) + gte(n, r) } function Ate(n, e) { const t = 1 - n; return t * t * t * e } function vte(n, e) { const t = 1 - n; return 3 * t * t * n * e } function yte(n, e) { return 3 * (1 - n) * n * n * e } function xte(n, e) { return n * n * n * e } function uA(n, e, t, r, i) { return Ate(n, e) + vte(n, t) + yte(n, r) + xte(n, i) } class ZS extends Iu { constructor(e = new Se, t = new Se, r = new Se, i = new Se) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i } getPoint(e, t = new Se) { const r = t, i = this.v0, s = this.v1, a = this.v2, o = this.v3; return r.set(uA(e, i.x, s.x, a.x, o.x), uA(e, i.y, s.y, a.y, o.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class XO extends Iu { constructor(e = new N, t = new N, r = new N, i = new N) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i } getPoint(e, t = new N) { const r = t, i = this.v0, s = this.v1, a = this.v2, o = this.v3; return r.set(uA(e, i.x, s.x, a.x, o.x), uA(e, i.y, s.y, a.y, o.y), uA(e, i.z, s.z, a.z, o.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class v8 extends Iu { constructor(e = new Se, t = new Se) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new Se) { const r = t; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new Se) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class YO extends Iu { constructor(e = new N, t = new N) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t } getPoint(e, t = new N) { const r = t; return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t = new N) { return t.subVectors(this.v2, this.v1).normalize() } getTangentAt(e, t) { return this.getTangent(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class $S extends Iu { constructor(e = new Se, t = new Se, r = new Se) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r } getPoint(e, t = new Se) { const r = t, i = this.v0, s = this.v1, a = this.v2; return r.set(lA(e, i.x, s.x, a.x), lA(e, i.y, s.y, a.y)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class eT extends Iu { constructor(e = new N, t = new N, r = new N) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r } getPoint(e, t = new N) { const r = t, i = this.v0, s = this.v1, a = this.v2; return r.set(lA(e, i.x, s.x, a.x), lA(e, i.y, s.y, a.y), lA(e, i.z, s.z, a.z)), r } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class tT extends Iu { constructor(e = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e } getPoint(e, t = new Se) { const r = t, i = this.points, s = (i.length - 1) * e, a = Math.floor(s), o = s - a, l = i[a === 0 ? a : a - 1], u = i[a], c = i[a > i.length - 2 ? i.length - 1 : a + 1], h = i[a > i.length - 3 ? i.length - 1 : a + 2]; return r.set(oB(o, l.x, u.x, c.x, h.x), oB(o, l.y, u.y, c.y, h.y)), r } copy(e) { super.copy(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, r = this.points.length; t < r; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, r = e.points.length; t < r; t++) { const i = e.points[t]; this.points.push(new Se().fromArray(i)) } return this } } var nT = Object.freeze({ __proto__: null, ArcCurve: VO, CatmullRomCurve3: WO, CubicBezierCurve: ZS, CubicBezierCurve3: XO, EllipseCurve: A8, LineCurve: v8, LineCurve3: YO, QuadraticBezierCurve: $S, QuadraticBezierCurve3: eT, SplineCurve: tT }); class jO extends Iu { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new v8(t, e)) } getPoint(e, t) { const r = e * this.getLength(), i = this.getCurveLengths(); let s = 0; for (; s < i.length;) { if (i[s] >= r) { const a = i[s] - r, o = this.curves[s], l = o.getLength(), u = l === 0 ? 0 : 1 - a / l; return o.getPointAt(u, t) } s++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let r = 0, i = this.curves.length; r < i; r++)t += this.curves[r].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let r = 0; r <= e; r++)t.push(this.getPoint(r / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let r; for (let i = 0, s = this.curves; i < s.length; i++) { const a = s[i], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o); for (let u = 0; u < l.length; u++) { const c = l[u]; r && r.equals(c) || (t.push(c), r = c) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, r = e.curves.length; t < r; t++) { const i = e.curves[t]; this.curves.push(i.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, r = this.curves.length; t < r; t++) { const i = this.curves[t]; e.curves.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, r = e.curves.length; t < r; t++) { const i = e.curves[t]; this.curves.push(new nT[i.type]().fromJSON(i)) } return this } } let l1 = class extends jO { constructor(e) { super(), this.type = "Path", this.currentPoint = new Se, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, r = e.length; t < r; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const r = new v8(this.currentPoint.clone(), new Se(e, t)); return this.curves.push(r), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, r, i) { const s = new $S(this.currentPoint.clone(), new Se(e, t), new Se(r, i)); return this.curves.push(s), this.currentPoint.set(r, i), this } bezierCurveTo(e, t, r, i, s, a) { const o = new ZS(this.currentPoint.clone(), new Se(e, t), new Se(r, i), new Se(s, a)); return this.curves.push(o), this.currentPoint.set(s, a), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), r = new tT(t); return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, r, i, s, a) { const o = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(e + o, t + l, r, i, s, a), this } absarc(e, t, r, i, s, a) { return this.absellipse(e, t, r, r, i, s, a), this } ellipse(e, t, r, i, s, a, o, l) { const u = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + u, t + c, r, i, s, a, o, l), this } absellipse(e, t, r, i, s, a, o, l) { const u = new A8(e, t, r, i, s, a, o, l); if (this.curves.length > 0) { const h = u.getPoint(0); h.equals(this.currentPoint) || this.lineTo(h.x, h.y) } this.curves.push(u); const c = u.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } }; class O1 extends pn { constructor(e = [new Se(0, -.5), new Se(.5, 0), new Se(0, .5)], t = 12, r = 0, i = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }, t = Math.floor(t), i = bi(i, 0, Math.PI * 2); const s = [], a = [], o = [], l = [], u = [], c = 1 / t, h = new N, d = new Se, m = new N, g = new N, v = new N; let y = 0, A = 0; for (let _ = 0; _ <= e.length - 1; _++)switch (_) { case 0: y = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -y, m.z = A * 0, v.copy(m), m.normalize(), l.push(m.x, m.y, m.z); break; case e.length - 1: l.push(v.x, v.y, v.z); break; default: y = e[_ + 1].x - e[_].x, A = e[_ + 1].y - e[_].y, m.x = A * 1, m.y = -y, m.z = A * 0, g.copy(m), m.x += v.x, m.y += v.y, m.z += v.z, m.normalize(), l.push(m.x, m.y, m.z), v.copy(g) }for (let _ = 0; _ <= t; _++) { const x = r + _ * c * i, C = Math.sin(x), T = Math.cos(x); for (let I = 0; I <= e.length - 1; I++) { h.x = e[I].x * C, h.y = e[I].y, h.z = e[I].x * T, a.push(h.x, h.y, h.z), d.x = _ / t, d.y = I / (e.length - 1), o.push(d.x, d.y); const w = l[3 * I + 0] * C, R = l[3 * I + 1], b = l[3 * I + 0] * T; u.push(w, R, b) } } for (let _ = 0; _ < t; _++)for (let x = 0; x < e.length - 1; x++) { const C = x + _ * e.length, T = C, I = C + e.length, w = C + e.length + 1, R = C + 1; s.push(T, I, R), s.push(w, R, I) } this.setIndex(s), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("uv", new Pt(o, 2)), this.setAttribute("normal", new Pt(u, 3)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new O1(e.points, e.segments, e.phiStart, e.phiLength) } } class y8 extends O1 { constructor(e = 1, t = 1, r = 4, i = 8) { const s = new l1; s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: r, radialSegments: i } } static fromJSON(e) { return new y8(e.radius, e.length, e.capSegments, e.radialSegments) } } class x8 extends pn { constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: r, thetaLength: i }, t = Math.max(3, t); const s = [], a = [], o = [], l = [], u = new N, c = new Se; a.push(0, 0, 0), o.push(0, 0, 1), l.push(.5, .5); for (let h = 0, d = 3; h <= t; h++, d += 3) { const m = r + h / t * i; u.x = e * Math.cos(m), u.y = e * Math.sin(m), a.push(u.x, u.y, u.z), o.push(0, 0, 1), c.x = (a[d] / e + 1) / 2, c.y = (a[d + 1] / e + 1) / 2, l.push(c.x, c.y) } for (let h = 1; h <= t; h++)s.push(h, h + 1, 0); this.setIndex(s), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("normal", new Pt(o, 3)), this.setAttribute("uv", new Pt(l, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new x8(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class _m extends pn { constructor(e = 1, t = 1, r = 1, i = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: r, radialSegments: i, heightSegments: s, openEnded: a, thetaStart: o, thetaLength: l }; const u = this; i = Math.floor(i), s = Math.floor(s); const c = [], h = [], d = [], m = []; let g = 0; const v = [], y = r / 2; let A = 0; _(), a === !1 && (e > 0 && x(!0), t > 0 && x(!1)), this.setIndex(c), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(m, 2)); function _() { const C = new N, T = new N; let I = 0; const w = (t - e) / r; for (let R = 0; R <= s; R++) { const b = [], B = R / s, F = B * (t - e) + e; for (let U = 0; U <= i; U++) { const G = U / i, Y = G * l + o, Z = Math.sin(Y), ne = Math.cos(Y); T.x = F * Z, T.y = -B * r + y, T.z = F * ne, h.push(T.x, T.y, T.z), C.set(Z, w, ne).normalize(), d.push(C.x, C.y, C.z), m.push(G, 1 - B), b.push(g++) } v.push(b) } for (let R = 0; R < i; R++)for (let b = 0; b < s; b++) { const B = v[b][R], F = v[b + 1][R], U = v[b + 1][R + 1], G = v[b][R + 1]; c.push(B, F, G), c.push(F, U, G), I += 6 } u.addGroup(A, I, 0), A += I } function x(C) { const T = g, I = new Se, w = new N; let R = 0; const b = C === !0 ? e : t, B = C === !0 ? 1 : -1; for (let U = 1; U <= i; U++)h.push(0, y * B, 0), d.push(0, B, 0), m.push(.5, .5), g++; const F = g; for (let U = 0; U <= i; U++) { const Y = U / i * l + o, Z = Math.cos(Y), ne = Math.sin(Y); w.x = b * ne, w.y = y * B, w.z = b * Z, h.push(w.x, w.y, w.z), d.push(0, B, 0), I.x = Z * .5 + .5, I.y = ne * .5 * B + .5, m.push(I.x, I.y), g++ } for (let U = 0; U < i; U++) { const G = T + U, Y = F + U; C === !0 ? c.push(Y, Y + 1, G) : c.push(Y + 1, Y, G), R += 3 } u.addGroup(A, R, C === !0 ? 1 : 2), A += R } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new _m(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class _8 extends _m { constructor(e = 1, t = 1, r = 32, i = 1, s = !1, a = 0, o = Math.PI * 2) { super(0, e, t, r, i, s, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: r, heightSegments: i, openEnded: s, thetaStart: a, thetaLength: o } } static fromJSON(e) { return new _8(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Jh extends pn { constructor(e = [], t = [], r = 1, i = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: r, detail: i }; const s = [], a = []; o(i), u(r), c(), this.setAttribute("position", new Pt(s, 3)), this.setAttribute("normal", new Pt(s.slice(), 3)), this.setAttribute("uv", new Pt(a, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function o(_) { const x = new N, C = new N, T = new N; for (let I = 0; I < t.length; I += 3)m(t[I + 0], x), m(t[I + 1], C), m(t[I + 2], T), l(x, C, T, _) } function l(_, x, C, T) { const I = T + 1, w = []; for (let R = 0; R <= I; R++) { w[R] = []; const b = _.clone().lerp(C, R / I), B = x.clone().lerp(C, R / I), F = I - R; for (let U = 0; U <= F; U++)U === 0 && R === I ? w[R][U] = b : w[R][U] = b.clone().lerp(B, U / F) } for (let R = 0; R < I; R++)for (let b = 0; b < 2 * (I - R) - 1; b++) { const B = Math.floor(b / 2); b % 2 === 0 ? (d(w[R][B + 1]), d(w[R + 1][B]), d(w[R][B])) : (d(w[R][B + 1]), d(w[R + 1][B + 1]), d(w[R + 1][B])) } } function u(_) { const x = new N; for (let C = 0; C < s.length; C += 3)x.x = s[C + 0], x.y = s[C + 1], x.z = s[C + 2], x.normalize().multiplyScalar(_), s[C + 0] = x.x, s[C + 1] = x.y, s[C + 2] = x.z } function c() { const _ = new N; for (let x = 0; x < s.length; x += 3) { _.x = s[x + 0], _.y = s[x + 1], _.z = s[x + 2]; const C = y(_) / 2 / Math.PI + .5, T = A(_) / Math.PI + .5; a.push(C, 1 - T) } g(), h() } function h() { for (let _ = 0; _ < a.length; _ += 6) { const x = a[_ + 0], C = a[_ + 2], T = a[_ + 4], I = Math.max(x, C, T), w = Math.min(x, C, T); I > .9 && w < .1 && (x < .2 && (a[_ + 0] += 1), C < .2 && (a[_ + 2] += 1), T < .2 && (a[_ + 4] += 1)) } } function d(_) { s.push(_.x, _.y, _.z) } function m(_, x) { const C = _ * 3; x.x = e[C + 0], x.y = e[C + 1], x.z = e[C + 2] } function g() { const _ = new N, x = new N, C = new N, T = new N, I = new Se, w = new Se, R = new Se; for (let b = 0, B = 0; b < s.length; b += 9, B += 6) { _.set(s[b + 0], s[b + 1], s[b + 2]), x.set(s[b + 3], s[b + 4], s[b + 5]), C.set(s[b + 6], s[b + 7], s[b + 8]), I.set(a[B + 0], a[B + 1]), w.set(a[B + 2], a[B + 3]), R.set(a[B + 4], a[B + 5]), T.copy(_).add(x).add(C).divideScalar(3); const F = y(T); v(I, B + 0, _, F), v(w, B + 2, x, F), v(R, B + 4, C, F) } } function v(_, x, C, T) { T < 0 && _.x === 1 && (a[x] = _.x - 1), C.x === 0 && C.z === 0 && (a[x] = T / 2 / Math.PI + .5) } function y(_) { return Math.atan2(_.z, -_.x) } function A(_) { return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new Jh(e.vertices, e.indices, e.radius, e.details) } } class E8 extends Jh { constructor(e = 1, t = 0) { const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, -i, -r, 0, -i, r, 0, i, -r, 0, i, r, 0, -r, 0, -i, r, 0, -i, -r, 0, i, r, 0, i], a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(s, a, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new E8(e.radius, e.detail) } } const Zv = new N, $v = new N, r_ = new N, e5 = new to; class JO extends pn { constructor(e = null, t = 1) { if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) { const i = Math.pow(10, 4), s = Math.cos(fp * t), a = e.getIndex(), o = e.getAttribute("position"), l = a ? a.count : o.count, u = [0, 0, 0], c = ["a", "b", "c"], h = new Array(3), d = {}, m = []; for (let g = 0; g < l; g += 3) { a ? (u[0] = a.getX(g), u[1] = a.getX(g + 1), u[2] = a.getX(g + 2)) : (u[0] = g, u[1] = g + 1, u[2] = g + 2); const { a: v, b: y, c: A } = e5; if (v.fromBufferAttribute(o, u[0]), y.fromBufferAttribute(o, u[1]), A.fromBufferAttribute(o, u[2]), e5.getNormal(r_), h[0] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(v.z * i)}`, h[1] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(y.z * i)}`, h[2] = `${Math.round(A.x * i)},${Math.round(A.y * i)},${Math.round(A.z * i)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0])) for (let _ = 0; _ < 3; _++) { const x = (_ + 1) % 3, C = h[_], T = h[x], I = e5[c[_]], w = e5[c[x]], R = `${C}_${T}`, b = `${T}_${C}`; b in d && d[b] ? (r_.dot(d[b].normal) <= s && (m.push(I.x, I.y, I.z), m.push(w.x, w.y, w.z)), d[b] = null) : R in d || (d[R] = { index0: u[_], index1: u[x], normal: r_.clone() }) } } for (const g in d) if (d[g]) { const { index0: v, index1: y } = d[g]; Zv.fromBufferAttribute(o, v), $v.fromBufferAttribute(o, y), m.push(Zv.x, Zv.y, Zv.z), m.push($v.x, $v.y, $v.z) } this.setAttribute("position", new Pt(m, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } class pp extends l1 { constructor(e) { super(e), this.uuid = Qo(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let r = 0, i = this.holes.length; r < i; r++)t[r] = this.holes[r].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, r = e.holes.length; t < r; t++) { const i = e.holes[t]; this.holes.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, r = this.holes.length; t < r; t++) { const i = this.holes[t]; e.holes.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, r = e.holes.length; t < r; t++) { const i = e.holes[t]; this.holes.push(new l1().fromJSON(i)) } return this } } const _te = { triangulate: function (n, e, t = 2) { const r = e && e.length, i = r ? e[0] * t : n.length; let s = KO(n, 0, i, t, !0); const a = []; if (!s || s.next === s.prev) return a; let o, l, u, c, h, d, m; if (r && (s = wte(n, e, s, t)), n.length > 80 * t) { o = u = n[0], l = c = n[1]; for (let g = t; g < i; g += t)h = n[g], d = n[g + 1], h < o && (o = h), d < l && (l = d), h > u && (u = h), d > c && (c = d); m = Math.max(u - o, c - l), m = m !== 0 ? 32767 / m : 0 } return u1(s, a, t, o, l, m, 0), a } }; function KO(n, e, t, r, i) { let s, a; if (i === Nte(n, e, t, r) > 0) for (s = e; s < t; s += r)a = lB(s, n[s], n[s + 1], a); else for (s = t - r; s >= e; s -= r)a = lB(s, n[s], n[s + 1], a); return a && C8(a, a.next) && (f1(a), a = a.next), a } function Mp(n, e) { if (!n) return n; e || (e = n); let t = n, r; do if (r = !1, !t.steiner && (C8(t, t.next) || gi(t.prev, t, t.next) === 0)) { if (f1(t), t = e = t.prev, t === t.next) break; r = !0 } else t = t.next; while (r || t !== e); return e } function u1(n, e, t, r, i, s, a) { if (!n) return; !a && s && Rte(n, r, i, s); let o = n, l, u; for (; n.prev !== n.next;) { if (l = n.prev, u = n.next, s ? Cte(n, r, i, s) : Ete(n)) { e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(u.i / t | 0), f1(n), n = u.next, o = u.next; continue } if (n = u, n === o) { a ? a === 1 ? (n = Ste(Mp(n), e, t), u1(n, e, t, r, i, s, 2)) : a === 2 && Tte(n, e, t, r, i, s) : u1(Mp(n), e, t, r, i, s, 1); break } } } function Ete(n) { const e = n.prev, t = n, r = n.next; if (gi(e, t, r) >= 0) return !1; const i = e.x, s = t.x, a = r.x, o = e.y, l = t.y, u = r.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, d = i > s ? i > a ? i : a : s > a ? s : a, m = o > l ? o > u ? o : u : l > u ? l : u; let g = r.next; for (; g !== e;) { if (g.x >= c && g.x <= d && g.y >= h && g.y <= m && f3(i, o, s, l, a, u, g.x, g.y) && gi(g.prev, g, g.next) >= 0) return !1; g = g.next } return !0 } function Cte(n, e, t, r) { const i = n.prev, s = n, a = n.next; if (gi(i, s, a) >= 0) return !1; const o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, d = a.y, m = o < l ? o < u ? o : u : l < u ? l : u, g = c < h ? c < d ? c : d : h < d ? h : d, v = o > l ? o > u ? o : u : l > u ? l : u, y = c > h ? c > d ? c : d : h > d ? h : d, A = c7(m, g, e, t, r), _ = c7(v, y, e, t, r); let x = n.prevZ, C = n.nextZ; for (; x && x.z >= A && C && C.z <= _;) { if (x.x >= m && x.x <= v && x.y >= g && x.y <= y && x !== i && x !== a && f3(o, c, l, h, u, d, x.x, x.y) && gi(x.prev, x, x.next) >= 0 || (x = x.prevZ, C.x >= m && C.x <= v && C.y >= g && C.y <= y && C !== i && C !== a && f3(o, c, l, h, u, d, C.x, C.y) && gi(C.prev, C, C.next) >= 0)) return !1; C = C.nextZ } for (; x && x.z >= A;) { if (x.x >= m && x.x <= v && x.y >= g && x.y <= y && x !== i && x !== a && f3(o, c, l, h, u, d, x.x, x.y) && gi(x.prev, x, x.next) >= 0) return !1; x = x.prevZ } for (; C && C.z <= _;) { if (C.x >= m && C.x <= v && C.y >= g && C.y <= y && C !== i && C !== a && f3(o, c, l, h, u, d, C.x, C.y) && gi(C.prev, C, C.next) >= 0) return !1; C = C.nextZ } return !0 } function Ste(n, e, t) { let r = n; do { const i = r.prev, s = r.next.next; !C8(i, s) && qO(i, r, r.next, s) && c1(i, s) && c1(s, i) && (e.push(i.i / t | 0), e.push(r.i / t | 0), e.push(s.i / t | 0), f1(r), f1(r.next), r = n = s), r = r.next } while (r !== n); return Mp(r) } function Tte(n, e, t, r, i, s) { let a = n; do { let o = a.next.next; for (; o !== a.prev;) { if (a.i !== o.i && Lte(a, o)) { let l = ZO(a, o); a = Mp(a, a.next), l = Mp(l, l.next), u1(a, e, t, r, i, s, 0), u1(l, e, t, r, i, s, 0); return } o = o.next } a = a.next } while (a !== n) } function wte(n, e, t, r) { const i = []; let s, a, o, l, u; for (s = 0, a = e.length; s < a; s++)o = e[s] * r, l = s < a - 1 ? e[s + 1] * r : n.length, u = KO(n, o, l, r, !1), u === u.next && (u.steiner = !0), i.push(Dte(u)); for (i.sort(Ite), s = 0; s < i.length; s++)t = Mte(i[s], t); return t } function Ite(n, e) { return n.x - e.x } function Mte(n, e) { const t = bte(n, e); if (!t) return e; const r = ZO(t, n); return Mp(r, r.next), Mp(t, t.next) } function bte(n, e) { let t = e, r = -1 / 0, i; const s = n.x, a = n.y; do { if (a <= t.y && a >= t.next.y && t.next.y !== t.y) { const d = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y); if (d <= s && d > r && (r = d, i = t.x < t.next.x ? t : t.next, d === s)) return i } t = t.next } while (t !== e); if (!i) return null; const o = i, l = i.x, u = i.y; let c = 1 / 0, h; t = i; do s >= t.x && t.x >= l && s !== t.x && f3(a < u ? s : r, a, l, u, a < u ? r : s, a, t.x, t.y) && (h = Math.abs(a - t.y) / (s - t.x), c1(t, n) && (h < c || h === c && (t.x > i.x || t.x === i.x && Bte(i, t))) && (i = t, c = h)), t = t.next; while (t !== o); return i } function Bte(n, e) { return gi(n.prev, n, e.prev) < 0 && gi(e.next, n, n.next) < 0 } function Rte(n, e, t, r) { let i = n; do i.z === 0 && (i.z = c7(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== n); i.prevZ.nextZ = null, i.prevZ = null, Pte(i) } function Pte(n) { let e, t, r, i, s, a, o, l, u = 1; do { for (t = n, n = null, s = null, a = 0; t;) { for (a++, r = t, o = 0, e = 0; e < u && (o++, r = r.nextZ, !!r); e++); for (l = u; o > 0 || l > 0 && r;)o !== 0 && (l === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, o--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : n = i, i.prevZ = s, s = i; t = r } s.nextZ = null, u *= 2 } while (a > 1); return n } function c7(n, e, t, r, i) { return n = (n - t) * i | 0, e = (e - r) * i | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1 } function Dte(n) { let e = n, t = n; do (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n); return t } function f3(n, e, t, r, i, s, a, o) { return (i - a) * (e - o) >= (n - a) * (s - o) && (n - a) * (r - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (i - a) * (r - o) } function Lte(n, e) { return n.next.i !== e.i && n.prev.i !== e.i && !Fte(n, e) && (c1(n, e) && c1(e, n) && kte(n, e) && (gi(n.prev, n, e.prev) || gi(n, e.prev, e)) || C8(n, e) && gi(n.prev, n, n.next) > 0 && gi(e.prev, e, e.next) > 0) } function gi(n, e, t) { return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y) } function C8(n, e) { return n.x === e.x && n.y === e.y } function qO(n, e, t, r) { const i = n5(gi(n, e, t)), s = n5(gi(n, e, r)), a = n5(gi(t, r, n)), o = n5(gi(t, r, e)); return !!(i !== s && a !== o || i === 0 && t5(n, t, e) || s === 0 && t5(n, r, e) || a === 0 && t5(t, n, r) || o === 0 && t5(t, e, r)) } function t5(n, e, t) { return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y) } function n5(n) { return n > 0 ? 1 : n < 0 ? -1 : 0 } function Fte(n, e) { let t = n; do { if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && qO(t, t.next, n, e)) return !0; t = t.next } while (t !== n); return !1 } function c1(n, e) { return gi(n.prev, n, n.next) < 0 ? gi(n, e, n.next) >= 0 && gi(n, n.prev, e) >= 0 : gi(n, e, n.prev) < 0 || gi(n, n.next, e) < 0 } function kte(n, e) { let t = n, r = !1; const i = (n.x + e.x) / 2, s = (n.y + e.y) / 2; do t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next; while (t !== n); return r } function ZO(n, e) { const t = new f7(n.i, n.x, n.y), r = new f7(e.i, e.x, e.y), i = n.next, s = e.prev; return n.next = e, e.prev = n, t.next = i, i.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r } function lB(n, e, t, r) { const i = new f7(n, e, t); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function f1(n) { n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ) } function f7(n, e, t) { this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function Nte(n, e, t, r) { let i = 0; for (let s = e, a = t - r; s < t; s += r)i += (n[a] - n[s]) * (n[s + 1] + n[a + 1]), a = s; return i } class oc { static area(e) { const t = e.length; let r = 0; for (let i = t - 1, s = 0; s < t; i = s++)r += e[i].x * e[s].y - e[s].x * e[i].y; return r * .5 } static isClockWise(e) { return oc.area(e) < 0 } static triangulateShape(e, t) { const r = [], i = [], s = []; uB(e), cB(r, e); let a = e.length; t.forEach(uB); for (let l = 0; l < t.length; l++)i.push(a), a += t[l].length, cB(r, t[l]); const o = _te.triangulate(r, i); for (let l = 0; l < o.length; l += 3)s.push(o.slice(l, l + 3)); return s } } function uB(n) { const e = n.length; e > 2 && n[e - 1].equals(n[0]) && n.pop() } function cB(n, e) { for (let t = 0; t < e.length; t++)n.push(e[t].x), n.push(e[t].y) } class S8 extends pn { constructor(e = new pp([new Se(.5, .5), new Se(-.5, .5), new Se(-.5, -.5), new Se(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const r = this, i = [], s = []; for (let o = 0, l = e.length; o < l; o++) { const u = e[o]; a(u) } this.setAttribute("position", new Pt(i, 3)), this.setAttribute("uv", new Pt(s, 2)), this.computeVertexNormals(); function a(o) { const l = [], u = t.curveSegments !== void 0 ? t.curveSegments : 12, c = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1; let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : .2, g = t.bevelSize !== void 0 ? t.bevelSize : m - .1, v = t.bevelOffset !== void 0 ? t.bevelOffset : 0, y = t.bevelSegments !== void 0 ? t.bevelSegments : 3; const A = t.extrudePath, _ = t.UVGenerator !== void 0 ? t.UVGenerator : Ote; let x, C = !1, T, I, w, R; A && (x = A.getSpacedPoints(c), C = !0, d = !1, T = A.computeFrenetFrames(c, !1), I = new N, w = new N, R = new N), d || (y = 0, m = 0, g = 0, v = 0); const b = o.extractPoints(u); let B = b.shape; const F = b.holes; if (!oc.isClockWise(B)) { B = B.reverse(); for (let K = 0, de = F.length; K < de; K++) { const Ce = F[K]; oc.isClockWise(Ce) && (F[K] = Ce.reverse()) } } const G = oc.triangulateShape(B, F), Y = B; for (let K = 0, de = F.length; K < de; K++) { const Ce = F[K]; B = B.concat(Ce) } function Z(K, de, Ce) { return de || console.error("THREE.ExtrudeGeometry: vec does not exist"), K.clone().addScaledVector(de, Ce) } const ne = B.length, $ = G.length; function L(K, de, Ce) { let Qe, De, ie; const qe = K.x - de.x, nt = K.y - de.y, it = Ce.x - K.x, xt = Ce.y - K.y, mn = qe * qe + nt * nt, X = qe * xt - nt * it; if (Math.abs(X) > Number.EPSILON) { const O = Math.sqrt(mn), fe = Math.sqrt(it * it + xt * xt), Ne = de.x - nt / O, Ue = de.y + qe / O, We = Ce.x - xt / fe, ut = Ce.y + it / fe, Ge = ((We - Ne) * xt - (ut - Ue) * it) / (qe * xt - nt * it); Qe = Ne + qe * Ge - K.x, De = Ue + nt * Ge - K.y; const Ae = Qe * Qe + De * De; if (Ae <= 2) return new Se(Qe, De); ie = Math.sqrt(Ae / 2) } else { let O = !1; qe > Number.EPSILON ? it > Number.EPSILON && (O = !0) : qe < -Number.EPSILON ? it < -Number.EPSILON && (O = !0) : Math.sign(nt) === Math.sign(xt) && (O = !0), O ? (Qe = -nt, De = qe, ie = Math.sqrt(mn)) : (Qe = qe, De = nt, ie = Math.sqrt(mn / 2)) } return new Se(Qe / ie, De / ie) } const Q = []; for (let K = 0, de = Y.length, Ce = de - 1, Qe = K + 1; K < de; K++, Ce++, Qe++)Ce === de && (Ce = 0), Qe === de && (Qe = 0), Q[K] = L(Y[K], Y[Ce], Y[Qe]); const D = []; let V, J = Q.concat(); for (let K = 0, de = F.length; K < de; K++) { const Ce = F[K]; V = []; for (let Qe = 0, De = Ce.length, ie = De - 1, qe = Qe + 1; Qe < De; Qe++, ie++, qe++)ie === De && (ie = 0), qe === De && (qe = 0), V[Qe] = L(Ce[Qe], Ce[ie], Ce[qe]); D.push(V), J = J.concat(V) } for (let K = 0; K < y; K++) { const de = K / y, Ce = m * Math.cos(de * Math.PI / 2), Qe = g * Math.sin(de * Math.PI / 2) + v; for (let De = 0, ie = Y.length; De < ie; De++) { const qe = Z(Y[De], Q[De], Qe); we(qe.x, qe.y, -Ce) } for (let De = 0, ie = F.length; De < ie; De++) { const qe = F[De]; V = D[De]; for (let nt = 0, it = qe.length; nt < it; nt++) { const xt = Z(qe[nt], V[nt], Qe); we(xt.x, xt.y, -Ce) } } } const Ee = g + v; for (let K = 0; K < ne; K++) { const de = d ? Z(B[K], J[K], Ee) : B[K]; C ? (w.copy(T.normals[0]).multiplyScalar(de.x), I.copy(T.binormals[0]).multiplyScalar(de.y), R.copy(x[0]).add(w).add(I), we(R.x, R.y, R.z)) : we(de.x, de.y, 0) } for (let K = 1; K <= c; K++)for (let de = 0; de < ne; de++) { const Ce = d ? Z(B[de], J[de], Ee) : B[de]; C ? (w.copy(T.normals[K]).multiplyScalar(Ce.x), I.copy(T.binormals[K]).multiplyScalar(Ce.y), R.copy(x[K]).add(w).add(I), we(R.x, R.y, R.z)) : we(Ce.x, Ce.y, h / c * K) } for (let K = y - 1; K >= 0; K--) { const de = K / y, Ce = m * Math.cos(de * Math.PI / 2), Qe = g * Math.sin(de * Math.PI / 2) + v; for (let De = 0, ie = Y.length; De < ie; De++) { const qe = Z(Y[De], Q[De], Qe); we(qe.x, qe.y, h + Ce) } for (let De = 0, ie = F.length; De < ie; De++) { const qe = F[De]; V = D[De]; for (let nt = 0, it = qe.length; nt < it; nt++) { const xt = Z(qe[nt], V[nt], Qe); C ? we(xt.x, xt.y + x[c - 1].y, x[c - 1].x + Ce) : we(xt.x, xt.y, h + Ce) } } } xe(), Be(); function xe() { const K = i.length / 3; if (d) { let de = 0, Ce = ne * de; for (let Qe = 0; Qe < $; Qe++) { const De = G[Qe]; ge(De[2] + Ce, De[1] + Ce, De[0] + Ce) } de = c + y * 2, Ce = ne * de; for (let Qe = 0; Qe < $; Qe++) { const De = G[Qe]; ge(De[0] + Ce, De[1] + Ce, De[2] + Ce) } } else { for (let de = 0; de < $; de++) { const Ce = G[de]; ge(Ce[2], Ce[1], Ce[0]) } for (let de = 0; de < $; de++) { const Ce = G[de]; ge(Ce[0] + ne * c, Ce[1] + ne * c, Ce[2] + ne * c) } } r.addGroup(K, i.length / 3 - K, 0) } function Be() { const K = i.length / 3; let de = 0; Fe(Y, de), de += Y.length; for (let Ce = 0, Qe = F.length; Ce < Qe; Ce++) { const De = F[Ce]; Fe(De, de), de += De.length } r.addGroup(K, i.length / 3 - K, 1) } function Fe(K, de) { let Ce = K.length; for (; --Ce >= 0;) { const Qe = Ce; let De = Ce - 1; De < 0 && (De = K.length - 1); for (let ie = 0, qe = c + y * 2; ie < qe; ie++) { const nt = ne * ie, it = ne * (ie + 1), xt = de + Qe + nt, mn = de + De + nt, X = de + De + it, O = de + Qe + it; tt(xt, mn, X, O) } } } function we(K, de, Ce) { l.push(K), l.push(de), l.push(Ce) } function ge(K, de, Ce) { je(K), je(de), je(Ce); const Qe = i.length / 3, De = _.generateTopUV(r, i, Qe - 3, Qe - 2, Qe - 1); Oe(De[0]), Oe(De[1]), Oe(De[2]) } function tt(K, de, Ce, Qe) { je(K), je(de), je(Qe), je(de), je(Ce), je(Qe); const De = i.length / 3, ie = _.generateSideWallUV(r, i, De - 6, De - 3, De - 2, De - 1); Oe(ie[0]), Oe(ie[1]), Oe(ie[3]), Oe(ie[1]), Oe(ie[2]), Oe(ie[3]) } function je(K) { i.push(l[K * 3 + 0]), i.push(l[K * 3 + 1]), i.push(l[K * 3 + 2]) } function Oe(K) { s.push(K.x), s.push(K.y) } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options; return Ute(t, r, e) } static fromJSON(e, t) { const r = []; for (let s = 0, a = e.shapes.length; s < a; s++) { const o = t[e.shapes[s]]; r.push(o) } const i = e.options.extrudePath; return i !== void 0 && (e.options.extrudePath = new nT[i.type]().fromJSON(i)), new S8(r, e.options) } } const Ote = { generateTopUV: function (n, e, t, r, i) { const s = e[t * 3], a = e[t * 3 + 1], o = e[r * 3], l = e[r * 3 + 1], u = e[i * 3], c = e[i * 3 + 1]; return [new Se(s, a), new Se(o, l), new Se(u, c)] }, generateSideWallUV: function (n, e, t, r, i, s) { const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], u = e[r * 3], c = e[r * 3 + 1], h = e[r * 3 + 2], d = e[i * 3], m = e[i * 3 + 1], g = e[i * 3 + 2], v = e[s * 3], y = e[s * 3 + 1], A = e[s * 3 + 2]; return Math.abs(o - c) < Math.abs(a - u) ? [new Se(a, 1 - l), new Se(u, 1 - h), new Se(d, 1 - g), new Se(v, 1 - A)] : [new Se(o, 1 - l), new Se(c, 1 - h), new Se(m, 1 - g), new Se(y, 1 - A)] } }; function Ute(n, e, t) { if (t.shapes = [], Array.isArray(n)) for (let r = 0, i = n.length; r < i; r++) { const s = n[r]; t.shapes.push(s.uuid) } else t.shapes.push(n.uuid); return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t } class T8 extends Jh { constructor(e = 1, t = 0) { const r = (1 + Math.sqrt(5)) / 2, i = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(i, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new T8(e.radius, e.detail) } } class U1 extends Jh { constructor(e = 1, t = 0) { const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2]; super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new U1(e.radius, e.detail) } } class w8 extends pn { constructor(e = .5, t = 1, r = 32, i = 1, s = 0, a = Math.PI * 2) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: r, phiSegments: i, thetaStart: s, thetaLength: a }, r = Math.max(3, r), i = Math.max(1, i); const o = [], l = [], u = [], c = []; let h = e; const d = (t - e) / i, m = new N, g = new Se; for (let v = 0; v <= i; v++) { for (let y = 0; y <= r; y++) { const A = s + y / r * a; m.x = h * Math.cos(A), m.y = h * Math.sin(A), l.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, c.push(g.x, g.y) } h += d } for (let v = 0; v < i; v++) { const y = v * (r + 1); for (let A = 0; A < r; A++) { const _ = A + y, x = _, C = _ + r + 1, T = _ + r + 2, I = _ + 1; o.push(x, C, I), o.push(C, T, I) } } this.setIndex(o), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(u, 3)), this.setAttribute("uv", new Pt(c, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new w8(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class I8 extends pn { constructor(e = new pp([new Se(0, .5), new Se(-.5, -.5), new Se(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const r = [], i = [], s = [], a = []; let o = 0, l = 0; if (Array.isArray(e) === !1) u(e); else for (let c = 0; c < e.length; c++)u(e[c]), this.addGroup(o, l, c), o += l, l = 0; this.setIndex(r), this.setAttribute("position", new Pt(i, 3)), this.setAttribute("normal", new Pt(s, 3)), this.setAttribute("uv", new Pt(a, 2)); function u(c) { const h = i.length / 3, d = c.extractPoints(t); let m = d.shape; const g = d.holes; oc.isClockWise(m) === !1 && (m = m.reverse()); for (let y = 0, A = g.length; y < A; y++) { const _ = g[y]; oc.isClockWise(_) === !0 && (g[y] = _.reverse()) } const v = oc.triangulateShape(m, g); for (let y = 0, A = g.length; y < A; y++) { const _ = g[y]; m = m.concat(_) } for (let y = 0, A = m.length; y < A; y++) { const _ = m[y]; i.push(_.x, _.y, 0), s.push(0, 0, 1), a.push(_.x, _.y) } for (let y = 0, A = v.length; y < A; y++) { const _ = v[y], x = _[0] + h, C = _[1] + h, T = _[2] + h; r.push(x, C, T), l += 3 } } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(), t = this.parameters.shapes; return Gte(t, e) } static fromJSON(e, t) { const r = []; for (let i = 0, s = e.shapes.length; i < s; i++) { const a = t[e.shapes[i]]; r.push(a) } return new I8(r, e.curveSegments) } } function Gte(n, e) { if (e.shapes = [], Array.isArray(n)) for (let t = 0, r = n.length; t < r; t++) { const i = n[t]; e.shapes.push(i.uuid) } else e.shapes.push(n.uuid); return e } class G1 extends pn { constructor(e = 1, t = 32, r = 16, i = 0, s = Math.PI * 2, a = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: r, phiStart: i, phiLength: s, thetaStart: a, thetaLength: o }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r)); const l = Math.min(a + o, Math.PI); let u = 0; const c = [], h = new N, d = new N, m = [], g = [], v = [], y = []; for (let A = 0; A <= r; A++) { const _ = [], x = A / r; let C = 0; A === 0 && a === 0 ? C = .5 / t : A === r && l === Math.PI && (C = -.5 / t); for (let T = 0; T <= t; T++) { const I = T / t; h.x = -e * Math.cos(i + I * s) * Math.sin(a + x * o), h.y = e * Math.cos(a + x * o), h.z = e * Math.sin(i + I * s) * Math.sin(a + x * o), g.push(h.x, h.y, h.z), d.copy(h).normalize(), v.push(d.x, d.y, d.z), y.push(I + C, 1 - x), _.push(u++) } c.push(_) } for (let A = 0; A < r; A++)for (let _ = 0; _ < t; _++) { const x = c[A][_ + 1], C = c[A][_], T = c[A + 1][_], I = c[A + 1][_ + 1]; (A !== 0 || a > 0) && m.push(x, C, I), (A !== r - 1 || l < Math.PI) && m.push(C, T, I) } this.setIndex(m), this.setAttribute("position", new Pt(g, 3)), this.setAttribute("normal", new Pt(v, 3)), this.setAttribute("uv", new Pt(y, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new G1(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class M8 extends Jh { constructor(e = 1, t = 0) { const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]; super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new M8(e.radius, e.detail) } } class b8 extends pn { constructor(e = 1, t = .4, r = 12, i = 48, s = Math.PI * 2) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: r, tubularSegments: i, arc: s }, r = Math.floor(r), i = Math.floor(i); const a = [], o = [], l = [], u = [], c = new N, h = new N, d = new N; for (let m = 0; m <= r; m++)for (let g = 0; g <= i; g++) { const v = g / i * s, y = m / r * Math.PI * 2; h.x = (e + t * Math.cos(y)) * Math.cos(v), h.y = (e + t * Math.cos(y)) * Math.sin(v), h.z = t * Math.sin(y), o.push(h.x, h.y, h.z), c.x = e * Math.cos(v), c.y = e * Math.sin(v), d.subVectors(h, c).normalize(), l.push(d.x, d.y, d.z), u.push(g / i), u.push(m / r) } for (let m = 1; m <= r; m++)for (let g = 1; g <= i; g++) { const v = (i + 1) * m + g - 1, y = (i + 1) * (m - 1) + g - 1, A = (i + 1) * (m - 1) + g, _ = (i + 1) * m + g; a.push(v, y, _), a.push(y, A, _) } this.setIndex(a), this.setAttribute("position", new Pt(o, 3)), this.setAttribute("normal", new Pt(l, 3)), this.setAttribute("uv", new Pt(u, 2)) } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new b8(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class B8 extends pn { constructor(e = 1, t = .4, r = 64, i = 8, s = 2, a = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: r, radialSegments: i, p: s, q: a }, r = Math.floor(r), i = Math.floor(i); const o = [], l = [], u = [], c = [], h = new N, d = new N, m = new N, g = new N, v = new N, y = new N, A = new N; for (let x = 0; x <= r; ++x) { const C = x / r * s * Math.PI * 2; _(C, s, a, e, m), _(C + .01, s, a, e, g), y.subVectors(g, m), A.addVectors(g, m), v.crossVectors(y, A), A.crossVectors(v, y), v.normalize(), A.normalize(); for (let T = 0; T <= i; ++T) { const I = T / i * Math.PI * 2, w = -t * Math.cos(I), R = t * Math.sin(I); h.x = m.x + (w * A.x + R * v.x), h.y = m.y + (w * A.y + R * v.y), h.z = m.z + (w * A.z + R * v.z), l.push(h.x, h.y, h.z), d.subVectors(h, m).normalize(), u.push(d.x, d.y, d.z), c.push(x / r), c.push(T / i) } } for (let x = 1; x <= r; x++)for (let C = 1; C <= i; C++) { const T = (i + 1) * (x - 1) + (C - 1), I = (i + 1) * x + (C - 1), w = (i + 1) * x + C, R = (i + 1) * (x - 1) + C; o.push(T, I, R), o.push(I, w, R) } this.setIndex(o), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(u, 3)), this.setAttribute("uv", new Pt(c, 2)); function _(x, C, T, I, w) { const R = Math.cos(x), b = Math.sin(x), B = T / C * x, F = Math.cos(B); w.x = I * (2 + F) * .5 * R, w.y = I * (2 + F) * b * .5, w.z = I * Math.sin(B) * .5 } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } static fromJSON(e) { return new B8(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class R8 extends pn { constructor(e = new eT(new N(-1, -1, 0), new N(-1, 1, 0), new N(1, 1, 0)), t = 64, r = 1, i = 8, s = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: r, radialSegments: i, closed: s }; const a = e.computeFrenetFrames(t, s); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals; const o = new N, l = new N, u = new Se; let c = new N; const h = [], d = [], m = [], g = []; v(), this.setIndex(g), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(m, 2)); function v() { for (let x = 0; x < t; x++)y(x); y(s === !1 ? t : 0), _(), A() } function y(x) { c = e.getPointAt(x / t, c); const C = a.normals[x], T = a.binormals[x]; for (let I = 0; I <= i; I++) { const w = I / i * Math.PI * 2, R = Math.sin(w), b = -Math.cos(w); l.x = b * C.x + R * T.x, l.y = b * C.y + R * T.y, l.z = b * C.z + R * T.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = c.x + r * l.x, o.y = c.y + r * l.y, o.z = c.z + r * l.z, h.push(o.x, o.y, o.z) } } function A() { for (let x = 1; x <= t; x++)for (let C = 1; C <= i; C++) { const T = (i + 1) * (x - 1) + (C - 1), I = (i + 1) * x + (C - 1), w = (i + 1) * x + C, R = (i + 1) * (x - 1) + C; g.push(T, I, R), g.push(I, w, R) } } function _() { for (let x = 0; x <= t; x++)for (let C = 0; C <= i; C++)u.x = x / t, u.y = C / i, m.push(u.x, u.y) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new R8(new nT[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class $O extends pn { constructor(e = null) { if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) { const t = [], r = new Set, i = new N, s = new N; if (e.index !== null) { const a = e.attributes.position, o = e.index; let l = e.groups; l.length === 0 && (l = [{ start: 0, count: o.count, materialIndex: 0 }]); for (let u = 0, c = l.length; u < c; ++u) { const h = l[u], d = h.start, m = h.count; for (let g = d, v = d + m; g < v; g += 3)for (let y = 0; y < 3; y++) { const A = o.getX(g + y), _ = o.getX(g + (y + 1) % 3); i.fromBufferAttribute(a, A), s.fromBufferAttribute(a, _), fB(i, s, r) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z)) } } } else { const a = e.attributes.position; for (let o = 0, l = a.count / 3; o < l; o++)for (let u = 0; u < 3; u++) { const c = 3 * o + u, h = 3 * o + (u + 1) % 3; i.fromBufferAttribute(a, c), s.fromBufferAttribute(a, h), fB(i, s, r) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z)) } } this.setAttribute("position", new Pt(t, 3)) } } copy(e) { return super.copy(e), this.parameters = Object.assign({}, e.parameters), this } } function fB(n, e, t) { const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`; return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0) } var hB = Object.freeze({ __proto__: null, BoxGeometry: jh, CapsuleGeometry: y8, CircleGeometry: x8, ConeGeometry: _8, CylinderGeometry: _m, DodecahedronGeometry: E8, EdgesGeometry: JO, ExtrudeGeometry: S8, IcosahedronGeometry: T8, LatheGeometry: O1, OctahedronGeometry: U1, PlaneGeometry: vm, PolyhedronGeometry: Jh, RingGeometry: w8, ShapeGeometry: I8, SphereGeometry: G1, TetrahedronGeometry: M8, TorusGeometry: b8, TorusKnotGeometry: B8, TubeGeometry: R8, WireframeGeometry: $O }); class eU extends as { constructor(e) { super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Je(0), this.transparent = !0, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this } } class cA extends tr { constructor(e) { super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial" } } class Q1 extends as { constructor(e) { super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Je(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class gc extends Q1 { constructor(e) { super(), this.isMeshPhysicalMaterial = !0, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Se(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return bi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (t) { this.ior = (1 + .4 * t) / (1 - .4 * t) } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Je(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Je(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Je(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e) } get anisotropy() { return this._anisotropy } set anisotropy(e) { this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get iridescence() { return this._iridescence } set iridescence(e) { this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } class tU extends as { constructor(e) { super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Je(16777215), this.specular = new Je(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = B1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class nU extends as { constructor(e) { super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Je(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this } } class H1 extends as { constructor(e) { super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class rU extends as { constructor(e) { super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Je(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Je(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = B1, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this } } class iU extends as { constructor(e) { super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Je(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Yh, this.normalScale = new Se(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this } } class sU extends Aa { constructor(e) { super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } function ml(n, e, t) { return rT(n) ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length)) : n.slice(e, t) } function $d(n, e, t) { return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n) } function rT(n) { return ArrayBuffer.isView(n) && !(n instanceof DataView) } function aU(n) { function e(i, s) { return n[i] - n[s] } const t = n.length, r = new Array(t); for (let i = 0; i !== t; ++i)r[i] = i; return r.sort(e), r } function h7(n, e, t) { const r = n.length, i = new n.constructor(r); for (let s = 0, a = 0; a !== r; ++s) { const o = t[s] * e; for (let l = 0; l !== e; ++l)i[a++] = n[o + l] } return i } function iT(n, e, t, r) { let i = 1, s = n[0]; for (; s !== void 0 && s[r] === void 0;)s = n[i++]; if (s === void 0) return; let a = s[r]; if (a !== void 0) if (Array.isArray(a)) do a = s[r], a !== void 0 && (e.push(s.time), t.push.apply(t, a)), s = n[i++]; while (s !== void 0); else if (a.toArray !== void 0) do a = s[r], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = n[i++]; while (s !== void 0); else do a = s[r], a !== void 0 && (e.push(s.time), t.push(a)), s = n[i++]; while (s !== void 0) } function Qte(n, e, t, r, i = 30) { const s = n.clone(); s.name = e; const a = []; for (let l = 0; l < s.tracks.length; ++l) { const u = s.tracks[l], c = u.getValueSize(), h = [], d = []; for (let m = 0; m < u.times.length; ++m) { const g = u.times[m] * i; if (!(g < t || g >= r)) { h.push(u.times[m]); for (let v = 0; v < c; ++v)d.push(u.values[m * c + v]) } } h.length !== 0 && (u.times = $d(h, u.times.constructor), u.values = $d(d, u.values.constructor), a.push(u)) } s.tracks = a; let o = 1 / 0; for (let l = 0; l < s.tracks.length; ++l)o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]); for (let l = 0; l < s.tracks.length; ++l)s.tracks[l].shift(-1 * o); return s.resetDuration(), s } function Hte(n, e = 0, t = n, r = 30) { r <= 0 && (r = 30); const i = t.tracks.length, s = e / r; for (let a = 0; a < i; ++a) { const o = t.tracks[a], l = o.ValueTypeName; if (l === "bool" || l === "string") continue; const u = n.tracks.find(function (A) { return A.name === o.name && A.ValueTypeName === l }); if (u === void 0) continue; let c = 0; const h = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3); let d = 0; const m = u.getValueSize(); u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = m / 3); const g = o.times.length - 1; let v; if (s <= o.times[0]) { const A = c, _ = h - c; v = ml(o.values, A, _) } else if (s >= o.times[g]) { const A = g * h + c, _ = A + h - c; v = ml(o.values, A, _) } else { const A = o.createInterpolant(), _ = c, x = h - c; A.evaluate(s), v = ml(A.resultBuffer, _, x) } l === "quaternion" && new xs().fromArray(v).normalize().conjugate().toArray(v); const y = u.times.length; for (let A = 0; A < y; ++A) { const _ = A * m + d; if (l === "quaternion") xs.multiplyQuaternionsFlat(u.values, _, v, 0, u.values, _); else { const x = m - d * 2; for (let C = 0; C < x; ++C)u.values[_ + C] -= v[C] } } } return n.blendMode = LS, n } const zte = { arraySlice: ml, convertArray: $d, isTypedArray: rT, getKeyframeOrder: aU, sortedArray: h7, flattenJSON: iT, subclip: Qte, makeClipAdditive: Hte }; class Em { constructor(e, t, r, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let r = this._cachedIndex, i = t[r], s = t[r - 1]; e: { t: { let a; n: { r: if (!(e < i)) { for (let o = r + 2; ;) { if (i === void 0) { if (e < s) break r; return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } if (r === o) break; if (s = i, i = t[++r], e < i) break t } a = t.length; break n } if (!(e >= s)) { const o = t[1]; e < o && (r = 2, s = o); for (let l = r - 2; ;) { if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === l) break; if (i = s, s = t[--r - 1], e >= s) break t } a = r, r = 0; break n } break e } for (; r < a;) { const o = r + a >>> 1; e < t[o] ? a = o : r = o + 1 } if (i = t[r], s = t[r - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (i === void 0) return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1) } this._cachedIndex = r, this.intervalChanged_(r, s, i) } return this.interpolate_(r, s, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, s = e * i; for (let a = 0; a !== i; ++a)t[a] = r[s + a]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } class oU extends Em { constructor(e, t, r, i) { super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Kd, endingEnd: Kd } } intervalChanged_(e, t, r) { const i = this.parameterPositions; let s = e - 2, a = e + 1, o = i[s], l = i[a]; if (o === void 0) switch (this.getSettings_().endingStart) { case qd: s = e, o = 2 * t - r; break; case i1: s = i.length - 2, o = t + i[s] - i[s + 1]; break; default: s = e, o = r }if (l === void 0) switch (this.getSettings_().endingEnd) { case qd: a = e, l = 2 * r - t; break; case i1: a = 1, l = r + i[1] - i[0]; break; default: a = e - 1, l = t }const u = (r - t) * .5, c = this.valueSize; this._weightPrev = u / (t - o), this._weightNext = u / (l - r), this._offsetPrev = s * c, this._offsetNext = a * c } interpolate_(e, t, r, i) { const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, u = l - o, c = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, m = this._weightNext, g = (r - t) / (i - t), v = g * g, y = v * g, A = -d * y + 2 * d * v - d * g, _ = (1 + d) * y + (-1.5 - 2 * d) * v + (-.5 + d) * g + 1, x = (-1 - m) * y + (1.5 + m) * v + .5 * g, C = m * y - m * v; for (let T = 0; T !== o; ++T)s[T] = A * a[c + T] + _ * a[u + T] + x * a[l + T] + C * a[h + T]; return s } } class sT extends Em { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e, t, r, i) { const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, u = l - o, c = (r - t) / (i - t), h = 1 - c; for (let d = 0; d !== o; ++d)s[d] = a[u + d] * h + a[l + d] * c; return s } } class lU extends Em { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Mu { constructor(e, t, r, i) { if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = $d(t, this.TimeBufferType), this.values = $d(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let r; if (t.toJSON !== this.toJSON) r = t.toJSON(e); else { r = { name: e.name, times: $d(e.times, Array), values: $d(e.values, Array) }; const i = e.getInterpolation(); i !== e.DefaultInterpolation && (r.interpolation = i) } return r.type = e.ValueTypeName, r } InterpolantFactoryMethodDiscrete(e) { return new lU(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new sT(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new oU(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case Z3: t = this.InterpolantFactoryMethodDiscrete; break; case Ip: t = this.InterpolantFactoryMethodLinear; break; case o6: t = this.InterpolantFactoryMethodSmooth; break }if (t === void 0) { const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(r); return console.warn("THREE.KeyframeTrack:", r), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return Z3; case this.InterpolantFactoryMethodLinear: return Ip; case this.InterpolantFactoryMethodSmooth: return o6 } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (e !== 0) { const t = this.times; for (let r = 0, i = t.length; r !== i; ++r)t[r] += e } return this } scale(e) { if (e !== 1) { const t = this.times; for (let r = 0, i = t.length; r !== i; ++r)t[r] *= e } return this } trim(e, t) { const r = this.times, i = r.length; let s = 0, a = i - 1; for (; s !== i && r[s] < e;)++s; for (; a !== -1 && r[a] > t;)--a; if (++a, s !== 0 || a !== i) { s >= a && (a = Math.max(a, 1), s = a - 1); const o = this.getValueSize(); this.times = ml(r, s, a), this.values = ml(this.values, s * o, a * o) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const r = this.times, i = this.values, s = r.length; s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let a = null; for (let o = 0; o !== s; o++) { const l = r[o]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = !1; break } if (a !== null && a > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = !1; break } a = l } if (i !== void 0 && rT(i)) for (let o = 0, l = i.length; o !== l; ++o) { const u = i[o]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, u), e = !1; break } } return e } optimize() { const e = ml(this.times), t = ml(this.values), r = this.getValueSize(), i = this.getInterpolation() === o6, s = e.length - 1; let a = 1; for (let o = 1; o < s; ++o) { let l = !1; const u = e[o], c = e[o + 1]; if (u !== c && (o !== 1 || u !== e[0])) if (i) l = !0; else { const h = o * r, d = h - r, m = h + r; for (let g = 0; g !== r; ++g) { const v = t[h + g]; if (v !== t[d + g] || v !== t[m + g]) { l = !0; break } } } if (l) { if (o !== a) { e[a] = e[o]; const h = o * r, d = a * r; for (let m = 0; m !== r; ++m)t[d + m] = t[h + m] } ++a } } if (s > 0) { e[a] = e[s]; for (let o = s * r, l = a * r, u = 0; u !== r; ++u)t[l + u] = t[o + u]; ++a } return a !== e.length ? (this.times = ml(e, 0, a), this.values = ml(t, 0, a * r)) : (this.times = e, this.values = t), this } clone() { const e = ml(this.times, 0), t = ml(this.values, 0), r = this.constructor, i = new r(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } Mu.prototype.TimeBufferType = Float32Array; Mu.prototype.ValueBufferType = Float32Array; Mu.prototype.DefaultInterpolation = Ip; class Up extends Mu { } Up.prototype.ValueTypeName = "bool"; Up.prototype.ValueBufferType = Array; Up.prototype.DefaultInterpolation = Z3; Up.prototype.InterpolantFactoryMethodLinear = void 0; Up.prototype.InterpolantFactoryMethodSmooth = void 0; class aT extends Mu { } aT.prototype.ValueTypeName = "color"; class nm extends Mu { } nm.prototype.ValueTypeName = "number"; class uU extends Em { constructor(e, t, r, i) { super(e, t, r, i) } interpolate_(e, t, r, i) { const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (r - t) / (i - t); let u = e * o; for (let c = u + o; u !== c; u += 4)xs.slerpFlat(s, 0, a, u - o, a, u, l); return s } } class Oh extends Mu { InterpolantFactoryMethodLinear(e) { return new uU(this.times, this.values, this.getValueSize(), e) } } Oh.prototype.ValueTypeName = "quaternion"; Oh.prototype.DefaultInterpolation = Ip; Oh.prototype.InterpolantFactoryMethodSmooth = void 0; class Gp extends Mu { } Gp.prototype.ValueTypeName = "string"; Gp.prototype.ValueBufferType = Array; Gp.prototype.DefaultInterpolation = Z3; Gp.prototype.InterpolantFactoryMethodLinear = void 0; Gp.prototype.InterpolantFactoryMethodSmooth = void 0; class rm extends Mu { } rm.prototype.ValueTypeName = "vector"; class im { constructor(e, t = -1, r, i = o8) { this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = Qo(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], r = e.tracks, i = 1 / (e.fps || 1); for (let a = 0, o = r.length; a !== o; ++a)t.push(Wte(r[a]).scale(i)); const s = new this(e.name, e.duration, t, e.blendMode); return s.uuid = e.uuid, s } static toJSON(e) { const t = [], r = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let s = 0, a = r.length; s !== a; ++s)t.push(Mu.toJSON(r[s])); return i } static CreateFromMorphTargetSequence(e, t, r, i) { const s = t.length, a = []; for (let o = 0; o < s; o++) { let l = [], u = []; l.push((o + s - 1) % s, o, (o + 1) % s), u.push(0, 1, 0); const c = aU(l); l = h7(l, 1, c), u = h7(u, 1, c), !i && l[0] === 0 && (l.push(s), u.push(u[0])), a.push(new nm(".morphTargetInfluences[" + t[o].name + "]", l, u).scale(1 / r)) } return new this(e, -1, a) } static findByName(e, t) { let r = e; if (!Array.isArray(e)) { const i = e; r = i.geometry && i.geometry.animations || i.animations } for (let i = 0; i < r.length; i++)if (r[i].name === t) return r[i]; return null } static CreateClipsFromMorphTargetSequences(e, t, r) { const i = {}, s = /^([\w-]*?)([\d]+)$/; for (let o = 0, l = e.length; o < l; o++) { const u = e[o], c = u.name.match(s); if (c && c.length > 1) { const h = c[1]; let d = i[h]; d || (i[h] = d = []), d.push(u) } } const a = []; for (const o in i) a.push(this.CreateFromMorphTargetSequence(o, i[o], t, r)); return a } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (h, d, m, g, v) { if (m.length !== 0) { const y = [], A = []; iT(m, y, A, g), y.length !== 0 && v.push(new h(d, y, A)) } }, i = [], s = e.name || "default", a = e.fps || 30, o = e.blendMode; let l = e.length || -1; const u = e.hierarchy || []; for (let h = 0; h < u.length; h++) { const d = u[h].keys; if (!(!d || d.length === 0)) if (d[0].morphTargets) { const m = {}; let g; for (g = 0; g < d.length; g++)if (d[g].morphTargets) for (let v = 0; v < d[g].morphTargets.length; v++)m[d[g].morphTargets[v]] = -1; for (const v in m) { const y = [], A = []; for (let _ = 0; _ !== d[g].morphTargets.length; ++_) { const x = d[g]; y.push(x.time), A.push(x.morphTarget === v ? 1 : 0) } i.push(new nm(".morphTargetInfluence[" + v + "]", y, A)) } l = m.length * a } else { const m = ".bones[" + t[h].name + "]"; r(rm, m + ".position", d, "pos", i), r(Oh, m + ".quaternion", d, "rot", i), r(rm, m + ".scale", d, "scl", i) } } return i.length === 0 ? null : new this(s, l, i, o) } resetDuration() { const e = this.tracks; let t = 0; for (let r = 0, i = e.length; r !== i; ++r) { const s = this.tracks[r]; t = Math.max(t, s.times[s.times.length - 1]) } return this.duration = t, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function Vte(n) { switch (n.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return nm; case "vector": case "vector2": case "vector3": case "vector4": return rm; case "color": return aT; case "quaternion": return Oh; case "bool": case "boolean": return Up; case "string": return Gp }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n) } function Wte(n) { if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = Vte(n.type); if (n.times === void 0) { const t = [], r = []; iT(n.keys, t, r, "value"), n.times = t, n.values = r } return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation) } const bp = { enabled: !1, files: {}, add: function (n, e) { this.enabled !== !1 && (this.files[n] = e) }, get: function (n) { if (this.enabled !== !1) return this.files[n] }, remove: function (n) { delete this.files[n] }, clear: function () { this.files = {} } }; class oT { constructor(e, t, r) { const i = this; let s = !1, a = 0, o = 0, l; const u = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function (c) { o++, s === !1 && i.onStart !== void 0 && i.onStart(c, a, o), s = !0 }, this.itemEnd = function (c) { a++, i.onProgress !== void 0 && i.onProgress(c, a, o), a === o && (s = !1, i.onLoad !== void 0 && i.onLoad()) }, this.itemError = function (c) { i.onError !== void 0 && i.onError(c) }, this.resolveURL = function (c) { return l ? l(c) : c }, this.setURLModifier = function (c) { return l = c, this }, this.addHandler = function (c, h) { return u.push(c, h), this }, this.removeHandler = function (c) { const h = u.indexOf(c); return h !== -1 && u.splice(h, 2), this }, this.getHandler = function (c) { for (let h = 0, d = u.length; h < d; h += 2) { const m = u[h], g = u[h + 1]; if (m.global && (m.lastIndex = 0), m.test(c)) return g } return null } } } const cU = new oT; class Us { constructor(e) { this.manager = e !== void 0 ? e : cU, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const r = this; return new Promise(function (i, s) { r.load(e, i, t, s) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } Us.DEFAULT_MATERIAL_NAME = "__DEFAULT"; const Oc = {}; class Xte extends Error { constructor(e, t) { super(e), this.response = t } } class _s extends Us { constructor(e) { super(e) } load(e, t, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = bp.get(e); if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => { t && t(s), this.manager.itemEnd(e) }, 0), s; if (Oc[e] !== void 0) { Oc[e].push({ onLoad: t, onProgress: r, onError: i }); return } Oc[e] = [], Oc[e].push({ onLoad: t, onProgress: r, onError: i }); const a = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o = this.mimeType, l = this.responseType; fetch(a).then(u => { if (u.status === 200 || u.status === 0) { if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u; const c = Oc[e], h = u.body.getReader(), d = u.headers.get("Content-Length") || u.headers.get("X-File-Size"), m = d ? parseInt(d) : 0, g = m !== 0; let v = 0; const y = new ReadableStream({ start(A) { _(); function _() { h.read().then(({ done: x, value: C }) => { if (x) A.close(); else { v += C.byteLength; const T = new ProgressEvent("progress", { lengthComputable: g, loaded: v, total: m }); for (let I = 0, w = c.length; I < w; I++) { const R = c[I]; R.onProgress && R.onProgress(T) } A.enqueue(C), _() } }) } } }); return new Response(y) } else throw new Xte(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u) }).then(u => { switch (l) { case "arraybuffer": return u.arrayBuffer(); case "blob": return u.blob(); case "document": return u.text().then(c => new DOMParser().parseFromString(c, o)); case "json": return u.json(); default: if (o === void 0) return u.text(); { const h = /charset="?([^;"\s]*)"?/i.exec(o), d = h && h[1] ? h[1].toLowerCase() : void 0, m = new TextDecoder(d); return u.arrayBuffer().then(g => m.decode(g)) } } }).then(u => { bp.add(e, u); const c = Oc[e]; delete Oc[e]; for (let h = 0, d = c.length; h < d; h++) { const m = c[h]; m.onLoad && m.onLoad(u) } }).catch(u => { const c = Oc[e]; if (c === void 0) throw this.manager.itemError(e), u; delete Oc[e]; for (let h = 0, d = c.length; h < d; h++) { const m = c[h]; m.onError && m.onError(u) } this.manager.itemError(e) }).finally(() => { this.manager.itemEnd(e) }), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class Yte extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = new _s(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (o) { try { t(s.parse(JSON.parse(o))) } catch (l) { i ? i(l) : console.error(l), s.manager.itemError(e) } }, r, i) } parse(e) { const t = []; for (let r = 0; r < e.length; r++) { const i = im.parse(e[r]); t.push(i) } return t } } class jte extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = [], o = new Nh, l = new _s(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials); let u = 0; function c(h) { l.load(e[h], function (d) { const m = s.parse(d, !0); a[h] = { width: m.width, height: m.height, format: m.format, mipmaps: m.mipmaps }, u += 1, u === 6 && (m.mipmapCount === 1 && (o.minFilter = wr), o.image = a, o.format = m.format, o.needsUpdate = !0, t && t(o)) }, r, i) } if (Array.isArray(e)) for (let h = 0, d = e.length; h < d; ++h)c(h); else l.load(e, function (h) { const d = s.parse(h, !0); if (d.isCubemap) { const m = d.mipmaps.length / d.mipmapCount; for (let g = 0; g < m; g++) { a[g] = { mipmaps: [] }; for (let v = 0; v < d.mipmapCount; v++)a[g].mipmaps.push(d.mipmaps[g * d.mipmapCount + v]), a[g].format = d.format, a[g].width = d.width, a[g].height = d.height } o.image = a } else o.image.width = d.width, o.image.height = d.height, o.mipmaps = d.mipmaps; d.mipmapCount === 1 && (o.minFilter = wr), o.format = d.format, o.needsUpdate = !0, t && t(o) }, r, i); return o } } class h1 extends Us { constructor(e) { super(e) } load(e, t, r, i) { this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, a = bp.get(e); if (a !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(a), s.manager.itemEnd(e) }, 0), a; const o = o1("img"); function l() { c(), bp.add(e, this), t && t(this), s.manager.itemEnd(e) } function u(h) { c(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e) } function c() { o.removeEventListener("load", l, !1), o.removeEventListener("error", u, !1) } return o.addEventListener("load", l, !1), o.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o } } class Jte extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = new L1; s.colorSpace = Ur; const a = new h1(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); let o = 0; function l(u) { a.load(e[u], function (c) { s.images[u] = c, o++, o === 6 && (s.needsUpdate = !0, t && t(s)) }, void 0, i) } for (let u = 0; u < e.length; ++u)l(u); return s } } class Kte extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = new ac, o = new _s(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(s.withCredentials), o.load(e, function (l) { let u; try { u = s.parse(l) } catch (c) { if (i !== void 0) i(c); else { console.error(c); return } } u.image !== void 0 ? a.image = u.image : u.data !== void 0 && (a.image.width = u.width, a.image.height = u.height, a.image.data = u.data), a.wrapS = u.wrapS !== void 0 ? u.wrapS : pi, a.wrapT = u.wrapT !== void 0 ? u.wrapT : pi, a.magFilter = u.magFilter !== void 0 ? u.magFilter : wr, a.minFilter = u.minFilter !== void 0 ? u.minFilter : wr, a.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.colorSpace !== void 0 ? a.colorSpace = u.colorSpace : u.encoding !== void 0 && (a.encoding = u.encoding), u.flipY !== void 0 && (a.flipY = u.flipY), u.format !== void 0 && (a.format = u.format), u.type !== void 0 && (a.type = u.type), u.mipmaps !== void 0 && (a.mipmaps = u.mipmaps, a.minFilter = Dl), u.mipmapCount === 1 && (a.minFilter = wr), u.generateMipmaps !== void 0 && (a.generateMipmaps = u.generateMipmaps), a.needsUpdate = !0, t && t(a, u) }, r, i), a } } class fU extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = new ri, a = new h1(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (o) { s.image = o, s.needsUpdate = !0, t !== void 0 && t(s) }, r, i), s } } class Kh extends Hn { constructor(e, t = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Je(e), this.intensity = t } dispose() { } copy(e, t) { return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t } } class hU extends Kh { constructor(e, t, r) { super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Hn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Je(t) } copy(e, t) { return super.copy(e, t), this.groundColor.copy(e.groundColor), this } } const i_ = new bt, dB = new N, pB = new N; class lT { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Se(512, 512), this.map = null, this.mapPass = null, this.matrix = new bt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new c8, this._frameExtents = new Se(1, 1), this._viewportCount = 1, this._viewports = [new Jn(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, r = this.matrix; dB.setFromMatrixPosition(e.matrixWorld), t.position.copy(dB), pB.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(pB), t.updateMatrixWorld(), i_.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i_), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(i_) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return new this.constructor().copy(this) } toJSON() { const e = {}; return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class qte extends lT { constructor() { super(new Gr(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices(e) { const t = this.camera, r = $3 * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, s = e.distance || t.far; (r !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = r, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } class uT extends Kh { constructor(e, t, r = 0, i = Math.PI / 3, s = 0, a = 2) { super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Hn.DEFAULT_UP), this.updateMatrix(), this.target = new Hn, this.distance = r, this.angle = i, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new qte } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } const mB = new bt, ag = new N, s_ = new N; class Zte extends lT { constructor() { super(new Gr(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Se(4, 2), this._viewportCount = 6, this._viewports = [new Jn(2, 1, 1, 1), new Jn(0, 1, 1, 1), new Jn(3, 1, 1, 1), new Jn(1, 1, 1, 1), new Jn(3, 0, 1, 1), new Jn(1, 0, 1, 1)], this._cubeDirections = [new N(1, 0, 0), new N(-1, 0, 0), new N(0, 0, 1), new N(0, 0, -1), new N(0, 1, 0), new N(0, -1, 0)], this._cubeUps = [new N(0, 1, 0), new N(0, 1, 0), new N(0, 1, 0), new N(0, 1, 0), new N(0, 0, 1), new N(0, 0, -1)] } updateMatrices(e, t = 0) { const r = this.camera, i = this.matrix, s = e.distance || r.far; s !== r.far && (r.far = s, r.updateProjectionMatrix()), ag.setFromMatrixPosition(e.matrixWorld), r.position.copy(ag), s_.copy(r.position), s_.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(s_), r.updateMatrixWorld(), i.makeTranslation(-ag.x, -ag.y, -ag.z), mB.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mB) } } class cT extends Kh { constructor(e, t, r = 0, i = 2) { super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new Zte } get power() { return this.intensity * 4 * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e, t) { return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } class $te extends lT { constructor() { super(new hu(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } } class fT extends Kh { constructor(e, t) { super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Hn.DEFAULT_UP), this.updateMatrix(), this.target = new Hn, this.shadow = new $te } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } class dU extends Kh { constructor(e, t) { super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight" } } class pU extends Kh { constructor(e, t, r = 10, i = 10) { super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } class mU { constructor() { this.isSphericalHarmonics3 = !0, this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new N) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const r = e.x, i = e.y, s = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * i), t.addScaledVector(a[2], .488603 * s), t.addScaledVector(a[3], .488603 * r), t.addScaledVector(a[4], 1.092548 * (r * i)), t.addScaledVector(a[5], 1.092548 * (i * s)), t.addScaledVector(a[6], .315392 * (3 * s * s - 1)), t.addScaledVector(a[7], 1.092548 * (r * s)), t.addScaledVector(a[8], .546274 * (r * r - i * i)), t } getIrradianceAt(e, t) { const r = e.x, i = e.y, s = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 2 * .511664 * i), t.addScaledVector(a[2], 2 * .511664 * s), t.addScaledVector(a[3], 2 * .511664 * r), t.addScaledVector(a[4], 2 * .429043 * r * i), t.addScaledVector(a[5], 2 * .429043 * i * s), t.addScaledVector(a[6], .743125 * s * s - .247708), t.addScaledVector(a[7], 2 * .429043 * r * s), t.addScaledVector(a[8], .429043 * (r * r - i * i)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let r = 0; r < 9; r++)this.coefficients[r].addScaledVector(e.coefficients[r], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let r = 0; r < 9; r++)this.coefficients[r].lerp(e.coefficients[r], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return new this.constructor().copy(this) } fromArray(e, t = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].fromArray(e, t + i * 3); return this } toArray(e = [], t = 0) { const r = this.coefficients; for (let i = 0; i < 9; i++)r[i].toArray(e, t + i * 3); return e } static getBasisAt(e, t) { const r = e.x, i = e.y, s = e.z; t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * s, t[3] = .488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * r * s, t[8] = .546274 * (r * r - i * i) } } class P8 extends Kh { constructor(e = new mU, t = 1) { super(void 0, t), this.isLightProbe = !0, this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } class D8 extends Us { constructor(e) { super(e), this.textures = {} } load(e, t, r, i) { const s = this, a = new _s(s.manager); a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function (o) { try { t(s.parse(JSON.parse(o))) } catch (l) { i ? i(l) : console.error(l), s.manager.itemError(e) } }, r, i) } parse(e) { const t = this.textures; function r(s) { return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s] } const i = D8.createMaterialFromType(e.type); if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Je().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) { const a = e.uniforms[s]; switch (i.uniforms[s] = {}, a.type) { case "t": i.uniforms[s].value = r(a.value); break; case "c": i.uniforms[s].value = new Je().setHex(a.value); break; case "v2": i.uniforms[s].value = new Se().fromArray(a.value); break; case "v3": i.uniforms[s].value = new N().fromArray(a.value); break; case "v4": i.uniforms[s].value = new Jn().fromArray(a.value); break; case "m3": i.uniforms[s].value = new In().fromArray(a.value); break; case "m4": i.uniforms[s].value = new bt().fromArray(a.value); break; default: i.uniforms[s].value = a.value } } if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) i.extensions[s] = e.extensions[s]; if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) { let s = e.normalScale; Array.isArray(s) === !1 && (s = [s, s]), i.normalScale = new Se().fromArray(s) } return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Se().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i } setTextures(e) { return this.textures = e, this } static createMaterialFromType(e) { const t = { ShadowMaterial: eU, SpriteMaterial: YS, RawShaderMaterial: cA, ShaderMaterial: tr, PointsMaterial: N1, MeshPhysicalMaterial: gc, MeshStandardMaterial: Q1, MeshPhongMaterial: tU, MeshToonMaterial: nU, MeshNormalMaterial: H1, MeshLambertMaterial: rU, MeshDepthMaterial: h8, MeshDistanceMaterial: WS, MeshBasicMaterial: qs, MeshMatcapMaterial: iU, LineDashedMaterial: sU, LineBasicMaterial: Aa, Material: as }; return new t[e] } } class lc { static decodeText(e) { if (typeof TextDecoder < "u") return new TextDecoder().decode(e); let t = ""; for (let r = 0, i = e.length; r < i; r++)t += String.fromCharCode(e[r]); try { return decodeURIComponent(escape(t)) } catch { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return t === -1 ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } class gU extends pn { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } toJSON() { const e = super.toJSON(); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } class AU extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = new _s(s.manager); a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function (o) { try { t(s.parse(JSON.parse(o))) } catch (l) { i ? i(l) : console.error(l), s.manager.itemError(e) } }, r, i) } parse(e) { const t = {}, r = {}; function i(m, g) { if (t[g] !== void 0) return t[g]; const y = m.interleavedBuffers[g], A = s(m, y.buffer), _ = u3(y.type, A), x = new F1(_, y.stride); return x.uuid = y.uuid, t[g] = x, x } function s(m, g) { if (r[g] !== void 0) return r[g]; const y = m.arrayBuffers[g], A = new Uint32Array(y).buffer; return r[g] = A, A } const a = e.isInstancedBufferGeometry ? new gU : new pn, o = e.data.index; if (o !== void 0) { const m = u3(o.type, o.array); a.setIndex(new lr(m, 1)) } const l = e.data.attributes; for (const m in l) { const g = l[m]; let v; if (g.isInterleavedBufferAttribute) { const y = i(e.data, g.data); v = new kh(y, g.itemSize, g.offset, g.normalized) } else { const y = u3(g.type, g.array), A = g.isInstancedBufferAttribute ? tm : lr; v = new A(y, g.itemSize, g.normalized) } g.name !== void 0 && (v.name = g.name), g.usage !== void 0 && v.setUsage(g.usage), g.updateRange !== void 0 && (v.updateRange.offset = g.updateRange.offset, v.updateRange.count = g.updateRange.count), a.setAttribute(m, v) } const u = e.data.morphAttributes; if (u) for (const m in u) { const g = u[m], v = []; for (let y = 0, A = g.length; y < A; y++) { const _ = g[y]; let x; if (_.isInterleavedBufferAttribute) { const C = i(e.data, _.data); x = new kh(C, _.itemSize, _.offset, _.normalized) } else { const C = u3(_.type, _.array); x = new lr(C, _.itemSize, _.normalized) } _.name !== void 0 && (x.name = _.name), v.push(x) } a.morphAttributes[m] = v } e.data.morphTargetsRelative && (a.morphTargetsRelative = !0); const h = e.data.groups || e.data.drawcalls || e.data.offsets; if (h !== void 0) for (let m = 0, g = h.length; m !== g; ++m) { const v = h[m]; a.addGroup(v.start, v.count, v.materialIndex) } const d = e.data.boundingSphere; if (d !== void 0) { const m = new N; d.center !== void 0 && m.fromArray(d.center), a.boundingSphere = new kl(m, d.radius) } return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a } } class ene extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = this.path === "" ? lc.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || a; const o = new _s(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function (l) { let u = null; try { u = JSON.parse(l) } catch (h) { i !== void 0 && i(h), console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message); return } const c = u.metadata; if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") { i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e); return } s.parse(u, t) }, r, i) } async loadAsync(e, t) { const r = this, i = this.path === "" ? lc.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || i; const s = new _s(this.manager); s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials); const a = await s.loadAsync(e, t), o = JSON.parse(a), l = o.metadata; if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e); return await r.parseAsync(o) } parse(e, t) { const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, i), a = this.parseImages(e.images, function () { t !== void 0 && t(u) }), o = this.parseTextures(e.textures, a), l = this.parseMaterials(e.materials, o), u = this.parseObject(e.object, s, l, o, r), c = this.parseSkeletons(e.skeletons, u); if (this.bindSkeletons(u, c), t !== void 0) { let h = !1; for (const d in a) if (a[d].data instanceof HTMLImageElement) { h = !0; break } h === !1 && t(u) } return u } async parseAsync(e) { const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), s = await this.parseImagesAsync(e.images), a = this.parseTextures(e.textures, s), o = this.parseMaterials(e.materials, a), l = this.parseObject(e.object, i, o, a, t), u = this.parseSkeletons(e.skeletons, l); return this.bindSkeletons(l, u), l } parseShapes(e) { const t = {}; if (e !== void 0) for (let r = 0, i = e.length; r < i; r++) { const s = new pp().fromJSON(e[r]); t[s.uuid] = s } return t } parseSkeletons(e, t) { const r = {}, i = {}; if (t.traverse(function (s) { s.isBone && (i[s.uuid] = s) }), e !== void 0) for (let s = 0, a = e.length; s < a; s++) { const o = new k1().fromJSON(e[s], i); r[o.uuid] = o } return r } parseGeometries(e, t) { const r = {}; if (e !== void 0) { const i = new AU; for (let s = 0, a = e.length; s < a; s++) { let o; const l = e[s]; switch (l.type) { case "BufferGeometry": case "InstancedBufferGeometry": o = i.parse(l); break; default: l.type in hB ? o = hB[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`) }o.uuid = l.uuid, l.name !== void 0 && (o.name = l.name), l.userData !== void 0 && (o.userData = l.userData), r[l.uuid] = o } } return r } parseMaterials(e, t) { const r = {}, i = {}; if (e !== void 0) { const s = new D8; s.setTextures(t); for (let a = 0, o = e.length; a < o; a++) { const l = e[a]; r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)), i[l.uuid] = r[l.uuid] } } return i } parseAnimations(e) { const t = {}; if (e !== void 0) for (let r = 0; r < e.length; r++) { const i = e[r], s = im.parse(i); t[s.uuid] = s } return t } parseImages(e, t) { const r = this, i = {}; let s; function a(l) { return r.manager.itemStart(l), s.load(l, function () { r.manager.itemEnd(l) }, void 0, function () { r.manager.itemError(l), r.manager.itemEnd(l) }) } function o(l) { if (typeof l == "string") { const u = l, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : r.resourcePath + u; return a(c) } else return l.data ? { data: u3(l.type, l.data), width: l.width, height: l.height } : null } if (e !== void 0 && e.length > 0) { const l = new oT(t); s = new h1(l), s.setCrossOrigin(this.crossOrigin); for (let u = 0, c = e.length; u < c; u++) { const h = e[u], d = h.url; if (Array.isArray(d)) { const m = []; for (let g = 0, v = d.length; g < v; g++) { const y = d[g], A = o(y); A !== null && (A instanceof HTMLImageElement ? m.push(A) : m.push(new ac(A.data, A.width, A.height))) } i[h.uuid] = new Zd(m) } else { const m = o(h.url); i[h.uuid] = new Zd(m) } } } return i } async parseImagesAsync(e) { const t = this, r = {}; let i; async function s(a) { if (typeof a == "string") { const o = a, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o; return await i.loadAsync(l) } else return a.data ? { data: u3(a.type, a.data), width: a.width, height: a.height } : null } if (e !== void 0 && e.length > 0) { i = new h1(this.manager), i.setCrossOrigin(this.crossOrigin); for (let a = 0, o = e.length; a < o; a++) { const l = e[a], u = l.url; if (Array.isArray(u)) { const c = []; for (let h = 0, d = u.length; h < d; h++) { const m = u[h], g = await s(m); g !== null && (g instanceof HTMLImageElement ? c.push(g) : c.push(new ac(g.data, g.width, g.height))) } r[l.uuid] = new Zd(c) } else { const c = await s(l.url); r[l.uuid] = new Zd(c) } } } return r } parseTextures(e, t) { function r(s, a) { return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), a[s]) } const i = {}; if (e !== void 0) for (let s = 0, a = e.length; s < a; s++) { const o = e[s]; o.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), t[o.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", o.image); const l = t[o.image], u = l.data; let c; Array.isArray(u) ? (c = new L1, u.length === 6 && (c.needsUpdate = !0)) : (u && u.data ? c = new ac : c = new ri, u && (c.needsUpdate = !0)), c.source = l, c.uuid = o.uuid, o.name !== void 0 && (c.name = o.name), o.mapping !== void 0 && (c.mapping = r(o.mapping, tne)), o.channel !== void 0 && (c.channel = o.channel), o.offset !== void 0 && c.offset.fromArray(o.offset), o.repeat !== void 0 && c.repeat.fromArray(o.repeat), o.center !== void 0 && c.center.fromArray(o.center), o.rotation !== void 0 && (c.rotation = o.rotation), o.wrap !== void 0 && (c.wrapS = r(o.wrap[0], gB), c.wrapT = r(o.wrap[1], gB)), o.format !== void 0 && (c.format = o.format), o.internalFormat !== void 0 && (c.internalFormat = o.internalFormat), o.type !== void 0 && (c.type = o.type), o.colorSpace !== void 0 && (c.colorSpace = o.colorSpace), o.encoding !== void 0 && (c.encoding = o.encoding), o.minFilter !== void 0 && (c.minFilter = r(o.minFilter, AB)), o.magFilter !== void 0 && (c.magFilter = r(o.magFilter, AB)), o.anisotropy !== void 0 && (c.anisotropy = o.anisotropy), o.flipY !== void 0 && (c.flipY = o.flipY), o.generateMipmaps !== void 0 && (c.generateMipmaps = o.generateMipmaps), o.premultiplyAlpha !== void 0 && (c.premultiplyAlpha = o.premultiplyAlpha), o.unpackAlignment !== void 0 && (c.unpackAlignment = o.unpackAlignment), o.compareFunction !== void 0 && (c.compareFunction = o.compareFunction), o.userData !== void 0 && (c.userData = o.userData), i[o.uuid] = c } return i } parseObject(e, t, r, i, s) { let a; function o(d) { return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d] } function l(d) { if (d !== void 0) { if (Array.isArray(d)) { const m = []; for (let g = 0, v = d.length; g < v; g++) { const y = d[g]; r[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", y), m.push(r[y]) } return m } return r[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), r[d] } } function u(d) { return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), i[d] } let c, h; switch (e.type) { case "Scene": a = new uy, e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new Je(e.background) : a.background = u(e.background)), e.environment !== void 0 && (a.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new p8(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new d8(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity); break; case "PerspectiveCamera": a = new Gr(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view)); break; case "OrthographicCamera": a = new hu(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view)); break; case "AmbientLight": a = new dU(e.color, e.intensity); break; case "DirectionalLight": a = new fT(e.color, e.intensity); break; case "PointLight": a = new cT(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": a = new pU(e.color, e.intensity, e.width, e.height); break; case "SpotLight": a = new uT(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": a = new hU(e.color, e.groundColor, e.intensity); break; case "LightProbe": a = new P8().fromJSON(e); break; case "SkinnedMesh": c = o(e.geometry), h = l(e.material), a = new jS(c, h), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton); break; case "Mesh": c = o(e.geometry), h = l(e.material), a = new gr(c, h); break; case "InstancedMesh": c = o(e.geometry), h = l(e.material); const d = e.count, m = e.instanceMatrix, g = e.instanceColor; a = new JS(c, h, d), a.instanceMatrix = new tm(new Float32Array(m.array), 16), g !== void 0 && (a.instanceColor = new tm(new Float32Array(g.array), g.itemSize)); break; case "LOD": a = new zO; break; case "Line": a = new Af(o(e.geometry), l(e.material)); break; case "LineLoop": a = new KS(o(e.geometry), l(e.material)); break; case "LineSegments": a = new wu(o(e.geometry), l(e.material)); break; case "PointCloud": case "Points": a = new g8(o(e.geometry), l(e.material)); break; case "Sprite": a = new HO(l(e.material)); break; case "Group": a = new ef; break; case "Bone": a = new m8; break; default: a = new Hn }if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) { const d = e.children; for (let m = 0; m < d.length; m++)a.add(this.parseObject(d[m], t, r, i, s)) } if (e.animations !== void 0) { const d = e.animations; for (let m = 0; m < d.length; m++) { const g = d[m]; a.animations.push(s[g]) } } if (e.type === "LOD") { e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate); const d = e.levels; for (let m = 0; m < d.length; m++) { const g = d[m], v = a.getObjectByProperty("uuid", g.object); v !== void 0 && a.addLevel(v, g.distance, g.hysteresis) } } return a } bindSkeletons(e, t) { Object.keys(t).length !== 0 && e.traverse(function (r) { if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) { const i = t[r.skeleton]; i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix) } }) } } const tne = { UVMapping: i8, CubeReflectionMapping: gf, CubeRefractionMapping: Lh, EquirectangularReflectionMapping: KA, EquirectangularRefractionMapping: qA, CubeUVReflectionMapping: Am }, gB = { RepeatWrapping: Pl, ClampToEdgeWrapping: pi, MirroredRepeatWrapping: q3 }, AB = { NearestFilter: cn, NearestMipmapNearestFilter: ZA, NearestMipmapLinearFilter: I3, LinearFilter: wr, LinearMipmapNearestFilter: s8, LinearMipmapLinearFilter: Dl }; class vU extends Us { constructor(e) { super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, r, i) { e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e); const s = this, a = bp.get(e); if (a !== void 0) return s.manager.itemStart(e), setTimeout(function () { t && t(a), s.manager.itemEnd(e) }, 0), a; const o = {}; o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then(function (l) { return l.blob() }).then(function (l) { return createImageBitmap(l, Object.assign(s.options, { colorSpaceConversion: "none" })) }).then(function (l) { bp.add(e, l), t && t(l), s.manager.itemEnd(e) }).catch(function (l) { i && i(l), s.manager.itemError(e), s.manager.itemEnd(e) }), s.manager.itemStart(e) } } let r5; class hT { static getContext() { return r5 === void 0 && (r5 = new (window.AudioContext || window.webkitAudioContext)), r5 } static setContext(e) { r5 = e } } class nne extends Us { constructor(e) { super(e) } load(e, t, r, i) { const s = this, a = new _s(this.manager); a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) { try { const u = l.slice(0); hT.getContext().decodeAudioData(u, function (h) { t(h) }, o) } catch (u) { o(u) } }, r, i); function o(l) { i ? i(l) : console.error(l), s.manager.itemError(e) } } } class rne extends P8 { constructor(e, t, r = 1) { super(void 0, r), this.isHemisphereLightProbe = !0; const i = new Je().set(e), s = new Je().set(t), a = new N(i.r, i.g, i.b), o = new N(s.r, s.g, s.b), l = Math.sqrt(Math.PI), u = l * Math.sqrt(.75); this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(u) } } class ine extends P8 { constructor(e, t = 1) { super(void 0, t), this.isAmbientLightProbe = !0; const r = new Je().set(e); this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } const vB = new bt, yB = new bt, vd = new bt; class sne { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Gr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Gr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, vd.copy(e.projectionMatrix); const i = t.eyeSep / 2, s = i * t.near / t.focus, a = t.near * Math.tan(fp * t.fov * .5) / t.zoom; let o, l; yB.elements[12] = -i, vB.elements[12] = i, o = -a * t.aspect + s, l = a * t.aspect + s, vd.elements[0] = 2 * t.near / (l - o), vd.elements[8] = (l + o) / (l - o), this.cameraL.projectionMatrix.copy(vd), o = -a * t.aspect - s, l = a * t.aspect - s, vd.elements[0] = 2 * t.near / (l - o), vd.elements[8] = (l + o) / (l - o), this.cameraR.projectionMatrix.copy(vd) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(yB), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(vB) } } class L8 { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = xB(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = xB(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function xB() { return (typeof performance > "u" ? Date : performance).now() } const yd = new N, _B = new xs, ane = new N, xd = new N; class one extends Hn { constructor() { super(), this.type = "AudioListener", this.context = hT.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new L8 } getInput() { return this.gain } removeFilter() { return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, r = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(yd, _B, ane), xd.set(0, 0, -1).applyQuaternion(_B), t.positionX) { const i = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(yd.x, i), t.positionY.linearRampToValueAtTime(yd.y, i), t.positionZ.linearRampToValueAtTime(yd.z, i), t.forwardX.linearRampToValueAtTime(xd.x, i), t.forwardY.linearRampToValueAtTime(xd.y, i), t.forwardZ.linearRampToValueAtTime(xd.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i) } else t.setPosition(yd.x, yd.y, yd.z), t.setOrientation(xd.x, xd.y, xd.z, r.x, r.y, r.z) } } class yU extends Hn { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (this.isPlaying === !0) { console.warn("THREE.Audio: Audio is already playing."); return } if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this } stop() { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this._connected !== !1) { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } } getFilters() { return this.filters } setFilters(e) { return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (this.hasPlaybackControl === !1) { console.warn("THREE.Audio: this Audio has no playback control."); return } return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const _d = new N, EB = new xs, lne = new N, Ed = new N; class une extends yU { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } connect() { super.connect(), this.panner.connect(this.gain) } disconnect() { super.disconnect(), this.panner.disconnect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, r) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return; this.matrixWorld.decompose(_d, EB, lne), Ed.set(0, 0, 1).applyQuaternion(EB); const t = this.panner; if (t.positionX) { const r = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(_d.x, r), t.positionY.linearRampToValueAtTime(_d.y, r), t.positionZ.linearRampToValueAtTime(_d.z, r), t.orientationX.linearRampToValueAtTime(Ed.x, r), t.orientationY.linearRampToValueAtTime(Ed.y, r), t.orientationZ.linearRampToValueAtTime(Ed.z, r) } else t.setPosition(_d.x, _d.y, _d.z), t.setOrientation(Ed.x, Ed.y, Ed.z) } } class cne { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let r = 0; r < t.length; r++)e += t[r]; return e / t.length } } class xU { constructor(e, t, r) { this.binding = e, this.valueSize = r; let i, s, a; switch (t) { case "quaternion": i = this._slerp, s = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5; break; case "string": case "bool": i = this._select, s = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5); break; default: i = this._lerp, s = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const r = this.buffer, i = this.valueSize, s = e * i + i; let a = this.cumulativeWeight; if (a === 0) { for (let o = 0; o !== i; ++o)r[s + o] = r[o]; a = t } else { a += t; const o = t / a; this._mixBufferRegion(r, s, 0, o, i) } this.cumulativeWeight = a } accumulateAdditive(e) { const t = this.buffer, r = this.valueSize, i = r * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, r = this.buffer, i = e * t + t, s = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) { const l = t * this._origIndex; this._mixBufferRegion(r, i, l, 1 - s, t) } a > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t); for (let l = t, u = t + t; l !== u; ++l)if (r[l] !== r[l + t]) { o.setValue(r, i); break } } saveOriginalState() { const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex; e.getValue(t, i); for (let s = r, a = i; s !== a; ++s)t[s] = t[i + s % r]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = this.valueSize * 3; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let r = e; r < t; r++)this.buffer[r] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let r = 0; r < this.valueSize; r++)this.buffer[t + r] = this.buffer[e + r] } _select(e, t, r, i, s) { if (i >= .5) for (let a = 0; a !== s; ++a)e[t + a] = e[r + a] } _slerp(e, t, r, i) { xs.slerpFlat(e, t, e, t, e, r, i) } _slerpAdditive(e, t, r, i, s) { const a = this._workIndex * s; xs.multiplyQuaternionsFlat(e, a, e, t, e, r), xs.slerpFlat(e, t, e, t, e, a, i) } _lerp(e, t, r, i, s) { const a = 1 - i; for (let o = 0; o !== s; ++o) { const l = t + o; e[l] = e[l] * a + e[r + o] * i } } _lerpAdditive(e, t, r, i, s) { for (let a = 0; a !== s; ++a) { const o = t + a; e[o] = e[o] + e[r + a] * i } } } const dT = "\\[\\]\\.:\\/", fne = new RegExp("[" + dT + "]", "g"), pT = "[^" + dT + "]", hne = "[^" + dT.replace("\\.", "") + "]", dne = /((?:WC+[\/:])*)/.source.replace("WC", pT), pne = /(WCOD+)?/.source.replace("WCOD", hne), mne = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", pT), gne = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", pT), Ane = new RegExp("^" + dne + pne + mne + gne + "$"), vne = ["material", "materials", "bones", "map"]; class yne { constructor(e, t, r) { const i = r || Zn.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const r = this._targetGroup.nCachedObjects_, i = this._bindings[r]; i !== void 0 && i.getValue(e, t) } setValue(e, t) { const r = this._bindings; for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)r[i].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)e[t].unbind() } } class Zn { constructor(e, t, r) { this.path = t, this.parsedPath = r || Zn.parseTrackName(t), this.node = Zn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, r) { return e && e.isAnimationObjectGroup ? new Zn.Composite(e, t, r) : new Zn(e, t, r) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(fne, "") } static parseTrackName(e) { const t = Ane.exec(e); if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const r = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, i = r.nodeName && r.nodeName.lastIndexOf("."); if (i !== void 0 && i !== -1) { const s = r.nodeName.substring(i + 1); vne.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = s) } if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return r } static findNode(e, t) { if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e; if (e.skeleton) { const r = e.skeleton.getBoneByName(t); if (r !== void 0) return r } if (e.children) { const r = function (s) { for (let a = 0; a < s.length; a++) { const o = s[a]; if (o.name === t || o.uuid === t) return o; const l = r(o.children); if (l) return l } return null }, i = r(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const r = this.resolvedProperty; for (let i = 0, s = r.length; i !== s; ++i)e[t++] = r[i] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const r = this.resolvedProperty; for (let i = 0, s = r.length; i !== s; ++i)r[i] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const r = this.resolvedProperty; for (let i = 0, s = r.length; i !== s; ++i)r[i] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const r = this.resolvedProperty; for (let i = 0, s = r.length; i !== s; ++i)r[i] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, r = t.objectName, i = t.propertyName; let s = t.propertyIndex; if (e || (e = Zn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) { console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + "."); return } if (r) { let u = t.objectIndex; switch (r) { case "materials": if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } e = e.material.materials; break; case "bones": if (!e.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } e = e.skeleton.bones; for (let c = 0; c < e.length; c++)if (e[c].name === u) { u = c; break } break; case "map": if ("map" in e) { e = e.map; break } if (!e.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!e.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } e = e.material.map; break; default: if (e[r] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } e = e[r] }if (u !== void 0) { if (e[u] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); return } e = e[u] } } const a = e[i]; if (a === void 0) { const u = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e); return } let o = this.Versioning.None; this.targetObject = e, e.needsUpdate !== void 0 ? o = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (o = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (s !== void 0) { if (i === "morphTargetInfluences") { if (!e.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!e.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } Zn.Composite = yne; Zn.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; Zn.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; Zn.prototype.GetterByBindingType = [Zn.prototype._getValue_direct, Zn.prototype._getValue_array, Zn.prototype._getValue_arrayElement, Zn.prototype._getValue_toArray]; Zn.prototype.SetterByBindingTypeAndVersioning = [[Zn.prototype._setValue_direct, Zn.prototype._setValue_direct_setNeedsUpdate, Zn.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Zn.prototype._setValue_array, Zn.prototype._setValue_array_setNeedsUpdate, Zn.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Zn.prototype._setValue_arrayElement, Zn.prototype._setValue_arrayElement_setNeedsUpdate, Zn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Zn.prototype._setValue_fromArray, Zn.prototype._setValue_fromArray_setNeedsUpdate, Zn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class xne { constructor() { this.isAnimationObjectGroup = !0, this.uuid = Qo(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let r = 0, i = arguments.length; r !== i; ++r)e[arguments[r].uuid] = r; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, s = this._bindings, a = s.length; let o, l = e.length, u = this.nCachedObjects_; for (let c = 0, h = arguments.length; c !== h; ++c) { const d = arguments[c], m = d.uuid; let g = t[m]; if (g === void 0) { g = l++, t[m] = g, e.push(d); for (let v = 0, y = a; v !== y; ++v)s[v].push(new Zn(d, r[v], i[v])) } else if (g < u) { o = e[g]; const v = --u, y = e[v]; t[y.uuid] = g, e[g] = y, t[m] = v, e[v] = d; for (let A = 0, _ = a; A !== _; ++A) { const x = s[A], C = x[v]; let T = x[g]; x[g] = C, T === void 0 && (T = new Zn(d, r[A], i[A])), x[v] = T } } else e[g] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = u } remove() { const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length; let s = this.nCachedObjects_; for (let a = 0, o = arguments.length; a !== o; ++a) { const l = arguments[a], u = l.uuid, c = t[u]; if (c !== void 0 && c >= s) { const h = s++, d = e[h]; t[d.uuid] = c, e[c] = d, t[u] = h, e[h] = l; for (let m = 0, g = i; m !== g; ++m) { const v = r[m], y = v[h], A = v[c]; v[c] = y, v[h] = A } } } this.nCachedObjects_ = s } uncache() { const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length; let s = this.nCachedObjects_, a = e.length; for (let o = 0, l = arguments.length; o !== l; ++o) { const u = arguments[o], c = u.uuid, h = t[c]; if (h !== void 0) if (delete t[c], h < s) { const d = --s, m = e[d], g = --a, v = e[g]; t[m.uuid] = h, e[h] = m, t[v.uuid] = d, e[d] = v, e.pop(); for (let y = 0, A = i; y !== A; ++y) { const _ = r[y], x = _[d], C = _[g]; _[h] = x, _[d] = C, _.pop() } } else { const d = --a, m = e[d]; d > 0 && (t[m.uuid] = h), e[h] = m, e.pop(); for (let g = 0, v = i; g !== v; ++g) { const y = r[g]; y[h] = y[d], y.pop() } } } this.nCachedObjects_ = s } subscribe_(e, t) { const r = this._bindingsIndicesByPath; let i = r[e]; const s = this._bindings; if (i !== void 0) return s[i]; const a = this._paths, o = this._parsedPaths, l = this._objects, u = l.length, c = this.nCachedObjects_, h = new Array(u); i = s.length, r[e] = i, a.push(e), o.push(t), s.push(h); for (let d = c, m = l.length; d !== m; ++d) { const g = l[d]; h[d] = new Zn(g, e, t) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, r = t[e]; if (r !== void 0) { const i = this._paths, s = this._parsedPaths, a = this._bindings, o = a.length - 1, l = a[o], u = e[o]; t[u] = r, a[r] = l, a.pop(), s[r] = s[o], s.pop(), i[r] = i[o], i.pop() } } } class _U { constructor(e, t, r = null, i = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i; const s = t.tracks, a = s.length, o = new Array(a), l = { endingStart: Kd, endingEnd: Kd }; for (let u = 0; u !== a; ++u) { const c = s[u].createInterpolant(null); o[u] = c, c.settings = l } this._interpolantSettings = l, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = dO, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, r) { if (e.fadeOut(t), this.fadeIn(t), r) { const i = this._clip.duration, s = e._clip.duration, a = s / i, o = i / s; e.warp(1, a, t), this.warp(o, 1, t) } return this } crossFadeTo(e, t, r) { return e.crossFadeFrom(this, t, r) } stopFading() { const e = this._weightInterpolant; return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, r) { const i = this._mixer, s = i.time, a = this.timeScale; let o = this._timeScaleInterpolant; o === null && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o); const l = o.parameterPositions, u = o.sampleValues; return l[0] = s, l[1] = s + r, u[0] = e / a, u[1] = t / a, this } stopWarping() { const e = this._timeScaleInterpolant; return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, r, i) { if (!this.enabled) { this._updateWeight(e); return } const s = this._startTime; if (s !== null) { const l = (e - s) * r; l < 0 || r === 0 ? t = 0 : (this._startTime = null, t = r * l) } t *= this._updateTimeScale(e); const a = this._updateTime(t), o = this._updateWeight(e); if (o > 0) { const l = this._interpolants, u = this._propertyBindings; switch (this.blendMode) { case LS: for (let c = 0, h = l.length; c !== h; ++c)l[c].evaluate(a), u[c].accumulateAdditive(o); break; case o8: default: for (let c = 0, h = l.length; c !== h; ++c)l[c].evaluate(a), u[c].accumulate(i, o) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const r = this._weightInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const r = this._timeScaleInterpolant; if (r !== null) { const i = r.evaluate(e)[0]; t *= i, e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, r = this.loop; let i = this.time + e, s = this._loopCount; const a = r === pO; if (e === 0) return s === -1 ? i : a && (s & 1) === 1 ? t - i : i; if (r === hO) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (i >= t) i = t; else if (i < 0) i = 0; else { this.time = i; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), i >= t || i < 0) { const o = Math.floor(i / t); i -= t * o, s += Math.abs(o); const l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (l === 1) { const u = e < 0; this._setEndings(u, !u, a) } else this._setEndings(!1, !1, a); this._loopCount = s, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o }) } } else this.time = i; if (a && (s & 1) === 1) return t - i } return i } _setEndings(e, t, r) { const i = this._interpolantSettings; r ? (i.endingStart = qd, i.endingEnd = qd) : (e ? i.endingStart = this.zeroSlopeAtStart ? qd : Kd : i.endingStart = i1, t ? i.endingEnd = this.zeroSlopeAtEnd ? qd : Kd : i.endingEnd = i1) } _scheduleFading(e, t, r) { const i = this._mixer, s = i.time; let a = this._weightInterpolant; a === null && (a = i._lendControlInterpolant(), this._weightInterpolant = a); const o = a.parameterPositions, l = a.sampleValues; return o[0] = s, l[0] = t, o[1] = s + e, l[1] = r, this } } const _ne = new Float32Array(1); class EU extends mc { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const r = e._localRoot || this._root, i = e._clip.tracks, s = i.length, a = e._propertyBindings, o = e._interpolants, l = r.uuid, u = this._bindingsByRootAndName; let c = u[l]; c === void 0 && (c = {}, u[l] = c); for (let h = 0; h !== s; ++h) { const d = i[h], m = d.name; let g = c[m]; if (g !== void 0) ++g.referenceCount, a[h] = g; else { if (g = a[h], g !== void 0) { g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, l, m)); continue } const v = t && t._propertyBindings[h].binding.parsedPath; g = new xU(Zn.create(r, m, v), d.ValueTypeName, d.getValueSize()), ++g.referenceCount, this._addInactiveBinding(g, l, m), a[h] = g } o[h].resultBuffer = g.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (e._cacheIndex === null) { const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, s = this._actionsByClip[i]; this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, i, r) } const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const s = t[r]; s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const s = t[r]; --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return t !== null && t < this._nActiveActions } _addInactiveAction(e, t, r) { const i = this._actions, s = this._actionsByClip; let a = s[t]; if (a === void 0) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = a; else { const o = a.knownActions; e._byClipCacheIndex = o.length, o.push(e) } e._cacheIndex = i.length, i.push(e), a.actionByRoot[r] = e } _removeInactiveAction(e) { const t = this._actions, r = t[t.length - 1], i = e._cacheIndex; r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null; const s = e._clip.uuid, a = this._actionsByClip, o = a[s], l = o.knownActions, u = l[l.length - 1], c = e._byClipCacheIndex; u._byClipCacheIndex = c, l[c] = u, l.pop(), e._byClipCacheIndex = null; const h = o.actionByRoot, d = (e._localRoot || this._root).uuid; delete h[d], l.length === 0 && delete a[s], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let r = 0, i = t.length; r !== i; ++r) { const s = t[r]; --s.referenceCount === 0 && this._removeInactiveBinding(s) } } _lendAction(e) { const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, s = t[i]; e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s } _takeBackAction(e) { const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, s = t[i]; e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s } _addInactiveBinding(e, t, r) { const i = this._bindingsByRootAndName, s = this._bindings; let a = i[t]; a === void 0 && (a = {}, i[t] = a), a[r] = e, e._cacheIndex = s.length, s.push(e) } _removeInactiveBinding(e) { const t = this._bindings, r = e.binding, i = r.rootNode.uuid, s = r.path, a = this._bindingsByRootAndName, o = a[i], l = t[t.length - 1], u = e._cacheIndex; l._cacheIndex = u, t[u] = l, t.pop(), delete o[s], Object.keys(o).length === 0 && delete a[i] } _lendBinding(e) { const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, s = t[i]; e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s } _takeBackBinding(e) { const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, s = t[i]; e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let r = e[t]; return r === void 0 && (r = new sT(new Float32Array(2), new Float32Array(2), 1, _ne), r.__cacheIndex = t, e[t] = r), r } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, s = t[i]; e.__cacheIndex = i, t[i] = e, s.__cacheIndex = r, t[r] = s } clipAction(e, t, r) { const i = t || this._root, s = i.uuid; let a = typeof e == "string" ? im.findByName(i, e) : e; const o = a !== null ? a.uuid : e, l = this._actionsByClip[o]; let u = null; if (r === void 0 && (a !== null ? r = a.blendMode : r = o8), l !== void 0) { const h = l.actionByRoot[s]; if (h !== void 0 && h.blendMode === r) return h; u = l.knownActions[0], a === null && (a = u._clip) } if (a === null) return null; const c = new _U(this, a, t, r); return this._bindAction(c, u), this._addInactiveAction(c, o, s), c } existingAction(e, t) { const r = t || this._root, i = r.uuid, s = typeof e == "string" ? im.findByName(r, e) : e, a = s ? s.uuid : e, o = this._actionsByClip[a]; return o !== void 0 && o.actionByRoot[i] || null } stopAllAction() { const e = this._actions, t = this._nActiveActions; for (let r = t - 1; r >= 0; --r)e[r].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, r = this._nActiveActions, i = this.time += e, s = Math.sign(e), a = this._accuIndex ^= 1; for (let u = 0; u !== r; ++u)t[u]._update(i, e, s, a); const o = this._bindings, l = this._nActiveBindings; for (let u = 0; u !== l; ++u)o[u].apply(a); return this } setTime(e) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, r = e.uuid, i = this._actionsByClip, s = i[r]; if (s !== void 0) { const a = s.knownActions; for (let o = 0, l = a.length; o !== l; ++o) { const u = a[o]; this._deactivateAction(u); const c = u._cacheIndex, h = t[t.length - 1]; u._cacheIndex = null, u._byClipCacheIndex = null, h._cacheIndex = c, t[c] = h, t.pop(), this._removeInactiveBindingsForAction(u) } delete i[r] } } uncacheRoot(e) { const t = e.uuid, r = this._actionsByClip; for (const a in r) { const o = r[a].actionByRoot, l = o[t]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } const i = this._bindingsByRootAndName, s = i[t]; if (s !== void 0) for (const a in s) { const o = s[a]; o.restoreOriginalState(), this._removeInactiveBinding(o) } } uncacheAction(e, t) { const r = this.existingAction(e, t); r !== null && (this._deactivateAction(r), this._removeInactiveAction(r)) } } class mT { constructor(e) { this.value = e } clone() { return new mT(this.value.clone === void 0 ? this.value : this.value.clone()) } } let Ene = 0; class Cne extends mc { constructor() { super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: Ene++ }), this.name = "", this.usage = s1, this.uniforms = [] } add(e) { return this.uniforms.push(e), this } remove(e) { const t = this.uniforms.indexOf(e); return t !== -1 && this.uniforms.splice(t, 1), this } setName(e) { return this.name = e, this } setUsage(e) { return this.usage = e, this } dispose() { return this.dispatchEvent({ type: "dispose" }), this } copy(e) { this.name = e.name, this.usage = e.usage; const t = e.uniforms; this.uniforms.length = 0; for (let r = 0, i = t.length; r < i; r++)this.uniforms.push(t[r].clone()); return this } clone() { return new this.constructor().copy(this) } } class Sne extends F1 { constructor(e, t, r = 1) { super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class Tne { constructor(e, t, r, i, s) { this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = s, this.version = 0 } set needsUpdate(e) { e === !0 && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } class CU { constructor(e, t, r = 0, i = 1 / 0) { this.ray = new Op(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new dp, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, r = []) { return d7(e, this, r, t), r.sort(CB), r } intersectObjects(e, t = !0, r = []) { for (let i = 0, s = e.length; i < s; i++)d7(e[i], this, r, t); return r.sort(CB), r } } function CB(n, e) { return n.distance - e.distance } function d7(n, e, t, r) { if (n.layers.test(e.layers) && n.raycast(e, t), r === !0) { const i = n.children; for (let s = 0, a = i.length; s < a; s++)d7(i[s], e, t, !0) } } class p7 { constructor(e = 1, t = 0, r = 0) { return this.radius = e, this.phi = t, this.theta = r, this } set(e, t, r) { return this.radius = e, this.phi = t, this.theta = r, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, r) { return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(bi(t / this.radius, -1, 1))), this } clone() { return new this.constructor().copy(this) } } class wne { constructor(e = 1, t = 0, r = 0) { return this.radius = e, this.theta = t, this.y = r, this } set(e, t, r) { return this.radius = e, this.theta = t, this.y = r, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, r) { return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this } clone() { return new this.constructor().copy(this) } } const SB = new Se; class SU { constructor(e = new Se(1 / 0, 1 / 0), t = new Se(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, r = e.length; t < r; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const r = SB.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(r), this.max.copy(e).add(r), this } clone() { return new this.constructor().copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return this.clampPoint(e, SB).distanceTo(e) } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } const TB = new N, i5 = new N; class Ine { constructor(e = new N, t = new N) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { TB.subVectors(e, this.start), i5.subVectors(this.end, this.start); const r = i5.dot(i5); let s = i5.dot(TB) / r; return t && (s = bi(s, 0, 1)), s } closestPointToPoint(e, t, r) { const i = this.closestPointToPointParameter(e, t); return this.delta(r).multiplyScalar(i).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return new this.constructor().copy(this) } } const wB = new N; class Mne extends Hn { constructor(e, t) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper"; const r = new pn, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let a = 0, o = 1, l = 32; a < l; a++, o++) { const u = a / l * Math.PI * 2, c = o / l * Math.PI * 2; i.push(Math.cos(u), Math.sin(u), 1, Math.cos(c), Math.sin(c), 1) } r.setAttribute("position", new Pt(i, 3)); const s = new Aa({ fog: !1, toneMapped: !1 }); this.cone = new wu(r, s), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), wB.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(wB), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const zf = new N, s5 = new bt, a_ = new bt; class bne extends wu { constructor(e) { const t = TU(e), r = new pn, i = [], s = [], a = new Je(0, 0, 1), o = new Je(0, 1, 0); for (let u = 0; u < t.length; u++) { const c = t[u]; c.parent && c.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(a.r, a.g, a.b), s.push(o.r, o.g, o.b)) } r.setAttribute("position", new Pt(i, 3)), r.setAttribute("color", new Pt(s, 3)); const l = new Aa({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 }); super(r, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, r = this.geometry, i = r.getAttribute("position"); a_.copy(this.root.matrixWorld).invert(); for (let s = 0, a = 0; s < t.length; s++) { const o = t[s]; o.parent && o.parent.isBone && (s5.multiplyMatrices(a_, o.matrixWorld), zf.setFromMatrixPosition(s5), i.setXYZ(a, zf.x, zf.y, zf.z), s5.multiplyMatrices(a_, o.parent.matrixWorld), zf.setFromMatrixPosition(s5), i.setXYZ(a + 1, zf.x, zf.y, zf.z), a += 2) } r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose() } } function TU(n) { const e = []; n.isBone === !0 && e.push(n); for (let t = 0; t < n.children.length; t++)e.push.apply(e, TU(n.children[t])); return e } class Bne extends gr { constructor(e, t, r) { const i = new G1(t, 4, 2), s = new qs({ wireframe: !0, fog: !1, toneMapped: !1 }); super(i, s), this.light = e, this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const Rne = new N, IB = new Je, MB = new Je; class Pne extends Hn { constructor(e, t, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "HemisphereLightHelper"; const i = new U1(t); i.rotateY(Math.PI * .5), this.material = new qs({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0); const s = i.getAttribute("position"), a = new Float32Array(s.count * 3); i.setAttribute("color", new lr(a, 3)), this.add(new gr(i, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (this.color !== void 0) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); IB.copy(this.light.color), MB.copy(this.light.groundColor); for (let r = 0, i = t.count; r < i; r++) { const s = r < i / 2 ? IB : MB; t.setXYZ(r, s.r, s.g, s.b) } t.needsUpdate = !0 } this.light.updateWorldMatrix(!0, !1), e.lookAt(Rne.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class Dne extends wu { constructor(e = 10, t = 10, r = 4473924, i = 8947848) { r = new Je(r), i = new Je(i); const s = t / 2, a = e / t, o = e / 2, l = [], u = []; for (let d = 0, m = 0, g = -o; d <= t; d++, g += a) { l.push(-o, 0, g, o, 0, g), l.push(g, 0, -o, g, 0, o); const v = d === s ? r : i; v.toArray(u, m), m += 3, v.toArray(u, m), m += 3, v.toArray(u, m), m += 3, v.toArray(u, m), m += 3 } const c = new pn; c.setAttribute("position", new Pt(l, 3)), c.setAttribute("color", new Pt(u, 3)); const h = new Aa({ vertexColors: !0, toneMapped: !1 }); super(c, h), this.type = "GridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } class Lne extends wu { constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, a = 8947848) { s = new Je(s), a = new Je(a); const o = [], l = []; if (t > 1) for (let h = 0; h < t; h++) { const d = h / t * (Math.PI * 2), m = Math.sin(d) * e, g = Math.cos(d) * e; o.push(0, 0, 0), o.push(m, 0, g); const v = h & 1 ? s : a; l.push(v.r, v.g, v.b), l.push(v.r, v.g, v.b) } for (let h = 0; h < r; h++) { const d = h & 1 ? s : a, m = e - e / r * h; for (let g = 0; g < i; g++) { let v = g / i * (Math.PI * 2), y = Math.sin(v) * m, A = Math.cos(v) * m; o.push(y, 0, A), l.push(d.r, d.g, d.b), v = (g + 1) / i * (Math.PI * 2), y = Math.sin(v) * m, A = Math.cos(v) * m, o.push(y, 0, A), l.push(d.r, d.g, d.b) } } const u = new pn; u.setAttribute("position", new Pt(o, 3)), u.setAttribute("color", new Pt(l, 3)); const c = new Aa({ vertexColors: !0, toneMapped: !1 }); super(u, c), this.type = "PolarGridHelper" } dispose() { this.geometry.dispose(), this.material.dispose() } } const bB = new N, a5 = new N, BB = new N; class Fne extends Hn { constructor(e, t, r) { super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, this.type = "DirectionalLightHelper", t === void 0 && (t = 1); let i = new pn; i.setAttribute("position", new Pt([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const s = new Aa({ fog: !1, toneMapped: !1 }); this.lightPlane = new Af(i, s), this.add(this.lightPlane), i = new pn, i.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Af(i, s), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), bB.setFromMatrixPosition(this.light.matrixWorld), a5.setFromMatrixPosition(this.light.target.matrixWorld), BB.subVectors(a5, bB), this.lightPlane.lookAt(a5), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(a5), this.targetLine.scale.z = BB.length() } } const o5 = new N, Ti = new D1; class kne extends wu { constructor(e) { const t = new pn, r = new Aa({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], s = [], a = {}; o("n1", "n2"), o("n2", "n4"), o("n4", "n3"), o("n3", "n1"), o("f1", "f2"), o("f2", "f4"), o("f4", "f3"), o("f3", "f1"), o("n1", "f1"), o("n2", "f2"), o("n3", "f3"), o("n4", "f4"), o("p", "n1"), o("p", "n2"), o("p", "n3"), o("p", "n4"), o("u1", "u2"), o("u2", "u3"), o("u3", "u1"), o("c", "t"), o("p", "c"), o("cn1", "cn2"), o("cn3", "cn4"), o("cf1", "cf2"), o("cf3", "cf4"); function o(g, v) { l(g), l(v) } function l(g) { i.push(0, 0, 0), s.push(0, 0, 0), a[g] === void 0 && (a[g] = []), a[g].push(i.length / 3 - 1) } t.setAttribute("position", new Pt(i, 3)), t.setAttribute("color", new Pt(s, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update(); const u = new Je(16755200), c = new Je(16711680), h = new Je(43775), d = new Je(16777215), m = new Je(3355443); this.setColors(u, c, h, d, m) } setColors(e, t, r, i, s) { const o = this.geometry.getAttribute("color"); o.setXYZ(0, e.r, e.g, e.b), o.setXYZ(1, e.r, e.g, e.b), o.setXYZ(2, e.r, e.g, e.b), o.setXYZ(3, e.r, e.g, e.b), o.setXYZ(4, e.r, e.g, e.b), o.setXYZ(5, e.r, e.g, e.b), o.setXYZ(6, e.r, e.g, e.b), o.setXYZ(7, e.r, e.g, e.b), o.setXYZ(8, e.r, e.g, e.b), o.setXYZ(9, e.r, e.g, e.b), o.setXYZ(10, e.r, e.g, e.b), o.setXYZ(11, e.r, e.g, e.b), o.setXYZ(12, e.r, e.g, e.b), o.setXYZ(13, e.r, e.g, e.b), o.setXYZ(14, e.r, e.g, e.b), o.setXYZ(15, e.r, e.g, e.b), o.setXYZ(16, e.r, e.g, e.b), o.setXYZ(17, e.r, e.g, e.b), o.setXYZ(18, e.r, e.g, e.b), o.setXYZ(19, e.r, e.g, e.b), o.setXYZ(20, e.r, e.g, e.b), o.setXYZ(21, e.r, e.g, e.b), o.setXYZ(22, e.r, e.g, e.b), o.setXYZ(23, e.r, e.g, e.b), o.setXYZ(24, t.r, t.g, t.b), o.setXYZ(25, t.r, t.g, t.b), o.setXYZ(26, t.r, t.g, t.b), o.setXYZ(27, t.r, t.g, t.b), o.setXYZ(28, t.r, t.g, t.b), o.setXYZ(29, t.r, t.g, t.b), o.setXYZ(30, t.r, t.g, t.b), o.setXYZ(31, t.r, t.g, t.b), o.setXYZ(32, r.r, r.g, r.b), o.setXYZ(33, r.r, r.g, r.b), o.setXYZ(34, r.r, r.g, r.b), o.setXYZ(35, r.r, r.g, r.b), o.setXYZ(36, r.r, r.g, r.b), o.setXYZ(37, r.r, r.g, r.b), o.setXYZ(38, i.r, i.g, i.b), o.setXYZ(39, i.r, i.g, i.b), o.setXYZ(40, s.r, s.g, s.b), o.setXYZ(41, s.r, s.g, s.b), o.setXYZ(42, s.r, s.g, s.b), o.setXYZ(43, s.r, s.g, s.b), o.setXYZ(44, s.r, s.g, s.b), o.setXYZ(45, s.r, s.g, s.b), o.setXYZ(46, s.r, s.g, s.b), o.setXYZ(47, s.r, s.g, s.b), o.setXYZ(48, s.r, s.g, s.b), o.setXYZ(49, s.r, s.g, s.b), o.needsUpdate = !0 } update() { const e = this.geometry, t = this.pointMap, r = 1, i = 1; Ti.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Hi("c", t, e, Ti, 0, 0, -1), Hi("t", t, e, Ti, 0, 0, 1), Hi("n1", t, e, Ti, -r, -i, -1), Hi("n2", t, e, Ti, r, -i, -1), Hi("n3", t, e, Ti, -r, i, -1), Hi("n4", t, e, Ti, r, i, -1), Hi("f1", t, e, Ti, -r, -i, 1), Hi("f2", t, e, Ti, r, -i, 1), Hi("f3", t, e, Ti, -r, i, 1), Hi("f4", t, e, Ti, r, i, 1), Hi("u1", t, e, Ti, r * .7, i * 1.1, -1), Hi("u2", t, e, Ti, -r * .7, i * 1.1, -1), Hi("u3", t, e, Ti, 0, i * 2, -1), Hi("cf1", t, e, Ti, -r, 0, 1), Hi("cf2", t, e, Ti, r, 0, 1), Hi("cf3", t, e, Ti, 0, -i, 1), Hi("cf4", t, e, Ti, 0, i, 1), Hi("cn1", t, e, Ti, -r, 0, -1), Hi("cn2", t, e, Ti, r, 0, -1), Hi("cn3", t, e, Ti, 0, -i, -1), Hi("cn4", t, e, Ti, 0, i, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } } function Hi(n, e, t, r, i, s, a) { o5.set(i, s, a).unproject(r); const o = e[n]; if (o !== void 0) { const l = t.getAttribute("position"); for (let u = 0, c = o.length; u < c; u++)l.setXYZ(o[u], o5.x, o5.y, o5.z) } } const l5 = new Tu; class Nne extends wu { constructor(e, t = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), s = new pn; s.setIndex(new lr(r, 1)), s.setAttribute("position", new lr(i, 3)), super(s, new Aa({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && l5.setFromObject(this.object), l5.isEmpty()) return; const t = l5.min, r = l5.max, i = this.geometry.attributes.position, s = i.array; s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = t.x, s[4] = r.y, s[5] = r.z, s[6] = t.x, s[7] = t.y, s[8] = r.z, s[9] = r.x, s[10] = t.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = t.z, s[15] = t.x, s[16] = r.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = r.x, s[22] = t.y, s[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e, t) { return super.copy(e, t), this.object = e.object, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class One extends wu { constructor(e, t = 16776960) { const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new pn; s.setIndex(new lr(r, 1)), s.setAttribute("position", new Pt(i, 3)), super(s, new Aa({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } dispose() { this.geometry.dispose(), this.material.dispose() } } class Une extends Af { constructor(e, t = 1, r = 16776960) { const i = r, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], a = new pn; a.setAttribute("position", new Pt(s, 3)), a.computeBoundingSphere(), super(a, new Aa({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new pn; l.setAttribute("position", new Pt(o, 3)), l.computeBoundingSphere(), this.add(new gr(l, new qs({ color: i, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e) } dispose() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() } } const RB = new N; let u5, o_; class Gne extends Hn { constructor(e = new N(0, 0, 1), t = new N(0, 0, 0), r = 1, i = 16776960, s = r * .2, a = s * .2) { super(), this.type = "ArrowHelper", u5 === void 0 && (u5 = new pn, u5.setAttribute("position", new Pt([0, 0, 0, 0, 1, 0], 3)), o_ = new _m(0, .5, 1, 5, 1), o_.translate(0, -.5, 0)), this.position.copy(t), this.line = new Af(u5, new Aa({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new gr(o_, new qs({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, s, a) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { RB.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(RB, t) } } setLength(e, t = e * .2, r = t * .2) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } dispose() { this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose() } } class Qne extends wu { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], r = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], i = new pn; i.setAttribute("position", new Pt(t, 3)), i.setAttribute("color", new Pt(r, 3)); const s = new Aa({ vertexColors: !0, toneMapped: !1 }); super(i, s), this.type = "AxesHelper" } setColors(e, t, r) { const i = new Je, s = this.geometry.attributes.color.array; return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(t), i.toArray(s, 6), i.toArray(s, 9), i.set(r), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } class wU { constructor() { this.type = "ShapePath", this.color = new Je, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new l1, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, r, i) { return this.currentPath.quadraticCurveTo(e, t, r, i), this } bezierCurveTo(e, t, r, i, s, a) { return this.currentPath.bezierCurveTo(e, t, r, i, s, a), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e) { function t(A) { const _ = []; for (let x = 0, C = A.length; x < C; x++) { const T = A[x], I = new pp; I.curves = T.curves, _.push(I) } return _ } function r(A, _) { const x = _.length; let C = !1; for (let T = x - 1, I = 0; I < x; T = I++) { let w = _[T], R = _[I], b = R.x - w.x, B = R.y - w.y; if (Math.abs(B) > Number.EPSILON) { if (B < 0 && (w = _[I], b = -b, R = _[T], B = -B), A.y < w.y || A.y > R.y) continue; if (A.y === w.y) { if (A.x === w.x) return !0 } else { const F = B * (A.x - w.x) - b * (A.y - w.y); if (F === 0) return !0; if (F < 0) continue; C = !C } } else { if (A.y !== w.y) continue; if (R.x <= A.x && A.x <= w.x || w.x <= A.x && A.x <= R.x) return !0 } } return C } const i = oc.isClockWise, s = this.subPaths; if (s.length === 0) return []; let a, o, l; const u = []; if (s.length === 1) return o = s[0], l = new pp, l.curves = o.curves, u.push(l), u; let c = !i(s[0].getPoints()); c = e ? !c : c; const h = [], d = []; let m = [], g = 0, v; d[g] = void 0, m[g] = []; for (let A = 0, _ = s.length; A < _; A++)o = s[A], v = o.getPoints(), a = i(v), a = e ? !a : a, a ? (!c && d[g] && g++, d[g] = { s: new pp, p: v }, d[g].s.curves = o.curves, c && g++, m[g] = []) : m[g].push({ h: o, p: v[0] }); if (!d[0]) return t(s); if (d.length > 1) { let A = !1, _ = 0; for (let x = 0, C = d.length; x < C; x++)h[x] = []; for (let x = 0, C = d.length; x < C; x++) { const T = m[x]; for (let I = 0; I < T.length; I++) { const w = T[I]; let R = !0; for (let b = 0; b < d.length; b++)r(w.p, d[b].p) && (x !== b && _++, R ? (R = !1, h[b].push(w)) : A = !0); R && h[x].push(w) } } _ > 0 && A === !1 && (m = h) } let y; for (let A = 0, _ = d.length; A < _; A++) { l = d[A].s, u.push(l), y = m[A]; for (let x = 0, C = y.length; x < C; x++)l.holes.push(y[x].h) } return u } } typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Su } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Su); const Hne = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: wS, AddEquation: ko, AddOperation: nO, AdditiveAnimationBlendMode: LS, AdditiveBlending: XA, AlphaFormat: uO, AlwaysCompare: wO, AlwaysDepth: JN, AlwaysStencilFunc: vO, AmbientLight: dU, AmbientLightProbe: ine, AnimationAction: _U, AnimationClip: im, AnimationLoader: Yte, AnimationMixer: EU, AnimationObjectGroup: xne, AnimationUtils: zte, ArcCurve: VO, ArrayCamera: UO, ArrowHelper: Gne, Audio: yU, AudioAnalyser: cne, AudioContext: hT, AudioListener: one, AudioLoader: nne, AxesHelper: Qne, BackSide: pa, BasicDepthPacking: gO, BasicShadowMap: UN, Bone: m8, BooleanKeyframeTrack: Up, Box2: SU, Box3: Tu, Box3Helper: One, BoxGeometry: jh, BoxHelper: Nne, BufferAttribute: lr, BufferGeometry: pn, BufferGeometryLoader: AU, ByteType: oO, Cache: bp, Camera: D1, CameraHelper: kne, CanvasTexture: dte, CapsuleGeometry: y8, CatmullRomCurve3: WO, CineonToneMapping: sO, CircleGeometry: x8, ClampToEdgeWrapping: pi, Clock: L8, Color: Je, ColorKeyframeTrack: aT, ColorManagement: fl, CompressedArrayTexture: fte, CompressedCubeTexture: hte, CompressedTexture: Nh, CompressedTextureLoader: jte, ConeGeometry: _8, CubeCamera: HS, CubeReflectionMapping: gf, CubeRefractionMapping: Lh, CubeTexture: L1, CubeTextureLoader: Jte, CubeUVReflectionMapping: Am, CubicBezierCurve: ZS, CubicBezierCurve3: XO, CubicInterpolant: oU, CullFaceBack: L9, CullFaceFront: ON, CullFaceFrontBack: lJ, CullFaceNone: NN, Curve: Iu, CurvePath: jO, CustomBlending: YA, CustomToneMapping: aO, CylinderGeometry: _m, Cylindrical: wne, Data3DTexture: GS, DataArrayTexture: l8, DataTexture: ac, DataTextureLoader: Kte, DataUtils: vK, DecrementStencilOp: vJ, DecrementWrapStencilOp: xJ, DefaultLoadingManager: cU, DepthFormat: Eh, DepthStencilFormat: Fh, DepthTexture: xm, DirectionalLight: fT, DirectionalLightHelper: Fne, DiscreteInterpolant: lU, DisplayP3ColorSpace: R1, DodecahedronGeometry: E8, DoubleSide: cu, DstAlphaFactor: n8, DstColorFactor: r8, DynamicCopyUsage: LJ, DynamicDrawUsage: sc, DynamicReadUsage: RJ, EdgesGeometry: JO, EllipseCurve: A8, EqualCompare: _O, EqualDepth: qN, EqualStencilFunc: SJ, EquirectangularReflectionMapping: KA, EquirectangularRefractionMapping: qA, Euler: P1, EventDispatcher: mc, ExtrudeGeometry: S8, FileLoader: _s, Float16BufferAttribute: SK, Float32BufferAttribute: Pt, Float64BufferAttribute: TK, FloatType: Oa, Fog: p8, FogExp2: d8, FramebufferTexture: cte, FrontSide: pc, Frustum: c8, GLBufferAttribute: Tne, GLSL1: kJ, GLSL3: s7, GreaterCompare: CO, GreaterDepth: $N, GreaterEqualCompare: TO, GreaterEqualDepth: ZN, GreaterEqualStencilFunc: MJ, GreaterStencilFunc: wJ, GridHelper: Dne, Group: ef, HalfFloatType: Wi, HemisphereLight: hU, HemisphereLightHelper: Pne, HemisphereLightProbe: rne, IcosahedronGeometry: T8, ImageBitmapLoader: vU, ImageLoader: h1, ImageUtils: US, IncrementStencilOp: AJ, IncrementWrapStencilOp: yJ, InstancedBufferAttribute: tm, InstancedBufferGeometry: gU, InstancedInterleavedBuffer: Sne, InstancedMesh: JS, Int16BufferAttribute: EK, Int32BufferAttribute: CK, Int8BufferAttribute: yK, IntType: IS, InterleavedBuffer: F1, InterleavedBufferAttribute: kh, Interpolant: Em, InterpolateDiscrete: Z3, InterpolateLinear: Ip, InterpolateSmooth: o6, InvertStencilOp: _J, KeepStencilOp: l6, KeyframeTrack: Mu, LOD: zO, LatheGeometry: O1, Layers: dp, LessCompare: xO, LessDepth: KN, LessEqualCompare: EO, LessEqualDepth: sy, LessEqualStencilFunc: TJ, LessStencilFunc: CJ, Light: Kh, LightProbe: P8, Line: Af, Line3: Ine, LineBasicMaterial: Aa, LineCurve: v8, LineCurve3: YO, LineDashedMaterial: sU, LineLoop: KS, LineSegments: wu, LinearDisplayP3ColorSpace: pJ, LinearEncoding: kS, LinearFilter: wr, LinearInterpolant: sT, LinearMipMapLinearFilter: dJ, LinearMipMapNearestFilter: hJ, LinearMipmapLinearFilter: Dl, LinearMipmapNearestFilter: s8, LinearSRGBColorSpace: yu, LinearToneMapping: rO, Loader: Us, LoaderUtils: lc, LoadingManager: oT, LoopOnce: hO, LoopPingPong: pO, LoopRepeat: dO, LuminanceAlphaFormat: cO, LuminanceFormat: BS, MOUSE: Rd, Material: as, MaterialLoader: D8, MathUtils: hp, Matrix3: In, Matrix4: bt, MaxEquation: O9, Mesh: gr, MeshBasicMaterial: qs, MeshDepthMaterial: h8, MeshDistanceMaterial: WS, MeshLambertMaterial: rU, MeshMatcapMaterial: iU, MeshNormalMaterial: H1, MeshPhongMaterial: tU, MeshPhysicalMaterial: gc, MeshStandardMaterial: Q1, MeshToonMaterial: nU, MinEquation: N9, MirroredRepeatWrapping: q3, MixOperation: tO, MultiplyBlending: k9, MultiplyOperation: B1, NearestFilter: cn, NearestMipMapLinearFilter: fJ, NearestMipMapNearestFilter: cJ, NearestMipmapLinearFilter: I3, NearestMipmapNearestFilter: ZA, NeverCompare: yO, NeverDepth: jN, NeverStencilFunc: EJ, NoBlending: On, NoColorSpace: Sh, NoToneMapping: wl, NormalAnimationBlendMode: o8, NormalBlending: ic, NotEqualCompare: SO, NotEqualDepth: eO, NotEqualStencilFunc: IJ, NumberKeyframeTrack: nm, Object3D: Hn, ObjectLoader: ene, ObjectSpaceNormalMap: AO, OctahedronGeometry: U1, OneFactor: HN, OneMinusDstAlphaFactor: WN, OneMinusDstColorFactor: XN, OneMinusSrcAlphaFactor: JA, OneMinusSrcColorFactor: VN, OrthographicCamera: hu, PCFShadowMap: t8, PCFSoftShadowMap: sA, PMREMGenerator: o7, Path: l1, PerspectiveCamera: Gr, Plane: Do, PlaneGeometry: vm, PlaneHelper: Une, PointLight: cT, PointLightHelper: Bne, Points: g8, PointsMaterial: N1, PolarGridHelper: Lne, PolyhedronGeometry: Jh, PositionalAudio: une, PropertyBinding: Zn, PropertyMixer: xU, QuadraticBezierCurve: $S, QuadraticBezierCurve3: eT, Quaternion: xs, QuaternionKeyframeTrack: Oh, QuaternionLinearInterpolant: uU, RED_GREEN_RGTC2_Format: r7, RED_RGTC1_Format: fO, REVISION: Su, RGBADepthPacking: NS, RGBAFormat: Ri, RGBAIntegerFormat: DS, RGBA_ASTC_10x10_Format: q9, RGBA_ASTC_10x5_Format: j9, RGBA_ASTC_10x6_Format: J9, RGBA_ASTC_10x8_Format: K9, RGBA_ASTC_12x10_Format: Z9, RGBA_ASTC_12x12_Format: $9, RGBA_ASTC_4x4_Format: r1, RGBA_ASTC_5x4_Format: Q9, RGBA_ASTC_5x5_Format: H9, RGBA_ASTC_6x5_Format: z9, RGBA_ASTC_6x6_Format: V9, RGBA_ASTC_8x5_Format: W9, RGBA_ASTC_8x6_Format: X9, RGBA_ASTC_8x8_Format: Y9, RGBA_BPTC_Format: B3, RGBA_ETC2_EAC_Format: n1, RGBA_PVRTC_2BPPV1_Format: G9, RGBA_PVRTC_4BPPV1_Format: e1, RGBA_S3TC_DXT1_Format: s6, RGBA_S3TC_DXT3_Format: a6, RGBA_S3TC_DXT5_Format: b3, RGB_BPTC_SIGNED_Format: e7, RGB_BPTC_UNSIGNED_Format: t7, RGB_ETC1_Format: a8, RGB_ETC2_Format: t1, RGB_PVRTC_2BPPV1_Format: U9, RGB_PVRTC_4BPPV1_Format: $A, RGB_S3TC_DXT1_Format: M3, RGFormat: l3, RGIntegerFormat: PS, RawShaderMaterial: cA, Ray: Op, Raycaster: CU, RectAreaLight: pU, RedFormat: Jd, RedIntegerFormat: RS, ReinhardToneMapping: iO, RenderTarget: BO, RepeatWrapping: Pl, ReplaceStencilOp: gJ, ReverseSubtractEquation: QN, RingGeometry: w8, SIGNED_RED_GREEN_RGTC2_Format: i7, SIGNED_RED_RGTC1_Format: n7, SRGBColorSpace: Ur, Scene: uy, ShaderChunk: Cn, ShaderLib: uu, ShaderMaterial: tr, ShadowMaterial: eU, Shape: pp, ShapeGeometry: I8, ShapePath: wU, ShapeUtils: oc, ShortType: lO, Skeleton: k1, SkeletonHelper: bne, SkinnedMesh: jS, Source: Zd, Sphere: kl, SphereGeometry: G1, Spherical: p7, SphericalHarmonics3: mU, SplineCurve: tT, SpotLight: uT, SpotLightHelper: Mne, Sprite: HO, SpriteMaterial: YS, SrcAlphaFactor: jA, SrcAlphaSaturateFactor: YN, SrcColorFactor: zN, StaticCopyUsage: DJ, StaticDrawUsage: s1, StaticReadUsage: BJ, StereoCamera: sne, StreamCopyUsage: FJ, StreamDrawUsage: bJ, StreamReadUsage: PJ, StringKeyframeTrack: Gp, SubtractEquation: GN, SubtractiveBlending: F9, TOUCH: Pd, TangentSpaceNormalMap: Yh, TetrahedronGeometry: M8, Texture: ri, TextureLoader: fU, TorusGeometry: b8, TorusKnotGeometry: B8, Triangle: to, TriangleFanDrawMode: ay, TriangleStripDrawMode: FS, TrianglesDrawMode: mO, TubeGeometry: R8, TwoPassDoubleSide: uJ, UVMapping: i8, Uint16BufferAttribute: QS, Uint32BufferAttribute: u8, Uint8BufferAttribute: xK, Uint8ClampedBufferAttribute: _K, Uniform: mT, UniformsGroup: Cne, UniformsLib: ot, UniformsUtils: mi, UnsignedByteType: As, UnsignedInt248Type: sf, UnsignedIntType: $c, UnsignedShort4444Type: MS, UnsignedShort5551Type: bS, UnsignedShortType: Np, VSMShadowMap: iu, Vector2: Se, Vector3: N, Vector4: Jn, VectorKeyframeTrack: rm, VideoTexture: ute, WebGL1Renderer: GO, WebGL3DRenderTarget: aK, WebGLArrayRenderTarget: sK, WebGLCoordinateSystem: Zu, WebGLCubeRenderTarget: zS, WebGLMultipleRenderTargets: oK, WebGLRenderTarget: Ir, WebGLRenderer: XS, WebGLUtils: OO, WebGPUCoordinateSystem: a1, WireframeGeometry: $O, WrapAroundEnding: i1, ZeroCurvatureEnding: Kd, ZeroFactor: K3, ZeroSlopeEnding: qd, ZeroStencilOp: mJ, _SRGBAFormat: oy, createCanvasElement: bO, sRGBEncoding: Ch }, Symbol.toStringTag, { value: "Module" })); var IU = { exports: {} }, Qp = {};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Qp.ConcurrentRoot = 1; Qp.ContinuousEventPriority = 4; Qp.DefaultEventPriority = 16; Qp.DiscreteEventPriority = 1; Qp.IdleEventPriority = 536870912; Qp.LegacyRoot = 0; IU.exports = Qp; var h3 = IU.exports; function zne(n) { let e; const t = new Set, r = (u, c) => { const h = typeof u == "function" ? u(e) : u; if (h !== e) { const d = e; e = c ? h : Object.assign({}, e, h), t.forEach(m => m(e, d)) } }, i = () => e, s = (u, c = i, h = Object.is) => { console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware"); let d = c(e); function m() { const g = c(e); if (!h(d, g)) { const v = d; u(d = g, v) } } return t.add(m), () => t.delete(m) }, l = { setState: r, getState: i, subscribe: (u, c, h) => c || h ? s(u, c, h) : (t.add(u), () => t.delete(u)), destroy: () => t.clear() }; return e = n(r, i, l), l } const Vne = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), PB = Vne ? ue.useEffect : ue.useLayoutEffect; function Wne(n) { const e = typeof n == "function" ? zne(n) : n, t = (r = e.getState, i = Object.is) => { const [, s] = ue.useReducer(y => y + 1, 0), a = e.getState(), o = ue.useRef(a), l = ue.useRef(r), u = ue.useRef(i), c = ue.useRef(!1), h = ue.useRef(); h.current === void 0 && (h.current = r(a)); let d, m = !1; (o.current !== a || l.current !== r || u.current !== i || c.current) && (d = r(a), m = !i(h.current, d)), PB(() => { m && (h.current = d), o.current = a, l.current = r, u.current = i, c.current = !1 }); const g = ue.useRef(a); PB(() => { const y = () => { try { const _ = e.getState(), x = l.current(_); u.current(h.current, x) || (o.current = _, h.current = x, s()) } catch { c.current = !0, s() } }, A = e.subscribe(y); return e.getState() !== g.current && y(), A }, []); const v = m ? d : h.current; return ue.useDebugValue(v), v }; return Object.assign(t, e), t[Symbol.iterator] = function () { console.warn("[useStore, api] = create() is deprecated and will be removed in v4"); const r = [t, e]; return { next() { const i = r.length <= 0; return { value: r.shift(), done: i } } } }, t } var MU = { exports: {} }, l_ = { exports: {} }, u_ = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var DB; function Xne() { return DB || (DB = 1, function (n) { function e(L, Q) { var D = L.length; L.push(Q); e: for (; 0 < D;) { var V = D - 1 >>> 1, J = L[V]; if (0 < i(J, Q)) L[V] = Q, L[D] = J, D = V; else break e } } function t(L) { return L.length === 0 ? null : L[0] } function r(L) { if (L.length === 0) return null; var Q = L[0], D = L.pop(); if (D !== Q) { L[0] = D; e: for (var V = 0, J = L.length, Ee = J >>> 1; V < Ee;) { var xe = 2 * (V + 1) - 1, Be = L[xe], Fe = xe + 1, we = L[Fe]; if (0 > i(Be, D)) Fe < J && 0 > i(we, Be) ? (L[V] = we, L[Fe] = D, V = Fe) : (L[V] = Be, L[xe] = D, V = xe); else if (Fe < J && 0 > i(we, D)) L[V] = we, L[Fe] = D, V = Fe; else break e } } return Q } function i(L, Q) { var D = L.sortIndex - Q.sortIndex; return D !== 0 ? D : L.id - Q.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var a = Date, o = a.now(); n.unstable_now = function () { return a.now() - o } } var l = [], u = [], c = 1, h = null, d = 3, m = !1, g = !1, v = !1, y = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function x(L) { for (var Q = t(u); Q !== null;) { if (Q.callback === null) r(u); else if (Q.startTime <= L) r(u), Q.sortIndex = Q.expirationTime, e(l, Q); else break; Q = t(u) } } function C(L) { if (v = !1, x(L), !g) if (t(l) !== null) g = !0, ne(T); else { var Q = t(u); Q !== null && $(C, Q.startTime - L) } } function T(L, Q) { g = !1, v && (v = !1, A(R), R = -1), m = !0; var D = d; try { for (x(Q), h = t(l); h !== null && (!(h.expirationTime > Q) || L && !F());) { var V = h.callback; if (typeof V == "function") { h.callback = null, d = h.priorityLevel; var J = V(h.expirationTime <= Q); Q = n.unstable_now(), typeof J == "function" ? h.callback = J : h === t(l) && r(l), x(Q) } else r(l); h = t(l) } if (h !== null) var Ee = !0; else { var xe = t(u); xe !== null && $(C, xe.startTime - Q), Ee = !1 } return Ee } finally { h = null, d = D, m = !1 } } var I = !1, w = null, R = -1, b = 5, B = -1; function F() { return !(n.unstable_now() - B < b) } function U() { if (w !== null) { var L = n.unstable_now(); B = L; var Q = !0; try { Q = w(!0, L) } finally { Q ? G() : (I = !1, w = null) } } else I = !1 } var G; if (typeof _ == "function") G = function () { _(U) }; else if (typeof MessageChannel < "u") { var Y = new MessageChannel, Z = Y.port2; Y.port1.onmessage = U, G = function () { Z.postMessage(null) } } else G = function () { y(U, 0) }; function ne(L) { w = L, I || (I = !0, G()) } function $(L, Q) { R = y(function () { L(n.unstable_now()) }, Q) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (L) { L.callback = null }, n.unstable_continueExecution = function () { g || m || (g = !0, ne(T)) }, n.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < L ? Math.floor(1e3 / L) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return d }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (L) { switch (d) { case 1: case 2: case 3: var Q = 3; break; default: Q = d }var D = d; d = Q; try { return L() } finally { d = D } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (L, Q) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var D = d; d = L; try { return Q() } finally { d = D } }, n.unstable_scheduleCallback = function (L, Q, D) { var V = n.unstable_now(); switch (typeof D == "object" && D !== null ? (D = D.delay, D = typeof D == "number" && 0 < D ? V + D : V) : D = V, L) { case 1: var J = -1; break; case 2: J = 250; break; case 5: J = 1073741823; break; case 4: J = 1e4; break; default: J = 5e3 }return J = D + J, L = { id: c++, callback: Q, priorityLevel: L, startTime: D, expirationTime: J, sortIndex: -1 }, D > V ? (L.sortIndex = D, e(u, L), t(l) === null && L === t(u) && (v ? (A(R), R = -1) : v = !0, $(C, D - V))) : (L.sortIndex = J, e(l, L), g || m || (g = !0, ne(T))), L }, n.unstable_shouldYield = F, n.unstable_wrapCallback = function (L) { var Q = d; return function () { var D = d; d = Q; try { return L.apply(this, arguments) } finally { d = D } } } }(u_)), u_ } var LB; function Yne() { return LB || (LB = 1, l_.exports = Xne()), l_.exports }/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jne = function (e) {
		var t = {}, r = ue, i = Yne(), s = Object.assign; function a(f) { for (var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + f, E = 1; E < arguments.length; E++)p += "&args[]=" + encodeURIComponent(arguments[E]); return "Minified React error #" + f + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), u = Symbol.for("react.portal"), c = Symbol.for("react.fragment"), h = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), g = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), A = Symbol.for("react.suspense_list"), _ = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), T = Symbol.iterator; function I(f) { return f === null || typeof f != "object" ? null : (f = T && f[T] || f["@@iterator"], typeof f == "function" ? f : null) } function w(f) { if (f == null) return null; if (typeof f == "function") return f.displayName || f.name || null; if (typeof f == "string") return f; switch (f) { case c: return "Fragment"; case u: return "Portal"; case d: return "Profiler"; case h: return "StrictMode"; case y: return "Suspense"; case A: return "SuspenseList" }if (typeof f == "object") switch (f.$$typeof) { case g: return (f.displayName || "Context") + ".Consumer"; case m: return (f._context.displayName || "Context") + ".Provider"; case v: var p = f.render; return f = f.displayName, f || (f = p.displayName || p.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f; case _: return p = f.displayName || null, p !== null ? p : w(f.type) || "Memo"; case x: p = f._payload, f = f._init; try { return w(f(p)) } catch { } }return null } function R(f) { var p = f.type; switch (f.tag) { case 24: return "Cache"; case 9: return (p.displayName || "Context") + ".Consumer"; case 10: return (p._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return f = p.render, f = f.displayName || f.name || "", p.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return p; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return w(p); case 8: return p === h ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof p == "function") return p.displayName || p.name || null; if (typeof p == "string") return p }return null } function b(f) { var p = f, E = f; if (f.alternate) for (; p.return;)p = p.return; else { f = p; do p = f, p.flags & 4098 && (E = p.return), f = p.return; while (f) } return p.tag === 3 ? E : null } function B(f) { if (b(f) !== f) throw Error(a(188)) } function F(f) { var p = f.alternate; if (!p) { if (p = b(f), p === null) throw Error(a(188)); return p !== f ? null : f } for (var E = f, S = p; ;) { var M = E.return; if (M === null) break; var P = M.alternate; if (P === null) { if (S = M.return, S !== null) { E = S; continue } break } if (M.child === P.child) { for (P = M.child; P;) { if (P === E) return B(M), f; if (P === S) return B(M), p; P = P.sibling } throw Error(a(188)) } if (E.return !== S.return) E = M, S = P; else { for (var q = !1, se = M.child; se;) { if (se === E) { q = !0, E = M, S = P; break } if (se === S) { q = !0, S = M, E = P; break } se = se.sibling } if (!q) { for (se = P.child; se;) { if (se === E) { q = !0, E = P, S = M; break } if (se === S) { q = !0, S = P, E = M; break } se = se.sibling } if (!q) throw Error(a(189)) } } if (E.alternate !== S) throw Error(a(190)) } if (E.tag !== 3) throw Error(a(188)); return E.stateNode.current === E ? f : p } function U(f) { return f = F(f), f !== null ? G(f) : null } function G(f) { if (f.tag === 5 || f.tag === 6) return f; for (f = f.child; f !== null;) { var p = G(f); if (p !== null) return p; f = f.sibling } return null } function Y(f) { if (f.tag === 5 || f.tag === 6) return f; for (f = f.child; f !== null;) { if (f.tag !== 4) { var p = Y(f); if (p !== null) return p } f = f.sibling } return null } var Z = Array.isArray, ne = e.getPublicInstance, $ = e.getRootHostContext, L = e.getChildHostContext, Q = e.prepareForCommit, D = e.resetAfterCommit, V = e.createInstance, J = e.appendInitialChild, Ee = e.finalizeInitialChildren, xe = e.prepareUpdate, Be = e.shouldSetTextContent, Fe = e.createTextInstance, we = e.scheduleTimeout, ge = e.cancelTimeout, tt = e.noTimeout, je = e.isPrimaryRenderer, Oe = e.supportsMutation, K = e.supportsPersistence, de = e.supportsHydration, Ce = e.getInstanceFromNode, Qe = e.preparePortalMount, De = e.getCurrentEventPriority, ie = e.detachDeletedInstance, qe = e.supportsMicrotasks, nt = e.scheduleMicrotask, it = e.supportsTestSelectors, xt = e.findFiberRoot, mn = e.getBoundingRect, X = e.getTextContent, O = e.isHiddenSubtree, fe = e.matchAccessibilityRole, Ne = e.setFocusIfFocusable, Ue = e.setupIntersectionObserver, We = e.appendChild, ut = e.appendChildToContainer, Ge = e.commitTextUpdate, Ae = e.commitMount, st = e.commitUpdate, vt = e.insertBefore, dt = e.insertInContainerBefore, at = e.removeChild, ee = e.removeChildFromContainer, Ie = e.resetTextContent, Ke = e.hideInstance, j = e.hideTextInstance, Ve = e.unhideInstance, oe = e.unhideTextInstance, ze = e.clearContainer, Ye = e.cloneInstance, jt = e.createContainerChildSet, ln = e.appendChildToContainerChildSet, fn = e.finalizeContainerChildren, Dt = e.replaceContainerChildren, $e = e.cloneHiddenInstance, Xt = e.cloneHiddenTextInstance, Qt = e.canHydrateInstance, ft = e.canHydrateTextInstance, xn = e.canHydrateSuspenseInstance, Vt = e.isSuspenseInstancePending, Yt = e.isSuspenseInstanceFallback, Mr = e.registerSuspenseInstanceRetry, sn = e.getNextHydratableSibling, vr = e.getFirstHydratableChild, Fi = e.getFirstHydratableChildWithinContainer, ur = e.getFirstHydratableChildWithinSuspenseInstance, rr = e.hydrateInstance, H = e.hydrateTextInstance, ae = e.hydrateSuspenseInstance, ve = e.getNextHydratableInstanceAfterSuspenseInstance, he = e.commitHydratedContainer, Te = e.commitHydratedSuspenseInstance, rt = e.clearSuspenseBoundary, ct = e.clearSuspenseBoundaryFromContainer, Ct = e.shouldDeleteUnhydratedTailInstances, Nt = e.didNotMatchHydratedContainerTextInstance, nn = e.didNotMatchHydratedTextInstance, yt; function pt(f) {
			if (yt === void 0) try { throw Error() } catch (E) { var p = E.stack.trim().match(/\n( *(at )?)/); yt = p && p[1] || "" } return `
`+ yt + f
		} var hn = !1; function Vn(f, p) {
			if (!f || hn) return ""; hn = !0; var E = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (p) if (p = function () { throw Error() }, Object.defineProperty(p.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(p, []) } catch (et) { var S = et } Reflect.construct(f, [], p) } else { try { p.call() } catch (et) { S = et } f.call(p.prototype) } else { try { throw Error() } catch (et) { S = et } f() } } catch (et) {
				if (et && S && typeof et.stack == "string") {
					for (var M = et.stack.split(`
`), P = S.stack.split(`
`), q = M.length - 1, se = P.length - 1; 1 <= q && 0 <= se && M[q] !== P[se];)se--; for (; 1 <= q && 0 <= se; q--, se--)if (M[q] !== P[se]) {
						if (q !== 1 || se !== 1) do if (q--, se--, 0 > se || M[q] !== P[se]) {
							var Le = `
`+ M[q].replace(" at new ", " at "); return f.displayName && Le.includes("<anonymous>") && (Le = Le.replace("<anonymous>", f.displayName)), Le
						} while (1 <= q && 0 <= se); break
					}
				}
			} finally { hn = !1, Error.prepareStackTrace = E } return (f = f ? f.displayName || f.name : "") ? pt(f) : ""
		} var oi = Object.prototype.hasOwnProperty, Vr = [], gn = -1; function gt(f) { return { current: f } } function an(f) { 0 > gn || (f.current = Vr[gn], Vr[gn] = null, gn--) } function Lt(f, p) { gn++, Vr[gn] = f.current, f.current = p } var Xi = {}, Rn = gt(Xi), $n = gt(!1), go = Xi; function Wr(f, p) { var E = f.type.contextTypes; if (!E) return Xi; var S = f.stateNode; if (S && S.__reactInternalMemoizedUnmaskedChildContext === p) return S.__reactInternalMemoizedMaskedChildContext; var M = {}, P; for (P in E) M[P] = p[P]; return S && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = p, f.__reactInternalMemoizedMaskedChildContext = M), M } function ir(f) { return f = f.childContextTypes, f != null } function $o() { an($n), an(Rn) } function os(f, p, E) { if (Rn.current !== Xi) throw Error(a(168)); Lt(Rn, p), Lt($n, E) } function wf(f, p, E) { var S = f.stateNode; if (p = p.childContextTypes, typeof S.getChildContext != "function") return E; S = S.getChildContext(); for (var M in S) if (!(M in p)) throw Error(a(108, R(f) || "Unknown", M)); return s({}, E, S) } function Lu(f) { return f = (f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext || Xi, go = Rn.current, Lt(Rn, f), Lt($n, $n.current), !0 } function td(f, p, E) { var S = f.stateNode; if (!S) throw Error(a(169)); E ? (f = wf(f, p, go), S.__reactInternalMemoizedMergedChildContext = f, an($n), an(Rn), Lt(Rn, f)) : an($n), Lt($n, E) } var ea = Math.clz32 ? Math.clz32 : Xp, Yi = Math.log, ji = Math.LN2; function Xp(f) { return f >>>= 0, f === 0 ? 32 : 31 - (Yi(f) / ji | 0) | 0 } var nd = 64, Sc = 4194304; function Fu(f) { switch (f & -f) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return f & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return f & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return f } } function Tc(f, p) { var E = f.pendingLanes; if (E === 0) return 0; var S = 0, M = f.suspendedLanes, P = f.pingedLanes, q = E & 268435455; if (q !== 0) { var se = q & ~M; se !== 0 ? S = Fu(se) : (P &= q, P !== 0 && (S = Fu(P))) } else q = E & ~M, q !== 0 ? S = Fu(q) : P !== 0 && (S = Fu(P)); if (S === 0) return 0; if (p !== 0 && p !== S && !(p & M) && (M = S & -S, P = p & -p, M >= P || M === 16 && (P & 4194240) !== 0)) return p; if (S & 4 && (S |= E & 16), p = f.entangledLanes, p !== 0) for (f = f.entanglements, p &= S; 0 < p;)E = 31 - ea(p), M = 1 << E, S |= f[E], p &= ~M; return S } function Yp(f, p) { switch (f) { case 1: case 2: case 4: return p + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return p + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function jp(f, p) { for (var E = f.suspendedLanes, S = f.pingedLanes, M = f.expirationTimes, P = f.pendingLanes; 0 < P;) { var q = 31 - ea(P), se = 1 << q, Le = M[q]; Le === -1 ? (!(se & E) || se & S) && (M[q] = Yp(se, p)) : Le <= p && (f.expiredLanes |= se), P &= ~se } } function _n(f) { return f = f.pendingLanes & -1073741825, f !== 0 ? f : f & 1073741824 ? 1073741824 : 0 } function rd(f) { for (var p = [], E = 0; 31 > E; E++)p.push(f); return p } function Ul(f, p, E) { f.pendingLanes |= p, p !== 536870912 && (f.suspendedLanes = 0, f.pingedLanes = 0), f = f.eventTimes, p = 31 - ea(p), f[p] = E } function c2(f, p) { var E = f.pendingLanes & ~p; f.pendingLanes = p, f.suspendedLanes = 0, f.pingedLanes = 0, f.expiredLanes &= p, f.mutableReadLanes &= p, f.entangledLanes &= p, p = f.entanglements; var S = f.eventTimes; for (f = f.expirationTimes; 0 < E;) { var M = 31 - ea(E), P = 1 << M; p[M] = 0, S[M] = -1, f[M] = -1, E &= ~P } } function ku(f, p) { var E = f.entangledLanes |= p; for (f = f.entanglements; E;) { var S = 31 - ea(E), M = 1 << S; M & p | f[S] & p && (f[S] |= p), E &= ~M } } var Un = 0; function If(f) { return f &= -f, 1 < f ? 4 < f ? f & 268435455 ? 16 : 536870912 : 4 : 1 } var Gl = i.unstable_scheduleCallback, f2 = i.unstable_cancelCallback, h2 = i.unstable_shouldYield, wc = i.unstable_requestPaint, sr = i.unstable_now, Jp = i.unstable_ImmediatePriority, Mm = i.unstable_UserBlockingPriority, Kp = i.unstable_NormalPriority, Gs = i.unstable_IdlePriority, el = null, Ao = null; function a4(f) { if (Ao && typeof Ao.onCommitFiberRoot == "function") try { Ao.onCommitFiberRoot(el, f, void 0, (f.current.flags & 128) === 128) } catch { } } function d2(f, p) { return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p } var ws = typeof Object.is == "function" ? Object.is : d2, vo = null, Ic = !1, Mc = !1; function tl(f) { vo === null ? vo = [f] : vo.push(f) } function bm(f) { Ic = !0, tl(f) } function va() { if (!Mc && vo !== null) { Mc = !0; var f = 0, p = Un; try { var E = vo; for (Un = 1; f < E.length; f++) { var S = E[f]; do S = S(!0); while (S !== null) } vo = null, Ic = !1 } catch (M) { throw vo !== null && (vo = vo.slice(f + 1)), Gl(Jp, va), M } finally { Un = p, Mc = !1 } } return null } var o4 = o.ReactCurrentBatchConfig; function Mf(f, p) { if (ws(f, p)) return !0; if (typeof f != "object" || f === null || typeof p != "object" || p === null) return !1; var E = Object.keys(f), S = Object.keys(p); if (E.length !== S.length) return !1; for (S = 0; S < E.length; S++) { var M = E[S]; if (!oi.call(p, M) || !ws(f[M], p[M])) return !1 } return !0 } function l4(f) { switch (f.tag) { case 5: return pt(f.type); case 16: return pt("Lazy"); case 13: return pt("Suspense"); case 19: return pt("SuspenseList"); case 0: case 2: case 15: return f = Vn(f.type, !1), f; case 11: return f = Vn(f.type.render, !1), f; case 1: return f = Vn(f.type, !0), f; default: return "" } } function Is(f, p) { if (f && f.defaultProps) { p = s({}, p), f = f.defaultProps; for (var E in f) p[E] === void 0 && (p[E] = f[E]); return p } return p } var bc = gt(null), qp = null, Ql = null, Zp = null; function Bm() { Zp = Ql = qp = null } function Rm(f, p, E) { je ? (Lt(bc, p._currentValue), p._currentValue = E) : (Lt(bc, p._currentValue2), p._currentValue2 = E) } function $p(f) { var p = bc.current; an(bc), je ? f._currentValue = p : f._currentValue2 = p } function bf(f, p, E) { for (; f !== null;) { var S = f.alternate; if ((f.childLanes & p) !== p ? (f.childLanes |= p, S !== null && (S.childLanes |= p)) : S !== null && (S.childLanes & p) !== p && (S.childLanes |= p), f === E) break; f = f.return } } function Bc(f, p) { qp = f, Zp = Ql = null, f = f.dependencies, f !== null && f.firstContext !== null && (f.lanes & p && (So = !0), f.firstContext = null) } function $t(f) { var p = je ? f._currentValue : f._currentValue2; if (Zp !== f) if (f = { context: f, memoizedValue: p, next: null }, Ql === null) { if (qp === null) throw Error(a(308)); Ql = f, qp.dependencies = { lanes: 0, firstContext: f } } else Ql = Ql.next = f; return p } var yo = null, nl = !1; function Bf(f) { f.updateQueue = { baseState: f.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function p2(f, p) { f = f.updateQueue, p.updateQueue === f && (p.updateQueue = { baseState: f.baseState, firstBaseUpdate: f.firstBaseUpdate, lastBaseUpdate: f.lastBaseUpdate, shared: f.shared, effects: f.effects }) } function rl(f, p) { return { eventTime: f, lane: p, tag: 0, payload: null, callback: null, next: null } } function Nu(f, p) { var E = f.updateQueue; E !== null && (E = E.shared, $i !== null && f.mode & 1 && !(Mn & 2) ? (f = E.interleaved, f === null ? (p.next = p, yo === null ? yo = [E] : yo.push(E)) : (p.next = f.next, f.next = p), E.interleaved = p) : (f = E.pending, f === null ? p.next = p : (p.next = f.next, f.next = p), E.pending = p)) } function id(f, p, E) { if (p = p.updateQueue, p !== null && (p = p.shared, (E & 4194240) !== 0)) { var S = p.lanes; S &= f.pendingLanes, E |= S, p.lanes = E, ku(f, E) } } function Pm(f, p) { var E = f.updateQueue, S = f.alternate; if (S !== null && (S = S.updateQueue, E === S)) { var M = null, P = null; if (E = E.firstBaseUpdate, E !== null) { do { var q = { eventTime: E.eventTime, lane: E.lane, tag: E.tag, payload: E.payload, callback: E.callback, next: null }; P === null ? M = P = q : P = P.next = q, E = E.next } while (E !== null); P === null ? M = P = p : P = P.next = p } else M = P = p; E = { baseState: S.baseState, firstBaseUpdate: M, lastBaseUpdate: P, shared: S.shared, effects: S.effects }, f.updateQueue = E; return } f = E.lastBaseUpdate, f === null ? E.firstBaseUpdate = p : f.next = p, E.lastBaseUpdate = p } function e0(f, p, E, S) { var M = f.updateQueue; nl = !1; var P = M.firstBaseUpdate, q = M.lastBaseUpdate, se = M.shared.pending; if (se !== null) { M.shared.pending = null; var Le = se, et = Le.next; Le.next = null, q === null ? P = et : q.next = et, q = Le; var It = f.alternate; It !== null && (It = It.updateQueue, se = It.lastBaseUpdate, se !== q && (se === null ? It.firstBaseUpdate = et : se.next = et, It.lastBaseUpdate = Le)) } if (P !== null) { var vn = M.baseState; q = 0, It = et = Le = null, se = P; do { var Kt = se.lane, Cr = se.eventTime; if ((S & Kt) === Kt) { It !== null && (It = It.next = { eventTime: Cr, lane: 0, tag: se.tag, payload: se.payload, callback: se.callback, next: null }); e: { var Ut = f, ia = se; switch (Kt = p, Cr = E, ia.tag) { case 1: if (Ut = ia.payload, typeof Ut == "function") { vn = Ut.call(Cr, vn, Kt); break e } vn = Ut; break e; case 3: Ut.flags = Ut.flags & -65537 | 128; case 0: if (Ut = ia.payload, Kt = typeof Ut == "function" ? Ut.call(Cr, vn, Kt) : Ut, Kt == null) break e; vn = s({}, vn, Kt); break e; case 2: nl = !0 } } se.callback !== null && se.lane !== 0 && (f.flags |= 64, Kt = M.effects, Kt === null ? M.effects = [se] : Kt.push(se)) } else Cr = { eventTime: Cr, lane: Kt, tag: se.tag, payload: se.payload, callback: se.callback, next: null }, It === null ? (et = It = Cr, Le = vn) : It = It.next = Cr, q |= Kt; if (se = se.next, se === null) { if (se = M.shared.pending, se === null) break; Kt = se, se = Kt.next, Kt.next = null, M.lastBaseUpdate = Kt, M.shared.pending = null } } while (1); if (It === null && (Le = vn), M.baseState = Le, M.firstBaseUpdate = et, M.lastBaseUpdate = It, p = M.shared.interleaved, p !== null) { M = p; do q |= M.lane, M = M.next; while (M !== p) } else P === null && (M.shared.lanes = 0); i0 |= q, f.lanes = q, f.memoizedState = vn } } function pe(f, p, E) { if (f = p.effects, p.effects = null, f !== null) for (p = 0; p < f.length; p++) { var S = f[p], M = S.callback; if (M !== null) { if (S.callback = null, S = E, typeof M != "function") throw Error(a(191, M)); M.call(S) } } } var k = new r.Component().refs; function te(f, p, E, S) { p = f.memoizedState, E = E(S, p), E = E == null ? p : s({}, p, E), f.memoizedState = E, f.lanes === 0 && (f.updateQueue.baseState = E) } var z = { isMounted: function (f) { return (f = f._reactInternals) ? b(f) === f : !1 }, enqueueSetState: function (f, p, E) { f = f._reactInternals; var S = Ta(), M = Df(f), P = rl(S, M); P.payload = p, E != null && (P.callback = E), Nu(f, P), p = al(f, M, S), p !== null && id(p, f, M) }, enqueueReplaceState: function (f, p, E) { f = f._reactInternals; var S = Ta(), M = Df(f), P = rl(S, M); P.tag = 1, P.payload = p, E != null && (P.callback = E), Nu(f, P), p = al(f, M, S), p !== null && id(p, f, M) }, enqueueForceUpdate: function (f, p) { f = f._reactInternals; var E = Ta(), S = Df(f), M = rl(E, S); M.tag = 2, p != null && (M.callback = p), Nu(f, M), p = al(f, S, E), p !== null && id(p, f, S) } }; function W(f, p, E, S, M, P, q) { return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(S, P, q) : p.prototype && p.prototype.isPureReactComponent ? !Mf(E, S) || !Mf(M, P) : !0 } function le(f, p, E) { var S = !1, M = Xi, P = p.contextType; return typeof P == "object" && P !== null ? P = $t(P) : (M = ir(p) ? go : Rn.current, S = p.contextTypes, P = (S = S != null) ? Wr(f, M) : Xi), p = new p(E, P), f.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = z, f.stateNode = p, p._reactInternals = f, S && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = M, f.__reactInternalMemoizedMaskedChildContext = P), p } function Pe(f, p, E, S) { f = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(E, S), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(E, S), p.state !== f && z.enqueueReplaceState(p, p.state, null) } function ye(f, p, E, S) { var M = f.stateNode; M.props = E, M.state = f.memoizedState, M.refs = k, Bf(f); var P = p.contextType; typeof P == "object" && P !== null ? M.context = $t(P) : (P = ir(p) ? go : Rn.current, M.context = Wr(f, P)), M.state = f.memoizedState, P = p.getDerivedStateFromProps, typeof P == "function" && (te(f, p, P, E), M.state = f.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function" || typeof M.UNSAFE_componentWillMount != "function" && typeof M.componentWillMount != "function" || (p = M.state, typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount(), p !== M.state && z.enqueueReplaceState(M, M.state, null), e0(f, E, M, S), M.state = f.memoizedState), typeof M.componentDidMount == "function" && (f.flags |= 4194308) } var lt = [], Jt = 0, Pn = null, Dn = 0, Tt = [], He = 0, kt = null, cr = 1, Wn = ""; function _r(f, p) { lt[Jt++] = Dn, lt[Jt++] = Pn, Pn = f, Dn = p } function br(f, p, E) { Tt[He++] = cr, Tt[He++] = Wn, Tt[He++] = kt, kt = f; var S = cr; f = Wn; var M = 32 - ea(S) - 1; S &= ~(1 << M), E += 1; var P = 32 - ea(p) + M; if (30 < P) { var q = M - M % 5; P = (S & (1 << q) - 1).toString(32), S >>= q, M -= q, cr = 1 << 32 - ea(p) + M | E << M | S, Wn = P + f } else cr = 1 << P | E << M | S, Wn = f } function ki(f) { f.return !== null && (_r(f, 1), br(f, 1, 0)) } function dn(f) { for (; f === Pn;)Pn = lt[--Jt], lt[Jt] = null, Dn = lt[--Jt], lt[Jt] = null; for (; f === kt;)kt = Tt[--He], Tt[He] = null, Wn = Tt[--He], Tt[He] = null, cr = Tt[--He], Tt[He] = null } var Br = null, bn = null, _t = !1, Ni = !1, Rr = null; function Wt(f, p) { var E = ol(5, null, null, 0); E.elementType = "DELETED", E.stateNode = p, E.return = f, p = f.deletions, p === null ? (f.deletions = [E], f.flags |= 16) : p.push(E) } function Ji(f, p) { switch (f.tag) { case 5: return p = Qt(p, f.type, f.pendingProps), p !== null ? (f.stateNode = p, Br = f, bn = vr(p), !0) : !1; case 6: return p = ft(p, f.pendingProps), p !== null ? (f.stateNode = p, Br = f, bn = null, !0) : !1; case 13: if (p = xn(p), p !== null) { var E = kt !== null ? { id: cr, overflow: Wn } : null; return f.memoizedState = { dehydrated: p, treeContext: E, retryLane: 1073741824 }, E = ol(18, null, null, 0), E.stateNode = p, E.return = f, f.child = E, Br = f, bn = null, !0 } return !1; default: return !1 } } function en(f) { return (f.mode & 1) !== 0 && (f.flags & 128) === 0 } function xo(f) { if (_t) { var p = bn; if (p) { var E = p; if (!Ji(f, p)) { if (en(f)) throw Error(a(418)); p = sn(E); var S = Br; p && Ji(f, p) ? Wt(S, E) : (f.flags = f.flags & -4097 | 2, _t = !1, Br = f) } } else { if (en(f)) throw Error(a(418)); f.flags = f.flags & -4097 | 2, _t = !1, Br = f } } } function xi(f) { for (f = f.return; f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;)f = f.return; Br = f } function Oi(f) { if (!de || f !== Br) return !1; if (!_t) return xi(f), _t = !0, !1; if (f.tag !== 3 && (f.tag !== 5 || Ct(f.type) && !Be(f.type, f.memoizedProps))) { var p = bn; if (p) { if (en(f)) { for (f = bn; f;)f = sn(f); throw Error(a(418)) } for (; p;)Wt(f, p), p = sn(p) } } if (xi(f), f.tag === 13) { if (!de) throw Error(a(316)); if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(a(317)); bn = ve(f) } else bn = Br ? sn(f.stateNode) : null; return !0 } function _i() { de && (bn = Br = null, Ni = _t = !1) } function fr(f) { Rr === null ? Rr = [f] : Rr.push(f) } function Pr(f, p, E) { if (f = E.ref, f !== null && typeof f != "function" && typeof f != "object") { if (E._owner) { if (E = E._owner, E) { if (E.tag !== 1) throw Error(a(309)); var S = E.stateNode } if (!S) throw Error(a(147, f)); var M = S, P = "" + f; return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === P ? p.ref : (p = function (q) { var se = M.refs; se === k && (se = M.refs = {}), q === null ? delete se[P] : se[P] = q }, p._stringRef = P, p) } if (typeof f != "string") throw Error(a(284)); if (!E._owner) throw Error(a(290, f)) } return f } function Xr(f, p) { throw f = Object.prototype.toString.call(p), Error(a(31, f === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : f)) } function me(f) { var p = f._init; return p(f._payload) } function Ei(f) { function p(_e, ce) { if (f) { var Me = _e.deletions; Me === null ? (_e.deletions = [ce], _e.flags |= 16) : Me.push(ce) } } function E(_e, ce) { if (!f) return null; for (; ce !== null;)p(_e, ce), ce = ce.sibling; return null } function S(_e, ce) { for (_e = new Map; ce !== null;)ce.key !== null ? _e.set(ce.key, ce) : _e.set(ce.index, ce), ce = ce.sibling; return _e } function M(_e, ce) { return _e = Ff(_e, ce), _e.index = 0, _e.sibling = null, _e } function P(_e, ce, Me) { return _e.index = Me, f ? (Me = _e.alternate, Me !== null ? (Me = Me.index, Me < ce ? (_e.flags |= 2, ce) : Me) : (_e.flags |= 2, ce)) : (_e.flags |= 1048576, ce) } function q(_e) { return f && _e.alternate === null && (_e.flags |= 2), _e } function se(_e, ce, Me, At) { return ce === null || ce.tag !== 6 ? (ce = D4(Me, _e.mode, At), ce.return = _e, ce) : (ce = M(ce, Me), ce.return = _e, ce) } function Le(_e, ce, Me, At) { var Ot = Me.type; return Ot === c ? It(_e, ce, Me.props.children, At, Me.key) : ce !== null && (ce.elementType === Ot || typeof Ot == "object" && Ot !== null && Ot.$$typeof === x && me(Ot) === ce.type) ? (At = M(ce, Me.props), At.ref = Pr(_e, ce, Me), At.return = _e, At) : (At = k2(Me.type, Me.key, Me.props, null, _e.mode, At), At.ref = Pr(_e, ce, Me), At.return = _e, At) } function et(_e, ce, Me, At) { return ce === null || ce.tag !== 4 || ce.stateNode.containerInfo !== Me.containerInfo || ce.stateNode.implementation !== Me.implementation ? (ce = L4(Me, _e.mode, At), ce.return = _e, ce) : (ce = M(ce, Me.children || []), ce.return = _e, ce) } function It(_e, ce, Me, At, Ot) { return ce === null || ce.tag !== 7 ? (ce = cd(Me, _e.mode, At, Ot), ce.return = _e, ce) : (ce = M(ce, Me), ce.return = _e, ce) } function vn(_e, ce, Me) { if (typeof ce == "string" && ce !== "" || typeof ce == "number") return ce = D4("" + ce, _e.mode, Me), ce.return = _e, ce; if (typeof ce == "object" && ce !== null) { switch (ce.$$typeof) { case l: return Me = k2(ce.type, ce.key, ce.props, null, _e.mode, Me), Me.ref = Pr(_e, null, ce), Me.return = _e, Me; case u: return ce = L4(ce, _e.mode, Me), ce.return = _e, ce; case x: var At = ce._init; return vn(_e, At(ce._payload), Me) }if (Z(ce) || I(ce)) return ce = cd(ce, _e.mode, Me, null), ce.return = _e, ce; Xr(_e, ce) } return null } function Kt(_e, ce, Me, At) { var Ot = ce !== null ? ce.key : null; if (typeof Me == "string" && Me !== "" || typeof Me == "number") return Ot !== null ? null : se(_e, ce, "" + Me, At); if (typeof Me == "object" && Me !== null) { switch (Me.$$typeof) { case l: return Me.key === Ot ? Le(_e, ce, Me, At) : null; case u: return Me.key === Ot ? et(_e, ce, Me, At) : null; case x: return Ot = Me._init, Kt(_e, ce, Ot(Me._payload), At) }if (Z(Me) || I(Me)) return Ot !== null ? null : It(_e, ce, Me, At, null); Xr(_e, Me) } return null } function Cr(_e, ce, Me, At, Ot) { if (typeof At == "string" && At !== "" || typeof At == "number") return _e = _e.get(Me) || null, se(ce, _e, "" + At, Ot); if (typeof At == "object" && At !== null) { switch (At.$$typeof) { case l: return _e = _e.get(At.key === null ? Me : At.key) || null, Le(ce, _e, At, Ot); case u: return _e = _e.get(At.key === null ? Me : At.key) || null, et(ce, _e, At, Ot); case x: var wn = At._init; return Cr(_e, ce, Me, wn(At._payload), Ot) }if (Z(At) || I(At)) return _e = _e.get(Me) || null, It(ce, _e, At, Ot, null); Xr(ce, At) } return null } function Ut(_e, ce, Me, At) { for (var Ot = null, wn = null, yn = ce, ar = ce = 0, Rs = null; yn !== null && ar < Me.length; ar++) { yn.index > ar ? (Rs = yn, yn = null) : Rs = yn.sibling; var or = Kt(_e, yn, Me[ar], At); if (or === null) { yn === null && (yn = Rs); break } f && yn && or.alternate === null && p(_e, yn), ce = P(or, ce, ar), wn === null ? Ot = or : wn.sibling = or, wn = or, yn = Rs } if (ar === Me.length) return E(_e, yn), _t && _r(_e, ar), Ot; if (yn === null) { for (; ar < Me.length; ar++)yn = vn(_e, Me[ar], At), yn !== null && (ce = P(yn, ce, ar), wn === null ? Ot = yn : wn.sibling = yn, wn = yn); return _t && _r(_e, ar), Ot } for (yn = S(_e, yn); ar < Me.length; ar++)Rs = Cr(yn, _e, ar, Me[ar], At), Rs !== null && (f && Rs.alternate !== null && yn.delete(Rs.key === null ? ar : Rs.key), ce = P(Rs, ce, ar), wn === null ? Ot = Rs : wn.sibling = Rs, wn = Rs); return f && yn.forEach(function (kf) { return p(_e, kf) }), _t && _r(_e, ar), Ot } function ia(_e, ce, Me, At) { var Ot = I(Me); if (typeof Ot != "function") throw Error(a(150)); if (Me = Ot.call(Me), Me == null) throw Error(a(151)); for (var wn = Ot = null, yn = ce, ar = ce = 0, Rs = null, or = Me.next(); yn !== null && !or.done; ar++, or = Me.next()) { yn.index > ar ? (Rs = yn, yn = null) : Rs = yn.sibling; var kf = Kt(_e, yn, or.value, At); if (kf === null) { yn === null && (yn = Rs); break } f && yn && kf.alternate === null && p(_e, yn), ce = P(kf, ce, ar), wn === null ? Ot = kf : wn.sibling = kf, wn = kf, yn = Rs } if (or.done) return E(_e, yn), _t && _r(_e, ar), Ot; if (yn === null) { for (; !or.done; ar++, or = Me.next())or = vn(_e, or.value, At), or !== null && (ce = P(or, ce, ar), wn === null ? Ot = or : wn.sibling = or, wn = or); return _t && _r(_e, ar), Ot } for (yn = S(_e, yn); !or.done; ar++, or = Me.next())or = Cr(yn, _e, ar, or.value, At), or !== null && (f && or.alternate !== null && yn.delete(or.key === null ? ar : or.key), ce = P(or, ce, ar), wn === null ? Ot = or : wn.sibling = or, wn = or); return f && yn.forEach(function (WH) { return p(_e, WH) }), _t && _r(_e, ar), Ot } function ll(_e, ce, Me, At) { if (typeof Me == "object" && Me !== null && Me.type === c && Me.key === null && (Me = Me.props.children), typeof Me == "object" && Me !== null) { switch (Me.$$typeof) { case l: e: { for (var Ot = Me.key, wn = ce; wn !== null;) { if (wn.key === Ot) { if (Ot = Me.type, Ot === c) { if (wn.tag === 7) { E(_e, wn.sibling), ce = M(wn, Me.props.children), ce.return = _e, _e = ce; break e } } else if (wn.elementType === Ot || typeof Ot == "object" && Ot !== null && Ot.$$typeof === x && me(Ot) === wn.type) { E(_e, wn.sibling), ce = M(wn, Me.props), ce.ref = Pr(_e, wn, Me), ce.return = _e, _e = ce; break e } E(_e, wn); break } else p(_e, wn); wn = wn.sibling } Me.type === c ? (ce = cd(Me.props.children, _e.mode, At, Me.key), ce.return = _e, _e = ce) : (At = k2(Me.type, Me.key, Me.props, null, _e.mode, At), At.ref = Pr(_e, ce, Me), At.return = _e, _e = At) } return q(_e); case u: e: { for (wn = Me.key; ce !== null;) { if (ce.key === wn) if (ce.tag === 4 && ce.stateNode.containerInfo === Me.containerInfo && ce.stateNode.implementation === Me.implementation) { E(_e, ce.sibling), ce = M(ce, Me.children || []), ce.return = _e, _e = ce; break e } else { E(_e, ce); break } else p(_e, ce); ce = ce.sibling } ce = L4(Me, _e.mode, At), ce.return = _e, _e = ce } return q(_e); case x: return wn = Me._init, ll(_e, ce, wn(Me._payload), At) }if (Z(Me)) return Ut(_e, ce, Me, At); if (I(Me)) return ia(_e, ce, Me, At); Xr(_e, Me) } return typeof Me == "string" && Me !== "" || typeof Me == "number" ? (Me = "" + Me, ce !== null && ce.tag === 6 ? (E(_e, ce.sibling), ce = M(ce, Me), ce.return = _e, _e = ce) : (E(_e, ce), ce = D4(Me, _e.mode, At), ce.return = _e, _e = ce), q(_e)) : E(_e, ce) } return ll } var Va = Ei(!0), Hl = Ei(!1), Ms = {}, Ci = gt(Ms), Ui = gt(Ms), Er = gt(Ms); function Dr(f) { if (f === Ms) throw Error(a(174)); return f } function Ki(f, p) { Lt(Er, p), Lt(Ui, f), Lt(Ci, Ms), f = $(p), an(Ci), Lt(Ci, f) } function ya() { an(Ci), an(Ui), an(Er) } function Qs(f) { var p = Dr(Er.current), E = Dr(Ci.current); p = L(E, f.type, p), E !== p && (Lt(Ui, f), Lt(Ci, p)) } function Wa(f) { Ui.current === f && (an(Ci), an(Ui)) } var Ht = gt(0); function Yr(f) { for (var p = f; p !== null;) { if (p.tag === 13) { var E = p.memoizedState; if (E !== null && (E = E.dehydrated, E === null || Vt(E) || Yt(E))) return p } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) { if (p.flags & 128) return p } else if (p.child !== null) { p.child.return = p, p = p.child; continue } if (p === f) break; for (; p.sibling === null;) { if (p.return === null || p.return === f) return null; p = p.return } p.sibling.return = p.return, p = p.sibling } return null } var bs = []; function Hs() { for (var f = 0; f < bs.length; f++) { var p = bs[f]; je ? p._workInProgressVersionPrimary = null : p._workInProgressVersionSecondary = null } bs.length = 0 } var Re = o.ReactCurrentDispatcher, Lr = o.ReactCurrentBatchConfig, ta = 0, hr = null, Ln = null, Fr = null, il = !1, zl = !1, li = 0, ui = 0; function yr() { throw Error(a(321)) } function xa(f, p) { if (p === null) return !1; for (var E = 0; E < p.length && E < f.length; E++)if (!ws(f[E], p[E])) return !1; return !0 } function Vl(f, p, E, S, M, P) { if (ta = P, hr = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, Re.current = f === null || f.memoizedState === null ? sl : Ca, f = E(S, M), zl) { P = 0; do { if (zl = !1, li = 0, 25 <= P) throw Error(a(301)); P += 1, Fr = Ln = null, p.updateQueue = null, Re.current = us, f = E(S, M) } while (zl) } if (Re.current = Bs, p = Ln !== null && Ln.next !== null, ta = 0, Fr = Ln = hr = null, il = !1, p) throw Error(a(300)); return f } function _o() { var f = li !== 0; return li = 0, f } function qi() { var f = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Fr === null ? hr.memoizedState = Fr = f : Fr = Fr.next = f, Fr } function jr() { if (Ln === null) { var f = hr.alternate; f = f !== null ? f.memoizedState : null } else f = Ln.next; var p = Fr === null ? hr.memoizedState : Fr.next; if (p !== null) Fr = p, Ln = f; else { if (f === null) throw Error(a(310)); Ln = f, f = { memoizedState: Ln.memoizedState, baseState: Ln.baseState, baseQueue: Ln.baseQueue, queue: Ln.queue, next: null }, Fr === null ? hr.memoizedState = Fr = f : Fr = Fr.next = f } return Fr } function _a(f, p) { return typeof p == "function" ? p(f) : p } function Wl(f) { var p = jr(), E = p.queue; if (E === null) throw Error(a(311)); E.lastRenderedReducer = f; var S = Ln, M = S.baseQueue, P = E.pending; if (P !== null) { if (M !== null) { var q = M.next; M.next = P.next, P.next = q } S.baseQueue = M = P, E.pending = null } if (M !== null) { P = M.next, S = S.baseState; var se = q = null, Le = null, et = P; do { var It = et.lane; if ((ta & It) === It) Le !== null && (Le = Le.next = { lane: 0, action: et.action, hasEagerState: et.hasEagerState, eagerState: et.eagerState, next: null }), S = et.hasEagerState ? et.eagerState : f(S, et.action); else { var vn = { lane: It, action: et.action, hasEagerState: et.hasEagerState, eagerState: et.eagerState, next: null }; Le === null ? (se = Le = vn, q = S) : Le = Le.next = vn, hr.lanes |= It, i0 |= It } et = et.next } while (et !== null && et !== P); Le === null ? q = S : Le.next = se, ws(S, p.memoizedState) || (So = !0), p.memoizedState = S, p.baseState = q, p.baseQueue = Le, E.lastRenderedState = S } if (f = E.interleaved, f !== null) { M = f; do P = M.lane, hr.lanes |= P, i0 |= P, M = M.next; while (M !== f) } else M === null && (E.lanes = 0); return [p.memoizedState, E.dispatch] } function Xl(f) { var p = jr(), E = p.queue; if (E === null) throw Error(a(311)); E.lastRenderedReducer = f; var S = E.dispatch, M = E.pending, P = p.memoizedState; if (M !== null) { E.pending = null; var q = M = M.next; do P = f(P, q.action), q = q.next; while (q !== M); ws(P, p.memoizedState) || (So = !0), p.memoizedState = P, p.baseQueue === null && (p.baseState = P), E.lastRenderedState = P } return [P, S] } function Ou() { } function Yl(f, p) { var E = hr, S = jr(), M = p(), P = !ws(S.memoizedState, M); if (P && (S.memoizedState = M, So = !0), S = S.queue, zt(Uu.bind(null, E, S, f), [f]), S.getSnapshot !== p || P || Fr !== null && Fr.memoizedState.tag & 1) { if (E.flags |= 2048, zs(9, Gn.bind(null, E, S, M, p), void 0, null), $i === null) throw Error(a(349)); ta & 30 || jl(E, p, M) } return M } function jl(f, p, E) { f.flags |= 16384, f = { getSnapshot: p, value: E }, p = hr.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, hr.updateQueue = p, p.stores = [f]) : (E = p.stores, E === null ? p.stores = [f] : E.push(f)) } function Gn(f, p, E, S) { p.value = E, p.getSnapshot = S, Xa(p) && al(f, 1, -1) } function Uu(f, p, E) { return E(function () { Xa(p) && al(f, 1, -1) }) } function Xa(f) { var p = f.getSnapshot; f = f.value; try { var E = p(); return !ws(f, E) } catch { return !0 } } function Ea(f) { var p = qi(); return typeof f == "function" && (f = f()), p.memoizedState = p.baseState = f, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: _a, lastRenderedState: f }, p.queue = f, f = f.dispatch = ls.bind(null, hr, f), [p.memoizedState, f] } function zs(f, p, E, S) { return f = { tag: f, create: p, destroy: E, deps: S, next: null }, p = hr.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, hr.updateQueue = p, p.lastEffect = f.next = f) : (E = p.lastEffect, E === null ? p.lastEffect = f.next = f : (S = E.next, E.next = f, f.next = S, p.lastEffect = f)), f } function Gu() { return jr().memoizedState } function Jl(f, p, E, S) { var M = qi(); hr.flags |= f, M.memoizedState = zs(1 | p, E, void 0, S === void 0 ? null : S) } function Ya(f, p, E, S) { var M = jr(); S = S === void 0 ? null : S; var P = void 0; if (Ln !== null) { var q = Ln.memoizedState; if (P = q.destroy, S !== null && xa(S, q.deps)) { M.memoizedState = zs(p, E, P, S); return } } hr.flags |= f, M.memoizedState = zs(1 | p, E, P, S) } function un(f, p) { return Jl(8390656, 8, f, p) } function zt(f, p) { return Ya(2048, 8, f, p) } function qn(f, p) { return Ya(4, 2, f, p) } function Jr(f, p) { return Ya(4, 4, f, p) } function Et(f, p) { if (typeof p == "function") return f = f(), p(f), function () { p(null) }; if (p != null) return f = f(), p.current = f, function () { p.current = null } } function Fn(f, p, E) { return E = E != null ? E.concat([f]) : null, Ya(4, 4, Et.bind(null, p, f), E) } function qt() { } function Tn(f, p) { var E = jr(); p = p === void 0 ? null : p; var S = E.memoizedState; return S !== null && p !== null && xa(p, S[1]) ? S[0] : (E.memoizedState = [f, p], f) } function Gi(f, p) { var E = jr(); p = p === void 0 ? null : p; var S = E.memoizedState; return S !== null && p !== null && xa(p, S[1]) ? S[0] : (f = f(), E.memoizedState = [f, p], f) } function Xn(f, p) { var E = Un; Un = E !== 0 && 4 > E ? E : 4, f(!0); var S = Lr.transition; Lr.transition = {}; try { f(!1), p() } finally { Un = E, Lr.transition = S } } function ii() { return jr().memoizedState } function Vs(f, p, E) { var S = Df(f); E = { lane: S, action: E, hasEagerState: !1, eagerState: null, next: null }, kr(f) ? dr(p, E) : (ja(f, p, E), E = Ta(), f = al(f, S, E), f !== null && Nr(f, p, S)) } function ls(f, p, E) { var S = Df(f), M = { lane: S, action: E, hasEagerState: !1, eagerState: null, next: null }; if (kr(f)) dr(p, M); else { ja(f, p, M); var P = f.alternate; if (f.lanes === 0 && (P === null || P.lanes === 0) && (P = p.lastRenderedReducer, P !== null)) try { var q = p.lastRenderedState, se = P(q, E); if (M.hasEagerState = !0, M.eagerState = se, ws(se, q)) return } catch { } finally { } E = Ta(), f = al(f, S, E), f !== null && Nr(f, p, S) } } function kr(f) { var p = f.alternate; return f === hr || p !== null && p === hr } function dr(f, p) { zl = il = !0; var E = f.pending; E === null ? p.next = p : (p.next = E.next, E.next = p), f.pending = p } function ja(f, p, E) { $i !== null && f.mode & 1 && !(Mn & 2) ? (f = p.interleaved, f === null ? (E.next = E, yo === null ? yo = [p] : yo.push(p)) : (E.next = f.next, f.next = E), p.interleaved = E) : (f = p.pending, f === null ? E.next = E : (E.next = f.next, f.next = E), p.pending = E) } function Nr(f, p, E) { if (E & 4194240) { var S = p.lanes; S &= f.pendingLanes, E |= S, p.lanes = E, ku(f, E) } } var Bs = { readContext: $t, useCallback: yr, useContext: yr, useEffect: yr, useImperativeHandle: yr, useInsertionEffect: yr, useLayoutEffect: yr, useMemo: yr, useReducer: yr, useRef: yr, useState: yr, useDebugValue: yr, useDeferredValue: yr, useTransition: yr, useMutableSource: yr, useSyncExternalStore: yr, useId: yr, unstable_isNewReconciler: !1 }, sl = { readContext: $t, useCallback: function (f, p) { return qi().memoizedState = [f, p === void 0 ? null : p], f }, useContext: $t, useEffect: un, useImperativeHandle: function (f, p, E) { return E = E != null ? E.concat([f]) : null, Jl(4194308, 4, Et.bind(null, p, f), E) }, useLayoutEffect: function (f, p) { return Jl(4194308, 4, f, p) }, useInsertionEffect: function (f, p) { return Jl(4, 2, f, p) }, useMemo: function (f, p) { var E = qi(); return p = p === void 0 ? null : p, f = f(), E.memoizedState = [f, p], f }, useReducer: function (f, p, E) { var S = qi(); return p = E !== void 0 ? E(p) : p, S.memoizedState = S.baseState = p, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: f, lastRenderedState: p }, S.queue = f, f = f.dispatch = Vs.bind(null, hr, f), [S.memoizedState, f] }, useRef: function (f) { var p = qi(); return f = { current: f }, p.memoizedState = f }, useState: Ea, useDebugValue: qt, useDeferredValue: function (f) { var p = Ea(f), E = p[0], S = p[1]; return un(function () { var M = Lr.transition; Lr.transition = {}; try { S(f) } finally { Lr.transition = M } }, [f]), E }, useTransition: function () { var f = Ea(!1), p = f[0]; return f = Xn.bind(null, f[1]), qi().memoizedState = f, [p, f] }, useMutableSource: function () { }, useSyncExternalStore: function (f, p, E) { var S = hr, M = qi(); if (_t) { if (E === void 0) throw Error(a(407)); E = E() } else { if (E = p(), $i === null) throw Error(a(349)); ta & 30 || jl(S, p, E) } M.memoizedState = E; var P = { value: E, getSnapshot: p }; return M.queue = P, un(Uu.bind(null, S, P, f), [f]), S.flags |= 2048, zs(9, Gn.bind(null, S, P, E, p), void 0, null), E }, useId: function () { var f = qi(), p = $i.identifierPrefix; if (_t) { var E = Wn, S = cr; E = (S & ~(1 << 32 - ea(S) - 1)).toString(32) + E, p = ":" + p + "R" + E, E = li++, 0 < E && (p += "H" + E.toString(32)), p += ":" } else E = ui++, p = ":" + p + "r" + E.toString(32) + ":"; return f.memoizedState = p }, unstable_isNewReconciler: !1 }, Ca = { readContext: $t, useCallback: Tn, useContext: $t, useEffect: zt, useImperativeHandle: Fn, useInsertionEffect: qn, useLayoutEffect: Jr, useMemo: Gi, useReducer: Wl, useRef: Gu, useState: function () { return Wl(_a) }, useDebugValue: qt, useDeferredValue: function (f) { var p = Wl(_a), E = p[0], S = p[1]; return zt(function () { var M = Lr.transition; Lr.transition = {}; try { S(f) } finally { Lr.transition = M } }, [f]), E }, useTransition: function () { var f = Wl(_a)[0], p = jr().memoizedState; return [f, p] }, useMutableSource: Ou, useSyncExternalStore: Yl, useId: ii, unstable_isNewReconciler: !1 }, us = { readContext: $t, useCallback: Tn, useContext: $t, useEffect: zt, useImperativeHandle: Fn, useInsertionEffect: qn, useLayoutEffect: Jr, useMemo: Gi, useReducer: Xl, useRef: Gu, useState: function () { return Xl(_a) }, useDebugValue: qt, useDeferredValue: function (f) { var p = Xl(_a), E = p[0], S = p[1]; return zt(function () { var M = Lr.transition; Lr.transition = {}; try { S(f) } finally { Lr.transition = M } }, [f]), E }, useTransition: function () { var f = Xl(_a)[0], p = jr().memoizedState; return [f, p] }, useMutableSource: Ou, useSyncExternalStore: Yl, useId: ii, unstable_isNewReconciler: !1 }; function Zi(f, p) {
			try { var E = "", S = p; do E += l4(S), S = S.return; while (S); var M = E } catch (P) {
				M = `
Error generating stack: `+ P.message + `
`+ P.stack
			} return { value: f, source: p, stack: M }
		} function Kl(f, p) { try { console.error(p.value) } catch (E) { setTimeout(function () { throw E }) } } var t0 = typeof WeakMap == "function" ? WeakMap : Map; function cs(f, p, E) { E = rl(-1, E), E.tag = 3, E.payload = { element: null }; var S = p.value; return E.callback = function () { b2 || (b2 = !0, w4 = S), Kl(f, p) }, E } function Si(f, p, E) { E = rl(-1, E), E.tag = 3; var S = f.type.getDerivedStateFromError; if (typeof S == "function") { var M = p.value; E.payload = function () { return S(M) }, E.callback = function () { Kl(f, p) } } var P = f.stateNode; return P !== null && typeof P.componentDidCatch == "function" && (E.callback = function () { Kl(f, p), typeof S != "function" && (Rf === null ? Rf = new Set([this]) : Rf.add(this)); var q = p.stack; this.componentDidCatch(p.value, { componentStack: q !== null ? q : "" }) }), E } function Eo(f, p, E) { var S = f.pingCache; if (S === null) { S = f.pingCache = new t0; var M = new Set; S.set(p, M) } else M = S.get(p), M === void 0 && (M = new Set, S.set(p, M)); M.has(E) || (M.add(E), f = NH.bind(null, f, p, E), p.then(f, f)) } function n0(f) { do { var p; if ((p = f.tag === 13) && (p = f.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p) return f; f = f.return } while (f !== null); return null } function Dm(f, p, E, S, M) { return f.mode & 1 ? (f.flags |= 65536, f.lanes = M, f) : (f === p ? f.flags |= 65536 : (f.flags |= 128, E.flags |= 131072, E.flags &= -52805, E.tag === 1 && (E.alternate === null ? E.tag = 17 : (p = rl(-1, 1), p.tag = 2, Nu(E, p))), E.lanes |= 1), f) } function na(f) { f.flags |= 4 } function Co(f, p) { if (f !== null && f.child === p.child) return !0; if (p.flags & 16) return !1; for (f = p.child; f !== null;) { if (f.flags & 12854 || f.subtreeFlags & 12854) return !1; f = f.sibling } return !0 } var ql, Qu, Hu, m2; if (Oe) ql = function (f, p) { for (var E = p.child; E !== null;) { if (E.tag === 5 || E.tag === 6) J(f, E.stateNode); else if (E.tag !== 4 && E.child !== null) { E.child.return = E, E = E.child; continue } if (E === p) break; for (; E.sibling === null;) { if (E.return === null || E.return === p) return; E = E.return } E.sibling.return = E.return, E = E.sibling } }, Qu = function () { }, Hu = function (f, p, E, S, M) { if (f = f.memoizedProps, f !== S) { var P = p.stateNode, q = Dr(Ci.current); E = xe(P, E, f, S, M, q), (p.updateQueue = E) && na(p) } }, m2 = function (f, p, E, S) { E !== S && na(p) }; else if (K) { ql = function (f, p, E, S) { for (var M = p.child; M !== null;) { if (M.tag === 5) { var P = M.stateNode; E && S && (P = $e(P, M.type, M.memoizedProps, M)), J(f, P) } else if (M.tag === 6) P = M.stateNode, E && S && (P = Xt(P, M.memoizedProps, M)), J(f, P); else if (M.tag !== 4) { if (M.tag === 22 && M.memoizedState !== null) P = M.child, P !== null && (P.return = M), ql(f, M, !0, !0); else if (M.child !== null) { M.child.return = M, M = M.child; continue } } if (M === p) break; for (; M.sibling === null;) { if (M.return === null || M.return === p) return; M = M.return } M.sibling.return = M.return, M = M.sibling } }; var nw = function (f, p, E, S) { for (var M = p.child; M !== null;) { if (M.tag === 5) { var P = M.stateNode; E && S && (P = $e(P, M.type, M.memoizedProps, M)), ln(f, P) } else if (M.tag === 6) P = M.stateNode, E && S && (P = Xt(P, M.memoizedProps, M)), ln(f, P); else if (M.tag !== 4) { if (M.tag === 22 && M.memoizedState !== null) P = M.child, P !== null && (P.return = M), nw(f, M, !0, !0); else if (M.child !== null) { M.child.return = M, M = M.child; continue } } if (M === p) break; for (; M.sibling === null;) { if (M.return === null || M.return === p) return; M = M.return } M.sibling.return = M.return, M = M.sibling } }; Qu = function (f, p) { var E = p.stateNode; if (!Co(f, p)) { f = E.containerInfo; var S = jt(f); nw(S, p, !1, !1), E.pendingChildren = S, na(p), fn(f, S) } }, Hu = function (f, p, E, S, M) { var P = f.stateNode, q = f.memoizedProps; if ((f = Co(f, p)) && q === S) p.stateNode = P; else { var se = p.stateNode, Le = Dr(Ci.current), et = null; q !== S && (et = xe(se, E, q, S, M, Le)), f && et === null ? p.stateNode = P : (P = Ye(P, et, E, q, S, p, f, se), Ee(P, E, S, M, Le) && na(p), p.stateNode = P, f ? na(p) : ql(P, p, !1, !1)) } }, m2 = function (f, p, E, S) { E !== S ? (f = Dr(Er.current), E = Dr(Ci.current), p.stateNode = Fe(S, f, E, p), na(p)) : p.stateNode = f.stateNode } } else Qu = function () { }, Hu = function () { }, m2 = function () { }; function Lm(f, p) { if (!_t) switch (f.tailMode) { case "hidden": p = f.tail; for (var E = null; p !== null;)p.alternate !== null && (E = p), p = p.sibling; E === null ? f.tail = null : E.sibling = null; break; case "collapsed": E = f.tail; for (var S = null; E !== null;)E.alternate !== null && (S = E), E = E.sibling; S === null ? p || f.tail === null ? f.tail = null : f.tail.sibling = null : S.sibling = null } } function ra(f) { var p = f.alternate !== null && f.alternate.child === f.child, E = 0, S = 0; if (p) for (var M = f.child; M !== null;)E |= M.lanes | M.childLanes, S |= M.subtreeFlags & 14680064, S |= M.flags & 14680064, M.return = f, M = M.sibling; else for (M = f.child; M !== null;)E |= M.lanes | M.childLanes, S |= M.subtreeFlags, S |= M.flags, M.return = f, M = M.sibling; return f.subtreeFlags |= S, f.childLanes = E, p } function SH(f, p, E) { var S = p.pendingProps; switch (dn(p), p.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ra(p), null; case 1: return ir(p.type) && $o(), ra(p), null; case 3: return S = p.stateNode, ya(), an($n), an(Rn), Hs(), S.pendingContext && (S.context = S.pendingContext, S.pendingContext = null), (f === null || f.child === null) && (Oi(p) ? na(p) : f === null || f.memoizedState.isDehydrated && !(p.flags & 256) || (p.flags |= 1024, Rr !== null && (b4(Rr), Rr = null))), Qu(f, p), ra(p), null; case 5: Wa(p), E = Dr(Er.current); var M = p.type; if (f !== null && p.stateNode != null) Hu(f, p, M, S, E), f.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152); else { if (!S) { if (p.stateNode === null) throw Error(a(166)); return ra(p), null } if (f = Dr(Ci.current), Oi(p)) { if (!de) throw Error(a(175)); f = rr(p.stateNode, p.type, p.memoizedProps, E, f, p, !Ni), p.updateQueue = f, f !== null && na(p) } else { var P = V(M, S, E, f, p); ql(P, p, !1, !1), p.stateNode = P, Ee(P, M, S, E, f) && na(p) } p.ref !== null && (p.flags |= 512, p.flags |= 2097152) } return ra(p), null; case 6: if (f && p.stateNode != null) m2(f, p, f.memoizedProps, S); else { if (typeof S != "string" && p.stateNode === null) throw Error(a(166)); if (f = Dr(Er.current), E = Dr(Ci.current), Oi(p)) { if (!de) throw Error(a(176)); if (f = p.stateNode, S = p.memoizedProps, (E = H(f, S, p, !Ni)) && (M = Br, M !== null)) switch (P = (M.mode & 1) !== 0, M.tag) { case 3: Nt(M.stateNode.containerInfo, f, S, P); break; case 5: nn(M.type, M.memoizedProps, M.stateNode, f, S, P) }E && na(p) } else p.stateNode = Fe(S, f, E, p) } return ra(p), null; case 13: if (an(Ht), S = p.memoizedState, _t && bn !== null && p.mode & 1 && !(p.flags & 128)) { for (f = bn; f;)f = sn(f); return _i(), p.flags |= 98560, p } if (S !== null && S.dehydrated !== null) { if (S = Oi(p), f === null) { if (!S) throw Error(a(318)); if (!de) throw Error(a(344)); if (f = p.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(a(317)); ae(f, p) } else _i(), !(p.flags & 128) && (p.memoizedState = null), p.flags |= 4; return ra(p), null } return Rr !== null && (b4(Rr), Rr = null), p.flags & 128 ? (p.lanes = E, p) : (S = S !== null, E = !1, f === null ? Oi(p) : E = f.memoizedState !== null, S && !E && (p.child.flags |= 8192, p.mode & 1 && (f === null || Ht.current & 1 ? fs === 0 && (fs = 3) : R4())), p.updateQueue !== null && (p.flags |= 4), ra(p), null); case 4: return ya(), Qu(f, p), f === null && Qe(p.stateNode.containerInfo), ra(p), null; case 10: return $p(p.type._context), ra(p), null; case 17: return ir(p.type) && $o(), ra(p), null; case 19: if (an(Ht), M = p.memoizedState, M === null) return ra(p), null; if (S = (p.flags & 128) !== 0, P = M.rendering, P === null) if (S) Lm(M, !1); else { if (fs !== 0 || f !== null && f.flags & 128) for (f = p.child; f !== null;) { if (P = Yr(f), P !== null) { for (p.flags |= 128, Lm(M, !1), f = P.updateQueue, f !== null && (p.updateQueue = f, p.flags |= 4), p.subtreeFlags = 0, f = E, S = p.child; S !== null;)E = S, M = f, E.flags &= 14680066, P = E.alternate, P === null ? (E.childLanes = 0, E.lanes = M, E.child = null, E.subtreeFlags = 0, E.memoizedProps = null, E.memoizedState = null, E.updateQueue = null, E.dependencies = null, E.stateNode = null) : (E.childLanes = P.childLanes, E.lanes = P.lanes, E.child = P.child, E.subtreeFlags = 0, E.deletions = null, E.memoizedProps = P.memoizedProps, E.memoizedState = P.memoizedState, E.updateQueue = P.updateQueue, E.type = P.type, M = P.dependencies, E.dependencies = M === null ? null : { lanes: M.lanes, firstContext: M.firstContext }), S = S.sibling; return Lt(Ht, Ht.current & 1 | 2), p.child } f = f.sibling } M.tail !== null && sr() > T4 && (p.flags |= 128, S = !0, Lm(M, !1), p.lanes = 4194304) } else { if (!S) if (f = Yr(P), f !== null) { if (p.flags |= 128, S = !0, f = f.updateQueue, f !== null && (p.updateQueue = f, p.flags |= 4), Lm(M, !0), M.tail === null && M.tailMode === "hidden" && !P.alternate && !_t) return ra(p), null } else 2 * sr() - M.renderingStartTime > T4 && E !== 1073741824 && (p.flags |= 128, S = !0, Lm(M, !1), p.lanes = 4194304); M.isBackwards ? (P.sibling = p.child, p.child = P) : (f = M.last, f !== null ? f.sibling = P : p.child = P, M.last = P) } return M.tail !== null ? (p = M.tail, M.rendering = p, M.tail = p.sibling, M.renderingStartTime = sr(), p.sibling = null, f = Ht.current, Lt(Ht, S ? f & 1 | 2 : f & 1), p) : (ra(p), null); case 22: case 23: return B4(), S = p.memoizedState !== null, f !== null && f.memoizedState !== null !== S && (p.flags |= 8192), S && p.mode & 1 ? To & 1073741824 && (ra(p), Oe && p.subtreeFlags & 6 && (p.flags |= 8192)) : ra(p), null; case 24: return null; case 25: return null }throw Error(a(156, p.tag)) } var TH = o.ReactCurrentOwner, So = !1; function Sa(f, p, E, S) { p.child = f === null ? Hl(p, null, E, S) : Va(p, f.child, E, S) } function rw(f, p, E, S, M) { E = E.render; var P = p.ref; return Bc(p, M), S = Vl(f, p, E, S, P, M), E = _o(), f !== null && !So ? (p.updateQueue = f.updateQueue, p.flags &= -2053, f.lanes &= ~M, Rc(f, p, M)) : (_t && E && ki(p), p.flags |= 1, Sa(f, p, S, M), p.child) } function iw(f, p, E, S, M) { if (f === null) { var P = E.type; return typeof P == "function" && !P4(P) && P.defaultProps === void 0 && E.compare === null && E.defaultProps === void 0 ? (p.tag = 15, p.type = P, sw(f, p, P, S, M)) : (f = k2(E.type, null, S, p, p.mode, M), f.ref = p.ref, f.return = p, p.child = f) } if (P = f.child, !(f.lanes & M)) { var q = P.memoizedProps; if (E = E.compare, E = E !== null ? E : Mf, E(q, S) && f.ref === p.ref) return Rc(f, p, M) } return p.flags |= 1, f = Ff(P, S), f.ref = p.ref, f.return = p, p.child = f } function sw(f, p, E, S, M) { if (f !== null && Mf(f.memoizedProps, S) && f.ref === p.ref) if (So = !1, (f.lanes & M) !== 0) f.flags & 131072 && (So = !0); else return p.lanes = f.lanes, Rc(f, p, M); return u4(f, p, E, S, M) } function aw(f, p, E) { var S = p.pendingProps, M = S.children, P = f !== null ? f.memoizedState : null; if (S.mode === "hidden") if (!(p.mode & 1)) p.memoizedState = { baseLanes: 0, cachePool: null }, Lt(r0, To), To |= E; else if (E & 1073741824) p.memoizedState = { baseLanes: 0, cachePool: null }, S = P !== null ? P.baseLanes : E, Lt(r0, To), To |= S; else return f = P !== null ? P.baseLanes | E : E, p.lanes = p.childLanes = 1073741824, p.memoizedState = { baseLanes: f, cachePool: null }, p.updateQueue = null, Lt(r0, To), To |= f, null; else P !== null ? (S = P.baseLanes | E, p.memoizedState = null) : S = E, Lt(r0, To), To |= S; return Sa(f, p, M, E), p.child } function ow(f, p) { var E = p.ref; (f === null && E !== null || f !== null && f.ref !== E) && (p.flags |= 512, p.flags |= 2097152) } function u4(f, p, E, S, M) { var P = ir(E) ? go : Rn.current; return P = Wr(p, P), Bc(p, M), E = Vl(f, p, E, S, P, M), S = _o(), f !== null && !So ? (p.updateQueue = f.updateQueue, p.flags &= -2053, f.lanes &= ~M, Rc(f, p, M)) : (_t && S && ki(p), p.flags |= 1, Sa(f, p, E, M), p.child) } function lw(f, p, E, S, M) { if (ir(E)) { var P = !0; Lu(p) } else P = !1; if (Bc(p, M), p.stateNode === null) f !== null && (f.alternate = null, p.alternate = null, p.flags |= 2), le(p, E, S), ye(p, E, S, M), S = !0; else if (f === null) { var q = p.stateNode, se = p.memoizedProps; q.props = se; var Le = q.context, et = E.contextType; typeof et == "object" && et !== null ? et = $t(et) : (et = ir(E) ? go : Rn.current, et = Wr(p, et)); var It = E.getDerivedStateFromProps, vn = typeof It == "function" || typeof q.getSnapshotBeforeUpdate == "function"; vn || typeof q.UNSAFE_componentWillReceiveProps != "function" && typeof q.componentWillReceiveProps != "function" || (se !== S || Le !== et) && Pe(p, q, S, et), nl = !1; var Kt = p.memoizedState; q.state = Kt, e0(p, S, q, M), Le = p.memoizedState, se !== S || Kt !== Le || $n.current || nl ? (typeof It == "function" && (te(p, E, It, S), Le = p.memoizedState), (se = nl || W(p, E, se, S, Kt, Le, et)) ? (vn || typeof q.UNSAFE_componentWillMount != "function" && typeof q.componentWillMount != "function" || (typeof q.componentWillMount == "function" && q.componentWillMount(), typeof q.UNSAFE_componentWillMount == "function" && q.UNSAFE_componentWillMount()), typeof q.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof q.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = S, p.memoizedState = Le), q.props = S, q.state = Le, q.context = et, S = se) : (typeof q.componentDidMount == "function" && (p.flags |= 4194308), S = !1) } else { q = p.stateNode, p2(f, p), se = p.memoizedProps, et = p.type === p.elementType ? se : Is(p.type, se), q.props = et, vn = p.pendingProps, Kt = q.context, Le = E.contextType, typeof Le == "object" && Le !== null ? Le = $t(Le) : (Le = ir(E) ? go : Rn.current, Le = Wr(p, Le)); var Cr = E.getDerivedStateFromProps; (It = typeof Cr == "function" || typeof q.getSnapshotBeforeUpdate == "function") || typeof q.UNSAFE_componentWillReceiveProps != "function" && typeof q.componentWillReceiveProps != "function" || (se !== vn || Kt !== Le) && Pe(p, q, S, Le), nl = !1, Kt = p.memoizedState, q.state = Kt, e0(p, S, q, M); var Ut = p.memoizedState; se !== vn || Kt !== Ut || $n.current || nl ? (typeof Cr == "function" && (te(p, E, Cr, S), Ut = p.memoizedState), (et = nl || W(p, E, et, S, Kt, Ut, Le) || !1) ? (It || typeof q.UNSAFE_componentWillUpdate != "function" && typeof q.componentWillUpdate != "function" || (typeof q.componentWillUpdate == "function" && q.componentWillUpdate(S, Ut, Le), typeof q.UNSAFE_componentWillUpdate == "function" && q.UNSAFE_componentWillUpdate(S, Ut, Le)), typeof q.componentDidUpdate == "function" && (p.flags |= 4), typeof q.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof q.componentDidUpdate != "function" || se === f.memoizedProps && Kt === f.memoizedState || (p.flags |= 4), typeof q.getSnapshotBeforeUpdate != "function" || se === f.memoizedProps && Kt === f.memoizedState || (p.flags |= 1024), p.memoizedProps = S, p.memoizedState = Ut), q.props = S, q.state = Ut, q.context = Le, S = et) : (typeof q.componentDidUpdate != "function" || se === f.memoizedProps && Kt === f.memoizedState || (p.flags |= 4), typeof q.getSnapshotBeforeUpdate != "function" || se === f.memoizedProps && Kt === f.memoizedState || (p.flags |= 1024), S = !1) } return c4(f, p, E, S, P, M) } function c4(f, p, E, S, M, P) { ow(f, p); var q = (p.flags & 128) !== 0; if (!S && !q) return M && td(p, E, !1), Rc(f, p, P); S = p.stateNode, TH.current = p; var se = q && typeof E.getDerivedStateFromError != "function" ? null : S.render(); return p.flags |= 1, f !== null && q ? (p.child = Va(p, f.child, null, P), p.child = Va(p, null, se, P)) : Sa(f, p, se, P), p.memoizedState = S.state, M && td(p, E, !0), p.child } function uw(f) { var p = f.stateNode; p.pendingContext ? os(f, p.pendingContext, p.pendingContext !== p.context) : p.context && os(f, p.context, !1), Ki(f, p.containerInfo) } function cw(f, p, E, S, M) { return _i(), fr(M), p.flags |= 256, Sa(f, p, E, S), p.child } var g2 = { dehydrated: null, treeContext: null, retryLane: 0 }; function A2(f) { return { baseLanes: f, cachePool: null } } function fw(f, p, E) { var S = p.pendingProps, M = Ht.current, P = !1, q = (p.flags & 128) !== 0, se; if ((se = q) || (se = f !== null && f.memoizedState === null ? !1 : (M & 2) !== 0), se ? (P = !0, p.flags &= -129) : (f === null || f.memoizedState !== null) && (M |= 1), Lt(Ht, M & 1), f === null) return xo(p), f = p.memoizedState, f !== null && (f = f.dehydrated, f !== null) ? (p.mode & 1 ? Yt(f) ? p.lanes = 8 : p.lanes = 1073741824 : p.lanes = 1, null) : (M = S.children, f = S.fallback, P ? (S = p.mode, P = p.child, M = { mode: "hidden", children: M }, !(S & 1) && P !== null ? (P.childLanes = 0, P.pendingProps = M) : P = N2(M, S, 0, null), f = cd(f, S, E, null), P.return = p, f.return = p, P.sibling = f, p.child = P, p.child.memoizedState = A2(E), p.memoizedState = g2, f) : f4(p, M)); if (M = f.memoizedState, M !== null) { if (se = M.dehydrated, se !== null) { if (q) return p.flags & 256 ? (p.flags &= -257, v2(f, p, E, Error(a(422)))) : p.memoizedState !== null ? (p.child = f.child, p.flags |= 128, null) : (P = S.fallback, M = p.mode, S = N2({ mode: "visible", children: S.children }, M, 0, null), P = cd(P, M, E, null), P.flags |= 2, S.return = p, P.return = p, S.sibling = P, p.child = S, p.mode & 1 && Va(p, f.child, null, E), p.child.memoizedState = A2(E), p.memoizedState = g2, P); if (!(p.mode & 1)) p = v2(f, p, E, null); else if (Yt(se)) p = v2(f, p, E, Error(a(419))); else if (S = (E & f.childLanes) !== 0, So || S) { if (S = $i, S !== null) { switch (E & -E) { case 4: P = 2; break; case 16: P = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: P = 32; break; case 536870912: P = 268435456; break; default: P = 0 }S = P & (S.suspendedLanes | E) ? 0 : P, S !== 0 && S !== M.retryLane && (M.retryLane = S, al(f, S, -1)) } R4(), p = v2(f, p, E, Error(a(421))) } else Vt(se) ? (p.flags |= 128, p.child = f.child, p = OH.bind(null, f), Mr(se, p), p = null) : (E = M.treeContext, de && (bn = ur(se), Br = p, _t = !0, Rr = null, Ni = !1, E !== null && (Tt[He++] = cr, Tt[He++] = Wn, Tt[He++] = kt, cr = E.id, Wn = E.overflow, kt = p)), p = f4(p, p.pendingProps.children), p.flags |= 4096); return p } return P ? (S = dw(f, p, S.children, S.fallback, E), P = p.child, M = f.child.memoizedState, P.memoizedState = M === null ? A2(E) : { baseLanes: M.baseLanes | E, cachePool: null }, P.childLanes = f.childLanes & ~E, p.memoizedState = g2, S) : (E = hw(f, p, S.children, E), p.memoizedState = null, E) } return P ? (S = dw(f, p, S.children, S.fallback, E), P = p.child, M = f.child.memoizedState, P.memoizedState = M === null ? A2(E) : { baseLanes: M.baseLanes | E, cachePool: null }, P.childLanes = f.childLanes & ~E, p.memoizedState = g2, S) : (E = hw(f, p, S.children, E), p.memoizedState = null, E) } function f4(f, p) { return p = N2({ mode: "visible", children: p }, f.mode, 0, null), p.return = f, f.child = p } function hw(f, p, E, S) { var M = f.child; return f = M.sibling, E = Ff(M, { mode: "visible", children: E }), !(p.mode & 1) && (E.lanes = S), E.return = p, E.sibling = null, f !== null && (S = p.deletions, S === null ? (p.deletions = [f], p.flags |= 16) : S.push(f)), p.child = E } function dw(f, p, E, S, M) { var P = p.mode; f = f.child; var q = f.sibling, se = { mode: "hidden", children: E }; return !(P & 1) && p.child !== f ? (E = p.child, E.childLanes = 0, E.pendingProps = se, p.deletions = null) : (E = Ff(f, se), E.subtreeFlags = f.subtreeFlags & 14680064), q !== null ? S = Ff(q, S) : (S = cd(S, P, M, null), S.flags |= 2), S.return = p, E.return = p, E.sibling = S, p.child = E, S } function v2(f, p, E, S) { return S !== null && fr(S), Va(p, f.child, null, E), f = f4(p, p.pendingProps.children), f.flags |= 2, p.memoizedState = null, f } function pw(f, p, E) { f.lanes |= p; var S = f.alternate; S !== null && (S.lanes |= p), bf(f.return, p, E) } function h4(f, p, E, S, M) { var P = f.memoizedState; P === null ? f.memoizedState = { isBackwards: p, rendering: null, renderingStartTime: 0, last: S, tail: E, tailMode: M } : (P.isBackwards = p, P.rendering = null, P.renderingStartTime = 0, P.last = S, P.tail = E, P.tailMode = M) } function mw(f, p, E) { var S = p.pendingProps, M = S.revealOrder, P = S.tail; if (Sa(f, p, S.children, E), S = Ht.current, S & 2) S = S & 1 | 2, p.flags |= 128; else { if (f !== null && f.flags & 128) e: for (f = p.child; f !== null;) { if (f.tag === 13) f.memoizedState !== null && pw(f, E, p); else if (f.tag === 19) pw(f, E, p); else if (f.child !== null) { f.child.return = f, f = f.child; continue } if (f === p) break e; for (; f.sibling === null;) { if (f.return === null || f.return === p) break e; f = f.return } f.sibling.return = f.return, f = f.sibling } S &= 1 } if (Lt(Ht, S), !(p.mode & 1)) p.memoizedState = null; else switch (M) { case "forwards": for (E = p.child, M = null; E !== null;)f = E.alternate, f !== null && Yr(f) === null && (M = E), E = E.sibling; E = M, E === null ? (M = p.child, p.child = null) : (M = E.sibling, E.sibling = null), h4(p, !1, M, E, P); break; case "backwards": for (E = null, M = p.child, p.child = null; M !== null;) { if (f = M.alternate, f !== null && Yr(f) === null) { p.child = M; break } f = M.sibling, M.sibling = E, E = M, M = f } h4(p, !0, E, null, P); break; case "together": h4(p, !1, null, null, void 0); break; default: p.memoizedState = null }return p.child } function Rc(f, p, E) { if (f !== null && (p.dependencies = f.dependencies), i0 |= p.lanes, !(E & p.childLanes)) return null; if (f !== null && p.child !== f.child) throw Error(a(153)); if (p.child !== null) { for (f = p.child, E = Ff(f, f.pendingProps), p.child = E, E.return = p; f.sibling !== null;)f = f.sibling, E = E.sibling = Ff(f, f.pendingProps), E.return = p; E.sibling = null } return p.child } function wH(f, p, E) { switch (p.tag) { case 3: uw(p), _i(); break; case 5: Qs(p); break; case 1: ir(p.type) && Lu(p); break; case 4: Ki(p, p.stateNode.containerInfo); break; case 10: Rm(p, p.type._context, p.memoizedProps.value); break; case 13: var S = p.memoizedState; if (S !== null) return S.dehydrated !== null ? (Lt(Ht, Ht.current & 1), p.flags |= 128, null) : E & p.child.childLanes ? fw(f, p, E) : (Lt(Ht, Ht.current & 1), f = Rc(f, p, E), f !== null ? f.sibling : null); Lt(Ht, Ht.current & 1); break; case 19: if (S = (E & p.childLanes) !== 0, f.flags & 128) { if (S) return mw(f, p, E); p.flags |= 128 } var M = p.memoizedState; if (M !== null && (M.rendering = null, M.tail = null, M.lastEffect = null), Lt(Ht, Ht.current), S) break; return null; case 22: case 23: return p.lanes = 0, aw(f, p, E) }return Rc(f, p, E) } function IH(f, p) { switch (dn(p), p.tag) { case 1: return ir(p.type) && $o(), f = p.flags, f & 65536 ? (p.flags = f & -65537 | 128, p) : null; case 3: return ya(), an($n), an(Rn), Hs(), f = p.flags, f & 65536 && !(f & 128) ? (p.flags = f & -65537 | 128, p) : null; case 5: return Wa(p), null; case 13: if (an(Ht), f = p.memoizedState, f !== null && f.dehydrated !== null) { if (p.alternate === null) throw Error(a(340)); _i() } return f = p.flags, f & 65536 ? (p.flags = f & -65537 | 128, p) : null; case 19: return an(Ht), null; case 4: return ya(), null; case 10: return $p(p.type._context), null; case 22: case 23: return B4(), null; case 24: return null; default: return null } } var y2 = !1, sd = !1, MH = typeof WeakSet == "function" ? WeakSet : Set, mt = null; function x2(f, p) { var E = f.ref; if (E !== null) if (typeof E == "function") try { E(null) } catch (S) { qa(f, p, S) } else E.current = null } function d4(f, p, E) { try { E() } catch (S) { qa(f, p, S) } } var gw = !1; function bH(f, p) { for (Q(f.containerInfo), mt = p; mt !== null;)if (f = mt, p = f.child, (f.subtreeFlags & 1028) !== 0 && p !== null) p.return = f, mt = p; else for (; mt !== null;) { f = mt; try { var E = f.alternate; if (f.flags & 1024) switch (f.tag) { case 0: case 11: case 15: break; case 1: if (E !== null) { var S = E.memoizedProps, M = E.memoizedState, P = f.stateNode, q = P.getSnapshotBeforeUpdate(f.elementType === f.type ? S : Is(f.type, S), M); P.__reactInternalSnapshotBeforeUpdate = q } break; case 3: Oe && ze(f.stateNode.containerInfo); break; case 5: case 6: case 4: case 17: break; default: throw Error(a(163)) } } catch (se) { qa(f, f.return, se) } if (p = f.sibling, p !== null) { p.return = f.return, mt = p; break } mt = f.return } return E = gw, gw = !1, E } function ad(f, p, E) { var S = p.updateQueue; if (S = S !== null ? S.lastEffect : null, S !== null) { var M = S = S.next; do { if ((M.tag & f) === f) { var P = M.destroy; M.destroy = void 0, P !== void 0 && d4(p, E, P) } M = M.next } while (M !== S) } } function Fm(f, p) { if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) { var E = p = p.next; do { if ((E.tag & f) === f) { var S = E.create; E.destroy = S() } E = E.next } while (E !== p) } } function p4(f) { var p = f.ref; if (p !== null) { var E = f.stateNode; switch (f.tag) { case 5: f = ne(E); break; default: f = E }typeof p == "function" ? p(f) : p.current = f } } function Aw(f, p, E) { if (Ao && typeof Ao.onCommitFiberUnmount == "function") try { Ao.onCommitFiberUnmount(el, p) } catch { } switch (p.tag) { case 0: case 11: case 14: case 15: if (f = p.updateQueue, f !== null && (f = f.lastEffect, f !== null)) { var S = f = f.next; do { var M = S, P = M.destroy; M = M.tag, P !== void 0 && (M & 2 || M & 4) && d4(p, E, P), S = S.next } while (S !== f) } break; case 1: if (x2(p, E), f = p.stateNode, typeof f.componentWillUnmount == "function") try { f.props = p.memoizedProps, f.state = p.memoizedState, f.componentWillUnmount() } catch (q) { qa(p, E, q) } break; case 5: x2(p, E); break; case 4: Oe ? Cw(f, p, E) : K && K && (p = p.stateNode.containerInfo, E = jt(p), Dt(p, E)) } } function vw(f, p, E) { for (var S = p; ;)if (Aw(f, S, E), S.child === null || Oe && S.tag === 4) { if (S === p) break; for (; S.sibling === null;) { if (S.return === null || S.return === p) return; S = S.return } S.sibling.return = S.return, S = S.sibling } else S.child.return = S, S = S.child } function yw(f) { var p = f.alternate; p !== null && (f.alternate = null, yw(p)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (p = f.stateNode, p !== null && ie(p)), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null } function xw(f) { return f.tag === 5 || f.tag === 3 || f.tag === 4 } function _w(f) { e: for (; ;) { for (; f.sibling === null;) { if (f.return === null || xw(f.return)) return null; f = f.return } for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && f.tag !== 18;) { if (f.flags & 2 || f.child === null || f.tag === 4) continue e; f.child.return = f, f = f.child } if (!(f.flags & 2)) return f.stateNode } } function Ew(f) { if (Oe) { e: { for (var p = f.return; p !== null;) { if (xw(p)) break e; p = p.return } throw Error(a(160)) } var E = p; switch (E.tag) { case 5: p = E.stateNode, E.flags & 32 && (Ie(p), E.flags &= -33), E = _w(f), g4(f, E, p); break; case 3: case 4: p = E.stateNode.containerInfo, E = _w(f), m4(f, E, p); break; default: throw Error(a(161)) } } } function m4(f, p, E) { var S = f.tag; if (S === 5 || S === 6) f = f.stateNode, p ? dt(E, f, p) : ut(E, f); else if (S !== 4 && (f = f.child, f !== null)) for (m4(f, p, E), f = f.sibling; f !== null;)m4(f, p, E), f = f.sibling } function g4(f, p, E) { var S = f.tag; if (S === 5 || S === 6) f = f.stateNode, p ? vt(E, f, p) : We(E, f); else if (S !== 4 && (f = f.child, f !== null)) for (g4(f, p, E), f = f.sibling; f !== null;)g4(f, p, E), f = f.sibling } function Cw(f, p, E) { for (var S = p, M = !1, P, q; ;) { if (!M) { M = S.return; e: for (; ;) { if (M === null) throw Error(a(160)); switch (P = M.stateNode, M.tag) { case 5: q = !1; break e; case 3: P = P.containerInfo, q = !0; break e; case 4: P = P.containerInfo, q = !0; break e }M = M.return } M = !0 } if (S.tag === 5 || S.tag === 6) vw(f, S, E), q ? ee(P, S.stateNode) : at(P, S.stateNode); else if (S.tag === 18) q ? ct(P, S.stateNode) : rt(P, S.stateNode); else if (S.tag === 4) { if (S.child !== null) { P = S.stateNode.containerInfo, q = !0, S.child.return = S, S = S.child; continue } } else if (Aw(f, S, E), S.child !== null) { S.child.return = S, S = S.child; continue } if (S === p) break; for (; S.sibling === null;) { if (S.return === null || S.return === p) return; S = S.return, S.tag === 4 && (M = !1) } S.sibling.return = S.return, S = S.sibling } } function A4(f, p) { if (Oe) { switch (p.tag) { case 0: case 11: case 14: case 15: ad(3, p, p.return), Fm(3, p), ad(5, p, p.return); return; case 1: return; case 5: var E = p.stateNode; if (E != null) { var S = p.memoizedProps; f = f !== null ? f.memoizedProps : S; var M = p.type, P = p.updateQueue; p.updateQueue = null, P !== null && st(E, P, M, f, S, p) } return; case 6: if (p.stateNode === null) throw Error(a(162)); E = p.memoizedProps, Ge(p.stateNode, f !== null ? f.memoizedProps : E, E); return; case 3: de && f !== null && f.memoizedState.isDehydrated && he(p.stateNode.containerInfo); return; case 12: return; case 13: _2(p); return; case 19: _2(p); return; case 17: return }throw Error(a(163)) } switch (p.tag) { case 0: case 11: case 14: case 15: ad(3, p, p.return), Fm(3, p), ad(5, p, p.return); return; case 12: return; case 13: _2(p); return; case 19: _2(p); return; case 3: de && f !== null && f.memoizedState.isDehydrated && he(p.stateNode.containerInfo); break; case 22: case 23: return }e: if (K) { switch (p.tag) { case 1: case 5: case 6: break e; case 3: case 4: p = p.stateNode, Dt(p.containerInfo, p.pendingChildren); break e }throw Error(a(163)) } } function _2(f) { var p = f.updateQueue; if (p !== null) { f.updateQueue = null; var E = f.stateNode; E === null && (E = f.stateNode = new MH), p.forEach(function (S) { var M = UH.bind(null, f, S); E.has(S) || (E.add(S), S.then(M, M)) }) } } function BH(f, p) { for (mt = p; mt !== null;) { p = mt; var E = p.deletions; if (E !== null) for (var S = 0; S < E.length; S++) { var M = E[S]; try { var P = f; Oe ? Cw(P, M, p) : vw(P, M, p); var q = M.alternate; q !== null && (q.return = null), M.return = null } catch (Ot) { qa(M, p, Ot) } } if (E = p.child, p.subtreeFlags & 12854 && E !== null) E.return = p, mt = E; else for (; mt !== null;) { p = mt; try { var se = p.flags; if (se & 32 && Oe && Ie(p.stateNode), se & 512) { var Le = p.alternate; if (Le !== null) { var et = Le.ref; et !== null && (typeof et == "function" ? et(null) : et.current = null) } } if (se & 8192) switch (p.tag) { case 13: if (p.memoizedState !== null) { var It = p.alternate; (It === null || It.memoizedState === null) && (S4 = sr()) } break; case 22: var vn = p.memoizedState !== null, Kt = p.alternate, Cr = Kt !== null && Kt.memoizedState !== null; if (E = p, Oe) { e: if (S = E, M = vn, P = null, Oe) for (var Ut = S; ;) { if (Ut.tag === 5) { if (P === null) { P = Ut; var ia = Ut.stateNode; M ? Ke(ia) : Ve(Ut.stateNode, Ut.memoizedProps) } } else if (Ut.tag === 6) { if (P === null) { var ll = Ut.stateNode; M ? j(ll) : oe(ll, Ut.memoizedProps) } } else if ((Ut.tag !== 22 && Ut.tag !== 23 || Ut.memoizedState === null || Ut === S) && Ut.child !== null) { Ut.child.return = Ut, Ut = Ut.child; continue } if (Ut === S) break; for (; Ut.sibling === null;) { if (Ut.return === null || Ut.return === S) break e; P === Ut && (P = null), Ut = Ut.return } P === Ut && (P = null), Ut.sibling.return = Ut.return, Ut = Ut.sibling } } if (vn && !Cr && E.mode & 1) { mt = E; for (var _e = E.child; _e !== null;) { for (E = mt = _e; mt !== null;) { S = mt; var ce = S.child; switch (S.tag) { case 0: case 11: case 14: case 15: ad(4, S, S.return); break; case 1: x2(S, S.return); var Me = S.stateNode; if (typeof Me.componentWillUnmount == "function") { var At = S.return; try { Me.props = S.memoizedProps, Me.state = S.memoizedState, Me.componentWillUnmount() } catch (Ot) { qa(S, At, Ot) } } break; case 5: x2(S, S.return); break; case 22: if (S.memoizedState !== null) { ww(E); continue } }ce !== null ? (ce.return = S, mt = ce) : ww(E) } _e = _e.sibling } } }switch (se & 4102) { case 2: Ew(p), p.flags &= -3; break; case 6: Ew(p), p.flags &= -3, A4(p.alternate, p); break; case 4096: p.flags &= -4097; break; case 4100: p.flags &= -4097, A4(p.alternate, p); break; case 4: A4(p.alternate, p) } } catch (Ot) { qa(p, p.return, Ot) } if (E = p.sibling, E !== null) { E.return = p.return, mt = E; break } mt = p.return } } } function RH(f, p, E) { mt = f, Sw(f) } function Sw(f, p, E) { for (var S = (f.mode & 1) !== 0; mt !== null;) { var M = mt, P = M.child; if (M.tag === 22 && S) { var q = M.memoizedState !== null || y2; if (!q) { var se = M.alternate, Le = se !== null && se.memoizedState !== null || sd; se = y2; var et = sd; if (y2 = q, (sd = Le) && !et) for (mt = M; mt !== null;)q = mt, Le = q.child, q.tag === 22 && q.memoizedState !== null ? Iw(M) : Le !== null ? (Le.return = q, mt = Le) : Iw(M); for (; P !== null;)mt = P, Sw(P), P = P.sibling; mt = M, y2 = se, sd = et } Tw(f) } else M.subtreeFlags & 8772 && P !== null ? (P.return = M, mt = P) : Tw(f) } } function Tw(f) { for (; mt !== null;) { var p = mt; if (p.flags & 8772) { var E = p.alternate; try { if (p.flags & 8772) switch (p.tag) { case 0: case 11: case 15: sd || Fm(5, p); break; case 1: var S = p.stateNode; if (p.flags & 4 && !sd) if (E === null) S.componentDidMount(); else { var M = p.elementType === p.type ? E.memoizedProps : Is(p.type, E.memoizedProps); S.componentDidUpdate(M, E.memoizedState, S.__reactInternalSnapshotBeforeUpdate) } var P = p.updateQueue; P !== null && pe(p, P, S); break; case 3: var q = p.updateQueue; if (q !== null) { if (E = null, p.child !== null) switch (p.child.tag) { case 5: E = ne(p.child.stateNode); break; case 1: E = p.child.stateNode }pe(p, q, E) } break; case 5: var se = p.stateNode; E === null && p.flags & 4 && Ae(se, p.type, p.memoizedProps, p); break; case 6: break; case 4: break; case 12: break; case 13: if (de && p.memoizedState === null) { var Le = p.alternate; if (Le !== null) { var et = Le.memoizedState; if (et !== null) { var It = et.dehydrated; It !== null && Te(It) } } } break; case 19: case 17: case 21: case 22: case 23: break; default: throw Error(a(163)) }sd || p.flags & 512 && p4(p) } catch (vn) { qa(p, p.return, vn) } } if (p === f) { mt = null; break } if (E = p.sibling, E !== null) { E.return = p.return, mt = E; break } mt = p.return } } function ww(f) { for (; mt !== null;) { var p = mt; if (p === f) { mt = null; break } var E = p.sibling; if (E !== null) { E.return = p.return, mt = E; break } mt = p.return } } function Iw(f) { for (; mt !== null;) { var p = mt; try { switch (p.tag) { case 0: case 11: case 15: var E = p.return; try { Fm(4, p) } catch (Le) { qa(p, E, Le) } break; case 1: var S = p.stateNode; if (typeof S.componentDidMount == "function") { var M = p.return; try { S.componentDidMount() } catch (Le) { qa(p, M, Le) } } var P = p.return; try { p4(p) } catch (Le) { qa(p, P, Le) } break; case 5: var q = p.return; try { p4(p) } catch (Le) { qa(p, q, Le) } } } catch (Le) { qa(p, p.return, Le) } if (p === f) { mt = null; break } var se = p.sibling; if (se !== null) { se.return = p.return, mt = se; break } mt = p.return } } var E2 = 0, C2 = 1, S2 = 2, T2 = 3, w2 = 4; if (typeof Symbol == "function" && Symbol.for) { var km = Symbol.for; E2 = km("selector.component"), C2 = km("selector.has_pseudo_class"), S2 = km("selector.role"), T2 = km("selector.test_id"), w2 = km("selector.text") } function v4(f) { var p = Ce(f); if (p != null) { if (typeof p.memoizedProps["data-testname"] != "string") throw Error(a(364)); return p } if (f = xt(f), f === null) throw Error(a(362)); return f.stateNode.current } function y4(f, p) { switch (p.$$typeof) { case E2: if (f.type === p.value) return !0; break; case C2: e: { p = p.value, f = [f, 0]; for (var E = 0; E < f.length;) { var S = f[E++], M = f[E++], P = p[M]; if (S.tag !== 5 || !O(S)) { for (; P != null && y4(S, P);)M++, P = p[M]; if (M === p.length) { p = !0; break e } else for (S = S.child; S !== null;)f.push(S, M), S = S.sibling } } p = !1 } return p; case S2: if (f.tag === 5 && fe(f.stateNode, p.value)) return !0; break; case w2: if ((f.tag === 5 || f.tag === 6) && (f = X(f), f !== null && 0 <= f.indexOf(p.value))) return !0; break; case T2: if (f.tag === 5 && (f = f.memoizedProps["data-testname"], typeof f == "string" && f.toLowerCase() === p.value.toLowerCase())) return !0; break; default: throw Error(a(365)) }return !1 } function x4(f) { switch (f.$$typeof) { case E2: return "<" + (w(f.value) || "Unknown") + ">"; case C2: return ":has(" + (x4(f) || "") + ")"; case S2: return '[role="' + f.value + '"]'; case w2: return '"' + f.value + '"'; case T2: return '[data-testname="' + f.value + '"]'; default: throw Error(a(365)) } } function Mw(f, p) { var E = []; f = [f, 0]; for (var S = 0; S < f.length;) { var M = f[S++], P = f[S++], q = p[P]; if (M.tag !== 5 || !O(M)) { for (; q != null && y4(M, q);)P++, q = p[P]; if (P === p.length) E.push(M); else for (M = M.child; M !== null;)f.push(M, P), M = M.sibling } } return E } function _4(f, p) { if (!it) throw Error(a(363)); f = v4(f), f = Mw(f, p), p = [], f = Array.from(f); for (var E = 0; E < f.length;) { var S = f[E++]; if (S.tag === 5) O(S) || p.push(S.stateNode); else for (S = S.child; S !== null;)f.push(S), S = S.sibling } return p } var PH = Math.ceil, I2 = o.ReactCurrentDispatcher, E4 = o.ReactCurrentOwner, Qi = o.ReactCurrentBatchConfig, Mn = 0, $i = null, es = null, Ws = 0, To = 0, r0 = gt(0), fs = 0, Nm = null, i0 = 0, M2 = 0, C4 = 0, Om = null, Ja = null, S4 = 0, T4 = 1 / 0; function s0() { T4 = sr() + 500 } var b2 = !1, w4 = null, Rf = null, B2 = !1, Pf = null, R2 = 0, Um = 0, I4 = null, P2 = -1, D2 = 0; function Ta() { return Mn & 6 ? sr() : P2 !== -1 ? P2 : P2 = sr() } function Df(f) { return f.mode & 1 ? Mn & 2 && Ws !== 0 ? Ws & -Ws : o4.transition !== null ? (D2 === 0 && (f = nd, nd <<= 1, !(nd & 4194240) && (nd = 64), D2 = f), D2) : (f = Un, f !== 0 ? f : De()) : 1 } function al(f, p, E) { if (50 < Um) throw Um = 0, I4 = null, Error(a(185)); var S = L2(f, p); return S === null ? null : (Ul(S, p, E), (!(Mn & 2) || S !== $i) && (S === $i && (!(Mn & 2) && (M2 |= p), fs === 4 && Lf(S, Ws)), Ka(S, E), p === 1 && Mn === 0 && !(f.mode & 1) && (s0(), Ic && va())), S) } function L2(f, p) { f.lanes |= p; var E = f.alternate; for (E !== null && (E.lanes |= p), E = f, f = f.return; f !== null;)f.childLanes |= p, E = f.alternate, E !== null && (E.childLanes |= p), E = f, f = f.return; return E.tag === 3 ? E.stateNode : null } function Ka(f, p) { var E = f.callbackNode; jp(f, p); var S = Tc(f, f === $i ? Ws : 0); if (S === 0) E !== null && f2(E), f.callbackNode = null, f.callbackPriority = 0; else if (p = S & -S, f.callbackPriority !== p) { if (E != null && f2(E), p === 1) f.tag === 0 ? bm(Bw.bind(null, f)) : tl(Bw.bind(null, f)), qe ? nt(function () { Mn === 0 && va() }) : Gl(Jp, va), E = null; else { switch (If(S)) { case 1: E = Jp; break; case 4: E = Mm; break; case 16: E = Kp; break; case 536870912: E = Gs; break; default: E = Kp }E = Uw(E, bw.bind(null, f)) } f.callbackPriority = p, f.callbackNode = E } } function bw(f, p) { if (P2 = -1, D2 = 0, Mn & 6) throw Error(a(327)); var E = f.callbackNode; if (ud() && f.callbackNode !== E) return null; var S = Tc(f, f === $i ? Ws : 0); if (S === 0) return null; if (S & 30 || S & f.expiredLanes || p) p = F2(f, S); else { p = S; var M = Mn; Mn |= 2; var P = Dw(); ($i !== f || Ws !== p) && (s0(), od(f, p)); do try { FH(); break } catch (se) { Pw(f, se) } while (1); Bm(), I2.current = P, Mn = M, es !== null ? p = 0 : ($i = null, Ws = 0, p = fs) } if (p !== 0) { if (p === 2 && (M = _n(f), M !== 0 && (S = M, p = M4(f, M))), p === 1) throw E = Nm, od(f, 0), Lf(f, S), Ka(f, sr()), E; if (p === 6) Lf(f, S); else { if (M = f.current.alternate, !(S & 30) && !DH(M) && (p = F2(f, S), p === 2 && (P = _n(f), P !== 0 && (S = P, p = M4(f, P))), p === 1)) throw E = Nm, od(f, 0), Lf(f, S), Ka(f, sr()), E; switch (f.finishedWork = M, f.finishedLanes = S, p) { case 0: case 1: throw Error(a(345)); case 2: ld(f, Ja); break; case 3: if (Lf(f, S), (S & 130023424) === S && (p = S4 + 500 - sr(), 10 < p)) { if (Tc(f, 0) !== 0) break; if (M = f.suspendedLanes, (M & S) !== S) { Ta(), f.pingedLanes |= f.suspendedLanes & M; break } f.timeoutHandle = we(ld.bind(null, f, Ja), p); break } ld(f, Ja); break; case 4: if (Lf(f, S), (S & 4194240) === S) break; for (p = f.eventTimes, M = -1; 0 < S;) { var q = 31 - ea(S); P = 1 << q, q = p[q], q > M && (M = q), S &= ~P } if (S = M, S = sr() - S, S = (120 > S ? 120 : 480 > S ? 480 : 1080 > S ? 1080 : 1920 > S ? 1920 : 3e3 > S ? 3e3 : 4320 > S ? 4320 : 1960 * PH(S / 1960)) - S, 10 < S) { f.timeoutHandle = we(ld.bind(null, f, Ja), S); break } ld(f, Ja); break; case 5: ld(f, Ja); break; default: throw Error(a(329)) } } } return Ka(f, sr()), f.callbackNode === E ? bw.bind(null, f) : null } function M4(f, p) { var E = Om; return f.current.memoizedState.isDehydrated && (od(f, p).flags |= 256), f = F2(f, p), f !== 2 && (p = Ja, Ja = E, p !== null && b4(p)), f } function b4(f) { Ja === null ? Ja = f : Ja.push.apply(Ja, f) } function DH(f) { for (var p = f; ;) { if (p.flags & 16384) { var E = p.updateQueue; if (E !== null && (E = E.stores, E !== null)) for (var S = 0; S < E.length; S++) { var M = E[S], P = M.getSnapshot; M = M.value; try { if (!ws(P(), M)) return !1 } catch { return !1 } } } if (E = p.child, p.subtreeFlags & 16384 && E !== null) E.return = p, p = E; else { if (p === f) break; for (; p.sibling === null;) { if (p.return === null || p.return === f) return !0; p = p.return } p.sibling.return = p.return, p = p.sibling } } return !0 } function Lf(f, p) { for (p &= ~C4, p &= ~M2, f.suspendedLanes |= p, f.pingedLanes &= ~p, f = f.expirationTimes; 0 < p;) { var E = 31 - ea(p), S = 1 << E; f[E] = -1, p &= ~S } } function Bw(f) { if (Mn & 6) throw Error(a(327)); ud(); var p = Tc(f, 0); if (!(p & 1)) return Ka(f, sr()), null; var E = F2(f, p); if (f.tag !== 0 && E === 2) { var S = _n(f); S !== 0 && (p = S, E = M4(f, S)) } if (E === 1) throw E = Nm, od(f, 0), Lf(f, p), Ka(f, sr()), E; if (E === 6) throw Error(a(345)); return f.finishedWork = f.current.alternate, f.finishedLanes = p, ld(f, Ja), Ka(f, sr()), null } function Rw(f) { Pf !== null && Pf.tag === 0 && !(Mn & 6) && ud(); var p = Mn; Mn |= 1; var E = Qi.transition, S = Un; try { if (Qi.transition = null, Un = 1, f) return f() } finally { Un = S, Qi.transition = E, Mn = p, !(Mn & 6) && va() } } function B4() { To = r0.current, an(r0) } function od(f, p) { f.finishedWork = null, f.finishedLanes = 0; var E = f.timeoutHandle; if (E !== tt && (f.timeoutHandle = tt, ge(E)), es !== null) for (E = es.return; E !== null;) { var S = E; switch (dn(S), S.tag) { case 1: S = S.type.childContextTypes, S != null && $o(); break; case 3: ya(), an($n), an(Rn), Hs(); break; case 5: Wa(S); break; case 4: ya(); break; case 13: an(Ht); break; case 19: an(Ht); break; case 10: $p(S.type._context); break; case 22: case 23: B4() }E = E.return } if ($i = f, es = f = Ff(f.current, null), Ws = To = p, fs = 0, Nm = null, C4 = M2 = i0 = 0, Ja = Om = null, yo !== null) { for (p = 0; p < yo.length; p++)if (E = yo[p], S = E.interleaved, S !== null) { E.interleaved = null; var M = S.next, P = E.pending; if (P !== null) { var q = P.next; P.next = M, S.next = q } E.pending = S } yo = null } return f } function Pw(f, p) { do { var E = es; try { if (Bm(), Re.current = Bs, il) { for (var S = hr.memoizedState; S !== null;) { var M = S.queue; M !== null && (M.pending = null), S = S.next } il = !1 } if (ta = 0, Fr = Ln = hr = null, zl = !1, li = 0, E4.current = null, E === null || E.return === null) { fs = 1, Nm = p, es = null; break } e: { var P = f, q = E.return, se = E, Le = p; if (p = Ws, se.flags |= 32768, Le !== null && typeof Le == "object" && typeof Le.then == "function") { var et = Le, It = se, vn = It.tag; if (!(It.mode & 1) && (vn === 0 || vn === 11 || vn === 15)) { var Kt = It.alternate; Kt ? (It.updateQueue = Kt.updateQueue, It.memoizedState = Kt.memoizedState, It.lanes = Kt.lanes) : (It.updateQueue = null, It.memoizedState = null) } var Cr = n0(q); if (Cr !== null) { Cr.flags &= -257, Dm(Cr, q, se, P, p), Cr.mode & 1 && Eo(P, et, p), p = Cr, Le = et; var Ut = p.updateQueue; if (Ut === null) { var ia = new Set; ia.add(Le), p.updateQueue = ia } else Ut.add(Le); break e } else { if (!(p & 1)) { Eo(P, et, p), R4(); break e } Le = Error(a(426)) } } else if (_t && se.mode & 1) { var ll = n0(q); if (ll !== null) { !(ll.flags & 65536) && (ll.flags |= 256), Dm(ll, q, se, P, p), fr(Le); break e } } P = Le, fs !== 4 && (fs = 2), Om === null ? Om = [P] : Om.push(P), Le = Zi(Le, se), se = q; do { switch (se.tag) { case 3: se.flags |= 65536, p &= -p, se.lanes |= p; var _e = cs(se, Le, p); Pm(se, _e); break e; case 1: P = Le; var ce = se.type, Me = se.stateNode; if (!(se.flags & 128) && (typeof ce.getDerivedStateFromError == "function" || Me !== null && typeof Me.componentDidCatch == "function" && (Rf === null || !Rf.has(Me)))) { se.flags |= 65536, p &= -p, se.lanes |= p; var At = Si(se, P, p); Pm(se, At); break e } }se = se.return } while (se !== null) } Fw(E) } catch (Ot) { p = Ot, es === E && E !== null && (es = E = E.return); continue } break } while (1) } function Dw() { var f = I2.current; return I2.current = Bs, f === null ? Bs : f } function R4() { (fs === 0 || fs === 3 || fs === 2) && (fs = 4), $i === null || !(i0 & 268435455) && !(M2 & 268435455) || Lf($i, Ws) } function F2(f, p) { var E = Mn; Mn |= 2; var S = Dw(); $i === f && Ws === p || od(f, p); do try { LH(); break } catch (M) { Pw(f, M) } while (1); if (Bm(), Mn = E, I2.current = S, es !== null) throw Error(a(261)); return $i = null, Ws = 0, fs } function LH() { for (; es !== null;)Lw(es) } function FH() { for (; es !== null && !h2();)Lw(es) } function Lw(f) { var p = Ow(f.alternate, f, To); f.memoizedProps = f.pendingProps, p === null ? Fw(f) : es = p, E4.current = null } function Fw(f) { var p = f; do { var E = p.alternate; if (f = p.return, p.flags & 32768) { if (E = IH(E, p), E !== null) { E.flags &= 32767, es = E; return } if (f !== null) f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null; else { fs = 6, es = null; return } } else if (E = SH(E, p, To), E !== null) { es = E; return } if (p = p.sibling, p !== null) { es = p; return } es = p = f } while (p !== null); fs === 0 && (fs = 5) } function ld(f, p) { var E = Un, S = Qi.transition; try { Qi.transition = null, Un = 1, kH(f, p, E) } finally { Qi.transition = S, Un = E } return null } function kH(f, p, E) { do ud(); while (Pf !== null); if (Mn & 6) throw Error(a(327)); var S = f.finishedWork, M = f.finishedLanes; if (S === null) return null; if (f.finishedWork = null, f.finishedLanes = 0, S === f.current) throw Error(a(177)); f.callbackNode = null, f.callbackPriority = 0; var P = S.lanes | S.childLanes; if (c2(f, P), f === $i && (es = $i = null, Ws = 0), !(S.subtreeFlags & 2064) && !(S.flags & 2064) || B2 || (B2 = !0, Uw(Kp, function () { return ud(), null })), P = (S.flags & 15990) !== 0, S.subtreeFlags & 15990 || P) { P = Qi.transition, Qi.transition = null; var q = Un; Un = 1; var se = Mn; Mn |= 4, E4.current = null, bH(f, S), BH(f, S), D(f.containerInfo), f.current = S, RH(S), wc(), Mn = se, Un = q, Qi.transition = P } else f.current = S; if (B2 && (B2 = !1, Pf = f, R2 = M), P = f.pendingLanes, P === 0 && (Rf = null), a4(S.stateNode), Ka(f, sr()), p !== null) for (E = f.onRecoverableError, S = 0; S < p.length; S++)E(p[S]); if (b2) throw b2 = !1, f = w4, w4 = null, f; return R2 & 1 && f.tag !== 0 && ud(), P = f.pendingLanes, P & 1 ? f === I4 ? Um++ : (Um = 0, I4 = f) : Um = 0, va(), null } function ud() { if (Pf !== null) { var f = If(R2), p = Qi.transition, E = Un; try { if (Qi.transition = null, Un = 16 > f ? 16 : f, Pf === null) var S = !1; else { if (f = Pf, Pf = null, R2 = 0, Mn & 6) throw Error(a(331)); var M = Mn; for (Mn |= 4, mt = f.current; mt !== null;) { var P = mt, q = P.child; if (mt.flags & 16) { var se = P.deletions; if (se !== null) { for (var Le = 0; Le < se.length; Le++) { var et = se[Le]; for (mt = et; mt !== null;) { var It = mt; switch (It.tag) { case 0: case 11: case 15: ad(8, It, P) }var vn = It.child; if (vn !== null) vn.return = It, mt = vn; else for (; mt !== null;) { It = mt; var Kt = It.sibling, Cr = It.return; if (yw(It), It === et) { mt = null; break } if (Kt !== null) { Kt.return = Cr, mt = Kt; break } mt = Cr } } } var Ut = P.alternate; if (Ut !== null) { var ia = Ut.child; if (ia !== null) { Ut.child = null; do { var ll = ia.sibling; ia.sibling = null, ia = ll } while (ia !== null) } } mt = P } } if (P.subtreeFlags & 2064 && q !== null) q.return = P, mt = q; else e: for (; mt !== null;) { if (P = mt, P.flags & 2048) switch (P.tag) { case 0: case 11: case 15: ad(9, P, P.return) }var _e = P.sibling; if (_e !== null) { _e.return = P.return, mt = _e; break e } mt = P.return } } var ce = f.current; for (mt = ce; mt !== null;) { q = mt; var Me = q.child; if (q.subtreeFlags & 2064 && Me !== null) Me.return = q, mt = Me; else e: for (q = ce; mt !== null;) { if (se = mt, se.flags & 2048) try { switch (se.tag) { case 0: case 11: case 15: Fm(9, se) } } catch (Ot) { qa(se, se.return, Ot) } if (se === q) { mt = null; break e } var At = se.sibling; if (At !== null) { At.return = se.return, mt = At; break e } mt = se.return } } if (Mn = M, va(), Ao && typeof Ao.onPostCommitFiberRoot == "function") try { Ao.onPostCommitFiberRoot(el, f) } catch { } S = !0 } return S } finally { Un = E, Qi.transition = p } } return !1 } function kw(f, p, E) { p = Zi(E, p), p = cs(f, p, 1), Nu(f, p), p = Ta(), f = L2(f, 1), f !== null && (Ul(f, 1, p), Ka(f, p)) } function qa(f, p, E) { if (f.tag === 3) kw(f, f, E); else for (; p !== null;) { if (p.tag === 3) { kw(p, f, E); break } else if (p.tag === 1) { var S = p.stateNode; if (typeof p.type.getDerivedStateFromError == "function" || typeof S.componentDidCatch == "function" && (Rf === null || !Rf.has(S))) { f = Zi(E, f), f = Si(p, f, 1), Nu(p, f), f = Ta(), p = L2(p, 1), p !== null && (Ul(p, 1, f), Ka(p, f)); break } } p = p.return } } function NH(f, p, E) { var S = f.pingCache; S !== null && S.delete(p), p = Ta(), f.pingedLanes |= f.suspendedLanes & E, $i === f && (Ws & E) === E && (fs === 4 || fs === 3 && (Ws & 130023424) === Ws && 500 > sr() - S4 ? od(f, 0) : C4 |= E), Ka(f, p) } function Nw(f, p) { p === 0 && (f.mode & 1 ? (p = Sc, Sc <<= 1, !(Sc & 130023424) && (Sc = 4194304)) : p = 1); var E = Ta(); f = L2(f, p), f !== null && (Ul(f, p, E), Ka(f, E)) } function OH(f) { var p = f.memoizedState, E = 0; p !== null && (E = p.retryLane), Nw(f, E) } function UH(f, p) { var E = 0; switch (f.tag) { case 13: var S = f.stateNode, M = f.memoizedState; M !== null && (E = M.retryLane); break; case 19: S = f.stateNode; break; default: throw Error(a(314)) }S !== null && S.delete(p), Nw(f, E) } var Ow; Ow = function (f, p, E) { if (f !== null) if (f.memoizedProps !== p.pendingProps || $n.current) So = !0; else { if (!(f.lanes & E) && !(p.flags & 128)) return So = !1, wH(f, p, E); So = !!(f.flags & 131072) } else So = !1, _t && p.flags & 1048576 && br(p, Dn, p.index); switch (p.lanes = 0, p.tag) { case 2: var S = p.type; f !== null && (f.alternate = null, p.alternate = null, p.flags |= 2), f = p.pendingProps; var M = Wr(p, Rn.current); Bc(p, E), M = Vl(null, p, S, f, M, E); var P = _o(); return p.flags |= 1, typeof M == "object" && M !== null && typeof M.render == "function" && M.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, ir(S) ? (P = !0, Lu(p)) : P = !1, p.memoizedState = M.state !== null && M.state !== void 0 ? M.state : null, Bf(p), M.updater = z, p.stateNode = M, M._reactInternals = p, ye(p, S, f, E), p = c4(null, p, S, !0, P, E)) : (p.tag = 0, _t && P && ki(p), Sa(null, p, M, E), p = p.child), p; case 16: S = p.elementType; e: { switch (f !== null && (f.alternate = null, p.alternate = null, p.flags |= 2), f = p.pendingProps, M = S._init, S = M(S._payload), p.type = S, M = p.tag = QH(S), f = Is(S, f), M) { case 0: p = u4(null, p, S, f, E); break e; case 1: p = lw(null, p, S, f, E); break e; case 11: p = rw(null, p, S, f, E); break e; case 14: p = iw(null, p, S, Is(S.type, f), E); break e }throw Error(a(306, S, "")) } return p; case 0: return S = p.type, M = p.pendingProps, M = p.elementType === S ? M : Is(S, M), u4(f, p, S, M, E); case 1: return S = p.type, M = p.pendingProps, M = p.elementType === S ? M : Is(S, M), lw(f, p, S, M, E); case 3: e: { if (uw(p), f === null) throw Error(a(387)); S = p.pendingProps, P = p.memoizedState, M = P.element, p2(f, p), e0(p, S, null, E); var q = p.memoizedState; if (S = q.element, de && P.isDehydrated) if (P = { element: S, isDehydrated: !1, cache: q.cache, transitions: q.transitions }, p.updateQueue.baseState = P, p.memoizedState = P, p.flags & 256) { M = Error(a(423)), p = cw(f, p, S, E, M); break e } else if (S !== M) { M = Error(a(424)), p = cw(f, p, S, E, M); break e } else for (de && (bn = Fi(p.stateNode.containerInfo), Br = p, _t = !0, Rr = null, Ni = !1), E = Hl(p, null, S, E), p.child = E; E;)E.flags = E.flags & -3 | 4096, E = E.sibling; else { if (_i(), S === M) { p = Rc(f, p, E); break e } Sa(f, p, S, E) } p = p.child } return p; case 5: return Qs(p), f === null && xo(p), S = p.type, M = p.pendingProps, P = f !== null ? f.memoizedProps : null, q = M.children, Be(S, M) ? q = null : P !== null && Be(S, P) && (p.flags |= 32), ow(f, p), Sa(f, p, q, E), p.child; case 6: return f === null && xo(p), null; case 13: return fw(f, p, E); case 4: return Ki(p, p.stateNode.containerInfo), S = p.pendingProps, f === null ? p.child = Va(p, null, S, E) : Sa(f, p, S, E), p.child; case 11: return S = p.type, M = p.pendingProps, M = p.elementType === S ? M : Is(S, M), rw(f, p, S, M, E); case 7: return Sa(f, p, p.pendingProps, E), p.child; case 8: return Sa(f, p, p.pendingProps.children, E), p.child; case 12: return Sa(f, p, p.pendingProps.children, E), p.child; case 10: e: { if (S = p.type._context, M = p.pendingProps, P = p.memoizedProps, q = M.value, Rm(p, S, q), P !== null) if (ws(P.value, q)) { if (P.children === M.children && !$n.current) { p = Rc(f, p, E); break e } } else for (P = p.child, P !== null && (P.return = p); P !== null;) { var se = P.dependencies; if (se !== null) { q = P.child; for (var Le = se.firstContext; Le !== null;) { if (Le.context === S) { if (P.tag === 1) { Le = rl(-1, E & -E), Le.tag = 2; var et = P.updateQueue; if (et !== null) { et = et.shared; var It = et.pending; It === null ? Le.next = Le : (Le.next = It.next, It.next = Le), et.pending = Le } } P.lanes |= E, Le = P.alternate, Le !== null && (Le.lanes |= E), bf(P.return, E, p), se.lanes |= E; break } Le = Le.next } } else if (P.tag === 10) q = P.type === p.type ? null : P.child; else if (P.tag === 18) { if (q = P.return, q === null) throw Error(a(341)); q.lanes |= E, se = q.alternate, se !== null && (se.lanes |= E), bf(q, E, p), q = P.sibling } else q = P.child; if (q !== null) q.return = P; else for (q = P; q !== null;) { if (q === p) { q = null; break } if (P = q.sibling, P !== null) { P.return = q.return, q = P; break } q = q.return } P = q } Sa(f, p, M.children, E), p = p.child } return p; case 9: return M = p.type, S = p.pendingProps.children, Bc(p, E), M = $t(M), S = S(M), p.flags |= 1, Sa(f, p, S, E), p.child; case 14: return S = p.type, M = Is(S, p.pendingProps), M = Is(S.type, M), iw(f, p, S, M, E); case 15: return sw(f, p, p.type, p.pendingProps, E); case 17: return S = p.type, M = p.pendingProps, M = p.elementType === S ? M : Is(S, M), f !== null && (f.alternate = null, p.alternate = null, p.flags |= 2), p.tag = 1, ir(S) ? (f = !0, Lu(p)) : f = !1, Bc(p, E), le(p, S, M), ye(p, S, M, E), c4(null, p, S, !0, f, E); case 19: return mw(f, p, E); case 22: return aw(f, p, E) }throw Error(a(156, p.tag)) }; function Uw(f, p) { return Gl(f, p) } function GH(f, p, E, S) { this.tag = f, this.key = E, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = S, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function ol(f, p, E, S) { return new GH(f, p, E, S) } function P4(f) { return f = f.prototype, !(!f || !f.isReactComponent) } function QH(f) { if (typeof f == "function") return P4(f) ? 1 : 0; if (f != null) { if (f = f.$$typeof, f === v) return 11; if (f === _) return 14 } return 2 } function Ff(f, p) { var E = f.alternate; return E === null ? (E = ol(f.tag, p, f.key, f.mode), E.elementType = f.elementType, E.type = f.type, E.stateNode = f.stateNode, E.alternate = f, f.alternate = E) : (E.pendingProps = p, E.type = f.type, E.flags = 0, E.subtreeFlags = 0, E.deletions = null), E.flags = f.flags & 14680064, E.childLanes = f.childLanes, E.lanes = f.lanes, E.child = f.child, E.memoizedProps = f.memoizedProps, E.memoizedState = f.memoizedState, E.updateQueue = f.updateQueue, p = f.dependencies, E.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }, E.sibling = f.sibling, E.index = f.index, E.ref = f.ref, E } function k2(f, p, E, S, M, P) { var q = 2; if (S = f, typeof f == "function") P4(f) && (q = 1); else if (typeof f == "string") q = 5; else e: switch (f) { case c: return cd(E.children, M, P, p); case h: q = 8, M |= 8; break; case d: return f = ol(12, E, p, M | 2), f.elementType = d, f.lanes = P, f; case y: return f = ol(13, E, p, M), f.elementType = y, f.lanes = P, f; case A: return f = ol(19, E, p, M), f.elementType = A, f.lanes = P, f; case C: return N2(E, M, P, p); default: if (typeof f == "object" && f !== null) switch (f.$$typeof) { case m: q = 10; break e; case g: q = 9; break e; case v: q = 11; break e; case _: q = 14; break e; case x: q = 16, S = null; break e }throw Error(a(130, f == null ? f : typeof f, "")) }return p = ol(q, E, p, M), p.elementType = f, p.type = S, p.lanes = P, p } function cd(f, p, E, S) { return f = ol(7, f, S, p), f.lanes = E, f } function N2(f, p, E, S) { return f = ol(22, f, S, p), f.elementType = C, f.lanes = E, f.stateNode = {}, f } function D4(f, p, E) { return f = ol(6, f, null, p), f.lanes = E, f } function L4(f, p, E) { return p = ol(4, f.children !== null ? f.children : [], f.key, p), p.lanes = E, p.stateNode = { containerInfo: f.containerInfo, pendingChildren: null, implementation: f.implementation }, p } function HH(f, p, E, S, M) { this.tag = p, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = tt, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = rd(0), this.expirationTimes = rd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = rd(0), this.identifierPrefix = S, this.onRecoverableError = M, de && (this.mutableSourceEagerHydrationData = null) } function Gw(f, p, E, S, M, P, q, se, Le) { return f = new HH(f, p, E, se, Le), p === 1 ? (p = 1, P === !0 && (p |= 8)) : p = 0, P = ol(3, null, null, p), f.current = P, P.stateNode = f, P.memoizedState = { element: S, isDehydrated: E, cache: null, transitions: null }, Bf(P), f } function Qw(f) { if (!f) return Xi; f = f._reactInternals; e: { if (b(f) !== f || f.tag !== 1) throw Error(a(170)); var p = f; do { switch (p.tag) { case 3: p = p.stateNode.context; break e; case 1: if (ir(p.type)) { p = p.stateNode.__reactInternalMemoizedMergedChildContext; break e } }p = p.return } while (p !== null); throw Error(a(171)) } if (f.tag === 1) { var E = f.type; if (ir(E)) return wf(f, E, p) } return p } function Hw(f) { var p = f._reactInternals; if (p === void 0) throw typeof f.render == "function" ? Error(a(188)) : (f = Object.keys(f).join(","), Error(a(268, f))); return f = U(p), f === null ? null : f.stateNode } function zw(f, p) { if (f = f.memoizedState, f !== null && f.dehydrated !== null) { var E = f.retryLane; f.retryLane = E !== 0 && E < p ? E : p } } function F4(f, p) { zw(f, p), (f = f.alternate) && zw(f, p) } function zH(f) { return f = U(f), f === null ? null : f.stateNode } function VH() { return null } return t.attemptContinuousHydration = function (f) { if (f.tag === 13) { var p = Ta(); al(f, 134217728, p), F4(f, 134217728) } }, t.attemptHydrationAtCurrentPriority = function (f) { if (f.tag === 13) { var p = Ta(), E = Df(f); al(f, E, p), F4(f, E) } }, t.attemptSynchronousHydration = function (f) { switch (f.tag) { case 3: var p = f.stateNode; if (p.current.memoizedState.isDehydrated) { var E = Fu(p.pendingLanes); E !== 0 && (ku(p, E | 1), Ka(p, sr()), !(Mn & 6) && (s0(), va())) } break; case 13: var S = Ta(); Rw(function () { return al(f, 1, S) }), F4(f, 1) } }, t.batchedUpdates = function (f, p) { var E = Mn; Mn |= 1; try { return f(p) } finally { Mn = E, Mn === 0 && (s0(), Ic && va()) } }, t.createComponentSelector = function (f) { return { $$typeof: E2, value: f } }, t.createContainer = function (f, p, E, S, M, P, q) { return Gw(f, p, !1, null, E, S, M, P, q) }, t.createHasPseudoClassSelector = function (f) { return { $$typeof: C2, value: f } }, t.createHydrationContainer = function (f, p, E, S, M, P, q, se, Le) { return f = Gw(E, S, !0, f, M, P, q, se, Le), f.context = Qw(null), E = f.current, S = Ta(), M = Df(E), P = rl(S, M), P.callback = p ?? null, Nu(E, P), f.current.lanes = M, Ul(f, M, S), Ka(f, S), f }, t.createPortal = function (f, p, E) { var S = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: u, key: S == null ? null : "" + S, children: f, containerInfo: p, implementation: E } }, t.createRoleSelector = function (f) { return { $$typeof: S2, value: f } }, t.createTestNameSelector = function (f) { return { $$typeof: T2, value: f } }, t.createTextSelector = function (f) { return { $$typeof: w2, value: f } }, t.deferredUpdates = function (f) { var p = Un, E = Qi.transition; try { return Qi.transition = null, Un = 16, f() } finally { Un = p, Qi.transition = E } }, t.discreteUpdates = function (f, p, E, S, M) { var P = Un, q = Qi.transition; try { return Qi.transition = null, Un = 1, f(p, E, S, M) } finally { Un = P, Qi.transition = q, Mn === 0 && s0() } }, t.findAllNodes = _4, t.findBoundingRects = function (f, p) { if (!it) throw Error(a(363)); p = _4(f, p), f = []; for (var E = 0; E < p.length; E++)f.push(mn(p[E])); for (p = f.length - 1; 0 < p; p--) { E = f[p]; for (var S = E.x, M = S + E.width, P = E.y, q = P + E.height, se = p - 1; 0 <= se; se--)if (p !== se) { var Le = f[se], et = Le.x, It = et + Le.width, vn = Le.y, Kt = vn + Le.height; if (S >= et && P >= vn && M <= It && q <= Kt) { f.splice(p, 1); break } else if (S !== et || E.width !== Le.width || Kt < P || vn > q) { if (!(P !== vn || E.height !== Le.height || It < S || et > M)) { et > S && (Le.width += et - S, Le.x = S), It < M && (Le.width = M - et), f.splice(p, 1); break } } else { vn > P && (Le.height += vn - P, Le.y = P), Kt < q && (Le.height = q - vn), f.splice(p, 1); break } } } return f }, t.findHostInstance = Hw, t.findHostInstanceWithNoPortals = function (f) { return f = F(f), f = f !== null ? Y(f) : null, f === null ? null : f.stateNode }, t.findHostInstanceWithWarning = function (f) { return Hw(f) }, t.flushControlled = function (f) { var p = Mn; Mn |= 1; var E = Qi.transition, S = Un; try { Qi.transition = null, Un = 1, f() } finally { Un = S, Qi.transition = E, Mn = p, Mn === 0 && (s0(), va()) } }, t.flushPassiveEffects = ud, t.flushSync = Rw, t.focusWithin = function (f, p) { if (!it) throw Error(a(363)); for (f = v4(f), p = Mw(f, p), p = Array.from(p), f = 0; f < p.length;) { var E = p[f++]; if (!O(E)) { if (E.tag === 5 && Ne(E.stateNode)) return !0; for (E = E.child; E !== null;)p.push(E), E = E.sibling } } return !1 }, t.getCurrentUpdatePriority = function () { return Un }, t.getFindAllNodesFailureDescription = function (f, p) {
			if (!it) throw Error(a(363)); var E = 0, S = []; f = [v4(f), 0]; for (var M = 0; M < f.length;) { var P = f[M++], q = f[M++], se = p[q]; if ((P.tag !== 5 || !O(P)) && (y4(P, se) && (S.push(x4(se)), q++, q > E && (E = q)), q < p.length)) for (P = P.child; P !== null;)f.push(P, q), P = P.sibling } if (E < p.length) {
				for (f = []; E < p.length; E++)f.push(x4(p[E])); return `findAllNodes was able to match part of the selector:
  `+ (S.join(" > ") + `

No matching component was found for:
  `) + f.join(" > ")
			} return null
		}, t.getPublicRootInstance = function (f) { if (f = f.current, !f.child) return null; switch (f.child.tag) { case 5: return ne(f.child.stateNode); default: return f.child.stateNode } }, t.injectIntoDevTools = function (f) { if (f = { bundleType: f.bundleType, version: f.version, rendererPackageName: f.rendererPackageName, rendererConfig: f.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: o.ReactCurrentDispatcher, findHostInstanceByFiber: zH, findFiberByHostInstance: f.findFiberByHostInstance || VH, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") f = !1; else { var p = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (p.isDisabled || !p.supportsFiber) f = !0; else { try { el = p.inject(f), Ao = p } catch { } f = !!p.checkDCE } } return f }, t.isAlreadyRendering = function () { return !1 }, t.observeVisibleRects = function (f, p, E, S) { if (!it) throw Error(a(363)); f = _4(f, p); var M = Ue(f, E, S).disconnect; return { disconnect: function () { M() } } }, t.registerMutableSourceForHydration = function (f, p) { var E = p._getVersion; E = E(p._source), f.mutableSourceEagerHydrationData == null ? f.mutableSourceEagerHydrationData = [p, E] : f.mutableSourceEagerHydrationData.push(p, E) }, t.runWithPriority = function (f, p) { var E = Un; try { return Un = f, p() } finally { Un = E } }, t.shouldError = function () { return null }, t.shouldSuspend = function () { return !1 }, t.updateContainer = function (f, p, E, S) { var M = p.current, P = Ta(), q = Df(M); return E = Qw(E), p.context === null ? p.context = E : p.pendingContext = E, p = rl(P, q), p.payload = { element: f }, S = S === void 0 ? null : S, S !== null && (p.callback = S), Nu(M, p), f = al(M, q, P), f !== null && id(f, M, q), q }, t
	}; MU.exports = jne; var Jne = MU.exports; const Kne = By(Jne); var bU = { exports: {} }, BU = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (n) { function e(L, Q) { var D = L.length; L.push(Q); e: for (; 0 < D;) { var V = D - 1 >>> 1, J = L[V]; if (0 < i(J, Q)) L[V] = Q, L[D] = J, D = V; else break e } } function t(L) { return L.length === 0 ? null : L[0] } function r(L) { if (L.length === 0) return null; var Q = L[0], D = L.pop(); if (D !== Q) { L[0] = D; e: for (var V = 0, J = L.length, Ee = J >>> 1; V < Ee;) { var xe = 2 * (V + 1) - 1, Be = L[xe], Fe = xe + 1, we = L[Fe]; if (0 > i(Be, D)) Fe < J && 0 > i(we, Be) ? (L[V] = we, L[Fe] = D, V = Fe) : (L[V] = Be, L[xe] = D, V = xe); else if (Fe < J && 0 > i(we, D)) L[V] = we, L[Fe] = D, V = Fe; else break e } } return Q } function i(L, Q) { var D = L.sortIndex - Q.sortIndex; return D !== 0 ? D : L.id - Q.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; n.unstable_now = function () { return s.now() } } else { var a = Date, o = a.now(); n.unstable_now = function () { return a.now() - o } } var l = [], u = [], c = 1, h = null, d = 3, m = !1, g = !1, v = !1, y = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function x(L) { for (var Q = t(u); Q !== null;) { if (Q.callback === null) r(u); else if (Q.startTime <= L) r(u), Q.sortIndex = Q.expirationTime, e(l, Q); else break; Q = t(u) } } function C(L) { if (v = !1, x(L), !g) if (t(l) !== null) g = !0, ne(T); else { var Q = t(u); Q !== null && $(C, Q.startTime - L) } } function T(L, Q) { g = !1, v && (v = !1, A(R), R = -1), m = !0; var D = d; try { for (x(Q), h = t(l); h !== null && (!(h.expirationTime > Q) || L && !F());) { var V = h.callback; if (typeof V == "function") { h.callback = null, d = h.priorityLevel; var J = V(h.expirationTime <= Q); Q = n.unstable_now(), typeof J == "function" ? h.callback = J : h === t(l) && r(l), x(Q) } else r(l); h = t(l) } if (h !== null) var Ee = !0; else { var xe = t(u); xe !== null && $(C, xe.startTime - Q), Ee = !1 } return Ee } finally { h = null, d = D, m = !1 } } var I = !1, w = null, R = -1, b = 5, B = -1; function F() { return !(n.unstable_now() - B < b) } function U() { if (w !== null) { var L = n.unstable_now(); B = L; var Q = !0; try { Q = w(!0, L) } finally { Q ? G() : (I = !1, w = null) } } else I = !1 } var G; if (typeof _ == "function") G = function () { _(U) }; else if (typeof MessageChannel < "u") { var Y = new MessageChannel, Z = Y.port2; Y.port1.onmessage = U, G = function () { Z.postMessage(null) } } else G = function () { y(U, 0) }; function ne(L) { w = L, I || (I = !0, G()) } function $(L, Q) { R = y(function () { L(n.unstable_now()) }, Q) } n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (L) { L.callback = null }, n.unstable_continueExecution = function () { g || m || (g = !0, ne(T)) }, n.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < L ? Math.floor(1e3 / L) : 5 }, n.unstable_getCurrentPriorityLevel = function () { return d }, n.unstable_getFirstCallbackNode = function () { return t(l) }, n.unstable_next = function (L) { switch (d) { case 1: case 2: case 3: var Q = 3; break; default: Q = d }var D = d; d = Q; try { return L() } finally { d = D } }, n.unstable_pauseExecution = function () { }, n.unstable_requestPaint = function () { }, n.unstable_runWithPriority = function (L, Q) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var D = d; d = L; try { return Q() } finally { d = D } }, n.unstable_scheduleCallback = function (L, Q, D) { var V = n.unstable_now(); switch (typeof D == "object" && D !== null ? (D = D.delay, D = typeof D == "number" && 0 < D ? V + D : V) : D = V, L) { case 1: var J = -1; break; case 2: J = 250; break; case 5: J = 1073741823; break; case 4: J = 1e4; break; default: J = 5e3 }return J = D + J, L = { id: c++, callback: Q, priorityLevel: L, startTime: D, expirationTime: J, sortIndex: -1 }, D > V ? (L.sortIndex = D, e(u, L), t(l) === null && L === t(u) && (v ? (A(R), R = -1) : v = !0, $(C, D - V))) : (L.sortIndex = J, e(l, L), g || m || (g = !0, ne(T))), L }, n.unstable_shouldYield = F, n.unstable_wrapCallback = function (L) { var Q = d; return function () { var D = d; d = Q; try { return L.apply(this, arguments) } finally { d = D } } } })(BU); bU.exports = BU; var FB = bU.exports; const qne = n => typeof n == "object" && typeof n.then == "function", ep = []; function RU(n, e, t = (r, i) => r === i) { if (n === e) return !0; if (!n || !e) return !1; const r = n.length; if (e.length !== r) return !1; for (let i = 0; i < r; i++)if (!t(n[i], e[i])) return !1; return !0 } function PU(n, e = null, t = !1, r = {}) { e === null && (e = [n]); for (const s of ep) if (RU(e, s.keys, s.equal)) { if (t) return; if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error; if (Object.prototype.hasOwnProperty.call(s, "response")) return r.lifespan && r.lifespan > 0 && (s.timeout && clearTimeout(s.timeout), s.timeout = setTimeout(s.remove, r.lifespan)), s.response; if (!t) throw s.promise } const i = { keys: e, equal: r.equal, remove: () => { const s = ep.indexOf(i); s !== -1 && ep.splice(s, 1) }, promise: (qne(n) ? n : n(...e)).then(s => { i.response = s, r.lifespan && r.lifespan > 0 && (i.timeout = setTimeout(i.remove, r.lifespan)) }).catch(s => i.error = s) }; if (ep.push(i), !t) throw i.promise } const Zne = (n, e, t) => PU(n, e, !1, t), $ne = (n, e, t) => void PU(n, e, !0, t), ere = n => { if (n === void 0 || n.length === 0) ep.splice(0, ep.length); else { const e = ep.find(t => RU(n, t.keys, t.equal)); e && e.remove() } }, gT = {}, tre = n => void Object.assign(gT, n); function nre(n, e) { function t(c, { args: h = [], attach: d, ...m }, g) { let v = `${c[0].toUpperCase()}${c.slice(1)}`, y; if (c === "primitive") { if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!"); const A = m.object; y = Q0(A, { type: c, root: g, attach: d, primitive: !0 }) } else { const A = gT[v]; if (!A) throw new Error(`R3F: ${v} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`); if (!Array.isArray(h)) throw new Error("R3F: The args prop must be an array!"); y = Q0(new A(...h), { type: c, root: g, attach: d, memoizedProps: { args: h } }) } return y.__r3f.attach === void 0 && (y instanceof pn ? y.__r3f.attach = "geometry" : y instanceof as && (y.__r3f.attach = "material")), v !== "inject" && h_(y, m), y } function r(c, h) { let d = !1; if (h) { var m, g; (m = h.__r3f) != null && m.attach ? f_(c, h, h.__r3f.attach) : h.isObject3D && c.isObject3D && (c.add(h), d = !0), d || (g = c.__r3f) == null || g.objects.push(h), h.__r3f || Q0(h, {}), h.__r3f.parent = c, g7(h), H0(h) } } function i(c, h, d) { let m = !1; if (h) { var g, v; if ((g = h.__r3f) != null && g.attach) f_(c, h, h.__r3f.attach); else if (h.isObject3D && c.isObject3D) { h.parent = c, h.dispatchEvent({ type: "added" }); const y = c.children.filter(_ => _ !== h), A = y.indexOf(d); c.children = [...y.slice(0, A), h, ...y.slice(A)], m = !0 } m || (v = c.__r3f) == null || v.objects.push(h), h.__r3f || Q0(h, {}), h.__r3f.parent = c, g7(h), H0(h) } } function s(c, h, d = !1) { c && [...c].forEach(m => a(h, m, d)) } function a(c, h, d) { if (h) { var m, g, v; if (h.__r3f && (h.__r3f.parent = null), (m = c.__r3f) != null && m.objects && (c.__r3f.objects = c.__r3f.objects.filter(C => C !== h)), (g = h.__r3f) != null && g.attach) GB(c, h, h.__r3f.attach); else if (h.isObject3D && c.isObject3D) { var y; c.remove(h), (y = h.__r3f) != null && y.root && cre(h.__r3f.root, h) } const _ = (v = h.__r3f) == null ? void 0 : v.primitive, x = d === void 0 ? h.dispose !== null && !_ : d; if (!_) { var A; s((A = h.__r3f) == null ? void 0 : A.objects, h, x), s(h.children, h, x) } delete h.__r3f, x && h.dispose && h.type !== "Scene" && FB.unstable_scheduleCallback(FB.unstable_IdlePriority, () => { try { h.dispose() } catch { } }), H0(c) } } function o(c, h, d, m) { var g; const v = (g = c.__r3f) == null ? void 0 : g.parent; if (!v) return; const y = t(h, d, c.__r3f.root); if (c.children) { for (const A of c.children) A.__r3f && r(y, A); c.children = c.children.filter(A => !A.__r3f) } c.__r3f.objects.forEach(A => r(y, A)), c.__r3f.objects = [], c.__r3f.autoRemovedBeforeAppend || a(v, c), y.parent && (y.__r3f.autoRemovedBeforeAppend = !0), r(v, y), y.raycast && y.__r3f.eventCount && y.__r3f.root.getState().internal.interaction.push(y), [m, m.alternate].forEach(A => { A !== null && (A.stateNode = y, A.ref && (typeof A.ref == "function" ? A.ref(y) : A.ref.current = y)) }) } const l = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters."); return { reconciler: Kne({ createInstance: t, removeChild: a, appendChild: r, appendInitialChild: r, insertBefore: i, supportsMutation: !0, isPrimaryRenderer: !1, supportsPersistence: !1, supportsHydration: !1, noTimeout: -1, appendChildToContainer: (c, h) => { if (!h) return; const d = c.getState().scene; d.__r3f && (d.__r3f.root = c, r(d, h)) }, removeChildFromContainer: (c, h) => { h && a(c.getState().scene, h) }, insertInContainerBefore: (c, h, d) => { if (!h || !d) return; const m = c.getState().scene; m.__r3f && i(m, h, d) }, getRootHostContext: () => null, getChildHostContext: c => c, finalizeInitialChildren(c) { var h; return !!((h = c == null ? void 0 : c.__r3f) != null ? h : {}).handlers }, prepareUpdate(c, h, d, m) { var g; if (((g = c == null ? void 0 : c.__r3f) != null ? g : {}).primitive && m.object && m.object !== c) return [!0]; { const { args: y = [], children: A, ..._ } = m, { args: x = [], children: C, ...T } = d; if (!Array.isArray(y)) throw new Error("R3F: the args prop must be an array!"); if (y.some((w, R) => w !== x[R])) return [!0]; const I = UU(c, _, T, !0); return I.changes.length ? [!1, I] : null } }, commitUpdate(c, [h, d], m, g, v, y) { h ? o(c, m, v, y) : h_(c, d) }, commitMount(c, h, d, m) { var g; const v = (g = c.__r3f) != null ? g : {}; c.raycast && v.handlers && v.eventCount && c.__r3f.root.getState().internal.interaction.push(c) }, getPublicInstance: c => c, prepareForCommit: () => null, preparePortalMount: c => Q0(c.getState().scene), resetAfterCommit: () => { }, shouldSetTextContent: () => !1, clearContainer: () => !1, hideInstance(c) { var h; const { attach: d, parent: m } = (h = c.__r3f) != null ? h : {}; d && m && GB(m, c, d), c.isObject3D && (c.visible = !1), H0(c) }, unhideInstance(c, h) { var d; const { attach: m, parent: g } = (d = c.__r3f) != null ? d : {}; m && g && f_(g, c, m), (c.isObject3D && h.visible == null || h.visible) && (c.visible = !0), H0(c) }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : h3.DefaultEventPriority, beforeActiveInstanceBlur: () => { }, afterActiveInstanceBlur: () => { }, detachDeletedInstance: () => { }, now: typeof performance < "u" && $r.fun(performance.now) ? performance.now : $r.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: $r.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: $r.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: h_ } } var kB, NB; const c_ = n => "colorSpace" in n || "outputColorSpace" in n, DU = () => { var n; return (n = gT.ColorManagement) != null ? n : null }, LU = n => n && n.isOrthographicCamera, rre = n => n && n.hasOwnProperty("current"), z1 = typeof window < "u" && ((kB = window.document) != null && kB.createElement || ((NB = window.navigator) == null ? void 0 : NB.product) === "ReactNative") ? ue.useLayoutEffect : ue.useEffect; function FU(n) { const e = ue.useRef(n); return z1(() => void (e.current = n), [n]), e } function ire({ set: n }) { return z1(() => (n(new Promise(() => null)), () => n(!1)), [n]), null } class kU extends ue.Component { constructor(...e) { super(...e), this.state = { error: !1 } } componentDidCatch(e) { this.props.set(e) } render() { return this.state.error ? null : this.props.children } } kU.getDerivedStateFromError = () => ({ error: !0 }); const NU = "__default", OB = new Map, sre = n => n && !!n.memoized && !!n.changes; function OU(n) { var e; const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1; return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n } const og = n => { var e; return (e = n.__r3f) == null ? void 0 : e.root.getState() }, $r = { obj: n => n === Object(n) && !$r.arr(n) && typeof n != "function", fun: n => typeof n == "function", str: n => typeof n == "string", num: n => typeof n == "number", boo: n => typeof n == "boolean", und: n => n === void 0, arr: n => Array.isArray(n), equ(n, e, { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}) { if (typeof n != typeof e || !!n != !!e) return !1; if ($r.str(n) || $r.num(n)) return n === e; const s = $r.obj(n); if (s && r === "reference") return n === e; const a = $r.arr(n); if (a && t === "reference") return n === e; if ((a || s) && n === e) return !0; let o; for (o in n) if (!(o in e)) return !1; if (s && t === "shallow" && r === "shallow") { for (o in i ? e : n) if (!$r.equ(n[o], e[o], { strict: i, objects: "reference" })) return !1 } else for (o in i ? e : n) if (n[o] !== e[o]) return !1; if ($r.und(o)) { if (a && n.length === 0 && e.length === 0 || s && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0; if (n !== e) return !1 } return !0 } }; function are(n) { const e = { nodes: {}, materials: {} }; return n && n.traverse(t => { t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material) }), e } function ore(n) { n.dispose && n.type !== "Scene" && n.dispose(); for (const e in n) e.dispose == null || e.dispose(), delete n[e] } function Q0(n, e) { const t = n; return t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, n } function m7(n, e) { let t = n; if (e.includes("-")) { const r = e.split("-"), i = r.pop(); return t = r.reduce((s, a) => s[a], n), { target: t, key: i } } else return { target: t, key: e } } const UB = /-\d+$/; function f_(n, e, t) { if ($r.str(t)) { if (UB.test(t)) { const s = t.replace(UB, ""), { target: a, key: o } = m7(n, s); Array.isArray(a[o]) || (a[o] = []) } const { target: r, key: i } = m7(n, t); e.__r3f.previousAttach = r[i], r[i] = e } else e.__r3f.previousAttach = t(n, e) } function GB(n, e, t) { var r, i; if ($r.str(t)) { const { target: s, key: a } = m7(n, t), o = e.__r3f.previousAttach; o === void 0 ? delete s[a] : s[a] = o } else (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e); (i = e.__r3f) == null || delete i.previousAttach } function UU(n, { children: e, key: t, ref: r, ...i }, { children: s, key: a, ref: o, ...l } = {}, u = !1) { var c; const h = (c = n == null ? void 0 : n.__r3f) != null ? c : {}, d = Object.entries(i), m = []; if (u) { const v = Object.keys(l); for (let y = 0; y < v.length; y++)i.hasOwnProperty(v[y]) || d.unshift([v[y], NU + "remove"]) } d.forEach(([v, y]) => { var A; if ((A = n.__r3f) != null && A.primitive && v === "object" || $r.equ(y, l[v])) return; if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v)) return m.push([v, y, !0, []]); let _ = []; v.includes("-") && (_ = v.split("-")), m.push([v, y, !1, _]); for (const x in i) { const C = i[x]; x.startsWith(`${v}-`) && m.push([x, C, !1, x.split("-")]) } }); const g = { ...i }; return h.memoizedProps && h.memoizedProps.args && (g.args = h.memoizedProps.args), h.memoizedProps && h.memoizedProps.attach && (g.attach = h.memoizedProps.attach), { memoized: g, changes: m } } function h_(n, e) { var t, r, i; const s = (t = n.__r3f) != null ? t : {}, a = s.root, o = (r = a == null || a.getState == null ? void 0 : a.getState()) != null ? r : {}, { memoized: l, changes: u } = sre(e) ? e : UU(n, e), c = s.eventCount; n.__r3f && (n.__r3f.memoizedProps = l); for (let d = 0; d < u.length; d++) { let [m, g, v, y] = u[d]; if (c_(n)) { const C = "srgb", T = "srgb-linear"; m === "encoding" ? (m = "colorSpace", g = g === 3001 ? C : T) : m === "outputEncoding" && (m = "outputColorSpace", g = g === 3001 ? C : T) } let A = n, _ = A[m]; if (y.length && (_ = y.reduce((x, C) => x[C], n), !(_ && _.set))) { const [x, ...C] = y.reverse(); A = C.reverse().reduce((T, I) => T[I], n), m = x } if (g === NU + "remove") if (A.constructor) { let x = OB.get(A.constructor); x || (x = new A.constructor, OB.set(A.constructor, x)), g = x[m] } else g = 0; if (v) g ? s.handlers[m] = g : delete s.handlers[m], s.eventCount = Object.keys(s.handlers).length; else if (_ && _.set && (_.copy || _ instanceof dp)) { if (Array.isArray(g)) _.fromArray ? _.fromArray(g) : _.set(...g); else if (_.copy && g && g.constructor && _.constructor === g.constructor) _.copy(g); else if (g !== void 0) { const x = _ instanceof Je; !x && _.setScalar ? _.setScalar(g) : _ instanceof dp && g instanceof dp ? _.mask = g.mask : _.set(g), !DU() && !o.linear && x && _.convertSRGBToLinear() } } else if (A[m] = g, A[m] instanceof ri && A[m].format === Ri && A[m].type === As) { const x = A[m]; c_(x) && c_(o.gl) ? x.colorSpace = o.gl.outputColorSpace : x.encoding = o.gl.outputEncoding } H0(n) } if (s.parent && o.internal && n.raycast && c !== s.eventCount) { const d = o.internal.interaction.indexOf(n); d > -1 && o.internal.interaction.splice(d, 1), s.eventCount && o.internal.interaction.push(n) } return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (i = n.__r3f) != null && i.parent && g7(n), n } function H0(n) { var e, t; const r = (e = n.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState(); r && r.internal.frames === 0 && r.invalidate() } function g7(n) { n.onUpdate == null || n.onUpdate(n) } function lre(n, e) { n.manual || (LU(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix(), n.updateMatrixWorld()) } function c5(n) { return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId } function ure() { var n; const e = typeof self < "u" && self || typeof window < "u" && window; if (!e) return h3.DefaultEventPriority; switch ((n = e.event) == null ? void 0 : n.type) { case "click": case "contextmenu": case "dblclick": case "pointercancel": case "pointerdown": case "pointerup": return h3.DiscreteEventPriority; case "pointermove": case "pointerout": case "pointerover": case "pointerenter": case "pointerleave": case "wheel": return h3.ContinuousEventPriority; default: return h3.DefaultEventPriority } } function GU(n, e, t, r) { const i = t.get(e); i && (t.delete(e), t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r))) } function cre(n, e) { const { internal: t } = n.getState(); t.interaction = t.interaction.filter(r => r !== e), t.initialHits = t.initialHits.filter(r => r !== e), t.hovered.forEach((r, i) => { (r.eventObject === e || r.object === e) && t.hovered.delete(i) }), t.capturedMap.forEach((r, i) => { GU(t.capturedMap, e, r, i) }) } function fre(n) { function e(l) { const { internal: u } = n.getState(), c = l.offsetX - u.initialClick[0], h = l.offsetY - u.initialClick[1]; return Math.round(Math.sqrt(c * c + h * h)) } function t(l) { return l.filter(u => ["Move", "Over", "Enter", "Out", "Leave"].some(c => { var h; return (h = u.__r3f) == null ? void 0 : h.handlers["onPointer" + c] })) } function r(l, u) { const c = n.getState(), h = new Set, d = [], m = u ? u(c.internal.interaction) : c.internal.interaction; for (let A = 0; A < m.length; A++) { const _ = og(m[A]); _ && (_.raycaster.camera = void 0) } c.previousRoot || c.events.compute == null || c.events.compute(l, c); function g(A) { const _ = og(A); if (!_ || !_.events.enabled || _.raycaster.camera === null) return []; if (_.raycaster.camera === void 0) { var x; _.events.compute == null || _.events.compute(l, _, (x = _.previousRoot) == null ? void 0 : x.getState()), _.raycaster.camera === void 0 && (_.raycaster.camera = null) } return _.raycaster.camera ? _.raycaster.intersectObject(A, !0) : [] } let v = m.flatMap(g).sort((A, _) => { const x = og(A.object), C = og(_.object); return !x || !C ? A.distance - _.distance : C.events.priority - x.events.priority || A.distance - _.distance }).filter(A => { const _ = c5(A); return h.has(_) ? !1 : (h.add(_), !0) }); c.events.filter && (v = c.events.filter(v, c)); for (const A of v) { let _ = A.object; for (; _;) { var y; (y = _.__r3f) != null && y.eventCount && d.push({ ...A, eventObject: _ }), _ = _.parent } } if ("pointerId" in l && c.internal.capturedMap.has(l.pointerId)) for (let A of c.internal.capturedMap.get(l.pointerId).values()) h.has(c5(A.intersection)) || d.push(A.intersection); return d } function i(l, u, c, h) { const d = n.getState(); if (l.length) { const m = { stopped: !1 }; for (const g of l) { const v = og(g.object) || d, { raycaster: y, pointer: A, camera: _, internal: x } = v, C = new N(A.x, A.y, 0).unproject(_), T = B => { var F, U; return (F = (U = x.capturedMap.get(B)) == null ? void 0 : U.has(g.eventObject)) != null ? F : !1 }, I = B => { const F = { intersection: g, target: u.target }; x.capturedMap.has(B) ? x.capturedMap.get(B).set(g.eventObject, F) : x.capturedMap.set(B, new Map([[g.eventObject, F]])), u.target.setPointerCapture(B) }, w = B => { const F = x.capturedMap.get(B); F && GU(x.capturedMap, g.eventObject, F, B) }; let R = {}; for (let B in u) { let F = u[B]; typeof F != "function" && (R[B] = F) } let b = { ...g, ...R, pointer: A, intersections: l, stopped: m.stopped, delta: c, unprojectedPoint: C, ray: y.ray, camera: _, stopPropagation() { const B = "pointerId" in u && x.capturedMap.get(u.pointerId); if ((!B || B.has(g.eventObject)) && (b.stopped = m.stopped = !0, x.hovered.size && Array.from(x.hovered.values()).find(F => F.eventObject === g.eventObject))) { const F = l.slice(0, l.indexOf(g)); s([...F, g]) } }, target: { hasPointerCapture: T, setPointerCapture: I, releasePointerCapture: w }, currentTarget: { hasPointerCapture: T, setPointerCapture: I, releasePointerCapture: w }, nativeEvent: u }; if (h(b), m.stopped === !0) break } } return l } function s(l) { const { internal: u } = n.getState(); for (const c of u.hovered.values()) if (!l.length || !l.find(h => h.object === c.object && h.index === c.index && h.instanceId === c.instanceId)) { const d = c.eventObject.__r3f, m = d == null ? void 0 : d.handlers; if (u.hovered.delete(c5(c)), d != null && d.eventCount) { const g = { ...c, intersections: l }; m.onPointerOut == null || m.onPointerOut(g), m.onPointerLeave == null || m.onPointerLeave(g) } } } function a(l, u) { for (let c = 0; c < u.length; c++) { const h = u[c].__r3f; h == null || h.handlers.onPointerMissed == null || h.handlers.onPointerMissed(l) } } function o(l) { switch (l) { case "onPointerLeave": case "onPointerCancel": return () => s([]); case "onLostPointerCapture": return u => { const { internal: c } = n.getState(); "pointerId" in u && c.capturedMap.has(u.pointerId) && requestAnimationFrame(() => { c.capturedMap.has(u.pointerId) && (c.capturedMap.delete(u.pointerId), s([])) }) } }return function (c) { const { onPointerMissed: h, internal: d } = n.getState(); d.lastEvent.current = c; const m = l === "onPointerMove", g = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", y = r(c, m ? t : void 0), A = g ? e(c) : 0; l === "onPointerDown" && (d.initialClick = [c.offsetX, c.offsetY], d.initialHits = y.map(x => x.eventObject)), g && !y.length && A <= 2 && (a(c, d.interaction), h && h(c)), m && s(y); function _(x) { const C = x.eventObject, T = C.__r3f, I = T == null ? void 0 : T.handlers; if (T != null && T.eventCount) if (m) { if (I.onPointerOver || I.onPointerEnter || I.onPointerOut || I.onPointerLeave) { const w = c5(x), R = d.hovered.get(w); R ? R.stopped && x.stopPropagation() : (d.hovered.set(w, x), I.onPointerOver == null || I.onPointerOver(x), I.onPointerEnter == null || I.onPointerEnter(x)) } I.onPointerMove == null || I.onPointerMove(x) } else { const w = I[l]; w ? (!g || d.initialHits.includes(C)) && (a(c, d.interaction.filter(R => !d.initialHits.includes(R))), w(x)) : g && d.initialHits.includes(C) && a(c, d.interaction.filter(R => !d.initialHits.includes(R))) } } i(y, c, A, _) } } return { handlePointer: o } } const QU = n => !!(n != null && n.render), HU = ue.createContext(null), hre = (n, e) => { const t = Wne((o, l) => { const u = new N, c = new N, h = new N; function d(A = l().camera, _ = c, x = l().size) { const { width: C, height: T, top: I, left: w } = x, R = C / T; _ instanceof N ? h.copy(_) : h.set(..._); const b = A.getWorldPosition(u).distanceTo(h); if (LU(A)) return { width: C / A.zoom, height: T / A.zoom, top: I, left: w, factor: 1, distance: b, aspect: R }; { const B = A.fov * Math.PI / 180, F = 2 * Math.tan(B / 2) * b, U = F * (C / T); return { width: U, height: F, top: I, left: w, factor: C / U, distance: b, aspect: R } } } let m; const g = A => o(_ => ({ performance: { ..._.performance, current: A } })), v = new Se; return { set: o, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: !0, connected: !1 }, xr: null, scene: null, invalidate: (A = 1) => n(l(), A), advance: (A, _) => e(A, _, l()), legacy: !1, linear: !1, flat: !1, controls: null, clock: new L8, pointer: v, mouse: v, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: .5, max: 1, debounce: 200, regress: () => { const A = l(); m && clearTimeout(m), A.performance.current !== A.performance.min && g(A.performance.min), m = setTimeout(() => g(l().performance.max), A.performance.debounce) } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: d }, setEvents: A => o(_ => ({ ..._, events: { ..._.events, ...A } })), setSize: (A, _, x, C, T) => { const I = l().camera, w = { width: A, height: _, top: C || 0, left: T || 0, updateStyle: x }; o(R => ({ size: w, viewport: { ...R.viewport, ...d(I, c, w) } })) }, setDpr: A => o(_ => { const x = OU(A); return { viewport: { ..._.viewport, dpr: x, initialDpr: _.viewport.initialDpr || x } } }), setFrameloop: (A = "always") => { const _ = l().clock; _.stop(), _.elapsedTime = 0, A !== "never" && (_.start(), _.elapsedTime = 0), o(() => ({ frameloop: A })) }, previousRoot: void 0, internal: { active: !1, priority: 0, frames: 0, lastEvent: ue.createRef(), interaction: [], hovered: new Map, subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: new Map, subscribe: (A, _, x) => { const C = l().internal; return C.priority = C.priority + (_ > 0 ? 1 : 0), C.subscribers.push({ ref: A, priority: _, store: x }), C.subscribers = C.subscribers.sort((T, I) => T.priority - I.priority), () => { const T = l().internal; T != null && T.subscribers && (T.priority = T.priority - (_ > 0 ? 1 : 0), T.subscribers = T.subscribers.filter(I => I.ref !== A)) } } } } }), r = t.getState(); let i = r.size, s = r.viewport.dpr, a = r.camera; return t.subscribe(() => { const { camera: o, size: l, viewport: u, gl: c, set: h } = t.getState(); if (l !== i || u.dpr !== s) { var d; i = l, s = u.dpr, lre(o, l), c.setPixelRatio(u.dpr); const m = (d = l.updateStyle) != null ? d : typeof HTMLCanvasElement < "u" && c.domElement instanceof HTMLCanvasElement; c.setSize(l.width, l.height, m) } o !== a && (a = o, h(m => ({ viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(o) } }))) }), t.subscribe(o => n(o)), t }; let f5, dre = new Set, pre = new Set, mre = new Set; function d_(n, e) { if (n.size) for (const { callback: t } of n.values()) t(e) } function lg(n, e) { switch (n) { case "before": return d_(dre, e); case "after": return d_(pre, e); case "tail": return d_(mre, e) } } let p_, m_; function g_(n, e, t) { let r = e.clock.getDelta(); for (e.frameloop === "never" && typeof n == "number" && (r = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), p_ = e.internal.subscribers, f5 = 0; f5 < p_.length; f5++)m_ = p_[f5], m_.ref.current(m_.store.getState(), r, t); return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames } function gre(n) { let e = !1, t, r, i; function s(l) { r = requestAnimationFrame(s), e = !0, t = 0, lg("before", l); for (const c of n.values()) { var u; i = c.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((u = i.gl.xr) != null && u.isPresenting) && (t += g_(l, i)) } if (lg("after", l), t === 0) return lg("tail", l), e = !1, cancelAnimationFrame(r) } function a(l, u = 1) { var c; if (!l) return n.forEach(h => a(h.store.getState()), u); (c = l.gl.xr) != null && c.isPresenting || !l.internal.active || l.frameloop === "never" || (l.internal.frames = Math.min(60, l.internal.frames + u), e || (e = !0, requestAnimationFrame(s))) } function o(l, u = !0, c, h) { if (u && lg("before", l), c) g_(l, c, h); else for (const d of n.values()) g_(l, d.store.getState()); u && lg("after", l) } return { loop: s, invalidate: a, advance: o } } function zU() { const n = ue.useContext(HU); if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!"); return n } function su(n = t => t, e) { return zU()(n, e) } function Cm(n, e = 0) { const t = zU(), r = t.getState().internal.subscribe, i = FU(n); return z1(() => r(i, e, t), [e, r, t]), null } const QB = new WeakMap; function VU(n, e) { return function (t, ...r) { let i = QB.get(t); return i || (i = new t, QB.set(t, i)), n && n(i), Promise.all(r.map(s => new Promise((a, o) => i.load(s, l => { l.scene && Object.assign(l, are(l.scene)), a(l) }, e, l => o(new Error(`Could not load ${s}: ${l == null ? void 0 : l.message}`)))))).finally(() => i.dispose == null ? void 0 : i.dispose()) } } function V1(n, e, t, r) { const i = Array.isArray(e) ? e : [e], s = Zne(VU(t, r), [n, ...i], { equal: $r.equ }); return Array.isArray(e) ? s : s[0] } V1.preload = function (n, e, t) { const r = Array.isArray(e) ? e : [e]; return $ne(VU(t), [n, ...r]) }; V1.clear = function (n, e) { const t = Array.isArray(e) ? e : [e]; return ere([n, ...t]) }; const sm = new Map, { invalidate: HB, advance: zB } = gre(sm), { reconciler: cy, applyProps: P0 } = nre(sm, ure), D0 = { objects: "shallow", strict: !1 }, Are = (n, e) => { const t = typeof n == "function" ? n(e) : n; return QU(t) ? t : new XS({ powerPreference: "high-performance", canvas: e, antialias: !0, alpha: !0, ...n }) }; function vre(n, e) { if (e) return e; if (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) { const { width: t, height: r, top: i, left: s } = n.parentElement.getBoundingClientRect(); return { width: t, height: r, top: i, left: s } } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return { width: n.width, height: n.height, top: 0, left: 0 }; return { width: 0, height: 0, top: 0, left: 0 } } function yre(n) { const e = sm.get(n), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store; e && console.warn("R3F.createRoot should only be called once!"); const i = typeof reportError == "function" ? reportError : console.error, s = r || hre(HB, zB), a = t || cy.createContainer(s, h3.ConcurrentRoot, null, !1, null, "", i, null); e || sm.set(n, { fiber: a, store: s }); let o, l = !1, u; return { configure(c = {}) { let { gl: h, size: d, scene: m, events: g, onCreated: v, shadows: y = !1, linear: A = !1, flat: _ = !1, legacy: x = !1, orthographic: C = !1, frameloop: T = "always", dpr: I = [1, 2], performance: w, raycaster: R, camera: b, onPointerMissed: B } = c, F = s.getState(), U = F.gl; F.gl || F.set({ gl: U = Are(h, n) }); let G = F.raycaster; G || F.set({ raycaster: G = new CU }); const { params: Y, ...Z } = R || {}; if ($r.equ(Z, G, D0) || P0(G, { ...Z }), $r.equ(Y, G.params, D0) || P0(G, { params: { ...G.params, ...Y } }), !F.camera || F.camera === u && !$r.equ(u, b, D0)) { u = b; const J = b instanceof D1, Ee = J ? b : C ? new hu(0, 0, 0, 0, .1, 1e3) : new Gr(75, 0, .1, 1e3); J || (Ee.position.z = 5, b && P0(Ee, b), !F.camera && !(b != null && b.rotation) && Ee.lookAt(0, 0, 0)), F.set({ camera: Ee }) } if (!F.scene) { let J; m instanceof uy ? J = m : (J = new uy, m && P0(J, m)), F.set({ scene: Q0(J) }) } if (!F.xr) { var ne; const J = (Be, Fe) => { const we = s.getState(); we.frameloop !== "never" && zB(Be, !0, we, Fe) }, Ee = () => { const Be = s.getState(); Be.gl.xr.enabled = Be.gl.xr.isPresenting, Be.gl.xr.setAnimationLoop(Be.gl.xr.isPresenting ? J : null), Be.gl.xr.isPresenting || HB(Be) }, xe = { connect() { const Be = s.getState().gl; Be.xr.addEventListener("sessionstart", Ee), Be.xr.addEventListener("sessionend", Ee) }, disconnect() { const Be = s.getState().gl; Be.xr.removeEventListener("sessionstart", Ee), Be.xr.removeEventListener("sessionend", Ee) } }; typeof ((ne = U.xr) == null ? void 0 : ne.addEventListener) == "function" && xe.connect(), F.set({ xr: xe }) } if (U.shadowMap) { const J = U.shadowMap.enabled, Ee = U.shadowMap.type; if (U.shadowMap.enabled = !!y, $r.boo(y)) U.shadowMap.type = sA; else if ($r.str(y)) { var $; const xe = { basic: UN, percentage: t8, soft: sA, variance: iu }; U.shadowMap.type = ($ = xe[y]) != null ? $ : sA } else $r.obj(y) && Object.assign(U.shadowMap, y); (J !== U.shadowMap.enabled || Ee !== U.shadowMap.type) && (U.shadowMap.needsUpdate = !0) } const L = DU(); L && ("enabled" in L ? L.enabled = !x : "legacyMode" in L && (L.legacyMode = x)), P0(U, { outputEncoding: A ? 3e3 : 3001, toneMapping: _ ? wl : wS }), F.legacy !== x && F.set(() => ({ legacy: x })), F.linear !== A && F.set(() => ({ linear: A })), F.flat !== _ && F.set(() => ({ flat: _ })), h && !$r.fun(h) && !QU(h) && !$r.equ(h, U, D0) && P0(U, h), g && !F.events.handlers && F.set({ events: g(s) }); const V = vre(n, d); return $r.equ(V, F.size, D0) || F.setSize(V.width, V.height, V.updateStyle, V.top, V.left), I && F.viewport.dpr !== OU(I) && F.setDpr(I), F.frameloop !== T && F.setFrameloop(T), F.onPointerMissed || F.set({ onPointerMissed: B }), w && !$r.equ(w, F.performance, D0) && F.set(J => ({ performance: { ...J.performance, ...w } })), o = v, l = !0, this }, render(c) { return l || this.configure(), cy.updateContainer(ue.createElement(xre, { store: s, children: c, onCreated: o, rootElement: n }), a, null, () => { }), s }, unmount() { WU(n) } } } function xre({ store: n, children: e, onCreated: t, rootElement: r }) { return z1(() => { const i = n.getState(); i.set(s => ({ internal: { ...s.internal, active: !0 } })), t && t(i), n.getState().events.connected || i.events.connect == null || i.events.connect(r) }, []), ue.createElement(HU.Provider, { value: n }, e) } function WU(n, e) { const t = sm.get(n), r = t == null ? void 0 : t.fiber; if (r) { const i = t == null ? void 0 : t.store.getState(); i && (i.internal.active = !1), cy.updateContainer(null, r, null, () => { i && setTimeout(() => { try { var s, a, o, l; i.events.disconnect == null || i.events.disconnect(), (s = i.gl) == null || (a = s.renderLists) == null || a.dispose == null || a.dispose(), (o = i.gl) == null || o.forceContextLoss == null || o.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), ore(i), sm.delete(n), e && e(n) } catch { } }, 500) }) } } cy.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: ue.version }); function A7(n, e, t) { var r, i, s, a, o; e == null && (e = 100); function l() { var c = Date.now() - a; c < e && c >= 0 ? r = setTimeout(l, e - c) : (r = null, t || (o = n.apply(s, i), s = i = null)) } var u = function () { s = this, i = arguments, a = Date.now(); var c = t && !r; return r || (r = setTimeout(l, e)), c && (o = n.apply(s, i), s = i = null), o }; return u.clear = function () { r && (clearTimeout(r), r = null) }, u.flush = function () { r && (o = n.apply(s, i), s = i = null, clearTimeout(r), r = null) }, u } A7.debounce = A7; var _re = A7; const VB = By(_re); function Ere(n) { let { debounce: e, scroll: t, polyfill: r, offsetSize: i } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n; const s = r || (typeof window > "u" ? class { } : window.ResizeObserver); if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"); const [a, o] = ue.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), l = ue.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: a }), u = e ? typeof e == "number" ? e : e.scroll : null, c = e ? typeof e == "number" ? e : e.resize : null, h = ue.useRef(!1); ue.useEffect(() => (h.current = !0, () => void (h.current = !1))); const [d, m, g] = ue.useMemo(() => { const _ = () => { if (!l.current.element) return; const { left: x, top: C, width: T, height: I, bottom: w, right: R, x: b, y: B } = l.current.element.getBoundingClientRect(), F = { left: x, top: C, width: T, height: I, bottom: w, right: R, x: b, y: B }; l.current.element instanceof HTMLElement && i && (F.height = l.current.element.offsetHeight, F.width = l.current.element.offsetWidth), Object.freeze(F), h.current && !wre(l.current.lastBounds, F) && o(l.current.lastBounds = F) }; return [_, c ? VB(_, c) : _, u ? VB(_, u) : _] }, [o, i, u, c]); function v() { l.current.scrollContainers && (l.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", g, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null) } function y() { l.current.element && (l.current.resizeObserver = new s(g), l.current.resizeObserver.observe(l.current.element), t && l.current.scrollContainers && l.current.scrollContainers.forEach(_ => _.addEventListener("scroll", g, { capture: !0, passive: !0 }))) } const A = _ => { !_ || _ === l.current.element || (v(), l.current.element = _, l.current.scrollContainers = XU(_), y()) }; return Sre(g, !!t), Cre(m), ue.useEffect(() => { v(), y() }, [t, g, m]), ue.useEffect(() => v, []), [A, a, d] } function Cre(n) { ue.useEffect(() => { const e = n; return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e) }, [n]) } function Sre(n, e) { ue.useEffect(() => { if (e) { const t = n; return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0) } }, [n, e]) } function XU(n) { const e = []; if (!n || n === document.body) return e; const { overflow: t, overflowX: r, overflowY: i } = window.getComputedStyle(n); return [t, r, i].some(s => s === "auto" || s === "scroll") && e.push(n), [...e, ...XU(n.parentElement)] } const Tre = ["x", "y", "top", "bottom", "left", "right", "width", "height"], wre = (n, e) => Tre.every(t => n[t] === e[t]); var Ire = Object.defineProperty, Mre = Object.defineProperties, bre = Object.getOwnPropertyDescriptors, WB = Object.getOwnPropertySymbols, Bre = Object.prototype.hasOwnProperty, Rre = Object.prototype.propertyIsEnumerable, XB = (n, e, t) => e in n ? Ire(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, YB = (n, e) => { for (var t in e || (e = {})) Bre.call(e, t) && XB(n, t, e[t]); if (WB) for (var t of WB(e)) Rre.call(e, t) && XB(n, t, e[t]); return n }, Pre = (n, e) => Mre(n, bre(e)); function YU(n, e, t) { if (!n) return; if (t(n) === !0) return n; let r = e ? n.return : n.child; for (; r;) { const i = YU(r, e, t); if (i) return i; r = e ? null : r.sibling } } function jU(n) { try { return Object.defineProperties(n, { _currentRenderer: { get() { return null }, set() { } }, _currentRenderer2: { get() { return null }, set() { } } }) } catch { return n } } const AT = jU(ue.createContext(null)); class JU extends ue.Component { render() { return ue.createElement(AT.Provider, { value: this._reactInternals }, this.props.children) } } const { ReactCurrentOwner: jB, ReactCurrentDispatcher: JB } = ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; function Dre() { const n = ue.useContext(AT); if (n === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!"); const e = ue.useId(); return ue.useMemo(() => { for (const r of [jB == null ? void 0 : jB.current, n, n == null ? void 0 : n.alternate]) { if (!r) continue; const i = YU(r, !1, s => { let a = s.memoizedState; for (; a;) { if (a.memoizedState === e) return !0; a = a.next } }); if (i) return i } }, [n, e]) } function Lre() { var n, e; const t = Dre(), [r] = ue.useState(() => new Map); r.clear(); let i = t; for (; i;) { const s = (n = i.type) == null ? void 0 : n._context; s && s !== AT && !r.has(s) && r.set(s, (e = JB == null ? void 0 : JB.current) == null ? void 0 : e.readContext(jU(s))), i = i.return } return r } function Fre() { const n = Lre(); return ue.useMemo(() => Array.from(n.keys()).reduce((e, t) => r => ue.createElement(e, null, ue.createElement(t.Provider, Pre(YB({}, r), { value: n.get(t) }))), e => ue.createElement(JU, YB({}, e))), [n]) } const A_ = { onClick: ["click", !1], onContextMenu: ["contextmenu", !1], onDoubleClick: ["dblclick", !1], onWheel: ["wheel", !0], onPointerDown: ["pointerdown", !0], onPointerUp: ["pointerup", !0], onPointerLeave: ["pointerleave", !0], onPointerMove: ["pointermove", !0], onPointerCancel: ["pointercancel", !0], onLostPointerCapture: ["lostpointercapture", !0] }; function kre(n) { const { handlePointer: e } = fre(n); return { priority: 1, enabled: !0, compute(t, r, i) { r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera) }, connected: void 0, handlers: Object.keys(A_).reduce((t, r) => ({ ...t, [r]: e(r) }), {}), update: () => { var t; const { events: r, internal: i } = n.getState(); (t = i.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current) }, connect: t => { var r; const { set: i, events: s } = n.getState(); s.disconnect == null || s.disconnect(), i(a => ({ events: { ...a.events, connected: t } })), Object.entries((r = s.handlers) != null ? r : []).forEach(([a, o]) => { const [l, u] = A_[a]; t.addEventListener(l, o, { passive: u }) }) }, disconnect: () => { const { set: t, events: r } = n.getState(); if (r.connected) { var i; Object.entries((i = r.handlers) != null ? i : []).forEach(([s, a]) => { if (r && r.connected instanceof HTMLElement) { const [o] = A_[s]; r.connected.removeEventListener(o, a) } }), t(s => ({ events: { ...s.events, connected: void 0 } })) } } } } const Nre = ue.forwardRef(function ({ children: e, fallback: t, resize: r, style: i, gl: s, events: a = kre, eventSource: o, eventPrefix: l, shadows: u, linear: c, flat: h, legacy: d, orthographic: m, frameloop: g, dpr: v, performance: y, raycaster: A, camera: _, scene: x, onPointerMissed: C, onCreated: T, ...I }, w) { ue.useMemo(() => tre(Hne), []); const R = Fre(), [b, B] = Ere({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }), F = ue.useRef(null), U = ue.useRef(null); ue.useImperativeHandle(w, () => F.current); const G = FU(C), [Y, Z] = ue.useState(!1), [ne, $] = ue.useState(!1); if (Y) throw Y; if (ne) throw ne; const L = ue.useRef(null); z1(() => { const D = F.current; B.width > 0 && B.height > 0 && D && (L.current || (L.current = yre(D)), L.current.configure({ gl: s, events: a, shadows: u, linear: c, flat: h, legacy: d, orthographic: m, frameloop: g, dpr: v, performance: y, raycaster: A, camera: _, scene: x, size: B, onPointerMissed: (...V) => G.current == null ? void 0 : G.current(...V), onCreated: V => { V.events.connect == null || V.events.connect(o ? rre(o) ? o.current : o : U.current), l && V.setEvents({ compute: (J, Ee) => { const xe = J[l + "X"], Be = J[l + "Y"]; Ee.pointer.set(xe / Ee.size.width * 2 - 1, -(Be / Ee.size.height) * 2 + 1), Ee.raycaster.setFromCamera(Ee.pointer, Ee.camera) } }), T == null || T(V) } }), L.current.render(ue.createElement(R, null, ue.createElement(kU, { set: $ }, ue.createElement(ue.Suspense, { fallback: ue.createElement(ire, { set: Z }) }, e))))) }), ue.useEffect(() => { const D = F.current; if (D) return () => WU(D) }, []); const Q = o ? "none" : "auto"; return ue.createElement("div", dc({ ref: U, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: Q, ...i } }, I), ue.createElement("div", { ref: b, style: { width: "100%", height: "100%" } }, ue.createElement("canvas", { ref: F, style: { display: "block" } }, t))) }), KU = ue.forwardRef(function (e, t) { return ue.createElement(JU, null, ue.createElement(Nre, dc({}, e, { ref: t }))) }); function qU(n) { return function (e) { n.forEach(function (t) { typeof t == "function" ? t(e) : t != null && (t.current = e) }) } } function P3(n, e, t) { return e in n ? Object.defineProperty(n, e, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : n[e] = t, n } function KB(n, e) { var t = Object.keys(n); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(n); e && (r = r.filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable })), t.push.apply(t, r) } return t } function qB(n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e] != null ? arguments[e] : {}; e % 2 ? KB(Object(t), !0).forEach(function (r) { P3(n, r, t[r]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : KB(Object(t)).forEach(function (r) { Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r)) }) } return n } new Se; new Se; function ZU(n, e) { if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function") } var cl = function n(e, t, r) { var i = this; ZU(this, n), P3(this, "dot2", function (s, a) { return i.x * s + i.y * a }), P3(this, "dot3", function (s, a, o) { return i.x * s + i.y * a + i.z * o }), this.x = e, this.y = t, this.z = r }, Ore = [new cl(1, 1, 0), new cl(-1, 1, 0), new cl(1, -1, 0), new cl(-1, -1, 0), new cl(1, 0, 1), new cl(-1, 0, 1), new cl(1, 0, -1), new cl(-1, 0, -1), new cl(0, 1, 1), new cl(0, -1, 1), new cl(0, 1, -1), new cl(0, -1, -1)], ZB = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], $B = new Array(512), eR = new Array(512), Ure = function (e) { e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8); for (var t = 0; t < 256; t++) { var r; t & 1 ? r = ZB[t] ^ e & 255 : r = ZB[t] ^ e >> 8 & 255, $B[t] = $B[t + 256] = r, eR[t] = eR[t + 256] = Ore[r % 12] } }; Ure(0); function Gre(n) { if (typeof n == "number") n = Math.abs(n); else if (typeof n == "string") { var e = n; n = 0; for (var t = 0; t < e.length; t++)n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647 } return n === 0 && (n = 311), n } function tR(n) { var e = Gre(n); return function () { var t = e * 48271 % 2147483647; return e = t, t / 2147483647 } } var Qre = function n(e) { var t = this; ZU(this, n), P3(this, "seed", 0), P3(this, "init", function (r) { t.seed = r, t.value = tR(r) }), P3(this, "value", tR(this.seed)), this.init(e) }, Hre = new Qre(Math.random()), zre = { radius: 1, center: [0, 0, 0] }; function Vre(n, e) { for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Hre, r = qB(qB({}, zre), e), i = r.radius, s = r.center, a = 0; a < n.length; a += 3) { var o = Math.pow(t.value(), .3333333333333333), l = t.value() * 2 - 1, u = t.value() * 2 - 1, c = t.value() * 2 - 1, h = Math.sqrt(l * l + u * u + c * c); l = o * l / h, u = o * u / h, c = o * c / h, n[a] = l * i + s[0], n[a + 1] = u * i + s[1], n[a + 2] = c * i + s[2] } return n } function vT() { } vT.prototype.s2u = function (n) { for (var e = this.s2uTable, t = "", r = 0; r < n.length;) { var i = n[r++]; if (!(i >= 0 && i <= 126 || i >= 161 && i <= 223) && r < n.length && (i = i << 8 | n[r++]), e[i] === void 0) return console.error("unknown char code " + i + "."), t; t += String.fromCharCode(e[i]) } return t }; vT.prototype.s2uTable = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 34: 34, 35: 35, 36: 36, 37: 37, 38: 38, 39: 39, 40: 40, 41: 41, 42: 42, 43: 43, 44: 44, 45: 45, 46: 46, 47: 47, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 58: 58, 59: 59, 60: 60, 61: 61, 62: 62, 63: 63, 64: 64, 65: 65, 66: 66, 67: 67, 68: 68, 69: 69, 70: 70, 71: 71, 72: 72, 73: 73, 74: 74, 75: 75, 76: 76, 77: 77, 78: 78, 79: 79, 80: 80, 81: 81, 82: 82, 83: 83, 84: 84, 85: 85, 86: 86, 87: 87, 88: 88, 89: 89, 90: 90, 91: 91, 92: 92, 93: 93, 94: 94, 95: 95, 96: 96, 97: 97, 98: 98, 99: 99, 100: 100, 101: 101, 102: 102, 103: 103, 104: 104, 105: 105, 106: 106, 107: 107, 108: 108, 109: 109, 110: 110, 111: 111, 112: 112, 113: 113, 114: 114, 115: 115, 116: 116, 117: 117, 118: 118, 119: 119, 120: 120, 121: 121, 122: 122, 123: 123, 124: 124, 125: 125, 126: 126, 161: 65377, 162: 65378, 163: 65379, 164: 65380, 165: 65381, 166: 65382, 167: 65383, 168: 65384, 169: 65385, 170: 65386, 171: 65387, 172: 65388, 173: 65389, 174: 65390, 175: 65391, 176: 65392, 177: 65393, 178: 65394, 179: 65395, 180: 65396, 181: 65397, 182: 65398, 183: 65399, 184: 65400, 185: 65401, 186: 65402, 187: 65403, 188: 65404, 189: 65405, 190: 65406, 191: 65407, 192: 65408, 193: 65409, 194: 65410, 195: 65411, 196: 65412, 197: 65413, 198: 65414, 199: 65415, 200: 65416, 201: 65417, 202: 65418, 203: 65419, 204: 65420, 205: 65421, 206: 65422, 207: 65423, 208: 65424, 209: 65425, 210: 65426, 211: 65427, 212: 65428, 213: 65429, 214: 65430, 215: 65431, 216: 65432, 217: 65433, 218: 65434, 219: 65435, 220: 65436, 221: 65437, 222: 65438, 223: 65439, 33088: 12288, 33089: 12289, 33090: 12290, 33091: 65292, 33092: 65294, 33093: 12539, 33094: 65306, 33095: 65307, 33096: 65311, 33097: 65281, 33098: 12443, 33099: 12444, 33100: 180, 33101: 65344, 33102: 168, 33103: 65342, 33104: 65507, 33105: 65343, 33106: 12541, 33107: 12542, 33108: 12445, 33109: 12446, 33110: 12291, 33111: 20189, 33112: 12293, 33113: 12294, 33114: 12295, 33115: 12540, 33116: 8213, 33117: 8208, 33118: 65295, 33119: 65340, 33120: 65374, 33121: 8741, 33122: 65372, 33123: 8230, 33124: 8229, 33125: 8216, 33126: 8217, 33127: 8220, 33128: 8221, 33129: 65288, 33130: 65289, 33131: 12308, 33132: 12309, 33133: 65339, 33134: 65341, 33135: 65371, 33136: 65373, 33137: 12296, 33138: 12297, 33139: 12298, 33140: 12299, 33141: 12300, 33142: 12301, 33143: 12302, 33144: 12303, 33145: 12304, 33146: 12305, 33147: 65291, 33148: 65293, 33149: 177, 33150: 215, 33152: 247, 33153: 65309, 33154: 8800, 33155: 65308, 33156: 65310, 33157: 8806, 33158: 8807, 33159: 8734, 33160: 8756, 33161: 9794, 33162: 9792, 33163: 176, 33164: 8242, 33165: 8243, 33166: 8451, 33167: 65509, 33168: 65284, 33169: 65504, 33170: 65505, 33171: 65285, 33172: 65283, 33173: 65286, 33174: 65290, 33175: 65312, 33176: 167, 33177: 9734, 33178: 9733, 33179: 9675, 33180: 9679, 33181: 9678, 33182: 9671, 33183: 9670, 33184: 9633, 33185: 9632, 33186: 9651, 33187: 9650, 33188: 9661, 33189: 9660, 33190: 8251, 33191: 12306, 33192: 8594, 33193: 8592, 33194: 8593, 33195: 8595, 33196: 12307, 33208: 8712, 33209: 8715, 33210: 8838, 33211: 8839, 33212: 8834, 33213: 8835, 33214: 8746, 33215: 8745, 33224: 8743, 33225: 8744, 33226: 65506, 33227: 8658, 33228: 8660, 33229: 8704, 33230: 8707, 33242: 8736, 33243: 8869, 33244: 8978, 33245: 8706, 33246: 8711, 33247: 8801, 33248: 8786, 33249: 8810, 33250: 8811, 33251: 8730, 33252: 8765, 33253: 8733, 33254: 8757, 33255: 8747, 33256: 8748, 33264: 8491, 33265: 8240, 33266: 9839, 33267: 9837, 33268: 9834, 33269: 8224, 33270: 8225, 33271: 182, 33276: 9711, 33359: 65296, 33360: 65297, 33361: 65298, 33362: 65299, 33363: 65300, 33364: 65301, 33365: 65302, 33366: 65303, 33367: 65304, 33368: 65305, 33376: 65313, 33377: 65314, 33378: 65315, 33379: 65316, 33380: 65317, 33381: 65318, 33382: 65319, 33383: 65320, 33384: 65321, 33385: 65322, 33386: 65323, 33387: 65324, 33388: 65325, 33389: 65326, 33390: 65327, 33391: 65328, 33392: 65329, 33393: 65330, 33394: 65331, 33395: 65332, 33396: 65333, 33397: 65334, 33398: 65335, 33399: 65336, 33400: 65337, 33401: 65338, 33409: 65345, 33410: 65346, 33411: 65347, 33412: 65348, 33413: 65349, 33414: 65350, 33415: 65351, 33416: 65352, 33417: 65353, 33418: 65354, 33419: 65355, 33420: 65356, 33421: 65357, 33422: 65358, 33423: 65359, 33424: 65360, 33425: 65361, 33426: 65362, 33427: 65363, 33428: 65364, 33429: 65365, 33430: 65366, 33431: 65367, 33432: 65368, 33433: 65369, 33434: 65370, 33439: 12353, 33440: 12354, 33441: 12355, 33442: 12356, 33443: 12357, 33444: 12358, 33445: 12359, 33446: 12360, 33447: 12361, 33448: 12362, 33449: 12363, 33450: 12364, 33451: 12365, 33452: 12366, 33453: 12367, 33454: 12368, 33455: 12369, 33456: 12370, 33457: 12371, 33458: 12372, 33459: 12373, 33460: 12374, 33461: 12375, 33462: 12376, 33463: 12377, 33464: 12378, 33465: 12379, 33466: 12380, 33467: 12381, 33468: 12382, 33469: 12383, 33470: 12384, 33471: 12385, 33472: 12386, 33473: 12387, 33474: 12388, 33475: 12389, 33476: 12390, 33477: 12391, 33478: 12392, 33479: 12393, 33480: 12394, 33481: 12395, 33482: 12396, 33483: 12397, 33484: 12398, 33485: 12399, 33486: 12400, 33487: 12401, 33488: 12402, 33489: 12403, 33490: 12404, 33491: 12405, 33492: 12406, 33493: 12407, 33494: 12408, 33495: 12409, 33496: 12410, 33497: 12411, 33498: 12412, 33499: 12413, 33500: 12414, 33501: 12415, 33502: 12416, 33503: 12417, 33504: 12418, 33505: 12419, 33506: 12420, 33507: 12421, 33508: 12422, 33509: 12423, 33510: 12424, 33511: 12425, 33512: 12426, 33513: 12427, 33514: 12428, 33515: 12429, 33516: 12430, 33517: 12431, 33518: 12432, 33519: 12433, 33520: 12434, 33521: 12435, 33600: 12449, 33601: 12450, 33602: 12451, 33603: 12452, 33604: 12453, 33605: 12454, 33606: 12455, 33607: 12456, 33608: 12457, 33609: 12458, 33610: 12459, 33611: 12460, 33612: 12461, 33613: 12462, 33614: 12463, 33615: 12464, 33616: 12465, 33617: 12466, 33618: 12467, 33619: 12468, 33620: 12469, 33621: 12470, 33622: 12471, 33623: 12472, 33624: 12473, 33625: 12474, 33626: 12475, 33627: 12476, 33628: 12477, 33629: 12478, 33630: 12479, 33631: 12480, 33632: 12481, 33633: 12482, 33634: 12483, 33635: 12484, 33636: 12485, 33637: 12486, 33638: 12487, 33639: 12488, 33640: 12489, 33641: 12490, 33642: 12491, 33643: 12492, 33644: 12493, 33645: 12494, 33646: 12495, 33647: 12496, 33648: 12497, 33649: 12498, 33650: 12499, 33651: 12500, 33652: 12501, 33653: 12502, 33654: 12503, 33655: 12504, 33656: 12505, 33657: 12506, 33658: 12507, 33659: 12508, 33660: 12509, 33661: 12510, 33662: 12511, 33664: 12512, 33665: 12513, 33666: 12514, 33667: 12515, 33668: 12516, 33669: 12517, 33670: 12518, 33671: 12519, 33672: 12520, 33673: 12521, 33674: 12522, 33675: 12523, 33676: 12524, 33677: 12525, 33678: 12526, 33679: 12527, 33680: 12528, 33681: 12529, 33682: 12530, 33683: 12531, 33684: 12532, 33685: 12533, 33686: 12534, 33695: 913, 33696: 914, 33697: 915, 33698: 916, 33699: 917, 33700: 918, 33701: 919, 33702: 920, 33703: 921, 33704: 922, 33705: 923, 33706: 924, 33707: 925, 33708: 926, 33709: 927, 33710: 928, 33711: 929, 33712: 931, 33713: 932, 33714: 933, 33715: 934, 33716: 935, 33717: 936, 33718: 937, 33727: 945, 33728: 946, 33729: 947, 33730: 948, 33731: 949, 33732: 950, 33733: 951, 33734: 952, 33735: 953, 33736: 954, 33737: 955, 33738: 956, 33739: 957, 33740: 958, 33741: 959, 33742: 960, 33743: 961, 33744: 963, 33745: 964, 33746: 965, 33747: 966, 33748: 967, 33749: 968, 33750: 969, 33856: 1040, 33857: 1041, 33858: 1042, 33859: 1043, 33860: 1044, 33861: 1045, 33862: 1025, 33863: 1046, 33864: 1047, 33865: 1048, 33866: 1049, 33867: 1050, 33868: 1051, 33869: 1052, 33870: 1053, 33871: 1054, 33872: 1055, 33873: 1056, 33874: 1057, 33875: 1058, 33876: 1059, 33877: 1060, 33878: 1061, 33879: 1062, 33880: 1063, 33881: 1064, 33882: 1065, 33883: 1066, 33884: 1067, 33885: 1068, 33886: 1069, 33887: 1070, 33888: 1071, 33904: 1072, 33905: 1073, 33906: 1074, 33907: 1075, 33908: 1076, 33909: 1077, 33910: 1105, 33911: 1078, 33912: 1079, 33913: 1080, 33914: 1081, 33915: 1082, 33916: 1083, 33917: 1084, 33918: 1085, 33920: 1086, 33921: 1087, 33922: 1088, 33923: 1089, 33924: 1090, 33925: 1091, 33926: 1092, 33927: 1093, 33928: 1094, 33929: 1095, 33930: 1096, 33931: 1097, 33932: 1098, 33933: 1099, 33934: 1100, 33935: 1101, 33936: 1102, 33937: 1103, 33951: 9472, 33952: 9474, 33953: 9484, 33954: 9488, 33955: 9496, 33956: 9492, 33957: 9500, 33958: 9516, 33959: 9508, 33960: 9524, 33961: 9532, 33962: 9473, 33963: 9475, 33964: 9487, 33965: 9491, 33966: 9499, 33967: 9495, 33968: 9507, 33969: 9523, 33970: 9515, 33971: 9531, 33972: 9547, 33973: 9504, 33974: 9519, 33975: 9512, 33976: 9527, 33977: 9535, 33978: 9501, 33979: 9520, 33980: 9509, 33981: 9528, 33982: 9538, 34624: 9312, 34625: 9313, 34626: 9314, 34627: 9315, 34628: 9316, 34629: 9317, 34630: 9318, 34631: 9319, 34632: 9320, 34633: 9321, 34634: 9322, 34635: 9323, 34636: 9324, 34637: 9325, 34638: 9326, 34639: 9327, 34640: 9328, 34641: 9329, 34642: 9330, 34643: 9331, 34644: 8544, 34645: 8545, 34646: 8546, 34647: 8547, 34648: 8548, 34649: 8549, 34650: 8550, 34651: 8551, 34652: 8552, 34653: 8553, 34655: 13129, 34656: 13076, 34657: 13090, 34658: 13133, 34659: 13080, 34660: 13095, 34661: 13059, 34662: 13110, 34663: 13137, 34664: 13143, 34665: 13069, 34666: 13094, 34667: 13091, 34668: 13099, 34669: 13130, 34670: 13115, 34671: 13212, 34672: 13213, 34673: 13214, 34674: 13198, 34675: 13199, 34676: 13252, 34677: 13217, 34686: 13179, 34688: 12317, 34689: 12319, 34690: 8470, 34691: 13261, 34692: 8481, 34693: 12964, 34694: 12965, 34695: 12966, 34696: 12967, 34697: 12968, 34698: 12849, 34699: 12850, 34700: 12857, 34701: 13182, 34702: 13181, 34703: 13180, 34704: 8786, 34705: 8801, 34706: 8747, 34707: 8750, 34708: 8721, 34709: 8730, 34710: 8869, 34711: 8736, 34712: 8735, 34713: 8895, 34714: 8757, 34715: 8745, 34716: 8746, 34975: 20124, 34976: 21782, 34977: 23043, 34978: 38463, 34979: 21696, 34980: 24859, 34981: 25384, 34982: 23030, 34983: 36898, 34984: 33909, 34985: 33564, 34986: 31312, 34987: 24746, 34988: 25569, 34989: 28197, 34990: 26093, 34991: 33894, 34992: 33446, 34993: 39925, 34994: 26771, 34995: 22311, 34996: 26017, 34997: 25201, 34998: 23451, 34999: 22992, 35e3: 34427, 35001: 39156, 35002: 32098, 35003: 32190, 35004: 39822, 35005: 25110, 35006: 31903, 35007: 34999, 35008: 23433, 35009: 24245, 35010: 25353, 35011: 26263, 35012: 26696, 35013: 38343, 35014: 38797, 35015: 26447, 35016: 20197, 35017: 20234, 35018: 20301, 35019: 20381, 35020: 20553, 35021: 22258, 35022: 22839, 35023: 22996, 35024: 23041, 35025: 23561, 35026: 24799, 35027: 24847, 35028: 24944, 35029: 26131, 35030: 26885, 35031: 28858, 35032: 30031, 35033: 30064, 35034: 31227, 35035: 32173, 35036: 32239, 35037: 32963, 35038: 33806, 35039: 34915, 35040: 35586, 35041: 36949, 35042: 36986, 35043: 21307, 35044: 20117, 35045: 20133, 35046: 22495, 35047: 32946, 35048: 37057, 35049: 30959, 35050: 19968, 35051: 22769, 35052: 28322, 35053: 36920, 35054: 31282, 35055: 33576, 35056: 33419, 35057: 39983, 35058: 20801, 35059: 21360, 35060: 21693, 35061: 21729, 35062: 22240, 35063: 23035, 35064: 24341, 35065: 39154, 35066: 28139, 35067: 32996, 35068: 34093, 35136: 38498, 35137: 38512, 35138: 38560, 35139: 38907, 35140: 21515, 35141: 21491, 35142: 23431, 35143: 28879, 35144: 32701, 35145: 36802, 35146: 38632, 35147: 21359, 35148: 40284, 35149: 31418, 35150: 19985, 35151: 30867, 35152: 33276, 35153: 28198, 35154: 22040, 35155: 21764, 35156: 27421, 35157: 34074, 35158: 39995, 35159: 23013, 35160: 21417, 35161: 28006, 35162: 29916, 35163: 38287, 35164: 22082, 35165: 20113, 35166: 36939, 35167: 38642, 35168: 33615, 35169: 39180, 35170: 21473, 35171: 21942, 35172: 23344, 35173: 24433, 35174: 26144, 35175: 26355, 35176: 26628, 35177: 27704, 35178: 27891, 35179: 27945, 35180: 29787, 35181: 30408, 35182: 31310, 35183: 38964, 35184: 33521, 35185: 34907, 35186: 35424, 35187: 37613, 35188: 28082, 35189: 30123, 35190: 30410, 35191: 39365, 35192: 24742, 35193: 35585, 35194: 36234, 35195: 38322, 35196: 27022, 35197: 21421, 35198: 20870, 35200: 22290, 35201: 22576, 35202: 22852, 35203: 23476, 35204: 24310, 35205: 24616, 35206: 25513, 35207: 25588, 35208: 27839, 35209: 28436, 35210: 28814, 35211: 28948, 35212: 29017, 35213: 29141, 35214: 29503, 35215: 32257, 35216: 33398, 35217: 33489, 35218: 34199, 35219: 36960, 35220: 37467, 35221: 40219, 35222: 22633, 35223: 26044, 35224: 27738, 35225: 29989, 35226: 20985, 35227: 22830, 35228: 22885, 35229: 24448, 35230: 24540, 35231: 25276, 35232: 26106, 35233: 27178, 35234: 27431, 35235: 27572, 35236: 29579, 35237: 32705, 35238: 35158, 35239: 40236, 35240: 40206, 35241: 40644, 35242: 23713, 35243: 27798, 35244: 33659, 35245: 20740, 35246: 23627, 35247: 25014, 35248: 33222, 35249: 26742, 35250: 29281, 35251: 20057, 35252: 20474, 35253: 21368, 35254: 24681, 35255: 28201, 35256: 31311, 35257: 38899, 35258: 19979, 35259: 21270, 35260: 20206, 35261: 20309, 35262: 20285, 35263: 20385, 35264: 20339, 35265: 21152, 35266: 21487, 35267: 22025, 35268: 22799, 35269: 23233, 35270: 23478, 35271: 23521, 35272: 31185, 35273: 26247, 35274: 26524, 35275: 26550, 35276: 27468, 35277: 27827, 35278: 28779, 35279: 29634, 35280: 31117, 35281: 31166, 35282: 31292, 35283: 31623, 35284: 33457, 35285: 33499, 35286: 33540, 35287: 33655, 35288: 33775, 35289: 33747, 35290: 34662, 35291: 35506, 35292: 22057, 35293: 36008, 35294: 36838, 35295: 36942, 35296: 38686, 35297: 34442, 35298: 20420, 35299: 23784, 35300: 25105, 35301: 29273, 35302: 30011, 35303: 33253, 35304: 33469, 35305: 34558, 35306: 36032, 35307: 38597, 35308: 39187, 35309: 39381, 35310: 20171, 35311: 20250, 35312: 35299, 35313: 22238, 35314: 22602, 35315: 22730, 35316: 24315, 35317: 24555, 35318: 24618, 35319: 24724, 35320: 24674, 35321: 25040, 35322: 25106, 35323: 25296, 35324: 25913, 35392: 39745, 35393: 26214, 35394: 26800, 35395: 28023, 35396: 28784, 35397: 30028, 35398: 30342, 35399: 32117, 35400: 33445, 35401: 34809, 35402: 38283, 35403: 38542, 35404: 35997, 35405: 20977, 35406: 21182, 35407: 22806, 35408: 21683, 35409: 23475, 35410: 23830, 35411: 24936, 35412: 27010, 35413: 28079, 35414: 30861, 35415: 33995, 35416: 34903, 35417: 35442, 35418: 37799, 35419: 39608, 35420: 28012, 35421: 39336, 35422: 34521, 35423: 22435, 35424: 26623, 35425: 34510, 35426: 37390, 35427: 21123, 35428: 22151, 35429: 21508, 35430: 24275, 35431: 25313, 35432: 25785, 35433: 26684, 35434: 26680, 35435: 27579, 35436: 29554, 35437: 30906, 35438: 31339, 35439: 35226, 35440: 35282, 35441: 36203, 35442: 36611, 35443: 37101, 35444: 38307, 35445: 38548, 35446: 38761, 35447: 23398, 35448: 23731, 35449: 27005, 35450: 38989, 35451: 38990, 35452: 25499, 35453: 31520, 35454: 27179, 35456: 27263, 35457: 26806, 35458: 39949, 35459: 28511, 35460: 21106, 35461: 21917, 35462: 24688, 35463: 25324, 35464: 27963, 35465: 28167, 35466: 28369, 35467: 33883, 35468: 35088, 35469: 36676, 35470: 19988, 35471: 39993, 35472: 21494, 35473: 26907, 35474: 27194, 35475: 38788, 35476: 26666, 35477: 20828, 35478: 31427, 35479: 33970, 35480: 37340, 35481: 37772, 35482: 22107, 35483: 40232, 35484: 26658, 35485: 33541, 35486: 33841, 35487: 31909, 35488: 21e3, 35489: 33477, 35490: 29926, 35491: 20094, 35492: 20355, 35493: 20896, 35494: 23506, 35495: 21002, 35496: 21208, 35497: 21223, 35498: 24059, 35499: 21914, 35500: 22570, 35501: 23014, 35502: 23436, 35503: 23448, 35504: 23515, 35505: 24178, 35506: 24185, 35507: 24739, 35508: 24863, 35509: 24931, 35510: 25022, 35511: 25563, 35512: 25954, 35513: 26577, 35514: 26707, 35515: 26874, 35516: 27454, 35517: 27475, 35518: 27735, 35519: 28450, 35520: 28567, 35521: 28485, 35522: 29872, 35523: 29976, 35524: 30435, 35525: 30475, 35526: 31487, 35527: 31649, 35528: 31777, 35529: 32233, 35530: 32566, 35531: 32752, 35532: 32925, 35533: 33382, 35534: 33694, 35535: 35251, 35536: 35532, 35537: 36011, 35538: 36996, 35539: 37969, 35540: 38291, 35541: 38289, 35542: 38306, 35543: 38501, 35544: 38867, 35545: 39208, 35546: 33304, 35547: 20024, 35548: 21547, 35549: 23736, 35550: 24012, 35551: 29609, 35552: 30284, 35553: 30524, 35554: 23721, 35555: 32747, 35556: 36107, 35557: 38593, 35558: 38929, 35559: 38996, 35560: 39e3, 35561: 20225, 35562: 20238, 35563: 21361, 35564: 21916, 35565: 22120, 35566: 22522, 35567: 22855, 35568: 23305, 35569: 23492, 35570: 23696, 35571: 24076, 35572: 24190, 35573: 24524, 35574: 25582, 35575: 26426, 35576: 26071, 35577: 26082, 35578: 26399, 35579: 26827, 35580: 26820, 35648: 27231, 35649: 24112, 35650: 27589, 35651: 27671, 35652: 27773, 35653: 30079, 35654: 31048, 35655: 23395, 35656: 31232, 35657: 32e3, 35658: 24509, 35659: 35215, 35660: 35352, 35661: 36020, 35662: 36215, 35663: 36556, 35664: 36637, 35665: 39138, 35666: 39438, 35667: 39740, 35668: 20096, 35669: 20605, 35670: 20736, 35671: 22931, 35672: 23452, 35673: 25135, 35674: 25216, 35675: 25836, 35676: 27450, 35677: 29344, 35678: 30097, 35679: 31047, 35680: 32681, 35681: 34811, 35682: 35516, 35683: 35696, 35684: 25516, 35685: 33738, 35686: 38816, 35687: 21513, 35688: 21507, 35689: 21931, 35690: 26708, 35691: 27224, 35692: 35440, 35693: 30759, 35694: 26485, 35695: 40653, 35696: 21364, 35697: 23458, 35698: 33050, 35699: 34384, 35700: 36870, 35701: 19992, 35702: 20037, 35703: 20167, 35704: 20241, 35705: 21450, 35706: 21560, 35707: 23470, 35708: 24339, 35709: 24613, 35710: 25937, 35712: 26429, 35713: 27714, 35714: 27762, 35715: 27875, 35716: 28792, 35717: 29699, 35718: 31350, 35719: 31406, 35720: 31496, 35721: 32026, 35722: 31998, 35723: 32102, 35724: 26087, 35725: 29275, 35726: 21435, 35727: 23621, 35728: 24040, 35729: 25298, 35730: 25312, 35731: 25369, 35732: 28192, 35733: 34394, 35734: 35377, 35735: 36317, 35736: 37624, 35737: 28417, 35738: 31142, 35739: 39770, 35740: 20136, 35741: 20139, 35742: 20140, 35743: 20379, 35744: 20384, 35745: 20689, 35746: 20807, 35747: 31478, 35748: 20849, 35749: 20982, 35750: 21332, 35751: 21281, 35752: 21375, 35753: 21483, 35754: 21932, 35755: 22659, 35756: 23777, 35757: 24375, 35758: 24394, 35759: 24623, 35760: 24656, 35761: 24685, 35762: 25375, 35763: 25945, 35764: 27211, 35765: 27841, 35766: 29378, 35767: 29421, 35768: 30703, 35769: 33016, 35770: 33029, 35771: 33288, 35772: 34126, 35773: 37111, 35774: 37857, 35775: 38911, 35776: 39255, 35777: 39514, 35778: 20208, 35779: 20957, 35780: 23597, 35781: 26241, 35782: 26989, 35783: 23616, 35784: 26354, 35785: 26997, 35786: 29577, 35787: 26704, 35788: 31873, 35789: 20677, 35790: 21220, 35791: 22343, 35792: 24062, 35793: 37670, 35794: 26020, 35795: 27427, 35796: 27453, 35797: 29748, 35798: 31105, 35799: 31165, 35800: 31563, 35801: 32202, 35802: 33465, 35803: 33740, 35804: 34943, 35805: 35167, 35806: 35641, 35807: 36817, 35808: 37329, 35809: 21535, 35810: 37504, 35811: 20061, 35812: 20534, 35813: 21477, 35814: 21306, 35815: 29399, 35816: 29590, 35817: 30697, 35818: 33510, 35819: 36527, 35820: 39366, 35821: 39368, 35822: 39378, 35823: 20855, 35824: 24858, 35825: 34398, 35826: 21936, 35827: 31354, 35828: 20598, 35829: 23507, 35830: 36935, 35831: 38533, 35832: 20018, 35833: 27355, 35834: 37351, 35835: 23633, 35836: 23624, 35904: 25496, 35905: 31391, 35906: 27795, 35907: 38772, 35908: 36705, 35909: 31402, 35910: 29066, 35911: 38536, 35912: 31874, 35913: 26647, 35914: 32368, 35915: 26705, 35916: 37740, 35917: 21234, 35918: 21531, 35919: 34219, 35920: 35347, 35921: 32676, 35922: 36557, 35923: 37089, 35924: 21350, 35925: 34952, 35926: 31041, 35927: 20418, 35928: 20670, 35929: 21009, 35930: 20804, 35931: 21843, 35932: 22317, 35933: 29674, 35934: 22411, 35935: 22865, 35936: 24418, 35937: 24452, 35938: 24693, 35939: 24950, 35940: 24935, 35941: 25001, 35942: 25522, 35943: 25658, 35944: 25964, 35945: 26223, 35946: 26690, 35947: 28179, 35948: 30054, 35949: 31293, 35950: 31995, 35951: 32076, 35952: 32153, 35953: 32331, 35954: 32619, 35955: 33550, 35956: 33610, 35957: 34509, 35958: 35336, 35959: 35427, 35960: 35686, 35961: 36605, 35962: 38938, 35963: 40335, 35964: 33464, 35965: 36814, 35966: 39912, 35968: 21127, 35969: 25119, 35970: 25731, 35971: 28608, 35972: 38553, 35973: 26689, 35974: 20625, 35975: 27424, 35976: 27770, 35977: 28500, 35978: 31348, 35979: 32080, 35980: 34880, 35981: 35363, 35982: 26376, 35983: 20214, 35984: 20537, 35985: 20518, 35986: 20581, 35987: 20860, 35988: 21048, 35989: 21091, 35990: 21927, 35991: 22287, 35992: 22533, 35993: 23244, 35994: 24314, 35995: 25010, 35996: 25080, 35997: 25331, 35998: 25458, 35999: 26908, 36e3: 27177, 36001: 29309, 36002: 29356, 36003: 29486, 36004: 30740, 36005: 30831, 36006: 32121, 36007: 30476, 36008: 32937, 36009: 35211, 36010: 35609, 36011: 36066, 36012: 36562, 36013: 36963, 36014: 37749, 36015: 38522, 36016: 38997, 36017: 39443, 36018: 40568, 36019: 20803, 36020: 21407, 36021: 21427, 36022: 24187, 36023: 24358, 36024: 28187, 36025: 28304, 36026: 29572, 36027: 29694, 36028: 32067, 36029: 33335, 36030: 35328, 36031: 35578, 36032: 38480, 36033: 20046, 36034: 20491, 36035: 21476, 36036: 21628, 36037: 22266, 36038: 22993, 36039: 23396, 36040: 24049, 36041: 24235, 36042: 24359, 36043: 25144, 36044: 25925, 36045: 26543, 36046: 28246, 36047: 29392, 36048: 31946, 36049: 34996, 36050: 32929, 36051: 32993, 36052: 33776, 36053: 34382, 36054: 35463, 36055: 36328, 36056: 37431, 36057: 38599, 36058: 39015, 36059: 40723, 36060: 20116, 36061: 20114, 36062: 20237, 36063: 21320, 36064: 21577, 36065: 21566, 36066: 23087, 36067: 24460, 36068: 24481, 36069: 24735, 36070: 26791, 36071: 27278, 36072: 29786, 36073: 30849, 36074: 35486, 36075: 35492, 36076: 35703, 36077: 37264, 36078: 20062, 36079: 39881, 36080: 20132, 36081: 20348, 36082: 20399, 36083: 20505, 36084: 20502, 36085: 20809, 36086: 20844, 36087: 21151, 36088: 21177, 36089: 21246, 36090: 21402, 36091: 21475, 36092: 21521, 36160: 21518, 36161: 21897, 36162: 22353, 36163: 22434, 36164: 22909, 36165: 23380, 36166: 23389, 36167: 23439, 36168: 24037, 36169: 24039, 36170: 24055, 36171: 24184, 36172: 24195, 36173: 24218, 36174: 24247, 36175: 24344, 36176: 24658, 36177: 24908, 36178: 25239, 36179: 25304, 36180: 25511, 36181: 25915, 36182: 26114, 36183: 26179, 36184: 26356, 36185: 26477, 36186: 26657, 36187: 26775, 36188: 27083, 36189: 27743, 36190: 27946, 36191: 28009, 36192: 28207, 36193: 28317, 36194: 30002, 36195: 30343, 36196: 30828, 36197: 31295, 36198: 31968, 36199: 32005, 36200: 32024, 36201: 32094, 36202: 32177, 36203: 32789, 36204: 32771, 36205: 32943, 36206: 32945, 36207: 33108, 36208: 33167, 36209: 33322, 36210: 33618, 36211: 34892, 36212: 34913, 36213: 35611, 36214: 36002, 36215: 36092, 36216: 37066, 36217: 37237, 36218: 37489, 36219: 30783, 36220: 37628, 36221: 38308, 36222: 38477, 36224: 38917, 36225: 39321, 36226: 39640, 36227: 40251, 36228: 21083, 36229: 21163, 36230: 21495, 36231: 21512, 36232: 22741, 36233: 25335, 36234: 28640, 36235: 35946, 36236: 36703, 36237: 40633, 36238: 20811, 36239: 21051, 36240: 21578, 36241: 22269, 36242: 31296, 36243: 37239, 36244: 40288, 36245: 40658, 36246: 29508, 36247: 28425, 36248: 33136, 36249: 29969, 36250: 24573, 36251: 24794, 36252: 39592, 36253: 29403, 36254: 36796, 36255: 27492, 36256: 38915, 36257: 20170, 36258: 22256, 36259: 22372, 36260: 22718, 36261: 23130, 36262: 24680, 36263: 25031, 36264: 26127, 36265: 26118, 36266: 26681, 36267: 26801, 36268: 28151, 36269: 30165, 36270: 32058, 36271: 33390, 36272: 39746, 36273: 20123, 36274: 20304, 36275: 21449, 36276: 21766, 36277: 23919, 36278: 24038, 36279: 24046, 36280: 26619, 36281: 27801, 36282: 29811, 36283: 30722, 36284: 35408, 36285: 37782, 36286: 35039, 36287: 22352, 36288: 24231, 36289: 25387, 36290: 20661, 36291: 20652, 36292: 20877, 36293: 26368, 36294: 21705, 36295: 22622, 36296: 22971, 36297: 23472, 36298: 24425, 36299: 25165, 36300: 25505, 36301: 26685, 36302: 27507, 36303: 28168, 36304: 28797, 36305: 37319, 36306: 29312, 36307: 30741, 36308: 30758, 36309: 31085, 36310: 25998, 36311: 32048, 36312: 33756, 36313: 35009, 36314: 36617, 36315: 38555, 36316: 21092, 36317: 22312, 36318: 26448, 36319: 32618, 36320: 36001, 36321: 20916, 36322: 22338, 36323: 38442, 36324: 22586, 36325: 27018, 36326: 32948, 36327: 21682, 36328: 23822, 36329: 22524, 36330: 30869, 36331: 40442, 36332: 20316, 36333: 21066, 36334: 21643, 36335: 25662, 36336: 26152, 36337: 26388, 36338: 26613, 36339: 31364, 36340: 31574, 36341: 32034, 36342: 37679, 36343: 26716, 36344: 39853, 36345: 31545, 36346: 21273, 36347: 20874, 36348: 21047, 36416: 23519, 36417: 25334, 36418: 25774, 36419: 25830, 36420: 26413, 36421: 27578, 36422: 34217, 36423: 38609, 36424: 30352, 36425: 39894, 36426: 25420, 36427: 37638, 36428: 39851, 36429: 30399, 36430: 26194, 36431: 19977, 36432: 20632, 36433: 21442, 36434: 23665, 36435: 24808, 36436: 25746, 36437: 25955, 36438: 26719, 36439: 29158, 36440: 29642, 36441: 29987, 36442: 31639, 36443: 32386, 36444: 34453, 36445: 35715, 36446: 36059, 36447: 37240, 36448: 39184, 36449: 26028, 36450: 26283, 36451: 27531, 36452: 20181, 36453: 20180, 36454: 20282, 36455: 20351, 36456: 21050, 36457: 21496, 36458: 21490, 36459: 21987, 36460: 22235, 36461: 22763, 36462: 22987, 36463: 22985, 36464: 23039, 36465: 23376, 36466: 23629, 36467: 24066, 36468: 24107, 36469: 24535, 36470: 24605, 36471: 25351, 36472: 25903, 36473: 23388, 36474: 26031, 36475: 26045, 36476: 26088, 36477: 26525, 36478: 27490, 36480: 27515, 36481: 27663, 36482: 29509, 36483: 31049, 36484: 31169, 36485: 31992, 36486: 32025, 36487: 32043, 36488: 32930, 36489: 33026, 36490: 33267, 36491: 35222, 36492: 35422, 36493: 35433, 36494: 35430, 36495: 35468, 36496: 35566, 36497: 36039, 36498: 36060, 36499: 38604, 36500: 39164, 36501: 27503, 36502: 20107, 36503: 20284, 36504: 20365, 36505: 20816, 36506: 23383, 36507: 23546, 36508: 24904, 36509: 25345, 36510: 26178, 36511: 27425, 36512: 28363, 36513: 27835, 36514: 29246, 36515: 29885, 36516: 30164, 36517: 30913, 36518: 31034, 36519: 32780, 36520: 32819, 36521: 33258, 36522: 33940, 36523: 36766, 36524: 27728, 36525: 40575, 36526: 24335, 36527: 35672, 36528: 40235, 36529: 31482, 36530: 36600, 36531: 23437, 36532: 38635, 36533: 19971, 36534: 21489, 36535: 22519, 36536: 22833, 36537: 23241, 36538: 23460, 36539: 24713, 36540: 28287, 36541: 28422, 36542: 30142, 36543: 36074, 36544: 23455, 36545: 34048, 36546: 31712, 36547: 20594, 36548: 26612, 36549: 33437, 36550: 23649, 36551: 34122, 36552: 32286, 36553: 33294, 36554: 20889, 36555: 23556, 36556: 25448, 36557: 36198, 36558: 26012, 36559: 29038, 36560: 31038, 36561: 32023, 36562: 32773, 36563: 35613, 36564: 36554, 36565: 36974, 36566: 34503, 36567: 37034, 36568: 20511, 36569: 21242, 36570: 23610, 36571: 26451, 36572: 28796, 36573: 29237, 36574: 37196, 36575: 37320, 36576: 37675, 36577: 33509, 36578: 23490, 36579: 24369, 36580: 24825, 36581: 20027, 36582: 21462, 36583: 23432, 36584: 25163, 36585: 26417, 36586: 27530, 36587: 29417, 36588: 29664, 36589: 31278, 36590: 33131, 36591: 36259, 36592: 37202, 36593: 39318, 36594: 20754, 36595: 21463, 36596: 21610, 36597: 23551, 36598: 25480, 36599: 27193, 36600: 32172, 36601: 38656, 36602: 22234, 36603: 21454, 36604: 21608, 36672: 23447, 36673: 23601, 36674: 24030, 36675: 20462, 36676: 24833, 36677: 25342, 36678: 27954, 36679: 31168, 36680: 31179, 36681: 32066, 36682: 32333, 36683: 32722, 36684: 33261, 36685: 33311, 36686: 33936, 36687: 34886, 36688: 35186, 36689: 35728, 36690: 36468, 36691: 36655, 36692: 36913, 36693: 37195, 36694: 37228, 36695: 38598, 36696: 37276, 36697: 20160, 36698: 20303, 36699: 20805, 36700: 21313, 36701: 24467, 36702: 25102, 36703: 26580, 36704: 27713, 36705: 28171, 36706: 29539, 36707: 32294, 36708: 37325, 36709: 37507, 36710: 21460, 36711: 22809, 36712: 23487, 36713: 28113, 36714: 31069, 36715: 32302, 36716: 31899, 36717: 22654, 36718: 29087, 36719: 20986, 36720: 34899, 36721: 36848, 36722: 20426, 36723: 23803, 36724: 26149, 36725: 30636, 36726: 31459, 36727: 33308, 36728: 39423, 36729: 20934, 36730: 24490, 36731: 26092, 36732: 26991, 36733: 27529, 36734: 28147, 36736: 28310, 36737: 28516, 36738: 30462, 36739: 32020, 36740: 24033, 36741: 36981, 36742: 37255, 36743: 38918, 36744: 20966, 36745: 21021, 36746: 25152, 36747: 26257, 36748: 26329, 36749: 28186, 36750: 24246, 36751: 32210, 36752: 32626, 36753: 26360, 36754: 34223, 36755: 34295, 36756: 35576, 36757: 21161, 36758: 21465, 36759: 22899, 36760: 24207, 36761: 24464, 36762: 24661, 36763: 37604, 36764: 38500, 36765: 20663, 36766: 20767, 36767: 21213, 36768: 21280, 36769: 21319, 36770: 21484, 36771: 21736, 36772: 21830, 36773: 21809, 36774: 22039, 36775: 22888, 36776: 22974, 36777: 23100, 36778: 23477, 36779: 23558, 36780: 23567, 36781: 23569, 36782: 23578, 36783: 24196, 36784: 24202, 36785: 24288, 36786: 24432, 36787: 25215, 36788: 25220, 36789: 25307, 36790: 25484, 36791: 25463, 36792: 26119, 36793: 26124, 36794: 26157, 36795: 26230, 36796: 26494, 36797: 26786, 36798: 27167, 36799: 27189, 36800: 27836, 36801: 28040, 36802: 28169, 36803: 28248, 36804: 28988, 36805: 28966, 36806: 29031, 36807: 30151, 36808: 30465, 36809: 30813, 36810: 30977, 36811: 31077, 36812: 31216, 36813: 31456, 36814: 31505, 36815: 31911, 36816: 32057, 36817: 32918, 36818: 33750, 36819: 33931, 36820: 34121, 36821: 34909, 36822: 35059, 36823: 35359, 36824: 35388, 36825: 35412, 36826: 35443, 36827: 35937, 36828: 36062, 36829: 37284, 36830: 37478, 36831: 37758, 36832: 37912, 36833: 38556, 36834: 38808, 36835: 19978, 36836: 19976, 36837: 19998, 36838: 20055, 36839: 20887, 36840: 21104, 36841: 22478, 36842: 22580, 36843: 22732, 36844: 23330, 36845: 24120, 36846: 24773, 36847: 25854, 36848: 26465, 36849: 26454, 36850: 27972, 36851: 29366, 36852: 30067, 36853: 31331, 36854: 33976, 36855: 35698, 36856: 37304, 36857: 37664, 36858: 22065, 36859: 22516, 36860: 39166, 36928: 25325, 36929: 26893, 36930: 27542, 36931: 29165, 36932: 32340, 36933: 32887, 36934: 33394, 36935: 35302, 36936: 39135, 36937: 34645, 36938: 36785, 36939: 23611, 36940: 20280, 36941: 20449, 36942: 20405, 36943: 21767, 36944: 23072, 36945: 23517, 36946: 23529, 36947: 24515, 36948: 24910, 36949: 25391, 36950: 26032, 36951: 26187, 36952: 26862, 36953: 27035, 36954: 28024, 36955: 28145, 36956: 30003, 36957: 30137, 36958: 30495, 36959: 31070, 36960: 31206, 36961: 32051, 36962: 33251, 36963: 33455, 36964: 34218, 36965: 35242, 36966: 35386, 36967: 36523, 36968: 36763, 36969: 36914, 36970: 37341, 36971: 38663, 36972: 20154, 36973: 20161, 36974: 20995, 36975: 22645, 36976: 22764, 36977: 23563, 36978: 29978, 36979: 23613, 36980: 33102, 36981: 35338, 36982: 36805, 36983: 38499, 36984: 38765, 36985: 31525, 36986: 35535, 36987: 38920, 36988: 37218, 36989: 22259, 36990: 21416, 36992: 36887, 36993: 21561, 36994: 22402, 36995: 24101, 36996: 25512, 36997: 27700, 36998: 28810, 36999: 30561, 37e3: 31883, 37001: 32736, 37002: 34928, 37003: 36930, 37004: 37204, 37005: 37648, 37006: 37656, 37007: 38543, 37008: 29790, 37009: 39620, 37010: 23815, 37011: 23913, 37012: 25968, 37013: 26530, 37014: 36264, 37015: 38619, 37016: 25454, 37017: 26441, 37018: 26905, 37019: 33733, 37020: 38935, 37021: 38592, 37022: 35070, 37023: 28548, 37024: 25722, 37025: 23544, 37026: 19990, 37027: 28716, 37028: 30045, 37029: 26159, 37030: 20932, 37031: 21046, 37032: 21218, 37033: 22995, 37034: 24449, 37035: 24615, 37036: 25104, 37037: 25919, 37038: 25972, 37039: 26143, 37040: 26228, 37041: 26866, 37042: 26646, 37043: 27491, 37044: 28165, 37045: 29298, 37046: 29983, 37047: 30427, 37048: 31934, 37049: 32854, 37050: 22768, 37051: 35069, 37052: 35199, 37053: 35488, 37054: 35475, 37055: 35531, 37056: 36893, 37057: 37266, 37058: 38738, 37059: 38745, 37060: 25993, 37061: 31246, 37062: 33030, 37063: 38587, 37064: 24109, 37065: 24796, 37066: 25114, 37067: 26021, 37068: 26132, 37069: 26512, 37070: 30707, 37071: 31309, 37072: 31821, 37073: 32318, 37074: 33034, 37075: 36012, 37076: 36196, 37077: 36321, 37078: 36447, 37079: 30889, 37080: 20999, 37081: 25305, 37082: 25509, 37083: 25666, 37084: 25240, 37085: 35373, 37086: 31363, 37087: 31680, 37088: 35500, 37089: 38634, 37090: 32118, 37091: 33292, 37092: 34633, 37093: 20185, 37094: 20808, 37095: 21315, 37096: 21344, 37097: 23459, 37098: 23554, 37099: 23574, 37100: 24029, 37101: 25126, 37102: 25159, 37103: 25776, 37104: 26643, 37105: 26676, 37106: 27849, 37107: 27973, 37108: 27927, 37109: 26579, 37110: 28508, 37111: 29006, 37112: 29053, 37113: 26059, 37114: 31359, 37115: 31661, 37116: 32218, 37184: 32330, 37185: 32680, 37186: 33146, 37187: 33307, 37188: 33337, 37189: 34214, 37190: 35438, 37191: 36046, 37192: 36341, 37193: 36984, 37194: 36983, 37195: 37549, 37196: 37521, 37197: 38275, 37198: 39854, 37199: 21069, 37200: 21892, 37201: 28472, 37202: 28982, 37203: 20840, 37204: 31109, 37205: 32341, 37206: 33203, 37207: 31950, 37208: 22092, 37209: 22609, 37210: 23720, 37211: 25514, 37212: 26366, 37213: 26365, 37214: 26970, 37215: 29401, 37216: 30095, 37217: 30094, 37218: 30990, 37219: 31062, 37220: 31199, 37221: 31895, 37222: 32032, 37223: 32068, 37224: 34311, 37225: 35380, 37226: 38459, 37227: 36961, 37228: 40736, 37229: 20711, 37230: 21109, 37231: 21452, 37232: 21474, 37233: 20489, 37234: 21930, 37235: 22766, 37236: 22863, 37237: 29245, 37238: 23435, 37239: 23652, 37240: 21277, 37241: 24803, 37242: 24819, 37243: 25436, 37244: 25475, 37245: 25407, 37246: 25531, 37248: 25805, 37249: 26089, 37250: 26361, 37251: 24035, 37252: 27085, 37253: 27133, 37254: 28437, 37255: 29157, 37256: 20105, 37257: 30185, 37258: 30456, 37259: 31379, 37260: 31967, 37261: 32207, 37262: 32156, 37263: 32865, 37264: 33609, 37265: 33624, 37266: 33900, 37267: 33980, 37268: 34299, 37269: 35013, 37270: 36208, 37271: 36865, 37272: 36973, 37273: 37783, 37274: 38684, 37275: 39442, 37276: 20687, 37277: 22679, 37278: 24974, 37279: 33235, 37280: 34101, 37281: 36104, 37282: 36896, 37283: 20419, 37284: 20596, 37285: 21063, 37286: 21363, 37287: 24687, 37288: 25417, 37289: 26463, 37290: 28204, 37291: 36275, 37292: 36895, 37293: 20439, 37294: 23646, 37295: 36042, 37296: 26063, 37297: 32154, 37298: 21330, 37299: 34966, 37300: 20854, 37301: 25539, 37302: 23384, 37303: 23403, 37304: 23562, 37305: 25613, 37306: 26449, 37307: 36956, 37308: 20182, 37309: 22810, 37310: 22826, 37311: 27760, 37312: 35409, 37313: 21822, 37314: 22549, 37315: 22949, 37316: 24816, 37317: 25171, 37318: 26561, 37319: 33333, 37320: 26965, 37321: 38464, 37322: 39364, 37323: 39464, 37324: 20307, 37325: 22534, 37326: 23550, 37327: 32784, 37328: 23729, 37329: 24111, 37330: 24453, 37331: 24608, 37332: 24907, 37333: 25140, 37334: 26367, 37335: 27888, 37336: 28382, 37337: 32974, 37338: 33151, 37339: 33492, 37340: 34955, 37341: 36024, 37342: 36864, 37343: 36910, 37344: 38538, 37345: 40667, 37346: 39899, 37347: 20195, 37348: 21488, 37349: 22823, 37350: 31532, 37351: 37261, 37352: 38988, 37353: 40441, 37354: 28381, 37355: 28711, 37356: 21331, 37357: 21828, 37358: 23429, 37359: 25176, 37360: 25246, 37361: 25299, 37362: 27810, 37363: 28655, 37364: 29730, 37365: 35351, 37366: 37944, 37367: 28609, 37368: 35582, 37369: 33592, 37370: 20967, 37371: 34552, 37372: 21482, 37440: 21481, 37441: 20294, 37442: 36948, 37443: 36784, 37444: 22890, 37445: 33073, 37446: 24061, 37447: 31466, 37448: 36799, 37449: 26842, 37450: 35895, 37451: 29432, 37452: 40008, 37453: 27197, 37454: 35504, 37455: 20025, 37456: 21336, 37457: 22022, 37458: 22374, 37459: 25285, 37460: 25506, 37461: 26086, 37462: 27470, 37463: 28129, 37464: 28251, 37465: 28845, 37466: 30701, 37467: 31471, 37468: 31658, 37469: 32187, 37470: 32829, 37471: 32966, 37472: 34507, 37473: 35477, 37474: 37723, 37475: 22243, 37476: 22727, 37477: 24382, 37478: 26029, 37479: 26262, 37480: 27264, 37481: 27573, 37482: 30007, 37483: 35527, 37484: 20516, 37485: 30693, 37486: 22320, 37487: 24347, 37488: 24677, 37489: 26234, 37490: 27744, 37491: 30196, 37492: 31258, 37493: 32622, 37494: 33268, 37495: 34584, 37496: 36933, 37497: 39347, 37498: 31689, 37499: 30044, 37500: 31481, 37501: 31569, 37502: 33988, 37504: 36880, 37505: 31209, 37506: 31378, 37507: 33590, 37508: 23265, 37509: 30528, 37510: 20013, 37511: 20210, 37512: 23449, 37513: 24544, 37514: 25277, 37515: 26172, 37516: 26609, 37517: 27880, 37518: 34411, 37519: 34935, 37520: 35387, 37521: 37198, 37522: 37619, 37523: 39376, 37524: 27159, 37525: 28710, 37526: 29482, 37527: 33511, 37528: 33879, 37529: 36015, 37530: 19969, 37531: 20806, 37532: 20939, 37533: 21899, 37534: 23541, 37535: 24086, 37536: 24115, 37537: 24193, 37538: 24340, 37539: 24373, 37540: 24427, 37541: 24500, 37542: 25074, 37543: 25361, 37544: 26274, 37545: 26397, 37546: 28526, 37547: 29266, 37548: 30010, 37549: 30522, 37550: 32884, 37551: 33081, 37552: 33144, 37553: 34678, 37554: 35519, 37555: 35548, 37556: 36229, 37557: 36339, 37558: 37530, 37559: 38263, 37560: 38914, 37561: 40165, 37562: 21189, 37563: 25431, 37564: 30452, 37565: 26389, 37566: 27784, 37567: 29645, 37568: 36035, 37569: 37806, 37570: 38515, 37571: 27941, 37572: 22684, 37573: 26894, 37574: 27084, 37575: 36861, 37576: 37786, 37577: 30171, 37578: 36890, 37579: 22618, 37580: 26626, 37581: 25524, 37582: 27131, 37583: 20291, 37584: 28460, 37585: 26584, 37586: 36795, 37587: 34086, 37588: 32180, 37589: 37716, 37590: 26943, 37591: 28528, 37592: 22378, 37593: 22775, 37594: 23340, 37595: 32044, 37596: 29226, 37597: 21514, 37598: 37347, 37599: 40372, 37600: 20141, 37601: 20302, 37602: 20572, 37603: 20597, 37604: 21059, 37605: 35998, 37606: 21576, 37607: 22564, 37608: 23450, 37609: 24093, 37610: 24213, 37611: 24237, 37612: 24311, 37613: 24351, 37614: 24716, 37615: 25269, 37616: 25402, 37617: 25552, 37618: 26799, 37619: 27712, 37620: 30855, 37621: 31118, 37622: 31243, 37623: 32224, 37624: 33351, 37625: 35330, 37626: 35558, 37627: 36420, 37628: 36883, 37696: 37048, 37697: 37165, 37698: 37336, 37699: 40718, 37700: 27877, 37701: 25688, 37702: 25826, 37703: 25973, 37704: 28404, 37705: 30340, 37706: 31515, 37707: 36969, 37708: 37841, 37709: 28346, 37710: 21746, 37711: 24505, 37712: 25764, 37713: 36685, 37714: 36845, 37715: 37444, 37716: 20856, 37717: 22635, 37718: 22825, 37719: 23637, 37720: 24215, 37721: 28155, 37722: 32399, 37723: 29980, 37724: 36028, 37725: 36578, 37726: 39003, 37727: 28857, 37728: 20253, 37729: 27583, 37730: 28593, 37731: 3e4, 37732: 38651, 37733: 20814, 37734: 21520, 37735: 22581, 37736: 22615, 37737: 22956, 37738: 23648, 37739: 24466, 37740: 26007, 37741: 26460, 37742: 28193, 37743: 30331, 37744: 33759, 37745: 36077, 37746: 36884, 37747: 37117, 37748: 37709, 37749: 30757, 37750: 30778, 37751: 21162, 37752: 24230, 37753: 22303, 37754: 22900, 37755: 24594, 37756: 20498, 37757: 20826, 37758: 20908, 37760: 20941, 37761: 20992, 37762: 21776, 37763: 22612, 37764: 22616, 37765: 22871, 37766: 23445, 37767: 23798, 37768: 23947, 37769: 24764, 37770: 25237, 37771: 25645, 37772: 26481, 37773: 26691, 37774: 26812, 37775: 26847, 37776: 30423, 37777: 28120, 37778: 28271, 37779: 28059, 37780: 28783, 37781: 29128, 37782: 24403, 37783: 30168, 37784: 31095, 37785: 31561, 37786: 31572, 37787: 31570, 37788: 31958, 37789: 32113, 37790: 21040, 37791: 33891, 37792: 34153, 37793: 34276, 37794: 35342, 37795: 35588, 37796: 35910, 37797: 36367, 37798: 36867, 37799: 36879, 37800: 37913, 37801: 38518, 37802: 38957, 37803: 39472, 37804: 38360, 37805: 20685, 37806: 21205, 37807: 21516, 37808: 22530, 37809: 23566, 37810: 24999, 37811: 25758, 37812: 27934, 37813: 30643, 37814: 31461, 37815: 33012, 37816: 33796, 37817: 36947, 37818: 37509, 37819: 23776, 37820: 40199, 37821: 21311, 37822: 24471, 37823: 24499, 37824: 28060, 37825: 29305, 37826: 30563, 37827: 31167, 37828: 31716, 37829: 27602, 37830: 29420, 37831: 35501, 37832: 26627, 37833: 27233, 37834: 20984, 37835: 31361, 37836: 26932, 37837: 23626, 37838: 40182, 37839: 33515, 37840: 23493, 37841: 37193, 37842: 28702, 37843: 22136, 37844: 23663, 37845: 24775, 37846: 25958, 37847: 27788, 37848: 35930, 37849: 36929, 37850: 38931, 37851: 21585, 37852: 26311, 37853: 37389, 37854: 22856, 37855: 37027, 37856: 20869, 37857: 20045, 37858: 20970, 37859: 34201, 37860: 35598, 37861: 28760, 37862: 25466, 37863: 37707, 37864: 26978, 37865: 39348, 37866: 32260, 37867: 30071, 37868: 21335, 37869: 26976, 37870: 36575, 37871: 38627, 37872: 27741, 37873: 20108, 37874: 23612, 37875: 24336, 37876: 36841, 37877: 21250, 37878: 36049, 37879: 32905, 37880: 34425, 37881: 24319, 37882: 26085, 37883: 20083, 37884: 20837, 37952: 22914, 37953: 23615, 37954: 38894, 37955: 20219, 37956: 22922, 37957: 24525, 37958: 35469, 37959: 28641, 37960: 31152, 37961: 31074, 37962: 23527, 37963: 33905, 37964: 29483, 37965: 29105, 37966: 24180, 37967: 24565, 37968: 25467, 37969: 25754, 37970: 29123, 37971: 31896, 37972: 20035, 37973: 24316, 37974: 20043, 37975: 22492, 37976: 22178, 37977: 24745, 37978: 28611, 37979: 32013, 37980: 33021, 37981: 33075, 37982: 33215, 37983: 36786, 37984: 35223, 37985: 34468, 37986: 24052, 37987: 25226, 37988: 25773, 37989: 35207, 37990: 26487, 37991: 27874, 37992: 27966, 37993: 29750, 37994: 30772, 37995: 23110, 37996: 32629, 37997: 33453, 37998: 39340, 37999: 20467, 38e3: 24259, 38001: 25309, 38002: 25490, 38003: 25943, 38004: 26479, 38005: 30403, 38006: 29260, 38007: 32972, 38008: 32954, 38009: 36649, 38010: 37197, 38011: 20493, 38012: 22521, 38013: 23186, 38014: 26757, 38016: 26995, 38017: 29028, 38018: 29437, 38019: 36023, 38020: 22770, 38021: 36064, 38022: 38506, 38023: 36889, 38024: 34687, 38025: 31204, 38026: 30695, 38027: 33833, 38028: 20271, 38029: 21093, 38030: 21338, 38031: 25293, 38032: 26575, 38033: 27850, 38034: 30333, 38035: 31636, 38036: 31893, 38037: 33334, 38038: 34180, 38039: 36843, 38040: 26333, 38041: 28448, 38042: 29190, 38043: 32283, 38044: 33707, 38045: 39361, 38046: 40614, 38047: 20989, 38048: 31665, 38049: 30834, 38050: 31672, 38051: 32903, 38052: 31560, 38053: 27368, 38054: 24161, 38055: 32908, 38056: 30033, 38057: 30048, 38058: 20843, 38059: 37474, 38060: 28300, 38061: 30330, 38062: 37271, 38063: 39658, 38064: 20240, 38065: 32624, 38066: 25244, 38067: 31567, 38068: 38309, 38069: 40169, 38070: 22138, 38071: 22617, 38072: 34532, 38073: 38588, 38074: 20276, 38075: 21028, 38076: 21322, 38077: 21453, 38078: 21467, 38079: 24070, 38080: 25644, 38081: 26001, 38082: 26495, 38083: 27710, 38084: 27726, 38085: 29256, 38086: 29359, 38087: 29677, 38088: 30036, 38089: 32321, 38090: 33324, 38091: 34281, 38092: 36009, 38093: 31684, 38094: 37318, 38095: 29033, 38096: 38930, 38097: 39151, 38098: 25405, 38099: 26217, 38100: 30058, 38101: 30436, 38102: 30928, 38103: 34115, 38104: 34542, 38105: 21290, 38106: 21329, 38107: 21542, 38108: 22915, 38109: 24199, 38110: 24444, 38111: 24754, 38112: 25161, 38113: 25209, 38114: 25259, 38115: 26e3, 38116: 27604, 38117: 27852, 38118: 30130, 38119: 30382, 38120: 30865, 38121: 31192, 38122: 32203, 38123: 32631, 38124: 32933, 38125: 34987, 38126: 35513, 38127: 36027, 38128: 36991, 38129: 38750, 38130: 39131, 38131: 27147, 38132: 31800, 38133: 20633, 38134: 23614, 38135: 24494, 38136: 26503, 38137: 27608, 38138: 29749, 38139: 30473, 38140: 32654, 38208: 40763, 38209: 26570, 38210: 31255, 38211: 21305, 38212: 30091, 38213: 39661, 38214: 24422, 38215: 33181, 38216: 33777, 38217: 32920, 38218: 24380, 38219: 24517, 38220: 30050, 38221: 31558, 38222: 36924, 38223: 26727, 38224: 23019, 38225: 23195, 38226: 32016, 38227: 30334, 38228: 35628, 38229: 20469, 38230: 24426, 38231: 27161, 38232: 27703, 38233: 28418, 38234: 29922, 38235: 31080, 38236: 34920, 38237: 35413, 38238: 35961, 38239: 24287, 38240: 25551, 38241: 30149, 38242: 31186, 38243: 33495, 38244: 37672, 38245: 37618, 38246: 33948, 38247: 34541, 38248: 39981, 38249: 21697, 38250: 24428, 38251: 25996, 38252: 27996, 38253: 28693, 38254: 36007, 38255: 36051, 38256: 38971, 38257: 25935, 38258: 29942, 38259: 19981, 38260: 20184, 38261: 22496, 38262: 22827, 38263: 23142, 38264: 23500, 38265: 20904, 38266: 24067, 38267: 24220, 38268: 24598, 38269: 25206, 38270: 25975, 38272: 26023, 38273: 26222, 38274: 28014, 38275: 29238, 38276: 31526, 38277: 33104, 38278: 33178, 38279: 33433, 38280: 35676, 38281: 36e3, 38282: 36070, 38283: 36212, 38284: 38428, 38285: 38468, 38286: 20398, 38287: 25771, 38288: 27494, 38289: 33310, 38290: 33889, 38291: 34154, 38292: 37096, 38293: 23553, 38294: 26963, 38295: 39080, 38296: 33914, 38297: 34135, 38298: 20239, 38299: 21103, 38300: 24489, 38301: 24133, 38302: 26381, 38303: 31119, 38304: 33145, 38305: 35079, 38306: 35206, 38307: 28149, 38308: 24343, 38309: 25173, 38310: 27832, 38311: 20175, 38312: 29289, 38313: 39826, 38314: 20998, 38315: 21563, 38316: 22132, 38317: 22707, 38318: 24996, 38319: 25198, 38320: 28954, 38321: 22894, 38322: 31881, 38323: 31966, 38324: 32027, 38325: 38640, 38326: 25991, 38327: 32862, 38328: 19993, 38329: 20341, 38330: 20853, 38331: 22592, 38332: 24163, 38333: 24179, 38334: 24330, 38335: 26564, 38336: 20006, 38337: 34109, 38338: 38281, 38339: 38491, 38340: 31859, 38341: 38913, 38342: 20731, 38343: 22721, 38344: 30294, 38345: 30887, 38346: 21029, 38347: 30629, 38348: 34065, 38349: 31622, 38350: 20559, 38351: 22793, 38352: 29255, 38353: 31687, 38354: 32232, 38355: 36794, 38356: 36820, 38357: 36941, 38358: 20415, 38359: 21193, 38360: 23081, 38361: 24321, 38362: 38829, 38363: 20445, 38364: 33303, 38365: 37610, 38366: 22275, 38367: 25429, 38368: 27497, 38369: 29995, 38370: 35036, 38371: 36628, 38372: 31298, 38373: 21215, 38374: 22675, 38375: 24917, 38376: 25098, 38377: 26286, 38378: 27597, 38379: 31807, 38380: 33769, 38381: 20515, 38382: 20472, 38383: 21253, 38384: 21574, 38385: 22577, 38386: 22857, 38387: 23453, 38388: 23792, 38389: 23791, 38390: 23849, 38391: 24214, 38392: 25265, 38393: 25447, 38394: 25918, 38395: 26041, 38396: 26379, 38464: 27861, 38465: 27873, 38466: 28921, 38467: 30770, 38468: 32299, 38469: 32990, 38470: 33459, 38471: 33804, 38472: 34028, 38473: 34562, 38474: 35090, 38475: 35370, 38476: 35914, 38477: 37030, 38478: 37586, 38479: 39165, 38480: 40179, 38481: 40300, 38482: 20047, 38483: 20129, 38484: 20621, 38485: 21078, 38486: 22346, 38487: 22952, 38488: 24125, 38489: 24536, 38490: 24537, 38491: 25151, 38492: 26292, 38493: 26395, 38494: 26576, 38495: 26834, 38496: 20882, 38497: 32033, 38498: 32938, 38499: 33192, 38500: 35584, 38501: 35980, 38502: 36031, 38503: 37502, 38504: 38450, 38505: 21536, 38506: 38956, 38507: 21271, 38508: 20693, 38509: 21340, 38510: 22696, 38511: 25778, 38512: 26420, 38513: 29287, 38514: 30566, 38515: 31302, 38516: 37350, 38517: 21187, 38518: 27809, 38519: 27526, 38520: 22528, 38521: 24140, 38522: 22868, 38523: 26412, 38524: 32763, 38525: 20961, 38526: 30406, 38528: 25705, 38529: 30952, 38530: 39764, 38531: 40635, 38532: 22475, 38533: 22969, 38534: 26151, 38535: 26522, 38536: 27598, 38537: 21737, 38538: 27097, 38539: 24149, 38540: 33180, 38541: 26517, 38542: 39850, 38543: 26622, 38544: 40018, 38545: 26717, 38546: 20134, 38547: 20451, 38548: 21448, 38549: 25273, 38550: 26411, 38551: 27819, 38552: 36804, 38553: 20397, 38554: 32365, 38555: 40639, 38556: 19975, 38557: 24930, 38558: 28288, 38559: 28459, 38560: 34067, 38561: 21619, 38562: 26410, 38563: 39749, 38564: 24051, 38565: 31637, 38566: 23724, 38567: 23494, 38568: 34588, 38569: 28234, 38570: 34001, 38571: 31252, 38572: 33032, 38573: 22937, 38574: 31885, 38575: 27665, 38576: 30496, 38577: 21209, 38578: 22818, 38579: 28961, 38580: 29279, 38581: 30683, 38582: 38695, 38583: 40289, 38584: 26891, 38585: 23167, 38586: 23064, 38587: 20901, 38588: 21517, 38589: 21629, 38590: 26126, 38591: 30431, 38592: 36855, 38593: 37528, 38594: 40180, 38595: 23018, 38596: 29277, 38597: 28357, 38598: 20813, 38599: 26825, 38600: 32191, 38601: 32236, 38602: 38754, 38603: 40634, 38604: 25720, 38605: 27169, 38606: 33538, 38607: 22916, 38608: 23391, 38609: 27611, 38610: 29467, 38611: 30450, 38612: 32178, 38613: 32791, 38614: 33945, 38615: 20786, 38616: 26408, 38617: 40665, 38618: 30446, 38619: 26466, 38620: 21247, 38621: 39173, 38622: 23588, 38623: 25147, 38624: 31870, 38625: 36016, 38626: 21839, 38627: 24758, 38628: 32011, 38629: 38272, 38630: 21249, 38631: 20063, 38632: 20918, 38633: 22812, 38634: 29242, 38635: 32822, 38636: 37326, 38637: 24357, 38638: 30690, 38639: 21380, 38640: 24441, 38641: 32004, 38642: 34220, 38643: 35379, 38644: 36493, 38645: 38742, 38646: 26611, 38647: 34222, 38648: 37971, 38649: 24841, 38650: 24840, 38651: 27833, 38652: 30290, 38720: 35565, 38721: 36664, 38722: 21807, 38723: 20305, 38724: 20778, 38725: 21191, 38726: 21451, 38727: 23461, 38728: 24189, 38729: 24736, 38730: 24962, 38731: 25558, 38732: 26377, 38733: 26586, 38734: 28263, 38735: 28044, 38736: 29494, 38737: 29495, 38738: 30001, 38739: 31056, 38740: 35029, 38741: 35480, 38742: 36938, 38743: 37009, 38744: 37109, 38745: 38596, 38746: 34701, 38747: 22805, 38748: 20104, 38749: 20313, 38750: 19982, 38751: 35465, 38752: 36671, 38753: 38928, 38754: 20653, 38755: 24188, 38756: 22934, 38757: 23481, 38758: 24248, 38759: 25562, 38760: 25594, 38761: 25793, 38762: 26332, 38763: 26954, 38764: 27096, 38765: 27915, 38766: 28342, 38767: 29076, 38768: 29992, 38769: 31407, 38770: 32650, 38771: 32768, 38772: 33865, 38773: 33993, 38774: 35201, 38775: 35617, 38776: 36362, 38777: 36965, 38778: 38525, 38779: 39178, 38780: 24958, 38781: 25233, 38782: 27442, 38784: 27779, 38785: 28020, 38786: 32716, 38787: 32764, 38788: 28096, 38789: 32645, 38790: 34746, 38791: 35064, 38792: 26469, 38793: 33713, 38794: 38972, 38795: 38647, 38796: 27931, 38797: 32097, 38798: 33853, 38799: 37226, 38800: 20081, 38801: 21365, 38802: 23888, 38803: 27396, 38804: 28651, 38805: 34253, 38806: 34349, 38807: 35239, 38808: 21033, 38809: 21519, 38810: 23653, 38811: 26446, 38812: 26792, 38813: 29702, 38814: 29827, 38815: 30178, 38816: 35023, 38817: 35041, 38818: 37324, 38819: 38626, 38820: 38520, 38821: 24459, 38822: 29575, 38823: 31435, 38824: 33870, 38825: 25504, 38826: 30053, 38827: 21129, 38828: 27969, 38829: 28316, 38830: 29705, 38831: 30041, 38832: 30827, 38833: 31890, 38834: 38534, 38835: 31452, 38836: 40845, 38837: 20406, 38838: 24942, 38839: 26053, 38840: 34396, 38841: 20102, 38842: 20142, 38843: 20698, 38844: 20001, 38845: 20940, 38846: 23534, 38847: 26009, 38848: 26753, 38849: 28092, 38850: 29471, 38851: 30274, 38852: 30637, 38853: 31260, 38854: 31975, 38855: 33391, 38856: 35538, 38857: 36988, 38858: 37327, 38859: 38517, 38860: 38936, 38861: 21147, 38862: 32209, 38863: 20523, 38864: 21400, 38865: 26519, 38866: 28107, 38867: 29136, 38868: 29747, 38869: 33256, 38870: 36650, 38871: 38563, 38872: 40023, 38873: 40607, 38874: 29792, 38875: 22593, 38876: 28057, 38877: 32047, 38878: 39006, 38879: 20196, 38880: 20278, 38881: 20363, 38882: 20919, 38883: 21169, 38884: 23994, 38885: 24604, 38886: 29618, 38887: 31036, 38888: 33491, 38889: 37428, 38890: 38583, 38891: 38646, 38892: 38666, 38893: 40599, 38894: 40802, 38895: 26278, 38896: 27508, 38897: 21015, 38898: 21155, 38899: 28872, 38900: 35010, 38901: 24265, 38902: 24651, 38903: 24976, 38904: 28451, 38905: 29001, 38906: 31806, 38907: 32244, 38908: 32879, 38976: 34030, 38977: 36899, 38978: 37676, 38979: 21570, 38980: 39791, 38981: 27347, 38982: 28809, 38983: 36034, 38984: 36335, 38985: 38706, 38986: 21172, 38987: 23105, 38988: 24266, 38989: 24324, 38990: 26391, 38991: 27004, 38992: 27028, 38993: 28010, 38994: 28431, 38995: 29282, 38996: 29436, 38997: 31725, 38998: 32769, 38999: 32894, 39e3: 34635, 39001: 37070, 39002: 20845, 39003: 40595, 39004: 31108, 39005: 32907, 39006: 37682, 39007: 35542, 39008: 20525, 39009: 21644, 39010: 35441, 39011: 27498, 39012: 36036, 39013: 33031, 39014: 24785, 39015: 26528, 39016: 40434, 39017: 20121, 39018: 20120, 39019: 39952, 39020: 35435, 39021: 34241, 39022: 34152, 39023: 26880, 39024: 28286, 39025: 30871, 39026: 33109, 39071: 24332, 39072: 19984, 39073: 19989, 39074: 20010, 39075: 20017, 39076: 20022, 39077: 20028, 39078: 20031, 39079: 20034, 39080: 20054, 39081: 20056, 39082: 20098, 39083: 20101, 39084: 35947, 39085: 20106, 39086: 33298, 39087: 24333, 39088: 20110, 39089: 20126, 39090: 20127, 39091: 20128, 39092: 20130, 39093: 20144, 39094: 20147, 39095: 20150, 39096: 20174, 39097: 20173, 39098: 20164, 39099: 20166, 39100: 20162, 39101: 20183, 39102: 20190, 39103: 20205, 39104: 20191, 39105: 20215, 39106: 20233, 39107: 20314, 39108: 20272, 39109: 20315, 39110: 20317, 39111: 20311, 39112: 20295, 39113: 20342, 39114: 20360, 39115: 20367, 39116: 20376, 39117: 20347, 39118: 20329, 39119: 20336, 39120: 20369, 39121: 20335, 39122: 20358, 39123: 20374, 39124: 20760, 39125: 20436, 39126: 20447, 39127: 20430, 39128: 20440, 39129: 20443, 39130: 20433, 39131: 20442, 39132: 20432, 39133: 20452, 39134: 20453, 39135: 20506, 39136: 20520, 39137: 20500, 39138: 20522, 39139: 20517, 39140: 20485, 39141: 20252, 39142: 20470, 39143: 20513, 39144: 20521, 39145: 20524, 39146: 20478, 39147: 20463, 39148: 20497, 39149: 20486, 39150: 20547, 39151: 20551, 39152: 26371, 39153: 20565, 39154: 20560, 39155: 20552, 39156: 20570, 39157: 20566, 39158: 20588, 39159: 20600, 39160: 20608, 39161: 20634, 39162: 20613, 39163: 20660, 39164: 20658, 39232: 20681, 39233: 20682, 39234: 20659, 39235: 20674, 39236: 20694, 39237: 20702, 39238: 20709, 39239: 20717, 39240: 20707, 39241: 20718, 39242: 20729, 39243: 20725, 39244: 20745, 39245: 20737, 39246: 20738, 39247: 20758, 39248: 20757, 39249: 20756, 39250: 20762, 39251: 20769, 39252: 20794, 39253: 20791, 39254: 20796, 39255: 20795, 39256: 20799, 39257: 20800, 39258: 20818, 39259: 20812, 39260: 20820, 39261: 20834, 39262: 31480, 39263: 20841, 39264: 20842, 39265: 20846, 39266: 20864, 39267: 20866, 39268: 22232, 39269: 20876, 39270: 20873, 39271: 20879, 39272: 20881, 39273: 20883, 39274: 20885, 39275: 20886, 39276: 20900, 39277: 20902, 39278: 20898, 39279: 20905, 39280: 20906, 39281: 20907, 39282: 20915, 39283: 20913, 39284: 20914, 39285: 20912, 39286: 20917, 39287: 20925, 39288: 20933, 39289: 20937, 39290: 20955, 39291: 20960, 39292: 34389, 39293: 20969, 39294: 20973, 39296: 20976, 39297: 20981, 39298: 20990, 39299: 20996, 39300: 21003, 39301: 21012, 39302: 21006, 39303: 21031, 39304: 21034, 39305: 21038, 39306: 21043, 39307: 21049, 39308: 21071, 39309: 21060, 39310: 21067, 39311: 21068, 39312: 21086, 39313: 21076, 39314: 21098, 39315: 21108, 39316: 21097, 39317: 21107, 39318: 21119, 39319: 21117, 39320: 21133, 39321: 21140, 39322: 21138, 39323: 21105, 39324: 21128, 39325: 21137, 39326: 36776, 39327: 36775, 39328: 21164, 39329: 21165, 39330: 21180, 39331: 21173, 39332: 21185, 39333: 21197, 39334: 21207, 39335: 21214, 39336: 21219, 39337: 21222, 39338: 39149, 39339: 21216, 39340: 21235, 39341: 21237, 39342: 21240, 39343: 21241, 39344: 21254, 39345: 21256, 39346: 30008, 39347: 21261, 39348: 21264, 39349: 21263, 39350: 21269, 39351: 21274, 39352: 21283, 39353: 21295, 39354: 21297, 39355: 21299, 39356: 21304, 39357: 21312, 39358: 21318, 39359: 21317, 39360: 19991, 39361: 21321, 39362: 21325, 39363: 20950, 39364: 21342, 39365: 21353, 39366: 21358, 39367: 22808, 39368: 21371, 39369: 21367, 39370: 21378, 39371: 21398, 39372: 21408, 39373: 21414, 39374: 21413, 39375: 21422, 39376: 21424, 39377: 21430, 39378: 21443, 39379: 31762, 39380: 38617, 39381: 21471, 39382: 26364, 39383: 29166, 39384: 21486, 39385: 21480, 39386: 21485, 39387: 21498, 39388: 21505, 39389: 21565, 39390: 21568, 39391: 21548, 39392: 21549, 39393: 21564, 39394: 21550, 39395: 21558, 39396: 21545, 39397: 21533, 39398: 21582, 39399: 21647, 39400: 21621, 39401: 21646, 39402: 21599, 39403: 21617, 39404: 21623, 39405: 21616, 39406: 21650, 39407: 21627, 39408: 21632, 39409: 21622, 39410: 21636, 39411: 21648, 39412: 21638, 39413: 21703, 39414: 21666, 39415: 21688, 39416: 21669, 39417: 21676, 39418: 21700, 39419: 21704, 39420: 21672, 39488: 21675, 39489: 21698, 39490: 21668, 39491: 21694, 39492: 21692, 39493: 21720, 39494: 21733, 39495: 21734, 39496: 21775, 39497: 21780, 39498: 21757, 39499: 21742, 39500: 21741, 39501: 21754, 39502: 21730, 39503: 21817, 39504: 21824, 39505: 21859, 39506: 21836, 39507: 21806, 39508: 21852, 39509: 21829, 39510: 21846, 39511: 21847, 39512: 21816, 39513: 21811, 39514: 21853, 39515: 21913, 39516: 21888, 39517: 21679, 39518: 21898, 39519: 21919, 39520: 21883, 39521: 21886, 39522: 21912, 39523: 21918, 39524: 21934, 39525: 21884, 39526: 21891, 39527: 21929, 39528: 21895, 39529: 21928, 39530: 21978, 39531: 21957, 39532: 21983, 39533: 21956, 39534: 21980, 39535: 21988, 39536: 21972, 39537: 22036, 39538: 22007, 39539: 22038, 39540: 22014, 39541: 22013, 39542: 22043, 39543: 22009, 39544: 22094, 39545: 22096, 39546: 29151, 39547: 22068, 39548: 22070, 39549: 22066, 39550: 22072, 39552: 22123, 39553: 22116, 39554: 22063, 39555: 22124, 39556: 22122, 39557: 22150, 39558: 22144, 39559: 22154, 39560: 22176, 39561: 22164, 39562: 22159, 39563: 22181, 39564: 22190, 39565: 22198, 39566: 22196, 39567: 22210, 39568: 22204, 39569: 22209, 39570: 22211, 39571: 22208, 39572: 22216, 39573: 22222, 39574: 22225, 39575: 22227, 39576: 22231, 39577: 22254, 39578: 22265, 39579: 22272, 39580: 22271, 39581: 22276, 39582: 22281, 39583: 22280, 39584: 22283, 39585: 22285, 39586: 22291, 39587: 22296, 39588: 22294, 39589: 21959, 39590: 22300, 39591: 22310, 39592: 22327, 39593: 22328, 39594: 22350, 39595: 22331, 39596: 22336, 39597: 22351, 39598: 22377, 39599: 22464, 39600: 22408, 39601: 22369, 39602: 22399, 39603: 22409, 39604: 22419, 39605: 22432, 39606: 22451, 39607: 22436, 39608: 22442, 39609: 22448, 39610: 22467, 39611: 22470, 39612: 22484, 39613: 22482, 39614: 22483, 39615: 22538, 39616: 22486, 39617: 22499, 39618: 22539, 39619: 22553, 39620: 22557, 39621: 22642, 39622: 22561, 39623: 22626, 39624: 22603, 39625: 22640, 39626: 27584, 39627: 22610, 39628: 22589, 39629: 22649, 39630: 22661, 39631: 22713, 39632: 22687, 39633: 22699, 39634: 22714, 39635: 22750, 39636: 22715, 39637: 22712, 39638: 22702, 39639: 22725, 39640: 22739, 39641: 22737, 39642: 22743, 39643: 22745, 39644: 22744, 39645: 22757, 39646: 22748, 39647: 22756, 39648: 22751, 39649: 22767, 39650: 22778, 39651: 22777, 39652: 22779, 39653: 22780, 39654: 22781, 39655: 22786, 39656: 22794, 39657: 22800, 39658: 22811, 39659: 26790, 39660: 22821, 39661: 22828, 39662: 22829, 39663: 22834, 39664: 22840, 39665: 22846, 39666: 31442, 39667: 22869, 39668: 22864, 39669: 22862, 39670: 22874, 39671: 22872, 39672: 22882, 39673: 22880, 39674: 22887, 39675: 22892, 39676: 22889, 39744: 22904, 39745: 22913, 39746: 22941, 39747: 20318, 39748: 20395, 39749: 22947, 39750: 22962, 39751: 22982, 39752: 23016, 39753: 23004, 39754: 22925, 39755: 23001, 39756: 23002, 39757: 23077, 39758: 23071, 39759: 23057, 39760: 23068, 39761: 23049, 39762: 23066, 39763: 23104, 39764: 23148, 39765: 23113, 39766: 23093, 39767: 23094, 39768: 23138, 39769: 23146, 39770: 23194, 39771: 23228, 39772: 23230, 39773: 23243, 39774: 23234, 39775: 23229, 39776: 23267, 39777: 23255, 39778: 23270, 39779: 23273, 39780: 23254, 39781: 23290, 39782: 23291, 39783: 23308, 39784: 23307, 39785: 23318, 39786: 23346, 39787: 23248, 39788: 23338, 39789: 23350, 39790: 23358, 39791: 23363, 39792: 23365, 39793: 23360, 39794: 23377, 39795: 23381, 39796: 23386, 39797: 23387, 39798: 23397, 39799: 23401, 39800: 23408, 39801: 23411, 39802: 23413, 39803: 23416, 39804: 25992, 39805: 23418, 39806: 23424, 39808: 23427, 39809: 23462, 39810: 23480, 39811: 23491, 39812: 23495, 39813: 23497, 39814: 23508, 39815: 23504, 39816: 23524, 39817: 23526, 39818: 23522, 39819: 23518, 39820: 23525, 39821: 23531, 39822: 23536, 39823: 23542, 39824: 23539, 39825: 23557, 39826: 23559, 39827: 23560, 39828: 23565, 39829: 23571, 39830: 23584, 39831: 23586, 39832: 23592, 39833: 23608, 39834: 23609, 39835: 23617, 39836: 23622, 39837: 23630, 39838: 23635, 39839: 23632, 39840: 23631, 39841: 23409, 39842: 23660, 39843: 23662, 39844: 20066, 39845: 23670, 39846: 23673, 39847: 23692, 39848: 23697, 39849: 23700, 39850: 22939, 39851: 23723, 39852: 23739, 39853: 23734, 39854: 23740, 39855: 23735, 39856: 23749, 39857: 23742, 39858: 23751, 39859: 23769, 39860: 23785, 39861: 23805, 39862: 23802, 39863: 23789, 39864: 23948, 39865: 23786, 39866: 23819, 39867: 23829, 39868: 23831, 39869: 23900, 39870: 23839, 39871: 23835, 39872: 23825, 39873: 23828, 39874: 23842, 39875: 23834, 39876: 23833, 39877: 23832, 39878: 23884, 39879: 23890, 39880: 23886, 39881: 23883, 39882: 23916, 39883: 23923, 39884: 23926, 39885: 23943, 39886: 23940, 39887: 23938, 39888: 23970, 39889: 23965, 39890: 23980, 39891: 23982, 39892: 23997, 39893: 23952, 39894: 23991, 39895: 23996, 39896: 24009, 39897: 24013, 39898: 24019, 39899: 24018, 39900: 24022, 39901: 24027, 39902: 24043, 39903: 24050, 39904: 24053, 39905: 24075, 39906: 24090, 39907: 24089, 39908: 24081, 39909: 24091, 39910: 24118, 39911: 24119, 39912: 24132, 39913: 24131, 39914: 24128, 39915: 24142, 39916: 24151, 39917: 24148, 39918: 24159, 39919: 24162, 39920: 24164, 39921: 24135, 39922: 24181, 39923: 24182, 39924: 24186, 39925: 40636, 39926: 24191, 39927: 24224, 39928: 24257, 39929: 24258, 39930: 24264, 39931: 24272, 39932: 24271, 4e4: 24278, 40001: 24291, 40002: 24285, 40003: 24282, 40004: 24283, 40005: 24290, 40006: 24289, 40007: 24296, 40008: 24297, 40009: 24300, 40010: 24305, 40011: 24307, 40012: 24304, 40013: 24308, 40014: 24312, 40015: 24318, 40016: 24323, 40017: 24329, 40018: 24413, 40019: 24412, 40020: 24331, 40021: 24337, 40022: 24342, 40023: 24361, 40024: 24365, 40025: 24376, 40026: 24385, 40027: 24392, 40028: 24396, 40029: 24398, 40030: 24367, 40031: 24401, 40032: 24406, 40033: 24407, 40034: 24409, 40035: 24417, 40036: 24429, 40037: 24435, 40038: 24439, 40039: 24451, 40040: 24450, 40041: 24447, 40042: 24458, 40043: 24456, 40044: 24465, 40045: 24455, 40046: 24478, 40047: 24473, 40048: 24472, 40049: 24480, 40050: 24488, 40051: 24493, 40052: 24508, 40053: 24534, 40054: 24571, 40055: 24548, 40056: 24568, 40057: 24561, 40058: 24541, 40059: 24755, 40060: 24575, 40061: 24609, 40062: 24672, 40064: 24601, 40065: 24592, 40066: 24617, 40067: 24590, 40068: 24625, 40069: 24603, 40070: 24597, 40071: 24619, 40072: 24614, 40073: 24591, 40074: 24634, 40075: 24666, 40076: 24641, 40077: 24682, 40078: 24695, 40079: 24671, 40080: 24650, 40081: 24646, 40082: 24653, 40083: 24675, 40084: 24643, 40085: 24676, 40086: 24642, 40087: 24684, 40088: 24683, 40089: 24665, 40090: 24705, 40091: 24717, 40092: 24807, 40093: 24707, 40094: 24730, 40095: 24708, 40096: 24731, 40097: 24726, 40098: 24727, 40099: 24722, 40100: 24743, 40101: 24715, 40102: 24801, 40103: 24760, 40104: 24800, 40105: 24787, 40106: 24756, 40107: 24560, 40108: 24765, 40109: 24774, 40110: 24757, 40111: 24792, 40112: 24909, 40113: 24853, 40114: 24838, 40115: 24822, 40116: 24823, 40117: 24832, 40118: 24820, 40119: 24826, 40120: 24835, 40121: 24865, 40122: 24827, 40123: 24817, 40124: 24845, 40125: 24846, 40126: 24903, 40127: 24894, 40128: 24872, 40129: 24871, 40130: 24906, 40131: 24895, 40132: 24892, 40133: 24876, 40134: 24884, 40135: 24893, 40136: 24898, 40137: 24900, 40138: 24947, 40139: 24951, 40140: 24920, 40141: 24921, 40142: 24922, 40143: 24939, 40144: 24948, 40145: 24943, 40146: 24933, 40147: 24945, 40148: 24927, 40149: 24925, 40150: 24915, 40151: 24949, 40152: 24985, 40153: 24982, 40154: 24967, 40155: 25004, 40156: 24980, 40157: 24986, 40158: 24970, 40159: 24977, 40160: 25003, 40161: 25006, 40162: 25036, 40163: 25034, 40164: 25033, 40165: 25079, 40166: 25032, 40167: 25027, 40168: 25030, 40169: 25018, 40170: 25035, 40171: 32633, 40172: 25037, 40173: 25062, 40174: 25059, 40175: 25078, 40176: 25082, 40177: 25076, 40178: 25087, 40179: 25085, 40180: 25084, 40181: 25086, 40182: 25088, 40183: 25096, 40184: 25097, 40185: 25101, 40186: 25100, 40187: 25108, 40188: 25115, 40256: 25118, 40257: 25121, 40258: 25130, 40259: 25134, 40260: 25136, 40261: 25138, 40262: 25139, 40263: 25153, 40264: 25166, 40265: 25182, 40266: 25187, 40267: 25179, 40268: 25184, 40269: 25192, 40270: 25212, 40271: 25218, 40272: 25225, 40273: 25214, 40274: 25234, 40275: 25235, 40276: 25238, 40277: 25300, 40278: 25219, 40279: 25236, 40280: 25303, 40281: 25297, 40282: 25275, 40283: 25295, 40284: 25343, 40285: 25286, 40286: 25812, 40287: 25288, 40288: 25308, 40289: 25292, 40290: 25290, 40291: 25282, 40292: 25287, 40293: 25243, 40294: 25289, 40295: 25356, 40296: 25326, 40297: 25329, 40298: 25383, 40299: 25346, 40300: 25352, 40301: 25327, 40302: 25333, 40303: 25424, 40304: 25406, 40305: 25421, 40306: 25628, 40307: 25423, 40308: 25494, 40309: 25486, 40310: 25472, 40311: 25515, 40312: 25462, 40313: 25507, 40314: 25487, 40315: 25481, 40316: 25503, 40317: 25525, 40318: 25451, 40320: 25449, 40321: 25534, 40322: 25577, 40323: 25536, 40324: 25542, 40325: 25571, 40326: 25545, 40327: 25554, 40328: 25590, 40329: 25540, 40330: 25622, 40331: 25652, 40332: 25606, 40333: 25619, 40334: 25638, 40335: 25654, 40336: 25885, 40337: 25623, 40338: 25640, 40339: 25615, 40340: 25703, 40341: 25711, 40342: 25718, 40343: 25678, 40344: 25898, 40345: 25749, 40346: 25747, 40347: 25765, 40348: 25769, 40349: 25736, 40350: 25788, 40351: 25818, 40352: 25810, 40353: 25797, 40354: 25799, 40355: 25787, 40356: 25816, 40357: 25794, 40358: 25841, 40359: 25831, 40360: 33289, 40361: 25824, 40362: 25825, 40363: 25260, 40364: 25827, 40365: 25839, 40366: 25900, 40367: 25846, 40368: 25844, 40369: 25842, 40370: 25850, 40371: 25856, 40372: 25853, 40373: 25880, 40374: 25884, 40375: 25861, 40376: 25892, 40377: 25891, 40378: 25899, 40379: 25908, 40380: 25909, 40381: 25911, 40382: 25910, 40383: 25912, 40384: 30027, 40385: 25928, 40386: 25942, 40387: 25941, 40388: 25933, 40389: 25944, 40390: 25950, 40391: 25949, 40392: 25970, 40393: 25976, 40394: 25986, 40395: 25987, 40396: 35722, 40397: 26011, 40398: 26015, 40399: 26027, 40400: 26039, 40401: 26051, 40402: 26054, 40403: 26049, 40404: 26052, 40405: 26060, 40406: 26066, 40407: 26075, 40408: 26073, 40409: 26080, 40410: 26081, 40411: 26097, 40412: 26482, 40413: 26122, 40414: 26115, 40415: 26107, 40416: 26483, 40417: 26165, 40418: 26166, 40419: 26164, 40420: 26140, 40421: 26191, 40422: 26180, 40423: 26185, 40424: 26177, 40425: 26206, 40426: 26205, 40427: 26212, 40428: 26215, 40429: 26216, 40430: 26207, 40431: 26210, 40432: 26224, 40433: 26243, 40434: 26248, 40435: 26254, 40436: 26249, 40437: 26244, 40438: 26264, 40439: 26269, 40440: 26305, 40441: 26297, 40442: 26313, 40443: 26302, 40444: 26300, 40512: 26308, 40513: 26296, 40514: 26326, 40515: 26330, 40516: 26336, 40517: 26175, 40518: 26342, 40519: 26345, 40520: 26352, 40521: 26357, 40522: 26359, 40523: 26383, 40524: 26390, 40525: 26398, 40526: 26406, 40527: 26407, 40528: 38712, 40529: 26414, 40530: 26431, 40531: 26422, 40532: 26433, 40533: 26424, 40534: 26423, 40535: 26438, 40536: 26462, 40537: 26464, 40538: 26457, 40539: 26467, 40540: 26468, 40541: 26505, 40542: 26480, 40543: 26537, 40544: 26492, 40545: 26474, 40546: 26508, 40547: 26507, 40548: 26534, 40549: 26529, 40550: 26501, 40551: 26551, 40552: 26607, 40553: 26548, 40554: 26604, 40555: 26547, 40556: 26601, 40557: 26552, 40558: 26596, 40559: 26590, 40560: 26589, 40561: 26594, 40562: 26606, 40563: 26553, 40564: 26574, 40565: 26566, 40566: 26599, 40567: 27292, 40568: 26654, 40569: 26694, 40570: 26665, 40571: 26688, 40572: 26701, 40573: 26674, 40574: 26702, 40576: 26803, 40577: 26667, 40578: 26713, 40579: 26723, 40580: 26743, 40581: 26751, 40582: 26783, 40583: 26767, 40584: 26797, 40585: 26772, 40586: 26781, 40587: 26779, 40588: 26755, 40589: 27310, 40590: 26809, 40591: 26740, 40592: 26805, 40593: 26784, 40594: 26810, 40595: 26895, 40596: 26765, 40597: 26750, 40598: 26881, 40599: 26826, 40600: 26888, 40601: 26840, 40602: 26914, 40603: 26918, 40604: 26849, 40605: 26892, 40606: 26829, 40607: 26836, 40608: 26855, 40609: 26837, 40610: 26934, 40611: 26898, 40612: 26884, 40613: 26839, 40614: 26851, 40615: 26917, 40616: 26873, 40617: 26848, 40618: 26863, 40619: 26920, 40620: 26922, 40621: 26906, 40622: 26915, 40623: 26913, 40624: 26822, 40625: 27001, 40626: 26999, 40627: 26972, 40628: 27e3, 40629: 26987, 40630: 26964, 40631: 27006, 40632: 26990, 40633: 26937, 40634: 26996, 40635: 26941, 40636: 26969, 40637: 26928, 40638: 26977, 40639: 26974, 40640: 26973, 40641: 27009, 40642: 26986, 40643: 27058, 40644: 27054, 40645: 27088, 40646: 27071, 40647: 27073, 40648: 27091, 40649: 27070, 40650: 27086, 40651: 23528, 40652: 27082, 40653: 27101, 40654: 27067, 40655: 27075, 40656: 27047, 40657: 27182, 40658: 27025, 40659: 27040, 40660: 27036, 40661: 27029, 40662: 27060, 40663: 27102, 40664: 27112, 40665: 27138, 40666: 27163, 40667: 27135, 40668: 27402, 40669: 27129, 40670: 27122, 40671: 27111, 40672: 27141, 40673: 27057, 40674: 27166, 40675: 27117, 40676: 27156, 40677: 27115, 40678: 27146, 40679: 27154, 40680: 27329, 40681: 27171, 40682: 27155, 40683: 27204, 40684: 27148, 40685: 27250, 40686: 27190, 40687: 27256, 40688: 27207, 40689: 27234, 40690: 27225, 40691: 27238, 40692: 27208, 40693: 27192, 40694: 27170, 40695: 27280, 40696: 27277, 40697: 27296, 40698: 27268, 40699: 27298, 40700: 27299, 40768: 27287, 40769: 34327, 40770: 27323, 40771: 27331, 40772: 27330, 40773: 27320, 40774: 27315, 40775: 27308, 40776: 27358, 40777: 27345, 40778: 27359, 40779: 27306, 40780: 27354, 40781: 27370, 40782: 27387, 40783: 27397, 40784: 34326, 40785: 27386, 40786: 27410, 40787: 27414, 40788: 39729, 40789: 27423, 40790: 27448, 40791: 27447, 40792: 30428, 40793: 27449, 40794: 39150, 40795: 27463, 40796: 27459, 40797: 27465, 40798: 27472, 40799: 27481, 40800: 27476, 40801: 27483, 40802: 27487, 40803: 27489, 40804: 27512, 40805: 27513, 40806: 27519, 40807: 27520, 40808: 27524, 40809: 27523, 40810: 27533, 40811: 27544, 40812: 27541, 40813: 27550, 40814: 27556, 40815: 27562, 40816: 27563, 40817: 27567, 40818: 27570, 40819: 27569, 40820: 27571, 40821: 27575, 40822: 27580, 40823: 27590, 40824: 27595, 40825: 27603, 40826: 27615, 40827: 27628, 40828: 27627, 40829: 27635, 40830: 27631, 40832: 40638, 40833: 27656, 40834: 27667, 40835: 27668, 40836: 27675, 40837: 27684, 40838: 27683, 40839: 27742, 40840: 27733, 40841: 27746, 40842: 27754, 40843: 27778, 40844: 27789, 40845: 27802, 40846: 27777, 40847: 27803, 40848: 27774, 40849: 27752, 40850: 27763, 40851: 27794, 40852: 27792, 40853: 27844, 40854: 27889, 40855: 27859, 40856: 27837, 40857: 27863, 40858: 27845, 40859: 27869, 40860: 27822, 40861: 27825, 40862: 27838, 40863: 27834, 40864: 27867, 40865: 27887, 40866: 27865, 40867: 27882, 40868: 27935, 40869: 34893, 40870: 27958, 40871: 27947, 40872: 27965, 40873: 27960, 40874: 27929, 40875: 27957, 40876: 27955, 40877: 27922, 40878: 27916, 40879: 28003, 40880: 28051, 40881: 28004, 40882: 27994, 40883: 28025, 40884: 27993, 40885: 28046, 40886: 28053, 40887: 28644, 40888: 28037, 40889: 28153, 40890: 28181, 40891: 28170, 40892: 28085, 40893: 28103, 40894: 28134, 40895: 28088, 40896: 28102, 40897: 28140, 40898: 28126, 40899: 28108, 40900: 28136, 40901: 28114, 40902: 28101, 40903: 28154, 40904: 28121, 40905: 28132, 40906: 28117, 40907: 28138, 40908: 28142, 40909: 28205, 40910: 28270, 40911: 28206, 40912: 28185, 40913: 28274, 40914: 28255, 40915: 28222, 40916: 28195, 40917: 28267, 40918: 28203, 40919: 28278, 40920: 28237, 40921: 28191, 40922: 28227, 40923: 28218, 40924: 28238, 40925: 28196, 40926: 28415, 40927: 28189, 40928: 28216, 40929: 28290, 40930: 28330, 40931: 28312, 40932: 28361, 40933: 28343, 40934: 28371, 40935: 28349, 40936: 28335, 40937: 28356, 40938: 28338, 40939: 28372, 40940: 28373, 40941: 28303, 40942: 28325, 40943: 28354, 40944: 28319, 40945: 28481, 40946: 28433, 40947: 28748, 40948: 28396, 40949: 28408, 40950: 28414, 40951: 28479, 40952: 28402, 40953: 28465, 40954: 28399, 40955: 28466, 40956: 28364, 57408: 28478, 57409: 28435, 57410: 28407, 57411: 28550, 57412: 28538, 57413: 28536, 57414: 28545, 57415: 28544, 57416: 28527, 57417: 28507, 57418: 28659, 57419: 28525, 57420: 28546, 57421: 28540, 57422: 28504, 57423: 28558, 57424: 28561, 57425: 28610, 57426: 28518, 57427: 28595, 57428: 28579, 57429: 28577, 57430: 28580, 57431: 28601, 57432: 28614, 57433: 28586, 57434: 28639, 57435: 28629, 57436: 28652, 57437: 28628, 57438: 28632, 57439: 28657, 57440: 28654, 57441: 28635, 57442: 28681, 57443: 28683, 57444: 28666, 57445: 28689, 57446: 28673, 57447: 28687, 57448: 28670, 57449: 28699, 57450: 28698, 57451: 28532, 57452: 28701, 57453: 28696, 57454: 28703, 57455: 28720, 57456: 28734, 57457: 28722, 57458: 28753, 57459: 28771, 57460: 28825, 57461: 28818, 57462: 28847, 57463: 28913, 57464: 28844, 57465: 28856, 57466: 28851, 57467: 28846, 57468: 28895, 57469: 28875, 57470: 28893, 57472: 28889, 57473: 28937, 57474: 28925, 57475: 28956, 57476: 28953, 57477: 29029, 57478: 29013, 57479: 29064, 57480: 29030, 57481: 29026, 57482: 29004, 57483: 29014, 57484: 29036, 57485: 29071, 57486: 29179, 57487: 29060, 57488: 29077, 57489: 29096, 57490: 29100, 57491: 29143, 57492: 29113, 57493: 29118, 57494: 29138, 57495: 29129, 57496: 29140, 57497: 29134, 57498: 29152, 57499: 29164, 57500: 29159, 57501: 29173, 57502: 29180, 57503: 29177, 57504: 29183, 57505: 29197, 57506: 29200, 57507: 29211, 57508: 29224, 57509: 29229, 57510: 29228, 57511: 29232, 57512: 29234, 57513: 29243, 57514: 29244, 57515: 29247, 57516: 29248, 57517: 29254, 57518: 29259, 57519: 29272, 57520: 29300, 57521: 29310, 57522: 29314, 57523: 29313, 57524: 29319, 57525: 29330, 57526: 29334, 57527: 29346, 57528: 29351, 57529: 29369, 57530: 29362, 57531: 29379, 57532: 29382, 57533: 29380, 57534: 29390, 57535: 29394, 57536: 29410, 57537: 29408, 57538: 29409, 57539: 29433, 57540: 29431, 57541: 20495, 57542: 29463, 57543: 29450, 57544: 29468, 57545: 29462, 57546: 29469, 57547: 29492, 57548: 29487, 57549: 29481, 57550: 29477, 57551: 29502, 57552: 29518, 57553: 29519, 57554: 40664, 57555: 29527, 57556: 29546, 57557: 29544, 57558: 29552, 57559: 29560, 57560: 29557, 57561: 29563, 57562: 29562, 57563: 29640, 57564: 29619, 57565: 29646, 57566: 29627, 57567: 29632, 57568: 29669, 57569: 29678, 57570: 29662, 57571: 29858, 57572: 29701, 57573: 29807, 57574: 29733, 57575: 29688, 57576: 29746, 57577: 29754, 57578: 29781, 57579: 29759, 57580: 29791, 57581: 29785, 57582: 29761, 57583: 29788, 57584: 29801, 57585: 29808, 57586: 29795, 57587: 29802, 57588: 29814, 57589: 29822, 57590: 29835, 57591: 29854, 57592: 29863, 57593: 29898, 57594: 29903, 57595: 29908, 57596: 29681, 57664: 29920, 57665: 29923, 57666: 29927, 57667: 29929, 57668: 29934, 57669: 29938, 57670: 29936, 57671: 29937, 57672: 29944, 57673: 29943, 57674: 29956, 57675: 29955, 57676: 29957, 57677: 29964, 57678: 29966, 57679: 29965, 57680: 29973, 57681: 29971, 57682: 29982, 57683: 29990, 57684: 29996, 57685: 30012, 57686: 30020, 57687: 30029, 57688: 30026, 57689: 30025, 57690: 30043, 57691: 30022, 57692: 30042, 57693: 30057, 57694: 30052, 57695: 30055, 57696: 30059, 57697: 30061, 57698: 30072, 57699: 30070, 57700: 30086, 57701: 30087, 57702: 30068, 57703: 30090, 57704: 30089, 57705: 30082, 57706: 30100, 57707: 30106, 57708: 30109, 57709: 30117, 57710: 30115, 57711: 30146, 57712: 30131, 57713: 30147, 57714: 30133, 57715: 30141, 57716: 30136, 57717: 30140, 57718: 30129, 57719: 30157, 57720: 30154, 57721: 30162, 57722: 30169, 57723: 30179, 57724: 30174, 57725: 30206, 57726: 30207, 57728: 30204, 57729: 30209, 57730: 30192, 57731: 30202, 57732: 30194, 57733: 30195, 57734: 30219, 57735: 30221, 57736: 30217, 57737: 30239, 57738: 30247, 57739: 30240, 57740: 30241, 57741: 30242, 57742: 30244, 57743: 30260, 57744: 30256, 57745: 30267, 57746: 30279, 57747: 30280, 57748: 30278, 57749: 30300, 57750: 30296, 57751: 30305, 57752: 30306, 57753: 30312, 57754: 30313, 57755: 30314, 57756: 30311, 57757: 30316, 57758: 30320, 57759: 30322, 57760: 30326, 57761: 30328, 57762: 30332, 57763: 30336, 57764: 30339, 57765: 30344, 57766: 30347, 57767: 30350, 57768: 30358, 57769: 30355, 57770: 30361, 57771: 30362, 57772: 30384, 57773: 30388, 57774: 30392, 57775: 30393, 57776: 30394, 57777: 30402, 57778: 30413, 57779: 30422, 57780: 30418, 57781: 30430, 57782: 30433, 57783: 30437, 57784: 30439, 57785: 30442, 57786: 34351, 57787: 30459, 57788: 30472, 57789: 30471, 57790: 30468, 57791: 30505, 57792: 30500, 57793: 30494, 57794: 30501, 57795: 30502, 57796: 30491, 57797: 30519, 57798: 30520, 57799: 30535, 57800: 30554, 57801: 30568, 57802: 30571, 57803: 30555, 57804: 30565, 57805: 30591, 57806: 30590, 57807: 30585, 57808: 30606, 57809: 30603, 57810: 30609, 57811: 30624, 57812: 30622, 57813: 30640, 57814: 30646, 57815: 30649, 57816: 30655, 57817: 30652, 57818: 30653, 57819: 30651, 57820: 30663, 57821: 30669, 57822: 30679, 57823: 30682, 57824: 30684, 57825: 30691, 57826: 30702, 57827: 30716, 57828: 30732, 57829: 30738, 57830: 31014, 57831: 30752, 57832: 31018, 57833: 30789, 57834: 30862, 57835: 30836, 57836: 30854, 57837: 30844, 57838: 30874, 57839: 30860, 57840: 30883, 57841: 30901, 57842: 30890, 57843: 30895, 57844: 30929, 57845: 30918, 57846: 30923, 57847: 30932, 57848: 30910, 57849: 30908, 57850: 30917, 57851: 30922, 57852: 30956, 57920: 30951, 57921: 30938, 57922: 30973, 57923: 30964, 57924: 30983, 57925: 30994, 57926: 30993, 57927: 31001, 57928: 31020, 57929: 31019, 57930: 31040, 57931: 31072, 57932: 31063, 57933: 31071, 57934: 31066, 57935: 31061, 57936: 31059, 57937: 31098, 57938: 31103, 57939: 31114, 57940: 31133, 57941: 31143, 57942: 40779, 57943: 31146, 57944: 31150, 57945: 31155, 57946: 31161, 57947: 31162, 57948: 31177, 57949: 31189, 57950: 31207, 57951: 31212, 57952: 31201, 57953: 31203, 57954: 31240, 57955: 31245, 57956: 31256, 57957: 31257, 57958: 31264, 57959: 31263, 57960: 31104, 57961: 31281, 57962: 31291, 57963: 31294, 57964: 31287, 57965: 31299, 57966: 31319, 57967: 31305, 57968: 31329, 57969: 31330, 57970: 31337, 57971: 40861, 57972: 31344, 57973: 31353, 57974: 31357, 57975: 31368, 57976: 31383, 57977: 31381, 57978: 31384, 57979: 31382, 57980: 31401, 57981: 31432, 57982: 31408, 57984: 31414, 57985: 31429, 57986: 31428, 57987: 31423, 57988: 36995, 57989: 31431, 57990: 31434, 57991: 31437, 57992: 31439, 57993: 31445, 57994: 31443, 57995: 31449, 57996: 31450, 57997: 31453, 57998: 31457, 57999: 31458, 58e3: 31462, 58001: 31469, 58002: 31472, 58003: 31490, 58004: 31503, 58005: 31498, 58006: 31494, 58007: 31539, 58008: 31512, 58009: 31513, 58010: 31518, 58011: 31541, 58012: 31528, 58013: 31542, 58014: 31568, 58015: 31610, 58016: 31492, 58017: 31565, 58018: 31499, 58019: 31564, 58020: 31557, 58021: 31605, 58022: 31589, 58023: 31604, 58024: 31591, 58025: 31600, 58026: 31601, 58027: 31596, 58028: 31598, 58029: 31645, 58030: 31640, 58031: 31647, 58032: 31629, 58033: 31644, 58034: 31642, 58035: 31627, 58036: 31634, 58037: 31631, 58038: 31581, 58039: 31641, 58040: 31691, 58041: 31681, 58042: 31692, 58043: 31695, 58044: 31668, 58045: 31686, 58046: 31709, 58047: 31721, 58048: 31761, 58049: 31764, 58050: 31718, 58051: 31717, 58052: 31840, 58053: 31744, 58054: 31751, 58055: 31763, 58056: 31731, 58057: 31735, 58058: 31767, 58059: 31757, 58060: 31734, 58061: 31779, 58062: 31783, 58063: 31786, 58064: 31775, 58065: 31799, 58066: 31787, 58067: 31805, 58068: 31820, 58069: 31811, 58070: 31828, 58071: 31823, 58072: 31808, 58073: 31824, 58074: 31832, 58075: 31839, 58076: 31844, 58077: 31830, 58078: 31845, 58079: 31852, 58080: 31861, 58081: 31875, 58082: 31888, 58083: 31908, 58084: 31917, 58085: 31906, 58086: 31915, 58087: 31905, 58088: 31912, 58089: 31923, 58090: 31922, 58091: 31921, 58092: 31918, 58093: 31929, 58094: 31933, 58095: 31936, 58096: 31941, 58097: 31938, 58098: 31960, 58099: 31954, 58100: 31964, 58101: 31970, 58102: 39739, 58103: 31983, 58104: 31986, 58105: 31988, 58106: 31990, 58107: 31994, 58108: 32006, 58176: 32002, 58177: 32028, 58178: 32021, 58179: 32010, 58180: 32069, 58181: 32075, 58182: 32046, 58183: 32050, 58184: 32063, 58185: 32053, 58186: 32070, 58187: 32115, 58188: 32086, 58189: 32078, 58190: 32114, 58191: 32104, 58192: 32110, 58193: 32079, 58194: 32099, 58195: 32147, 58196: 32137, 58197: 32091, 58198: 32143, 58199: 32125, 58200: 32155, 58201: 32186, 58202: 32174, 58203: 32163, 58204: 32181, 58205: 32199, 58206: 32189, 58207: 32171, 58208: 32317, 58209: 32162, 58210: 32175, 58211: 32220, 58212: 32184, 58213: 32159, 58214: 32176, 58215: 32216, 58216: 32221, 58217: 32228, 58218: 32222, 58219: 32251, 58220: 32242, 58221: 32225, 58222: 32261, 58223: 32266, 58224: 32291, 58225: 32289, 58226: 32274, 58227: 32305, 58228: 32287, 58229: 32265, 58230: 32267, 58231: 32290, 58232: 32326, 58233: 32358, 58234: 32315, 58235: 32309, 58236: 32313, 58237: 32323, 58238: 32311, 58240: 32306, 58241: 32314, 58242: 32359, 58243: 32349, 58244: 32342, 58245: 32350, 58246: 32345, 58247: 32346, 58248: 32377, 58249: 32362, 58250: 32361, 58251: 32380, 58252: 32379, 58253: 32387, 58254: 32213, 58255: 32381, 58256: 36782, 58257: 32383, 58258: 32392, 58259: 32393, 58260: 32396, 58261: 32402, 58262: 32400, 58263: 32403, 58264: 32404, 58265: 32406, 58266: 32398, 58267: 32411, 58268: 32412, 58269: 32568, 58270: 32570, 58271: 32581, 58272: 32588, 58273: 32589, 58274: 32590, 58275: 32592, 58276: 32593, 58277: 32597, 58278: 32596, 58279: 32600, 58280: 32607, 58281: 32608, 58282: 32616, 58283: 32617, 58284: 32615, 58285: 32632, 58286: 32642, 58287: 32646, 58288: 32643, 58289: 32648, 58290: 32647, 58291: 32652, 58292: 32660, 58293: 32670, 58294: 32669, 58295: 32666, 58296: 32675, 58297: 32687, 58298: 32690, 58299: 32697, 58300: 32686, 58301: 32694, 58302: 32696, 58303: 35697, 58304: 32709, 58305: 32710, 58306: 32714, 58307: 32725, 58308: 32724, 58309: 32737, 58310: 32742, 58311: 32745, 58312: 32755, 58313: 32761, 58314: 39132, 58315: 32774, 58316: 32772, 58317: 32779, 58318: 32786, 58319: 32792, 58320: 32793, 58321: 32796, 58322: 32801, 58323: 32808, 58324: 32831, 58325: 32827, 58326: 32842, 58327: 32838, 58328: 32850, 58329: 32856, 58330: 32858, 58331: 32863, 58332: 32866, 58333: 32872, 58334: 32883, 58335: 32882, 58336: 32880, 58337: 32886, 58338: 32889, 58339: 32893, 58340: 32895, 58341: 32900, 58342: 32902, 58343: 32901, 58344: 32923, 58345: 32915, 58346: 32922, 58347: 32941, 58348: 20880, 58349: 32940, 58350: 32987, 58351: 32997, 58352: 32985, 58353: 32989, 58354: 32964, 58355: 32986, 58356: 32982, 58357: 33033, 58358: 33007, 58359: 33009, 58360: 33051, 58361: 33065, 58362: 33059, 58363: 33071, 58364: 33099, 58432: 38539, 58433: 33094, 58434: 33086, 58435: 33107, 58436: 33105, 58437: 33020, 58438: 33137, 58439: 33134, 58440: 33125, 58441: 33126, 58442: 33140, 58443: 33155, 58444: 33160, 58445: 33162, 58446: 33152, 58447: 33154, 58448: 33184, 58449: 33173, 58450: 33188, 58451: 33187, 58452: 33119, 58453: 33171, 58454: 33193, 58455: 33200, 58456: 33205, 58457: 33214, 58458: 33208, 58459: 33213, 58460: 33216, 58461: 33218, 58462: 33210, 58463: 33225, 58464: 33229, 58465: 33233, 58466: 33241, 58467: 33240, 58468: 33224, 58469: 33242, 58470: 33247, 58471: 33248, 58472: 33255, 58473: 33274, 58474: 33275, 58475: 33278, 58476: 33281, 58477: 33282, 58478: 33285, 58479: 33287, 58480: 33290, 58481: 33293, 58482: 33296, 58483: 33302, 58484: 33321, 58485: 33323, 58486: 33336, 58487: 33331, 58488: 33344, 58489: 33369, 58490: 33368, 58491: 33373, 58492: 33370, 58493: 33375, 58494: 33380, 58496: 33378, 58497: 33384, 58498: 33386, 58499: 33387, 58500: 33326, 58501: 33393, 58502: 33399, 58503: 33400, 58504: 33406, 58505: 33421, 58506: 33426, 58507: 33451, 58508: 33439, 58509: 33467, 58510: 33452, 58511: 33505, 58512: 33507, 58513: 33503, 58514: 33490, 58515: 33524, 58516: 33523, 58517: 33530, 58518: 33683, 58519: 33539, 58520: 33531, 58521: 33529, 58522: 33502, 58523: 33542, 58524: 33500, 58525: 33545, 58526: 33497, 58527: 33589, 58528: 33588, 58529: 33558, 58530: 33586, 58531: 33585, 58532: 33600, 58533: 33593, 58534: 33616, 58535: 33605, 58536: 33583, 58537: 33579, 58538: 33559, 58539: 33560, 58540: 33669, 58541: 33690, 58542: 33706, 58543: 33695, 58544: 33698, 58545: 33686, 58546: 33571, 58547: 33678, 58548: 33671, 58549: 33674, 58550: 33660, 58551: 33717, 58552: 33651, 58553: 33653, 58554: 33696, 58555: 33673, 58556: 33704, 58557: 33780, 58558: 33811, 58559: 33771, 58560: 33742, 58561: 33789, 58562: 33795, 58563: 33752, 58564: 33803, 58565: 33729, 58566: 33783, 58567: 33799, 58568: 33760, 58569: 33778, 58570: 33805, 58571: 33826, 58572: 33824, 58573: 33725, 58574: 33848, 58575: 34054, 58576: 33787, 58577: 33901, 58578: 33834, 58579: 33852, 58580: 34138, 58581: 33924, 58582: 33911, 58583: 33899, 58584: 33965, 58585: 33902, 58586: 33922, 58587: 33897, 58588: 33862, 58589: 33836, 58590: 33903, 58591: 33913, 58592: 33845, 58593: 33994, 58594: 33890, 58595: 33977, 58596: 33983, 58597: 33951, 58598: 34009, 58599: 33997, 58600: 33979, 58601: 34010, 58602: 34e3, 58603: 33985, 58604: 33990, 58605: 34006, 58606: 33953, 58607: 34081, 58608: 34047, 58609: 34036, 58610: 34071, 58611: 34072, 58612: 34092, 58613: 34079, 58614: 34069, 58615: 34068, 58616: 34044, 58617: 34112, 58618: 34147, 58619: 34136, 58620: 34120, 58688: 34113, 58689: 34306, 58690: 34123, 58691: 34133, 58692: 34176, 58693: 34212, 58694: 34184, 58695: 34193, 58696: 34186, 58697: 34216, 58698: 34157, 58699: 34196, 58700: 34203, 58701: 34282, 58702: 34183, 58703: 34204, 58704: 34167, 58705: 34174, 58706: 34192, 58707: 34249, 58708: 34234, 58709: 34255, 58710: 34233, 58711: 34256, 58712: 34261, 58713: 34269, 58714: 34277, 58715: 34268, 58716: 34297, 58717: 34314, 58718: 34323, 58719: 34315, 58720: 34302, 58721: 34298, 58722: 34310, 58723: 34338, 58724: 34330, 58725: 34352, 58726: 34367, 58727: 34381, 58728: 20053, 58729: 34388, 58730: 34399, 58731: 34407, 58732: 34417, 58733: 34451, 58734: 34467, 58735: 34473, 58736: 34474, 58737: 34443, 58738: 34444, 58739: 34486, 58740: 34479, 58741: 34500, 58742: 34502, 58743: 34480, 58744: 34505, 58745: 34851, 58746: 34475, 58747: 34516, 58748: 34526, 58749: 34537, 58750: 34540, 58752: 34527, 58753: 34523, 58754: 34543, 58755: 34578, 58756: 34566, 58757: 34568, 58758: 34560, 58759: 34563, 58760: 34555, 58761: 34577, 58762: 34569, 58763: 34573, 58764: 34553, 58765: 34570, 58766: 34612, 58767: 34623, 58768: 34615, 58769: 34619, 58770: 34597, 58771: 34601, 58772: 34586, 58773: 34656, 58774: 34655, 58775: 34680, 58776: 34636, 58777: 34638, 58778: 34676, 58779: 34647, 58780: 34664, 58781: 34670, 58782: 34649, 58783: 34643, 58784: 34659, 58785: 34666, 58786: 34821, 58787: 34722, 58788: 34719, 58789: 34690, 58790: 34735, 58791: 34763, 58792: 34749, 58793: 34752, 58794: 34768, 58795: 38614, 58796: 34731, 58797: 34756, 58798: 34739, 58799: 34759, 58800: 34758, 58801: 34747, 58802: 34799, 58803: 34802, 58804: 34784, 58805: 34831, 58806: 34829, 58807: 34814, 58808: 34806, 58809: 34807, 58810: 34830, 58811: 34770, 58812: 34833, 58813: 34838, 58814: 34837, 58815: 34850, 58816: 34849, 58817: 34865, 58818: 34870, 58819: 34873, 58820: 34855, 58821: 34875, 58822: 34884, 58823: 34882, 58824: 34898, 58825: 34905, 58826: 34910, 58827: 34914, 58828: 34923, 58829: 34945, 58830: 34942, 58831: 34974, 58832: 34933, 58833: 34941, 58834: 34997, 58835: 34930, 58836: 34946, 58837: 34967, 58838: 34962, 58839: 34990, 58840: 34969, 58841: 34978, 58842: 34957, 58843: 34980, 58844: 34992, 58845: 35007, 58846: 34993, 58847: 35011, 58848: 35012, 58849: 35028, 58850: 35032, 58851: 35033, 58852: 35037, 58853: 35065, 58854: 35074, 58855: 35068, 58856: 35060, 58857: 35048, 58858: 35058, 58859: 35076, 58860: 35084, 58861: 35082, 58862: 35091, 58863: 35139, 58864: 35102, 58865: 35109, 58866: 35114, 58867: 35115, 58868: 35137, 58869: 35140, 58870: 35131, 58871: 35126, 58872: 35128, 58873: 35148, 58874: 35101, 58875: 35168, 58876: 35166, 58944: 35174, 58945: 35172, 58946: 35181, 58947: 35178, 58948: 35183, 58949: 35188, 58950: 35191, 58951: 35198, 58952: 35203, 58953: 35208, 58954: 35210, 58955: 35219, 58956: 35224, 58957: 35233, 58958: 35241, 58959: 35238, 58960: 35244, 58961: 35247, 58962: 35250, 58963: 35258, 58964: 35261, 58965: 35263, 58966: 35264, 58967: 35290, 58968: 35292, 58969: 35293, 58970: 35303, 58971: 35316, 58972: 35320, 58973: 35331, 58974: 35350, 58975: 35344, 58976: 35340, 58977: 35355, 58978: 35357, 58979: 35365, 58980: 35382, 58981: 35393, 58982: 35419, 58983: 35410, 58984: 35398, 58985: 35400, 58986: 35452, 58987: 35437, 58988: 35436, 58989: 35426, 58990: 35461, 58991: 35458, 58992: 35460, 58993: 35496, 58994: 35489, 58995: 35473, 58996: 35493, 58997: 35494, 58998: 35482, 58999: 35491, 59e3: 35524, 59001: 35533, 59002: 35522, 59003: 35546, 59004: 35563, 59005: 35571, 59006: 35559, 59008: 35556, 59009: 35569, 59010: 35604, 59011: 35552, 59012: 35554, 59013: 35575, 59014: 35550, 59015: 35547, 59016: 35596, 59017: 35591, 59018: 35610, 59019: 35553, 59020: 35606, 59021: 35600, 59022: 35607, 59023: 35616, 59024: 35635, 59025: 38827, 59026: 35622, 59027: 35627, 59028: 35646, 59029: 35624, 59030: 35649, 59031: 35660, 59032: 35663, 59033: 35662, 59034: 35657, 59035: 35670, 59036: 35675, 59037: 35674, 59038: 35691, 59039: 35679, 59040: 35692, 59041: 35695, 59042: 35700, 59043: 35709, 59044: 35712, 59045: 35724, 59046: 35726, 59047: 35730, 59048: 35731, 59049: 35734, 59050: 35737, 59051: 35738, 59052: 35898, 59053: 35905, 59054: 35903, 59055: 35912, 59056: 35916, 59057: 35918, 59058: 35920, 59059: 35925, 59060: 35938, 59061: 35948, 59062: 35960, 59063: 35962, 59064: 35970, 59065: 35977, 59066: 35973, 59067: 35978, 59068: 35981, 59069: 35982, 59070: 35988, 59071: 35964, 59072: 35992, 59073: 25117, 59074: 36013, 59075: 36010, 59076: 36029, 59077: 36018, 59078: 36019, 59079: 36014, 59080: 36022, 59081: 36040, 59082: 36033, 59083: 36068, 59084: 36067, 59085: 36058, 59086: 36093, 59087: 36090, 59088: 36091, 59089: 36100, 59090: 36101, 59091: 36106, 59092: 36103, 59093: 36111, 59094: 36109, 59095: 36112, 59096: 40782, 59097: 36115, 59098: 36045, 59099: 36116, 59100: 36118, 59101: 36199, 59102: 36205, 59103: 36209, 59104: 36211, 59105: 36225, 59106: 36249, 59107: 36290, 59108: 36286, 59109: 36282, 59110: 36303, 59111: 36314, 59112: 36310, 59113: 36300, 59114: 36315, 59115: 36299, 59116: 36330, 59117: 36331, 59118: 36319, 59119: 36323, 59120: 36348, 59121: 36360, 59122: 36361, 59123: 36351, 59124: 36381, 59125: 36382, 59126: 36368, 59127: 36383, 59128: 36418, 59129: 36405, 59130: 36400, 59131: 36404, 59132: 36426, 59200: 36423, 59201: 36425, 59202: 36428, 59203: 36432, 59204: 36424, 59205: 36441, 59206: 36452, 59207: 36448, 59208: 36394, 59209: 36451, 59210: 36437, 59211: 36470, 59212: 36466, 59213: 36476, 59214: 36481, 59215: 36487, 59216: 36485, 59217: 36484, 59218: 36491, 59219: 36490, 59220: 36499, 59221: 36497, 59222: 36500, 59223: 36505, 59224: 36522, 59225: 36513, 59226: 36524, 59227: 36528, 59228: 36550, 59229: 36529, 59230: 36542, 59231: 36549, 59232: 36552, 59233: 36555, 59234: 36571, 59235: 36579, 59236: 36604, 59237: 36603, 59238: 36587, 59239: 36606, 59240: 36618, 59241: 36613, 59242: 36629, 59243: 36626, 59244: 36633, 59245: 36627, 59246: 36636, 59247: 36639, 59248: 36635, 59249: 36620, 59250: 36646, 59251: 36659, 59252: 36667, 59253: 36665, 59254: 36677, 59255: 36674, 59256: 36670, 59257: 36684, 59258: 36681, 59259: 36678, 59260: 36686, 59261: 36695, 59262: 36700, 59264: 36706, 59265: 36707, 59266: 36708, 59267: 36764, 59268: 36767, 59269: 36771, 59270: 36781, 59271: 36783, 59272: 36791, 59273: 36826, 59274: 36837, 59275: 36834, 59276: 36842, 59277: 36847, 59278: 36999, 59279: 36852, 59280: 36869, 59281: 36857, 59282: 36858, 59283: 36881, 59284: 36885, 59285: 36897, 59286: 36877, 59287: 36894, 59288: 36886, 59289: 36875, 59290: 36903, 59291: 36918, 59292: 36917, 59293: 36921, 59294: 36856, 59295: 36943, 59296: 36944, 59297: 36945, 59298: 36946, 59299: 36878, 59300: 36937, 59301: 36926, 59302: 36950, 59303: 36952, 59304: 36958, 59305: 36968, 59306: 36975, 59307: 36982, 59308: 38568, 59309: 36978, 59310: 36994, 59311: 36989, 59312: 36993, 59313: 36992, 59314: 37002, 59315: 37001, 59316: 37007, 59317: 37032, 59318: 37039, 59319: 37041, 59320: 37045, 59321: 37090, 59322: 37092, 59323: 25160, 59324: 37083, 59325: 37122, 59326: 37138, 59327: 37145, 59328: 37170, 59329: 37168, 59330: 37194, 59331: 37206, 59332: 37208, 59333: 37219, 59334: 37221, 59335: 37225, 59336: 37235, 59337: 37234, 59338: 37259, 59339: 37257, 59340: 37250, 59341: 37282, 59342: 37291, 59343: 37295, 59344: 37290, 59345: 37301, 59346: 37300, 59347: 37306, 59348: 37312, 59349: 37313, 59350: 37321, 59351: 37323, 59352: 37328, 59353: 37334, 59354: 37343, 59355: 37345, 59356: 37339, 59357: 37372, 59358: 37365, 59359: 37366, 59360: 37406, 59361: 37375, 59362: 37396, 59363: 37420, 59364: 37397, 59365: 37393, 59366: 37470, 59367: 37463, 59368: 37445, 59369: 37449, 59370: 37476, 59371: 37448, 59372: 37525, 59373: 37439, 59374: 37451, 59375: 37456, 59376: 37532, 59377: 37526, 59378: 37523, 59379: 37531, 59380: 37466, 59381: 37583, 59382: 37561, 59383: 37559, 59384: 37609, 59385: 37647, 59386: 37626, 59387: 37700, 59388: 37678, 59456: 37657, 59457: 37666, 59458: 37658, 59459: 37667, 59460: 37690, 59461: 37685, 59462: 37691, 59463: 37724, 59464: 37728, 59465: 37756, 59466: 37742, 59467: 37718, 59468: 37808, 59469: 37804, 59470: 37805, 59471: 37780, 59472: 37817, 59473: 37846, 59474: 37847, 59475: 37864, 59476: 37861, 59477: 37848, 59478: 37827, 59479: 37853, 59480: 37840, 59481: 37832, 59482: 37860, 59483: 37914, 59484: 37908, 59485: 37907, 59486: 37891, 59487: 37895, 59488: 37904, 59489: 37942, 59490: 37931, 59491: 37941, 59492: 37921, 59493: 37946, 59494: 37953, 59495: 37970, 59496: 37956, 59497: 37979, 59498: 37984, 59499: 37986, 59500: 37982, 59501: 37994, 59502: 37417, 59503: 38e3, 59504: 38005, 59505: 38007, 59506: 38013, 59507: 37978, 59508: 38012, 59509: 38014, 59510: 38017, 59511: 38015, 59512: 38274, 59513: 38279, 59514: 38282, 59515: 38292, 59516: 38294, 59517: 38296, 59518: 38297, 59520: 38304, 59521: 38312, 59522: 38311, 59523: 38317, 59524: 38332, 59525: 38331, 59526: 38329, 59527: 38334, 59528: 38346, 59529: 28662, 59530: 38339, 59531: 38349, 59532: 38348, 59533: 38357, 59534: 38356, 59535: 38358, 59536: 38364, 59537: 38369, 59538: 38373, 59539: 38370, 59540: 38433, 59541: 38440, 59542: 38446, 59543: 38447, 59544: 38466, 59545: 38476, 59546: 38479, 59547: 38475, 59548: 38519, 59549: 38492, 59550: 38494, 59551: 38493, 59552: 38495, 59553: 38502, 59554: 38514, 59555: 38508, 59556: 38541, 59557: 38552, 59558: 38549, 59559: 38551, 59560: 38570, 59561: 38567, 59562: 38577, 59563: 38578, 59564: 38576, 59565: 38580, 59566: 38582, 59567: 38584, 59568: 38585, 59569: 38606, 59570: 38603, 59571: 38601, 59572: 38605, 59573: 35149, 59574: 38620, 59575: 38669, 59576: 38613, 59577: 38649, 59578: 38660, 59579: 38662, 59580: 38664, 59581: 38675, 59582: 38670, 59583: 38673, 59584: 38671, 59585: 38678, 59586: 38681, 59587: 38692, 59588: 38698, 59589: 38704, 59590: 38713, 59591: 38717, 59592: 38718, 59593: 38724, 59594: 38726, 59595: 38728, 59596: 38722, 59597: 38729, 59598: 38748, 59599: 38752, 59600: 38756, 59601: 38758, 59602: 38760, 59603: 21202, 59604: 38763, 59605: 38769, 59606: 38777, 59607: 38789, 59608: 38780, 59609: 38785, 59610: 38778, 59611: 38790, 59612: 38795, 59613: 38799, 59614: 38800, 59615: 38812, 59616: 38824, 59617: 38822, 59618: 38819, 59619: 38835, 59620: 38836, 59621: 38851, 59622: 38854, 59623: 38856, 59624: 38859, 59625: 38876, 59626: 38893, 59627: 40783, 59628: 38898, 59629: 31455, 59630: 38902, 59631: 38901, 59632: 38927, 59633: 38924, 59634: 38968, 59635: 38948, 59636: 38945, 59637: 38967, 59638: 38973, 59639: 38982, 59640: 38991, 59641: 38987, 59642: 39019, 59643: 39023, 59644: 39024, 59712: 39025, 59713: 39028, 59714: 39027, 59715: 39082, 59716: 39087, 59717: 39089, 59718: 39094, 59719: 39108, 59720: 39107, 59721: 39110, 59722: 39145, 59723: 39147, 59724: 39171, 59725: 39177, 59726: 39186, 59727: 39188, 59728: 39192, 59729: 39201, 59730: 39197, 59731: 39198, 59732: 39204, 59733: 39200, 59734: 39212, 59735: 39214, 59736: 39229, 59737: 39230, 59738: 39234, 59739: 39241, 59740: 39237, 59741: 39248, 59742: 39243, 59743: 39249, 59744: 39250, 59745: 39244, 59746: 39253, 59747: 39319, 59748: 39320, 59749: 39333, 59750: 39341, 59751: 39342, 59752: 39356, 59753: 39391, 59754: 39387, 59755: 39389, 59756: 39384, 59757: 39377, 59758: 39405, 59759: 39406, 59760: 39409, 59761: 39410, 59762: 39419, 59763: 39416, 59764: 39425, 59765: 39439, 59766: 39429, 59767: 39394, 59768: 39449, 59769: 39467, 59770: 39479, 59771: 39493, 59772: 39490, 59773: 39488, 59774: 39491, 59776: 39486, 59777: 39509, 59778: 39501, 59779: 39515, 59780: 39511, 59781: 39519, 59782: 39522, 59783: 39525, 59784: 39524, 59785: 39529, 59786: 39531, 59787: 39530, 59788: 39597, 59789: 39600, 59790: 39612, 59791: 39616, 59792: 39631, 59793: 39633, 59794: 39635, 59795: 39636, 59796: 39646, 59797: 39647, 59798: 39650, 59799: 39651, 59800: 39654, 59801: 39663, 59802: 39659, 59803: 39662, 59804: 39668, 59805: 39665, 59806: 39671, 59807: 39675, 59808: 39686, 59809: 39704, 59810: 39706, 59811: 39711, 59812: 39714, 59813: 39715, 59814: 39717, 59815: 39719, 59816: 39720, 59817: 39721, 59818: 39722, 59819: 39726, 59820: 39727, 59821: 39730, 59822: 39748, 59823: 39747, 59824: 39759, 59825: 39757, 59826: 39758, 59827: 39761, 59828: 39768, 59829: 39796, 59830: 39827, 59831: 39811, 59832: 39825, 59833: 39830, 59834: 39831, 59835: 39839, 59836: 39840, 59837: 39848, 59838: 39860, 59839: 39872, 59840: 39882, 59841: 39865, 59842: 39878, 59843: 39887, 59844: 39889, 59845: 39890, 59846: 39907, 59847: 39906, 59848: 39908, 59849: 39892, 59850: 39905, 59851: 39994, 59852: 39922, 59853: 39921, 59854: 39920, 59855: 39957, 59856: 39956, 59857: 39945, 59858: 39955, 59859: 39948, 59860: 39942, 59861: 39944, 59862: 39954, 59863: 39946, 59864: 39940, 59865: 39982, 59866: 39963, 59867: 39973, 59868: 39972, 59869: 39969, 59870: 39984, 59871: 40007, 59872: 39986, 59873: 40006, 59874: 39998, 59875: 40026, 59876: 40032, 59877: 40039, 59878: 40054, 59879: 40056, 59880: 40167, 59881: 40172, 59882: 40176, 59883: 40201, 59884: 40200, 59885: 40171, 59886: 40195, 59887: 40198, 59888: 40234, 59889: 40230, 59890: 40367, 59891: 40227, 59892: 40223, 59893: 40260, 59894: 40213, 59895: 40210, 59896: 40257, 59897: 40255, 59898: 40254, 59899: 40262, 59900: 40264, 59968: 40285, 59969: 40286, 59970: 40292, 59971: 40273, 59972: 40272, 59973: 40281, 59974: 40306, 59975: 40329, 59976: 40327, 59977: 40363, 59978: 40303, 59979: 40314, 59980: 40346, 59981: 40356, 59982: 40361, 59983: 40370, 59984: 40388, 59985: 40385, 59986: 40379, 59987: 40376, 59988: 40378, 59989: 40390, 59990: 40399, 59991: 40386, 59992: 40409, 59993: 40403, 59994: 40440, 59995: 40422, 59996: 40429, 59997: 40431, 59998: 40445, 59999: 40474, 6e4: 40475, 60001: 40478, 60002: 40565, 60003: 40569, 60004: 40573, 60005: 40577, 60006: 40584, 60007: 40587, 60008: 40588, 60009: 40594, 60010: 40597, 60011: 40593, 60012: 40605, 60013: 40613, 60014: 40617, 60015: 40632, 60016: 40618, 60017: 40621, 60018: 38753, 60019: 40652, 60020: 40654, 60021: 40655, 60022: 40656, 60023: 40660, 60024: 40668, 60025: 40670, 60026: 40669, 60027: 40672, 60028: 40677, 60029: 40680, 60030: 40687, 60032: 40692, 60033: 40694, 60034: 40695, 60035: 40697, 60036: 40699, 60037: 40700, 60038: 40701, 60039: 40711, 60040: 40712, 60041: 30391, 60042: 40725, 60043: 40737, 60044: 40748, 60045: 40766, 60046: 40778, 60047: 40786, 60048: 40788, 60049: 40803, 60050: 40799, 60051: 40800, 60052: 40801, 60053: 40806, 60054: 40807, 60055: 40812, 60056: 40810, 60057: 40823, 60058: 40818, 60059: 40822, 60060: 40853, 60061: 40860, 60062: 40864, 60063: 22575, 60064: 27079, 60065: 36953, 60066: 29796, 60067: 20956, 60068: 29081, 60736: 32394, 60737: 35100, 60738: 37704, 60739: 37512, 60740: 34012, 60741: 20425, 60742: 28859, 60743: 26161, 60744: 26824, 60745: 37625, 60746: 26363, 60747: 24389, 60748: 20008, 60749: 20193, 60750: 20220, 60751: 20224, 60752: 20227, 60753: 20281, 60754: 20310, 60755: 20370, 60756: 20362, 60757: 20378, 60758: 20372, 60759: 20429, 60760: 20544, 60761: 20514, 60762: 20479, 60763: 20510, 60764: 20550, 60765: 20592, 60766: 20546, 60767: 20628, 60768: 20724, 60769: 20696, 60770: 20810, 60771: 20836, 60772: 20893, 60773: 20926, 60774: 20972, 60775: 21013, 60776: 21148, 60777: 21158, 60778: 21184, 60779: 21211, 60780: 21248, 60781: 21255, 60782: 21284, 60783: 21362, 60784: 21395, 60785: 21426, 60786: 21469, 60787: 64014, 60788: 21660, 60789: 21642, 60790: 21673, 60791: 21759, 60792: 21894, 60793: 22361, 60794: 22373, 60795: 22444, 60796: 22472, 60797: 22471, 60798: 64015, 60800: 64016, 60801: 22686, 60802: 22706, 60803: 22795, 60804: 22867, 60805: 22875, 60806: 22877, 60807: 22883, 60808: 22948, 60809: 22970, 60810: 23382, 60811: 23488, 60812: 29999, 60813: 23512, 60814: 23532, 60815: 23582, 60816: 23718, 60817: 23738, 60818: 23797, 60819: 23847, 60820: 23891, 60821: 64017, 60822: 23874, 60823: 23917, 60824: 23992, 60825: 23993, 60826: 24016, 60827: 24353, 60828: 24372, 60829: 24423, 60830: 24503, 60831: 24542, 60832: 24669, 60833: 24709, 60834: 24714, 60835: 24798, 60836: 24789, 60837: 24864, 60838: 24818, 60839: 24849, 60840: 24887, 60841: 24880, 60842: 24984, 60843: 25107, 60844: 25254, 60845: 25589, 60846: 25696, 60847: 25757, 60848: 25806, 60849: 25934, 60850: 26112, 60851: 26133, 60852: 26171, 60853: 26121, 60854: 26158, 60855: 26142, 60856: 26148, 60857: 26213, 60858: 26199, 60859: 26201, 60860: 64018, 60861: 26227, 60862: 26265, 60863: 26272, 60864: 26290, 60865: 26303, 60866: 26362, 60867: 26382, 60868: 63785, 60869: 26470, 60870: 26555, 60871: 26706, 60872: 26560, 60873: 26625, 60874: 26692, 60875: 26831, 60876: 64019, 60877: 26984, 60878: 64020, 60879: 27032, 60880: 27106, 60881: 27184, 60882: 27243, 60883: 27206, 60884: 27251, 60885: 27262, 60886: 27362, 60887: 27364, 60888: 27606, 60889: 27711, 60890: 27740, 60891: 27782, 60892: 27759, 60893: 27866, 60894: 27908, 60895: 28039, 60896: 28015, 60897: 28054, 60898: 28076, 60899: 28111, 60900: 28152, 60901: 28146, 60902: 28156, 60903: 28217, 60904: 28252, 60905: 28199, 60906: 28220, 60907: 28351, 60908: 28552, 60909: 28597, 60910: 28661, 60911: 28677, 60912: 28679, 60913: 28712, 60914: 28805, 60915: 28843, 60916: 28943, 60917: 28932, 60918: 29020, 60919: 28998, 60920: 28999, 60921: 64021, 60922: 29121, 60923: 29182, 60924: 29361, 60992: 29374, 60993: 29476, 60994: 64022, 60995: 29559, 60996: 29629, 60997: 29641, 60998: 29654, 60999: 29667, 61e3: 29650, 61001: 29703, 61002: 29685, 61003: 29734, 61004: 29738, 61005: 29737, 61006: 29742, 61007: 29794, 61008: 29833, 61009: 29855, 61010: 29953, 61011: 30063, 61012: 30338, 61013: 30364, 61014: 30366, 61015: 30363, 61016: 30374, 61017: 64023, 61018: 30534, 61019: 21167, 61020: 30753, 61021: 30798, 61022: 30820, 61023: 30842, 61024: 31024, 61025: 64024, 61026: 64025, 61027: 64026, 61028: 31124, 61029: 64027, 61030: 31131, 61031: 31441, 61032: 31463, 61033: 64028, 61034: 31467, 61035: 31646, 61036: 64029, 61037: 32072, 61038: 32092, 61039: 32183, 61040: 32160, 61041: 32214, 61042: 32338, 61043: 32583, 61044: 32673, 61045: 64030, 61046: 33537, 61047: 33634, 61048: 33663, 61049: 33735, 61050: 33782, 61051: 33864, 61052: 33972, 61053: 34131, 61054: 34137, 61056: 34155, 61057: 64031, 61058: 34224, 61059: 64032, 61060: 64033, 61061: 34823, 61062: 35061, 61063: 35346, 61064: 35383, 61065: 35449, 61066: 35495, 61067: 35518, 61068: 35551, 61069: 64034, 61070: 35574, 61071: 35667, 61072: 35711, 61073: 36080, 61074: 36084, 61075: 36114, 61076: 36214, 61077: 64035, 61078: 36559, 61079: 64036, 61080: 64037, 61081: 36967, 61082: 37086, 61083: 64038, 61084: 37141, 61085: 37159, 61086: 37338, 61087: 37335, 61088: 37342, 61089: 37357, 61090: 37358, 61091: 37348, 61092: 37349, 61093: 37382, 61094: 37392, 61095: 37386, 61096: 37434, 61097: 37440, 61098: 37436, 61099: 37454, 61100: 37465, 61101: 37457, 61102: 37433, 61103: 37479, 61104: 37543, 61105: 37495, 61106: 37496, 61107: 37607, 61108: 37591, 61109: 37593, 61110: 37584, 61111: 64039, 61112: 37589, 61113: 37600, 61114: 37587, 61115: 37669, 61116: 37665, 61117: 37627, 61118: 64040, 61119: 37662, 61120: 37631, 61121: 37661, 61122: 37634, 61123: 37744, 61124: 37719, 61125: 37796, 61126: 37830, 61127: 37854, 61128: 37880, 61129: 37937, 61130: 37957, 61131: 37960, 61132: 38290, 61133: 63964, 61134: 64041, 61135: 38557, 61136: 38575, 61137: 38707, 61138: 38715, 61139: 38723, 61140: 38733, 61141: 38735, 61142: 38737, 61143: 38741, 61144: 38999, 61145: 39013, 61146: 64042, 61147: 64043, 61148: 39207, 61149: 64044, 61150: 39326, 61151: 39502, 61152: 39641, 61153: 39644, 61154: 39797, 61155: 39794, 61156: 39823, 61157: 39857, 61158: 39867, 61159: 39936, 61160: 40304, 61161: 40299, 61162: 64045, 61163: 40473, 61164: 40657, 61167: 8560, 61168: 8561, 61169: 8562, 61170: 8563, 61171: 8564, 61172: 8565, 61173: 8566, 61174: 8567, 61175: 8568, 61176: 8569, 61177: 65506, 61178: 65508, 61179: 65287, 61180: 65282, 61504: 57344, 61505: 57345, 61506: 57346, 61507: 57347, 61508: 57348, 61509: 57349, 61510: 57350, 61511: 57351, 61512: 57352, 61513: 57353, 61514: 57354, 61515: 57355, 61516: 57356, 61517: 57357, 61518: 57358, 61519: 57359, 61520: 57360, 61521: 57361, 61522: 57362, 61523: 57363, 61524: 57364, 61525: 57365, 61526: 57366, 61527: 57367, 61528: 57368, 61529: 57369, 61530: 57370, 61531: 57371, 61532: 57372, 61533: 57373, 61534: 57374, 61535: 57375, 61536: 57376, 61537: 57377, 61538: 57378, 61539: 57379, 61540: 57380, 61541: 57381, 61542: 57382, 61543: 57383, 61544: 57384, 61545: 57385, 61546: 57386, 61547: 57387, 61548: 57388, 61549: 57389, 61550: 57390, 61551: 57391, 61552: 57392, 61553: 57393, 61554: 57394, 61555: 57395, 61556: 57396, 61557: 57397, 61558: 57398, 61559: 57399, 61560: 57400, 61561: 57401, 61562: 57402, 61563: 57403, 61564: 57404, 61565: 57405, 61566: 57406, 61568: 57407, 61569: 57408, 61570: 57409, 61571: 57410, 61572: 57411, 61573: 57412, 61574: 57413, 61575: 57414, 61576: 57415, 61577: 57416, 61578: 57417, 61579: 57418, 61580: 57419, 61581: 57420, 61582: 57421, 61583: 57422, 61584: 57423, 61585: 57424, 61586: 57425, 61587: 57426, 61588: 57427, 61589: 57428, 61590: 57429, 61591: 57430, 61592: 57431, 61593: 57432, 61594: 57433, 61595: 57434, 61596: 57435, 61597: 57436, 61598: 57437, 61599: 57438, 61600: 57439, 61601: 57440, 61602: 57441, 61603: 57442, 61604: 57443, 61605: 57444, 61606: 57445, 61607: 57446, 61608: 57447, 61609: 57448, 61610: 57449, 61611: 57450, 61612: 57451, 61613: 57452, 61614: 57453, 61615: 57454, 61616: 57455, 61617: 57456, 61618: 57457, 61619: 57458, 61620: 57459, 61621: 57460, 61622: 57461, 61623: 57462, 61624: 57463, 61625: 57464, 61626: 57465, 61627: 57466, 61628: 57467, 61629: 57468, 61630: 57469, 61631: 57470, 61632: 57471, 61633: 57472, 61634: 57473, 61635: 57474, 61636: 57475, 61637: 57476, 61638: 57477, 61639: 57478, 61640: 57479, 61641: 57480, 61642: 57481, 61643: 57482, 61644: 57483, 61645: 57484, 61646: 57485, 61647: 57486, 61648: 57487, 61649: 57488, 61650: 57489, 61651: 57490, 61652: 57491, 61653: 57492, 61654: 57493, 61655: 57494, 61656: 57495, 61657: 57496, 61658: 57497, 61659: 57498, 61660: 57499, 61661: 57500, 61662: 57501, 61663: 57502, 61664: 57503, 61665: 57504, 61666: 57505, 61667: 57506, 61668: 57507, 61669: 57508, 61670: 57509, 61671: 57510, 61672: 57511, 61673: 57512, 61674: 57513, 61675: 57514, 61676: 57515, 61677: 57516, 61678: 57517, 61679: 57518, 61680: 57519, 61681: 57520, 61682: 57521, 61683: 57522, 61684: 57523, 61685: 57524, 61686: 57525, 61687: 57526, 61688: 57527, 61689: 57528, 61690: 57529, 61691: 57530, 61692: 57531, 61760: 57532, 61761: 57533, 61762: 57534, 61763: 57535, 61764: 57536, 61765: 57537, 61766: 57538, 61767: 57539, 61768: 57540, 61769: 57541, 61770: 57542, 61771: 57543, 61772: 57544, 61773: 57545, 61774: 57546, 61775: 57547, 61776: 57548, 61777: 57549, 61778: 57550, 61779: 57551, 61780: 57552, 61781: 57553, 61782: 57554, 61783: 57555, 61784: 57556, 61785: 57557, 61786: 57558, 61787: 57559, 61788: 57560, 61789: 57561, 61790: 57562, 61791: 57563, 61792: 57564, 61793: 57565, 61794: 57566, 61795: 57567, 61796: 57568, 61797: 57569, 61798: 57570, 61799: 57571, 61800: 57572, 61801: 57573, 61802: 57574, 61803: 57575, 61804: 57576, 61805: 57577, 61806: 57578, 61807: 57579, 61808: 57580, 61809: 57581, 61810: 57582, 61811: 57583, 61812: 57584, 61813: 57585, 61814: 57586, 61815: 57587, 61816: 57588, 61817: 57589, 61818: 57590, 61819: 57591, 61820: 57592, 61821: 57593, 61822: 57594, 61824: 57595, 61825: 57596, 61826: 57597, 61827: 57598, 61828: 57599, 61829: 57600, 61830: 57601, 61831: 57602, 61832: 57603, 61833: 57604, 61834: 57605, 61835: 57606, 61836: 57607, 61837: 57608, 61838: 57609, 61839: 57610, 61840: 57611, 61841: 57612, 61842: 57613, 61843: 57614, 61844: 57615, 61845: 57616, 61846: 57617, 61847: 57618, 61848: 57619, 61849: 57620, 61850: 57621, 61851: 57622, 61852: 57623, 61853: 57624, 61854: 57625, 61855: 57626, 61856: 57627, 61857: 57628, 61858: 57629, 61859: 57630, 61860: 57631, 61861: 57632, 61862: 57633, 61863: 57634, 61864: 57635, 61865: 57636, 61866: 57637, 61867: 57638, 61868: 57639, 61869: 57640, 61870: 57641, 61871: 57642, 61872: 57643, 61873: 57644, 61874: 57645, 61875: 57646, 61876: 57647, 61877: 57648, 61878: 57649, 61879: 57650, 61880: 57651, 61881: 57652, 61882: 57653, 61883: 57654, 61884: 57655, 61885: 57656, 61886: 57657, 61887: 57658, 61888: 57659, 61889: 57660, 61890: 57661, 61891: 57662, 61892: 57663, 61893: 57664, 61894: 57665, 61895: 57666, 61896: 57667, 61897: 57668, 61898: 57669, 61899: 57670, 61900: 57671, 61901: 57672, 61902: 57673, 61903: 57674, 61904: 57675, 61905: 57676, 61906: 57677, 61907: 57678, 61908: 57679, 61909: 57680, 61910: 57681, 61911: 57682, 61912: 57683, 61913: 57684, 61914: 57685, 61915: 57686, 61916: 57687, 61917: 57688, 61918: 57689, 61919: 57690, 61920: 57691, 61921: 57692, 61922: 57693, 61923: 57694, 61924: 57695, 61925: 57696, 61926: 57697, 61927: 57698, 61928: 57699, 61929: 57700, 61930: 57701, 61931: 57702, 61932: 57703, 61933: 57704, 61934: 57705, 61935: 57706, 61936: 57707, 61937: 57708, 61938: 57709, 61939: 57710, 61940: 57711, 61941: 57712, 61942: 57713, 61943: 57714, 61944: 57715, 61945: 57716, 61946: 57717, 61947: 57718, 61948: 57719, 62016: 57720, 62017: 57721, 62018: 57722, 62019: 57723, 62020: 57724, 62021: 57725, 62022: 57726, 62023: 57727, 62024: 57728, 62025: 57729, 62026: 57730, 62027: 57731, 62028: 57732, 62029: 57733, 62030: 57734, 62031: 57735, 62032: 57736, 62033: 57737, 62034: 57738, 62035: 57739, 62036: 57740, 62037: 57741, 62038: 57742, 62039: 57743, 62040: 57744, 62041: 57745, 62042: 57746, 62043: 57747, 62044: 57748, 62045: 57749, 62046: 57750, 62047: 57751, 62048: 57752, 62049: 57753, 62050: 57754, 62051: 57755, 62052: 57756, 62053: 57757, 62054: 57758, 62055: 57759, 62056: 57760, 62057: 57761, 62058: 57762, 62059: 57763, 62060: 57764, 62061: 57765, 62062: 57766, 62063: 57767, 62064: 57768, 62065: 57769, 62066: 57770, 62067: 57771, 62068: 57772, 62069: 57773, 62070: 57774, 62071: 57775, 62072: 57776, 62073: 57777, 62074: 57778, 62075: 57779, 62076: 57780, 62077: 57781, 62078: 57782, 62080: 57783, 62081: 57784, 62082: 57785, 62083: 57786, 62084: 57787, 62085: 57788, 62086: 57789, 62087: 57790, 62088: 57791, 62089: 57792, 62090: 57793, 62091: 57794, 62092: 57795, 62093: 57796, 62094: 57797, 62095: 57798, 62096: 57799, 62097: 57800, 62098: 57801, 62099: 57802, 62100: 57803, 62101: 57804, 62102: 57805, 62103: 57806, 62104: 57807, 62105: 57808, 62106: 57809, 62107: 57810, 62108: 57811, 62109: 57812, 62110: 57813, 62111: 57814, 62112: 57815, 62113: 57816, 62114: 57817, 62115: 57818, 62116: 57819, 62117: 57820, 62118: 57821, 62119: 57822, 62120: 57823, 62121: 57824, 62122: 57825, 62123: 57826, 62124: 57827, 62125: 57828, 62126: 57829, 62127: 57830, 62128: 57831, 62129: 57832, 62130: 57833, 62131: 57834, 62132: 57835, 62133: 57836, 62134: 57837, 62135: 57838, 62136: 57839, 62137: 57840, 62138: 57841, 62139: 57842, 62140: 57843, 62141: 57844, 62142: 57845, 62143: 57846, 62144: 57847, 62145: 57848, 62146: 57849, 62147: 57850, 62148: 57851, 62149: 57852, 62150: 57853, 62151: 57854, 62152: 57855, 62153: 57856, 62154: 57857, 62155: 57858, 62156: 57859, 62157: 57860, 62158: 57861, 62159: 57862, 62160: 57863, 62161: 57864, 62162: 57865, 62163: 57866, 62164: 57867, 62165: 57868, 62166: 57869, 62167: 57870, 62168: 57871, 62169: 57872, 62170: 57873, 62171: 57874, 62172: 57875, 62173: 57876, 62174: 57877, 62175: 57878, 62176: 57879, 62177: 57880, 62178: 57881, 62179: 57882, 62180: 57883, 62181: 57884, 62182: 57885, 62183: 57886, 62184: 57887, 62185: 57888, 62186: 57889, 62187: 57890, 62188: 57891, 62189: 57892, 62190: 57893, 62191: 57894, 62192: 57895, 62193: 57896, 62194: 57897, 62195: 57898, 62196: 57899, 62197: 57900, 62198: 57901, 62199: 57902, 62200: 57903, 62201: 57904, 62202: 57905, 62203: 57906, 62204: 57907, 62272: 57908, 62273: 57909, 62274: 57910, 62275: 57911, 62276: 57912, 62277: 57913, 62278: 57914, 62279: 57915, 62280: 57916, 62281: 57917, 62282: 57918, 62283: 57919, 62284: 57920, 62285: 57921, 62286: 57922, 62287: 57923, 62288: 57924, 62289: 57925, 62290: 57926, 62291: 57927, 62292: 57928, 62293: 57929, 62294: 57930, 62295: 57931, 62296: 57932, 62297: 57933, 62298: 57934, 62299: 57935, 62300: 57936, 62301: 57937, 62302: 57938, 62303: 57939, 62304: 57940, 62305: 57941, 62306: 57942, 62307: 57943, 62308: 57944, 62309: 57945, 62310: 57946, 62311: 57947, 62312: 57948, 62313: 57949, 62314: 57950, 62315: 57951, 62316: 57952, 62317: 57953, 62318: 57954, 62319: 57955, 62320: 57956, 62321: 57957, 62322: 57958, 62323: 57959, 62324: 57960, 62325: 57961, 62326: 57962, 62327: 57963, 62328: 57964, 62329: 57965, 62330: 57966, 62331: 57967, 62332: 57968, 62333: 57969, 62334: 57970, 62336: 57971, 62337: 57972, 62338: 57973, 62339: 57974, 62340: 57975, 62341: 57976, 62342: 57977, 62343: 57978, 62344: 57979, 62345: 57980, 62346: 57981, 62347: 57982, 62348: 57983, 62349: 57984, 62350: 57985, 62351: 57986, 62352: 57987, 62353: 57988, 62354: 57989, 62355: 57990, 62356: 57991, 62357: 57992, 62358: 57993, 62359: 57994, 62360: 57995, 62361: 57996, 62362: 57997, 62363: 57998, 62364: 57999, 62365: 58e3, 62366: 58001, 62367: 58002, 62368: 58003, 62369: 58004, 62370: 58005, 62371: 58006, 62372: 58007, 62373: 58008, 62374: 58009, 62375: 58010, 62376: 58011, 62377: 58012, 62378: 58013, 62379: 58014, 62380: 58015, 62381: 58016, 62382: 58017, 62383: 58018, 62384: 58019, 62385: 58020, 62386: 58021, 62387: 58022, 62388: 58023, 62389: 58024, 62390: 58025, 62391: 58026, 62392: 58027, 62393: 58028, 62394: 58029, 62395: 58030, 62396: 58031, 62397: 58032, 62398: 58033, 62399: 58034, 62400: 58035, 62401: 58036, 62402: 58037, 62403: 58038, 62404: 58039, 62405: 58040, 62406: 58041, 62407: 58042, 62408: 58043, 62409: 58044, 62410: 58045, 62411: 58046, 62412: 58047, 62413: 58048, 62414: 58049, 62415: 58050, 62416: 58051, 62417: 58052, 62418: 58053, 62419: 58054, 62420: 58055, 62421: 58056, 62422: 58057, 62423: 58058, 62424: 58059, 62425: 58060, 62426: 58061, 62427: 58062, 62428: 58063, 62429: 58064, 62430: 58065, 62431: 58066, 62432: 58067, 62433: 58068, 62434: 58069, 62435: 58070, 62436: 58071, 62437: 58072, 62438: 58073, 62439: 58074, 62440: 58075, 62441: 58076, 62442: 58077, 62443: 58078, 62444: 58079, 62445: 58080, 62446: 58081, 62447: 58082, 62448: 58083, 62449: 58084, 62450: 58085, 62451: 58086, 62452: 58087, 62453: 58088, 62454: 58089, 62455: 58090, 62456: 58091, 62457: 58092, 62458: 58093, 62459: 58094, 62460: 58095, 62528: 58096, 62529: 58097, 62530: 58098, 62531: 58099, 62532: 58100, 62533: 58101, 62534: 58102, 62535: 58103, 62536: 58104, 62537: 58105, 62538: 58106, 62539: 58107, 62540: 58108, 62541: 58109, 62542: 58110, 62543: 58111, 62544: 58112, 62545: 58113, 62546: 58114, 62547: 58115, 62548: 58116, 62549: 58117, 62550: 58118, 62551: 58119, 62552: 58120, 62553: 58121, 62554: 58122, 62555: 58123, 62556: 58124, 62557: 58125, 62558: 58126, 62559: 58127, 62560: 58128, 62561: 58129, 62562: 58130, 62563: 58131, 62564: 58132, 62565: 58133, 62566: 58134, 62567: 58135, 62568: 58136, 62569: 58137, 62570: 58138, 62571: 58139, 62572: 58140, 62573: 58141, 62574: 58142, 62575: 58143, 62576: 58144, 62577: 58145, 62578: 58146, 62579: 58147, 62580: 58148, 62581: 58149, 62582: 58150, 62583: 58151, 62584: 58152, 62585: 58153, 62586: 58154, 62587: 58155, 62588: 58156, 62589: 58157, 62590: 58158, 62592: 58159, 62593: 58160, 62594: 58161, 62595: 58162, 62596: 58163, 62597: 58164, 62598: 58165, 62599: 58166, 62600: 58167, 62601: 58168, 62602: 58169, 62603: 58170, 62604: 58171, 62605: 58172, 62606: 58173, 62607: 58174, 62608: 58175, 62609: 58176, 62610: 58177, 62611: 58178, 62612: 58179, 62613: 58180, 62614: 58181, 62615: 58182, 62616: 58183, 62617: 58184, 62618: 58185, 62619: 58186, 62620: 58187, 62621: 58188, 62622: 58189, 62623: 58190, 62624: 58191, 62625: 58192, 62626: 58193, 62627: 58194, 62628: 58195, 62629: 58196, 62630: 58197, 62631: 58198, 62632: 58199, 62633: 58200, 62634: 58201, 62635: 58202, 62636: 58203, 62637: 58204, 62638: 58205, 62639: 58206, 62640: 58207, 62641: 58208, 62642: 58209, 62643: 58210, 62644: 58211, 62645: 58212, 62646: 58213, 62647: 58214, 62648: 58215, 62649: 58216, 62650: 58217, 62651: 58218, 62652: 58219, 62653: 58220, 62654: 58221, 62655: 58222, 62656: 58223, 62657: 58224, 62658: 58225, 62659: 58226, 62660: 58227, 62661: 58228, 62662: 58229, 62663: 58230, 62664: 58231, 62665: 58232, 62666: 58233, 62667: 58234, 62668: 58235, 62669: 58236, 62670: 58237, 62671: 58238, 62672: 58239, 62673: 58240, 62674: 58241, 62675: 58242, 62676: 58243, 62677: 58244, 62678: 58245, 62679: 58246, 62680: 58247, 62681: 58248, 62682: 58249, 62683: 58250, 62684: 58251, 62685: 58252, 62686: 58253, 62687: 58254, 62688: 58255, 62689: 58256, 62690: 58257, 62691: 58258, 62692: 58259, 62693: 58260, 62694: 58261, 62695: 58262, 62696: 58263, 62697: 58264, 62698: 58265, 62699: 58266, 62700: 58267, 62701: 58268, 62702: 58269, 62703: 58270, 62704: 58271, 62705: 58272, 62706: 58273, 62707: 58274, 62708: 58275, 62709: 58276, 62710: 58277, 62711: 58278, 62712: 58279, 62713: 58280, 62714: 58281, 62715: 58282, 62716: 58283, 62784: 58284, 62785: 58285, 62786: 58286, 62787: 58287, 62788: 58288, 62789: 58289, 62790: 58290, 62791: 58291, 62792: 58292, 62793: 58293, 62794: 58294, 62795: 58295, 62796: 58296, 62797: 58297, 62798: 58298, 62799: 58299, 62800: 58300, 62801: 58301, 62802: 58302, 62803: 58303, 62804: 58304, 62805: 58305, 62806: 58306, 62807: 58307, 62808: 58308, 62809: 58309, 62810: 58310, 62811: 58311, 62812: 58312, 62813: 58313, 62814: 58314, 62815: 58315, 62816: 58316, 62817: 58317, 62818: 58318, 62819: 58319, 62820: 58320, 62821: 58321, 62822: 58322, 62823: 58323, 62824: 58324, 62825: 58325, 62826: 58326, 62827: 58327, 62828: 58328, 62829: 58329, 62830: 58330, 62831: 58331, 62832: 58332, 62833: 58333, 62834: 58334, 62835: 58335, 62836: 58336, 62837: 58337, 62838: 58338, 62839: 58339, 62840: 58340, 62841: 58341, 62842: 58342, 62843: 58343, 62844: 58344, 62845: 58345, 62846: 58346, 62848: 58347, 62849: 58348, 62850: 58349, 62851: 58350, 62852: 58351, 62853: 58352, 62854: 58353, 62855: 58354, 62856: 58355, 62857: 58356, 62858: 58357, 62859: 58358, 62860: 58359, 62861: 58360, 62862: 58361, 62863: 58362, 62864: 58363, 62865: 58364, 62866: 58365, 62867: 58366, 62868: 58367, 62869: 58368, 62870: 58369, 62871: 58370, 62872: 58371, 62873: 58372, 62874: 58373, 62875: 58374, 62876: 58375, 62877: 58376, 62878: 58377, 62879: 58378, 62880: 58379, 62881: 58380, 62882: 58381, 62883: 58382, 62884: 58383, 62885: 58384, 62886: 58385, 62887: 58386, 62888: 58387, 62889: 58388, 62890: 58389, 62891: 58390, 62892: 58391, 62893: 58392, 62894: 58393, 62895: 58394, 62896: 58395, 62897: 58396, 62898: 58397, 62899: 58398, 62900: 58399, 62901: 58400, 62902: 58401, 62903: 58402, 62904: 58403, 62905: 58404, 62906: 58405, 62907: 58406, 62908: 58407, 62909: 58408, 62910: 58409, 62911: 58410, 62912: 58411, 62913: 58412, 62914: 58413, 62915: 58414, 62916: 58415, 62917: 58416, 62918: 58417, 62919: 58418, 62920: 58419, 62921: 58420, 62922: 58421, 62923: 58422, 62924: 58423, 62925: 58424, 62926: 58425, 62927: 58426, 62928: 58427, 62929: 58428, 62930: 58429, 62931: 58430, 62932: 58431, 62933: 58432, 62934: 58433, 62935: 58434, 62936: 58435, 62937: 58436, 62938: 58437, 62939: 58438, 62940: 58439, 62941: 58440, 62942: 58441, 62943: 58442, 62944: 58443, 62945: 58444, 62946: 58445, 62947: 58446, 62948: 58447, 62949: 58448, 62950: 58449, 62951: 58450, 62952: 58451, 62953: 58452, 62954: 58453, 62955: 58454, 62956: 58455, 62957: 58456, 62958: 58457, 62959: 58458, 62960: 58459, 62961: 58460, 62962: 58461, 62963: 58462, 62964: 58463, 62965: 58464, 62966: 58465, 62967: 58466, 62968: 58467, 62969: 58468, 62970: 58469, 62971: 58470, 62972: 58471, 63040: 58472, 63041: 58473, 63042: 58474, 63043: 58475, 63044: 58476, 63045: 58477, 63046: 58478, 63047: 58479, 63048: 58480, 63049: 58481, 63050: 58482, 63051: 58483, 63052: 58484, 63053: 58485, 63054: 58486, 63055: 58487, 63056: 58488, 63057: 58489, 63058: 58490, 63059: 58491, 63060: 58492, 63061: 58493, 63062: 58494, 63063: 58495, 63064: 58496, 63065: 58497, 63066: 58498, 63067: 58499, 63068: 58500, 63069: 58501, 63070: 58502, 63071: 58503, 63072: 58504, 63073: 58505, 63074: 58506, 63075: 58507, 63076: 58508, 63077: 58509, 63078: 58510, 63079: 58511, 63080: 58512, 63081: 58513, 63082: 58514, 63083: 58515, 63084: 58516, 63085: 58517, 63086: 58518, 63087: 58519, 63088: 58520, 63089: 58521, 63090: 58522, 63091: 58523, 63092: 58524, 63093: 58525, 63094: 58526, 63095: 58527, 63096: 58528, 63097: 58529, 63098: 58530, 63099: 58531, 63100: 58532, 63101: 58533, 63102: 58534, 63104: 58535, 63105: 58536, 63106: 58537, 63107: 58538, 63108: 58539, 63109: 58540, 63110: 58541, 63111: 58542, 63112: 58543, 63113: 58544, 63114: 58545, 63115: 58546, 63116: 58547, 63117: 58548, 63118: 58549, 63119: 58550, 63120: 58551, 63121: 58552, 63122: 58553, 63123: 58554, 63124: 58555, 63125: 58556, 63126: 58557, 63127: 58558, 63128: 58559, 63129: 58560, 63130: 58561, 63131: 58562, 63132: 58563, 63133: 58564, 63134: 58565, 63135: 58566, 63136: 58567, 63137: 58568, 63138: 58569, 63139: 58570, 63140: 58571, 63141: 58572, 63142: 58573, 63143: 58574, 63144: 58575, 63145: 58576, 63146: 58577, 63147: 58578, 63148: 58579, 63149: 58580, 63150: 58581, 63151: 58582, 63152: 58583, 63153: 58584, 63154: 58585, 63155: 58586, 63156: 58587, 63157: 58588, 63158: 58589, 63159: 58590, 63160: 58591, 63161: 58592, 63162: 58593, 63163: 58594, 63164: 58595, 63165: 58596, 63166: 58597, 63167: 58598, 63168: 58599, 63169: 58600, 63170: 58601, 63171: 58602, 63172: 58603, 63173: 58604, 63174: 58605, 63175: 58606, 63176: 58607, 63177: 58608, 63178: 58609, 63179: 58610, 63180: 58611, 63181: 58612, 63182: 58613, 63183: 58614, 63184: 58615, 63185: 58616, 63186: 58617, 63187: 58618, 63188: 58619, 63189: 58620, 63190: 58621, 63191: 58622, 63192: 58623, 63193: 58624, 63194: 58625, 63195: 58626, 63196: 58627, 63197: 58628, 63198: 58629, 63199: 58630, 63200: 58631, 63201: 58632, 63202: 58633, 63203: 58634, 63204: 58635, 63205: 58636, 63206: 58637, 63207: 58638, 63208: 58639, 63209: 58640, 63210: 58641, 63211: 58642, 63212: 58643, 63213: 58644, 63214: 58645, 63215: 58646, 63216: 58647, 63217: 58648, 63218: 58649, 63219: 58650, 63220: 58651, 63221: 58652, 63222: 58653, 63223: 58654, 63224: 58655, 63225: 58656, 63226: 58657, 63227: 58658, 63228: 58659, 63296: 58660, 63297: 58661, 63298: 58662, 63299: 58663, 63300: 58664, 63301: 58665, 63302: 58666, 63303: 58667, 63304: 58668, 63305: 58669, 63306: 58670, 63307: 58671, 63308: 58672, 63309: 58673, 63310: 58674, 63311: 58675, 63312: 58676, 63313: 58677, 63314: 58678, 63315: 58679, 63316: 58680, 63317: 58681, 63318: 58682, 63319: 58683, 63320: 58684, 63321: 58685, 63322: 58686, 63323: 58687, 63324: 58688, 63325: 58689, 63326: 58690, 63327: 58691, 63328: 58692, 63329: 58693, 63330: 58694, 63331: 58695, 63332: 58696, 63333: 58697, 63334: 58698, 63335: 58699, 63336: 58700, 63337: 58701, 63338: 58702, 63339: 58703, 63340: 58704, 63341: 58705, 63342: 58706, 63343: 58707, 63344: 58708, 63345: 58709, 63346: 58710, 63347: 58711, 63348: 58712, 63349: 58713, 63350: 58714, 63351: 58715, 63352: 58716, 63353: 58717, 63354: 58718, 63355: 58719, 63356: 58720, 63357: 58721, 63358: 58722, 63360: 58723, 63361: 58724, 63362: 58725, 63363: 58726, 63364: 58727, 63365: 58728, 63366: 58729, 63367: 58730, 63368: 58731, 63369: 58732, 63370: 58733, 63371: 58734, 63372: 58735, 63373: 58736, 63374: 58737, 63375: 58738, 63376: 58739, 63377: 58740, 63378: 58741, 63379: 58742, 63380: 58743, 63381: 58744, 63382: 58745, 63383: 58746, 63384: 58747, 63385: 58748, 63386: 58749, 63387: 58750, 63388: 58751, 63389: 58752, 63390: 58753, 63391: 58754, 63392: 58755, 63393: 58756, 63394: 58757, 63395: 58758, 63396: 58759, 63397: 58760, 63398: 58761, 63399: 58762, 63400: 58763, 63401: 58764, 63402: 58765, 63403: 58766, 63404: 58767, 63405: 58768, 63406: 58769, 63407: 58770, 63408: 58771, 63409: 58772, 63410: 58773, 63411: 58774, 63412: 58775, 63413: 58776, 63414: 58777, 63415: 58778, 63416: 58779, 63417: 58780, 63418: 58781, 63419: 58782, 63420: 58783, 63421: 58784, 63422: 58785, 63423: 58786, 63424: 58787, 63425: 58788, 63426: 58789, 63427: 58790, 63428: 58791, 63429: 58792, 63430: 58793, 63431: 58794, 63432: 58795, 63433: 58796, 63434: 58797, 63435: 58798, 63436: 58799, 63437: 58800, 63438: 58801, 63439: 58802, 63440: 58803, 63441: 58804, 63442: 58805, 63443: 58806, 63444: 58807, 63445: 58808, 63446: 58809, 63447: 58810, 63448: 58811, 63449: 58812, 63450: 58813, 63451: 58814, 63452: 58815, 63453: 58816, 63454: 58817, 63455: 58818, 63456: 58819, 63457: 58820, 63458: 58821, 63459: 58822, 63460: 58823, 63461: 58824, 63462: 58825, 63463: 58826, 63464: 58827, 63465: 58828, 63466: 58829, 63467: 58830, 63468: 58831, 63469: 58832, 63470: 58833, 63471: 58834, 63472: 58835, 63473: 58836, 63474: 58837, 63475: 58838, 63476: 58839, 63477: 58840, 63478: 58841, 63479: 58842, 63480: 58843, 63481: 58844, 63482: 58845, 63483: 58846, 63484: 58847, 63552: 58848, 63553: 58849, 63554: 58850, 63555: 58851, 63556: 58852, 63557: 58853, 63558: 58854, 63559: 58855, 63560: 58856, 63561: 58857, 63562: 58858, 63563: 58859, 63564: 58860, 63565: 58861, 63566: 58862, 63567: 58863, 63568: 58864, 63569: 58865, 63570: 58866, 63571: 58867, 63572: 58868, 63573: 58869, 63574: 58870, 63575: 58871, 63576: 58872, 63577: 58873, 63578: 58874, 63579: 58875, 63580: 58876, 63581: 58877, 63582: 58878, 63583: 58879, 63584: 58880, 63585: 58881, 63586: 58882, 63587: 58883, 63588: 58884, 63589: 58885, 63590: 58886, 63591: 58887, 63592: 58888, 63593: 58889, 63594: 58890, 63595: 58891, 63596: 58892, 63597: 58893, 63598: 58894, 63599: 58895, 63600: 58896, 63601: 58897, 63602: 58898, 63603: 58899, 63604: 58900, 63605: 58901, 63606: 58902, 63607: 58903, 63608: 58904, 63609: 58905, 63610: 58906, 63611: 58907, 63612: 58908, 63613: 58909, 63614: 58910, 63616: 58911, 63617: 58912, 63618: 58913, 63619: 58914, 63620: 58915, 63621: 58916, 63622: 58917, 63623: 58918, 63624: 58919, 63625: 58920, 63626: 58921, 63627: 58922, 63628: 58923, 63629: 58924, 63630: 58925, 63631: 58926, 63632: 58927, 63633: 58928, 63634: 58929, 63635: 58930, 63636: 58931, 63637: 58932, 63638: 58933, 63639: 58934, 63640: 58935, 63641: 58936, 63642: 58937, 63643: 58938, 63644: 58939, 63645: 58940, 63646: 58941, 63647: 58942, 63648: 58943, 63649: 58944, 63650: 58945, 63651: 58946, 63652: 58947, 63653: 58948, 63654: 58949, 63655: 58950, 63656: 58951, 63657: 58952, 63658: 58953, 63659: 58954, 63660: 58955, 63661: 58956, 63662: 58957, 63663: 58958, 63664: 58959, 63665: 58960, 63666: 58961, 63667: 58962, 63668: 58963, 63669: 58964, 63670: 58965, 63671: 58966, 63672: 58967, 63673: 58968, 63674: 58969, 63675: 58970, 63676: 58971, 63677: 58972, 63678: 58973, 63679: 58974, 63680: 58975, 63681: 58976, 63682: 58977, 63683: 58978, 63684: 58979, 63685: 58980, 63686: 58981, 63687: 58982, 63688: 58983, 63689: 58984, 63690: 58985, 63691: 58986, 63692: 58987, 63693: 58988, 63694: 58989, 63695: 58990, 63696: 58991, 63697: 58992, 63698: 58993, 63699: 58994, 63700: 58995, 63701: 58996, 63702: 58997, 63703: 58998, 63704: 58999, 63705: 59e3, 63706: 59001, 63707: 59002, 63708: 59003, 63709: 59004, 63710: 59005, 63711: 59006, 63712: 59007, 63713: 59008, 63714: 59009, 63715: 59010, 63716: 59011, 63717: 59012, 63718: 59013, 63719: 59014, 63720: 59015, 63721: 59016, 63722: 59017, 63723: 59018, 63724: 59019, 63725: 59020, 63726: 59021, 63727: 59022, 63728: 59023, 63729: 59024, 63730: 59025, 63731: 59026, 63732: 59027, 63733: 59028, 63734: 59029, 63735: 59030, 63736: 59031, 63737: 59032, 63738: 59033, 63739: 59034, 63740: 59035, 64064: 8560, 64065: 8561, 64066: 8562, 64067: 8563, 64068: 8564, 64069: 8565, 64070: 8566, 64071: 8567, 64072: 8568, 64073: 8569, 64074: 8544, 64075: 8545, 64076: 8546, 64077: 8547, 64078: 8548, 64079: 8549, 64080: 8550, 64081: 8551, 64082: 8552, 64083: 8553, 64084: 65506, 64085: 65508, 64086: 65287, 64087: 65282, 64088: 12849, 64089: 8470, 64090: 8481, 64091: 8757, 64092: 32394, 64093: 35100, 64094: 37704, 64095: 37512, 64096: 34012, 64097: 20425, 64098: 28859, 64099: 26161, 64100: 26824, 64101: 37625, 64102: 26363, 64103: 24389, 64104: 20008, 64105: 20193, 64106: 20220, 64107: 20224, 64108: 20227, 64109: 20281, 64110: 20310, 64111: 20370, 64112: 20362, 64113: 20378, 64114: 20372, 64115: 20429, 64116: 20544, 64117: 20514, 64118: 20479, 64119: 20510, 64120: 20550, 64121: 20592, 64122: 20546, 64123: 20628, 64124: 20724, 64125: 20696, 64126: 20810, 64128: 20836, 64129: 20893, 64130: 20926, 64131: 20972, 64132: 21013, 64133: 21148, 64134: 21158, 64135: 21184, 64136: 21211, 64137: 21248, 64138: 21255, 64139: 21284, 64140: 21362, 64141: 21395, 64142: 21426, 64143: 21469, 64144: 64014, 64145: 21660, 64146: 21642, 64147: 21673, 64148: 21759, 64149: 21894, 64150: 22361, 64151: 22373, 64152: 22444, 64153: 22472, 64154: 22471, 64155: 64015, 64156: 64016, 64157: 22686, 64158: 22706, 64159: 22795, 64160: 22867, 64161: 22875, 64162: 22877, 64163: 22883, 64164: 22948, 64165: 22970, 64166: 23382, 64167: 23488, 64168: 29999, 64169: 23512, 64170: 23532, 64171: 23582, 64172: 23718, 64173: 23738, 64174: 23797, 64175: 23847, 64176: 23891, 64177: 64017, 64178: 23874, 64179: 23917, 64180: 23992, 64181: 23993, 64182: 24016, 64183: 24353, 64184: 24372, 64185: 24423, 64186: 24503, 64187: 24542, 64188: 24669, 64189: 24709, 64190: 24714, 64191: 24798, 64192: 24789, 64193: 24864, 64194: 24818, 64195: 24849, 64196: 24887, 64197: 24880, 64198: 24984, 64199: 25107, 64200: 25254, 64201: 25589, 64202: 25696, 64203: 25757, 64204: 25806, 64205: 25934, 64206: 26112, 64207: 26133, 64208: 26171, 64209: 26121, 64210: 26158, 64211: 26142, 64212: 26148, 64213: 26213, 64214: 26199, 64215: 26201, 64216: 64018, 64217: 26227, 64218: 26265, 64219: 26272, 64220: 26290, 64221: 26303, 64222: 26362, 64223: 26382, 64224: 63785, 64225: 26470, 64226: 26555, 64227: 26706, 64228: 26560, 64229: 26625, 64230: 26692, 64231: 26831, 64232: 64019, 64233: 26984, 64234: 64020, 64235: 27032, 64236: 27106, 64237: 27184, 64238: 27243, 64239: 27206, 64240: 27251, 64241: 27262, 64242: 27362, 64243: 27364, 64244: 27606, 64245: 27711, 64246: 27740, 64247: 27782, 64248: 27759, 64249: 27866, 64250: 27908, 64251: 28039, 64252: 28015, 64320: 28054, 64321: 28076, 64322: 28111, 64323: 28152, 64324: 28146, 64325: 28156, 64326: 28217, 64327: 28252, 64328: 28199, 64329: 28220, 64330: 28351, 64331: 28552, 64332: 28597, 64333: 28661, 64334: 28677, 64335: 28679, 64336: 28712, 64337: 28805, 64338: 28843, 64339: 28943, 64340: 28932, 64341: 29020, 64342: 28998, 64343: 28999, 64344: 64021, 64345: 29121, 64346: 29182, 64347: 29361, 64348: 29374, 64349: 29476, 64350: 64022, 64351: 29559, 64352: 29629, 64353: 29641, 64354: 29654, 64355: 29667, 64356: 29650, 64357: 29703, 64358: 29685, 64359: 29734, 64360: 29738, 64361: 29737, 64362: 29742, 64363: 29794, 64364: 29833, 64365: 29855, 64366: 29953, 64367: 30063, 64368: 30338, 64369: 30364, 64370: 30366, 64371: 30363, 64372: 30374, 64373: 64023, 64374: 30534, 64375: 21167, 64376: 30753, 64377: 30798, 64378: 30820, 64379: 30842, 64380: 31024, 64381: 64024, 64382: 64025, 64384: 64026, 64385: 31124, 64386: 64027, 64387: 31131, 64388: 31441, 64389: 31463, 64390: 64028, 64391: 31467, 64392: 31646, 64393: 64029, 64394: 32072, 64395: 32092, 64396: 32183, 64397: 32160, 64398: 32214, 64399: 32338, 64400: 32583, 64401: 32673, 64402: 64030, 64403: 33537, 64404: 33634, 64405: 33663, 64406: 33735, 64407: 33782, 64408: 33864, 64409: 33972, 64410: 34131, 64411: 34137, 64412: 34155, 64413: 64031, 64414: 34224, 64415: 64032, 64416: 64033, 64417: 34823, 64418: 35061, 64419: 35346, 64420: 35383, 64421: 35449, 64422: 35495, 64423: 35518, 64424: 35551, 64425: 64034, 64426: 35574, 64427: 35667, 64428: 35711, 64429: 36080, 64430: 36084, 64431: 36114, 64432: 36214, 64433: 64035, 64434: 36559, 64435: 64036, 64436: 64037, 64437: 36967, 64438: 37086, 64439: 64038, 64440: 37141, 64441: 37159, 64442: 37338, 64443: 37335, 64444: 37342, 64445: 37357, 64446: 37358, 64447: 37348, 64448: 37349, 64449: 37382, 64450: 37392, 64451: 37386, 64452: 37434, 64453: 37440, 64454: 37436, 64455: 37454, 64456: 37465, 64457: 37457, 64458: 37433, 64459: 37479, 64460: 37543, 64461: 37495, 64462: 37496, 64463: 37607, 64464: 37591, 64465: 37593, 64466: 37584, 64467: 64039, 64468: 37589, 64469: 37600, 64470: 37587, 64471: 37669, 64472: 37665, 64473: 37627, 64474: 64040, 64475: 37662, 64476: 37631, 64477: 37661, 64478: 37634, 64479: 37744, 64480: 37719, 64481: 37796, 64482: 37830, 64483: 37854, 64484: 37880, 64485: 37937, 64486: 37957, 64487: 37960, 64488: 38290, 64489: 63964, 64490: 64041, 64491: 38557, 64492: 38575, 64493: 38707, 64494: 38715, 64495: 38723, 64496: 38733, 64497: 38735, 64498: 38737, 64499: 38741, 64500: 38999, 64501: 39013, 64502: 64042, 64503: 64043, 64504: 39207, 64505: 64044, 64506: 39326, 64507: 39502, 64508: 39641, 64576: 39644, 64577: 39797, 64578: 39794, 64579: 39823, 64580: 39857, 64581: 39867, 64582: 39936, 64583: 40304, 64584: 40299, 64585: 64045, 64586: 40473, 64587: 40657 }; function nR(n, e) { this.dv = new DataView(n), this.offset = 0, this.littleEndian = e !== void 0 ? e : !0, this.encoder = new vT } nR.prototype = { constructor: nR, getInt8: function () { var n = this.dv.getInt8(this.offset); return this.offset += 1, n }, getInt8Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getInt8()); return e }, getUint8: function () { var n = this.dv.getUint8(this.offset); return this.offset += 1, n }, getUint8Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getUint8()); return e }, getInt16: function () { var n = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, n }, getInt16Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getInt16()); return e }, getUint16: function () { var n = this.dv.getUint16(this.offset, this.littleEndian); return this.offset += 2, n }, getUint16Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getUint16()); return e }, getInt32: function () { var n = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, n }, getInt32Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getInt32()); return e }, getUint32: function () { var n = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, n }, getUint32Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getUint32()); return e }, getFloat32: function () { var n = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, n }, getFloat32Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getFloat32()); return e }, getFloat64: function () { var n = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, n }, getFloat64Array: function (n) { for (var e = [], t = 0; t < n; t++)e.push(this.getFloat64()); return e }, getIndex: function (n, e) { switch (n) { case 1: return e === !0 ? this.getUint8() : this.getInt8(); case 2: return e === !0 ? this.getUint16() : this.getInt16(); case 4: return this.getInt32(); default: throw "unknown number type " + n + " exception." } }, getIndexArray: function (n, e, t) { for (var r = [], i = 0; i < e; i++)r.push(this.getIndex(n, t)); return r }, getChars: function (n) { for (var e = ""; n > 0;) { var t = this.getUint8(); if (n--, t === 0) break; e += String.fromCharCode(t) } for (; n > 0;)this.getUint8(), n--; return e }, getSjisStringsAsUnicode: function (n) { for (var e = []; n > 0;) { var t = this.getUint8(); if (n--, t === 0) break; e.push(t) } for (; n > 0;)this.getUint8(), n--; return this.encoder.s2u(new Uint8Array(e)) }, getUnicodeStrings: function (n) { for (var e = ""; n > 0;) { var t = this.getUint16(); if (n -= 2, t === 0) break; e += String.fromCharCode(t) } for (; n > 0;)this.getUint8(), n--; return e }, getTextBuffer: function () { var n = this.getUint32(); return this.getUnicodeStrings(n) } }; function rR() { } rR.prototype = { constructor: rR, leftToRightVector3: function (n) { n[2] = -n[2] }, leftToRightQuaternion: function (n) { n[0] = -n[0], n[1] = -n[1] }, leftToRightEuler: function (n) { n[0] = -n[0], n[1] = -n[1] }, leftToRightIndexOrder: function (n) { var e = n[2]; n[2] = n[0], n[0] = e }, leftToRightVector3Range: function (n, e) { var t = -e[2]; e[2] = -n[2], n[2] = t }, leftToRightEulerRange: function (n, e) { var t = -e[0], r = -e[1]; e[0] = -n[0], e[1] = -n[1], n[0] = t, n[1] = r } }; const $U = 0, Wre = 2, Xre = 0, Yre = 0, jre = 2, Jre = 0, Kre = 0, qre = 1, v7 = 2, Zre = 1, $re = 64, eG = 0, tG = 9, yT = 15, nG = 16, xT = 22, rG = 37, _T = 43, iG = 76, sG = 83, aG = 97, oG = 100, lG = 103, uG = 109; class eie { constructor() { this.vkFormat = eG, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = $U, this.levels = [], this.dataFormatDescriptor = [{ vendorId: Yre, descriptorType: Xre, descriptorBlockSize: 0, versionNumber: jre, colorModel: Jre, colorPrimaries: Zre, transferFunction: v7, flags: Kre, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null } } class ug { constructor(e, t, r, i) { this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, r), this._littleEndian = i, this._offset = 0 } _nextUint8() { const e = this._dataView.getUint8(this._offset); return this._offset += 1, e } _nextUint16() { const e = this._dataView.getUint16(this._offset, this._littleEndian); return this._offset += 2, e } _nextUint32() { const e = this._dataView.getUint32(this._offset, this._littleEndian); return this._offset += 4, e } _nextUint64() { const e = this._dataView.getUint32(this._offset, this._littleEndian), t = this._dataView.getUint32(this._offset + 4, this._littleEndian), r = e + 2 ** 32 * t; return this._offset += 8, r } _nextInt32() { const e = this._dataView.getInt32(this._offset, this._littleEndian); return this._offset += 4, e } _skip(e) { return this._offset += e, this } _scan(e, t = 0) { const r = this._offset; let i = 0; for (; this._dataView.getUint8(this._offset) !== t && i < e;)i++, this._offset++; return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + r, i) } } const Ma = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10]; function iR(n) { return typeof TextDecoder < "u" ? new TextDecoder().decode(n) : Buffer.from(n).toString("utf8") } function tie(n) { const e = new Uint8Array(n.buffer, n.byteOffset, Ma.length); if (e[0] !== Ma[0] || e[1] !== Ma[1] || e[2] !== Ma[2] || e[3] !== Ma[3] || e[4] !== Ma[4] || e[5] !== Ma[5] || e[6] !== Ma[6] || e[7] !== Ma[7] || e[8] !== Ma[8] || e[9] !== Ma[9] || e[10] !== Ma[10] || e[11] !== Ma[11]) throw new Error("Missing KTX 2.0 identifier."); const t = new eie, r = 17 * Uint32Array.BYTES_PER_ELEMENT, i = new ug(n, Ma.length, r, !0); t.vkFormat = i._nextUint32(), t.typeSize = i._nextUint32(), t.pixelWidth = i._nextUint32(), t.pixelHeight = i._nextUint32(), t.pixelDepth = i._nextUint32(), t.layerCount = i._nextUint32(), t.faceCount = i._nextUint32(); const s = i._nextUint32(); t.supercompressionScheme = i._nextUint32(); const a = i._nextUint32(), o = i._nextUint32(), l = i._nextUint32(), u = i._nextUint32(), c = i._nextUint64(), h = i._nextUint64(), d = s * 3 * 8, m = new ug(n, Ma.length + r, d, !0); for (let D = 0; D < s; D++)t.levels.push({ levelData: new Uint8Array(n.buffer, n.byteOffset + m._nextUint64(), m._nextUint64()), uncompressedByteLength: m._nextUint64() }); const g = new ug(n, a, o, !0), v = { vendorId: g._skip(4)._nextUint16(), descriptorType: g._nextUint16(), versionNumber: g._nextUint16(), descriptorBlockSize: g._nextUint16(), colorModel: g._nextUint8(), colorPrimaries: g._nextUint8(), transferFunction: g._nextUint8(), flags: g._nextUint8(), texelBlockDimension: [g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8()], bytesPlane: [g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8()], samples: [] }, y = 6, A = 4, _ = (v.descriptorBlockSize / 4 - y) / A; for (let D = 0; D < _; D++) { const V = { bitOffset: g._nextUint16(), bitLength: g._nextUint8(), channelType: g._nextUint8(), samplePosition: [g._nextUint8(), g._nextUint8(), g._nextUint8(), g._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 }; V.channelType & $re ? (V.sampleLower = g._nextInt32(), V.sampleUpper = g._nextInt32()) : (V.sampleLower = g._nextUint32(), V.sampleUpper = g._nextUint32()), v.samples[D] = V } t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(v); const x = new ug(n, l, u, !0); for (; x._offset < u;) { const D = x._nextUint32(), V = x._scan(D), J = iR(V), Ee = x._scan(D - V.byteLength); t.keyValue[J] = J.match(/^ktx/i) ? iR(Ee) : Ee, x._offset % 4 && x._skip(4 - x._offset % 4) } if (h <= 0) return t; const C = new ug(n, c, h, !0), T = C._nextUint16(), I = C._nextUint16(), w = C._nextUint32(), R = C._nextUint32(), b = C._nextUint32(), B = C._nextUint32(), F = []; for (let D = 0; D < s; D++)F.push({ imageFlags: C._nextUint32(), rgbSliceByteOffset: C._nextUint32(), rgbSliceByteLength: C._nextUint32(), alphaSliceByteOffset: C._nextUint32(), alphaSliceByteLength: C._nextUint32() }); const U = c + C._offset, G = U + w, Y = G + R, Z = Y + b, ne = new Uint8Array(n.buffer, n.byteOffset + U, w), $ = new Uint8Array(n.buffer, n.byteOffset + G, R), L = new Uint8Array(n.buffer, n.byteOffset + Y, b), Q = new Uint8Array(n.buffer, n.byteOffset + Z, B); return t.globalData = { endpointCount: T, selectorCount: I, imageDescs: F, endpointsData: ne, selectorsData: $, tablesData: L, extendedData: Q }, t } let v_, Qc, y7; const y_ = { env: { emscripten_notify_memory_growth: function (n) { y7 = new Uint8Array(Qc.exports.memory.buffer) } } }; class nie { init() { return v_ || (v_ = typeof fetch < "u" ? fetch("data:application/wasm;base64," + sR).then(e => e.arrayBuffer()).then(e => WebAssembly.instantiate(e, y_)).then(this._init) : WebAssembly.instantiate(Buffer.from(sR, "base64"), y_).then(this._init), v_) } _init(e) { Qc = e.instance, y_.env.emscripten_notify_memory_growth(0) } decode(e, t = 0) { if (!Qc) throw new Error("ZSTDDecoder: Await .init() before decoding."); const r = e.byteLength, i = Qc.exports.malloc(r); y7.set(e, i), t = t || Number(Qc.exports.ZSTD_findDecompressedSize(i, r)); const s = Qc.exports.malloc(t), a = Qc.exports.ZSTD_decompress(s, t, i, r), o = y7.slice(s, s + a); return Qc.exports.free(i), Qc.exports.free(s), o } } const sR = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";/*! https://mths.be/codepointat v0.2.0 by @mathias */String.prototype.codePointAt || function () { var n = function () { try { var t = {}, r = Object.defineProperty, i = r(t, t, t) && r } catch { } return i }(), e = function (t) { if (this == null) throw TypeError(); var r = String(this), i = r.length, s = t ? Number(t) : 0; if (s != s && (s = 0), !(s < 0 || s >= i)) { var a = r.charCodeAt(s), o; return a >= 55296 && a <= 56319 && i > s + 1 && (o = r.charCodeAt(s + 1), o >= 56320 && o <= 57343) ? (a - 55296) * 1024 + o - 56320 + 65536 : a } }; n ? n(String.prototype, "codePointAt", { value: e, configurable: !0, writable: !0 }) : String.prototype.codePointAt = e }(); function cG() { this.table = new Uint16Array(16), this.trans = new Uint16Array(288) } var rie = new cG, iie = new cG, fG = new Uint8Array(30), hG = new Uint16Array(30), sie = new Uint8Array(30), aie = new Uint16Array(30); function dG(n, e, t, r) { var i, s; for (i = 0; i < t; ++i)n[i] = 0; for (i = 0; i < 30 - t; ++i)n[i + t] = i / t | 0; for (s = r, i = 0; i < 30; ++i)e[i] = s, s += 1 << n[i] } function oie(n, e) { var t; for (t = 0; t < 7; ++t)n.table[t] = 0; for (n.table[7] = 24, n.table[8] = 152, n.table[9] = 112, t = 0; t < 24; ++t)n.trans[t] = 256 + t; for (t = 0; t < 144; ++t)n.trans[24 + t] = t; for (t = 0; t < 8; ++t)n.trans[24 + 144 + t] = 280 + t; for (t = 0; t < 112; ++t)n.trans[24 + 144 + 8 + t] = 144 + t; for (t = 0; t < 5; ++t)e.table[t] = 0; for (e.table[5] = 32, t = 0; t < 32; ++t)e.trans[t] = t } oie(rie, iie); dG(fG, hG, 4, 3); dG(sie, aie, 2, 1); fG[28] = 0; hG[28] = 258; function L0(n, e, t, r, i) { return Math.pow(1 - i, 3) * n + 3 * Math.pow(1 - i, 2) * i * e + 3 * (1 - i) * Math.pow(i, 2) * t + Math.pow(i, 3) * r } function qh() { this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN } qh.prototype.isEmpty = function () { return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2) }; qh.prototype.addPoint = function (n, e) { typeof n == "number" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = n, this.x2 = n), n < this.x1 && (this.x1 = n), n > this.x2 && (this.x2 = n)), typeof e == "number" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e)) }; qh.prototype.addX = function (n) { this.addPoint(n, null) }; qh.prototype.addY = function (n) { this.addPoint(null, n) }; qh.prototype.addBezier = function (n, e, t, r, i, s, a, o) { var l = [n, e], u = [t, r], c = [i, s], h = [a, o]; this.addPoint(n, e), this.addPoint(a, o); for (var d = 0; d <= 1; d++) { var m = 6 * l[d] - 12 * u[d] + 6 * c[d], g = -3 * l[d] + 9 * u[d] - 9 * c[d] + 3 * h[d], v = 3 * u[d] - 3 * l[d]; if (g === 0) { if (m === 0) continue; var y = -v / m; 0 < y && y < 1 && (d === 0 && this.addX(L0(l[d], u[d], c[d], h[d], y)), d === 1 && this.addY(L0(l[d], u[d], c[d], h[d], y))); continue } var A = Math.pow(m, 2) - 4 * v * g; if (!(A < 0)) { var _ = (-m + Math.sqrt(A)) / (2 * g); 0 < _ && _ < 1 && (d === 0 && this.addX(L0(l[d], u[d], c[d], h[d], _)), d === 1 && this.addY(L0(l[d], u[d], c[d], h[d], _))); var x = (-m - Math.sqrt(A)) / (2 * g); 0 < x && x < 1 && (d === 0 && this.addX(L0(l[d], u[d], c[d], h[d], x)), d === 1 && this.addY(L0(l[d], u[d], c[d], h[d], x))) } } }; qh.prototype.addQuad = function (n, e, t, r, i, s) { var a = n + .6666666666666666 * (t - n), o = e + 2 / 3 * (r - e), l = a + 1 / 3 * (i - n), u = o + 1 / 3 * (s - e); this.addBezier(n, e, a, o, l, u, i, s) }; function Ts() { this.commands = [], this.fill = "black", this.stroke = null, this.strokeWidth = 1 } Ts.prototype.moveTo = function (n, e) { this.commands.push({ type: "M", x: n, y: e }) }; Ts.prototype.lineTo = function (n, e) { this.commands.push({ type: "L", x: n, y: e }) }; Ts.prototype.curveTo = Ts.prototype.bezierCurveTo = function (n, e, t, r, i, s) { this.commands.push({ type: "C", x1: n, y1: e, x2: t, y2: r, x: i, y: s }) }; Ts.prototype.quadTo = Ts.prototype.quadraticCurveTo = function (n, e, t, r) { this.commands.push({ type: "Q", x1: n, y1: e, x: t, y: r }) }; Ts.prototype.close = Ts.prototype.closePath = function () { this.commands.push({ type: "Z" }) }; Ts.prototype.extend = function (n) { if (n.commands) n = n.commands; else if (n instanceof qh) { var e = n; this.moveTo(e.x1, e.y1), this.lineTo(e.x2, e.y1), this.lineTo(e.x2, e.y2), this.lineTo(e.x1, e.y2), this.close(); return } Array.prototype.push.apply(this.commands, n) }; Ts.prototype.getBoundingBox = function () { for (var n = new qh, e = 0, t = 0, r = 0, i = 0, s = 0; s < this.commands.length; s++) { var a = this.commands[s]; switch (a.type) { case "M": n.addPoint(a.x, a.y), e = r = a.x, t = i = a.y; break; case "L": n.addPoint(a.x, a.y), r = a.x, i = a.y; break; case "Q": n.addQuad(r, i, a.x1, a.y1, a.x, a.y), r = a.x, i = a.y; break; case "C": n.addBezier(r, i, a.x1, a.y1, a.x2, a.y2, a.x, a.y), r = a.x, i = a.y; break; case "Z": r = e, i = t; break; default: throw new Error("Unexpected path command " + a.type) } } return n.isEmpty() && n.addPoint(0, 0), n }; Ts.prototype.draw = function (n) { n.beginPath(); for (var e = 0; e < this.commands.length; e += 1) { var t = this.commands[e]; t.type === "M" ? n.moveTo(t.x, t.y) : t.type === "L" ? n.lineTo(t.x, t.y) : t.type === "C" ? n.bezierCurveTo(t.x1, t.y1, t.x2, t.y2, t.x, t.y) : t.type === "Q" ? n.quadraticCurveTo(t.x1, t.y1, t.x, t.y) : t.type === "Z" && n.closePath() } this.fill && (n.fillStyle = this.fill, n.fill()), this.stroke && (n.strokeStyle = this.stroke, n.lineWidth = this.strokeWidth, n.stroke()) }; Ts.prototype.toPathData = function (n) { n = n !== void 0 ? n : 2; function e(a) { return Math.round(a) === a ? "" + Math.round(a) : a.toFixed(n) } function t() { for (var a = arguments, o = "", l = 0; l < arguments.length; l += 1) { var u = a[l]; u >= 0 && l > 0 && (o += " "), o += e(u) } return o } for (var r = "", i = 0; i < this.commands.length; i += 1) { var s = this.commands[i]; s.type === "M" ? r += "M" + t(s.x, s.y) : s.type === "L" ? r += "L" + t(s.x, s.y) : s.type === "C" ? r += "C" + t(s.x1, s.y1, s.x2, s.y2, s.x, s.y) : s.type === "Q" ? r += "Q" + t(s.x1, s.y1, s.x, s.y) : s.type === "Z" && (r += "Z") } return r }; Ts.prototype.toSVG = function (n) { var e = '<path d="'; return e += this.toPathData(n), e += '"', this.fill && this.fill !== "black" && (this.fill === null ? e += ' fill="none"' : e += ' fill="' + this.fill + '"'), this.stroke && (e += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"'), e += "/>", e }; Ts.prototype.toDOMElement = function (n) { var e = this.toPathData(n), t = document.createElementNS("http://www.w3.org/2000/svg", "path"); return t.setAttribute("d", e), t }; function pG(n) { throw new Error(n) } function aR(n, e) { n || pG(e) } var An = { fail: pG, argument: aR, assert: aR }, oR = 32768, lR = 2147483648, am = {}, ht = {}, on = {}; function bu(n) { return function () { return n } } ht.BYTE = function (n) { return An.argument(n >= 0 && n <= 255, "Byte value should be between 0 and 255."), [n] }; on.BYTE = bu(1); ht.CHAR = function (n) { return [n.charCodeAt(0)] }; on.CHAR = bu(1); ht.CHARARRAY = function (n) { typeof n > "u" && (n = "", console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.")); for (var e = [], t = 0; t < n.length; t += 1)e[t] = n.charCodeAt(t); return e }; on.CHARARRAY = function (n) { return typeof n > "u" ? 0 : n.length }; ht.USHORT = function (n) { return [n >> 8 & 255, n & 255] }; on.USHORT = bu(2); ht.SHORT = function (n) { return n >= oR && (n = -(2 * oR - n)), [n >> 8 & 255, n & 255] }; on.SHORT = bu(2); ht.UINT24 = function (n) { return [n >> 16 & 255, n >> 8 & 255, n & 255] }; on.UINT24 = bu(3); ht.ULONG = function (n) { return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255] }; on.ULONG = bu(4); ht.LONG = function (n) { return n >= lR && (n = -(2 * lR - n)), [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255] }; on.LONG = bu(4); ht.FIXED = ht.ULONG; on.FIXED = on.ULONG; ht.FWORD = ht.SHORT; on.FWORD = on.SHORT; ht.UFWORD = ht.USHORT; on.UFWORD = on.USHORT; ht.LONGDATETIME = function (n) { return [0, 0, 0, 0, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255] }; on.LONGDATETIME = bu(8); ht.TAG = function (n) { return An.argument(n.length === 4, "Tag should be exactly 4 ASCII characters."), [n.charCodeAt(0), n.charCodeAt(1), n.charCodeAt(2), n.charCodeAt(3)] }; on.TAG = bu(4); ht.Card8 = ht.BYTE; on.Card8 = on.BYTE; ht.Card16 = ht.USHORT; on.Card16 = on.USHORT; ht.OffSize = ht.BYTE; on.OffSize = on.BYTE; ht.SID = ht.USHORT; on.SID = on.USHORT; ht.NUMBER = function (n) { return n >= -107 && n <= 107 ? [n + 139] : n >= 108 && n <= 1131 ? (n = n - 108, [(n >> 8) + 247, n & 255]) : n >= -1131 && n <= -108 ? (n = -n - 108, [(n >> 8) + 251, n & 255]) : n >= -32768 && n <= 32767 ? ht.NUMBER16(n) : ht.NUMBER32(n) }; on.NUMBER = function (n) { return ht.NUMBER(n).length }; ht.NUMBER16 = function (n) { return [28, n >> 8 & 255, n & 255] }; on.NUMBER16 = bu(3); ht.NUMBER32 = function (n) { return [29, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255] }; on.NUMBER32 = bu(5); ht.REAL = function (n) { var e = n.toString(), t = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(e); if (t) { var r = parseFloat("1e" + ((t[2] ? +t[2] : 0) + t[1].length)); e = (Math.round(n * r) / r).toString() } for (var i = "", s = 0, a = e.length; s < a; s += 1) { var o = e[s]; o === "e" ? i += e[++s] === "-" ? "c" : "b" : o === "." ? i += "a" : o === "-" ? i += "e" : i += o } i += i.length & 1 ? "f" : "ff"; for (var l = [30], u = 0, c = i.length; u < c; u += 2)l.push(parseInt(i.substr(u, 2), 16)); return l }; on.REAL = function (n) { return ht.REAL(n).length }; ht.NAME = ht.CHARARRAY; on.NAME = on.CHARARRAY; ht.STRING = ht.CHARARRAY; on.STRING = on.CHARARRAY; am.UTF8 = function (n, e, t) { for (var r = [], i = t, s = 0; s < i; s++, e += 1)r[s] = n.getUint8(e); return String.fromCharCode.apply(null, r) }; am.UTF16 = function (n, e, t) { for (var r = [], i = t / 2, s = 0; s < i; s++, e += 2)r[s] = n.getUint16(e); return String.fromCharCode.apply(null, r) }; ht.UTF16 = function (n) { for (var e = [], t = 0; t < n.length; t += 1) { var r = n.charCodeAt(t); e[e.length] = r >> 8 & 255, e[e.length] = r & 255 } return e }; on.UTF16 = function (n) { return n.length * 2 }; var x7 = { "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ", "x-mac-cyrillic": "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю", "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ", "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­", "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł", "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ", macintosh: "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ", "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ" }; am.MACSTRING = function (n, e, t, r) { var i = x7[r]; if (i !== void 0) { for (var s = "", a = 0; a < t; a++) { var o = n.getUint8(e + a); o <= 127 ? s += String.fromCharCode(o) : s += i[o & 127] } return s } }; var h5 = typeof WeakMap == "function" && new WeakMap, d5, lie = function (n) { if (!d5) { d5 = {}; for (var e in x7) d5[e] = new String(e) } var t = d5[n]; if (t !== void 0) { if (h5) { var r = h5.get(t); if (r !== void 0) return r } var i = x7[n]; if (i !== void 0) { for (var s = {}, a = 0; a < i.length; a++)s[i.charCodeAt(a)] = a + 128; return h5 && h5.set(t, s), s } } }; ht.MACSTRING = function (n, e) { var t = lie(e); if (t !== void 0) { for (var r = [], i = 0; i < n.length; i++) { var s = n.charCodeAt(i); if (s >= 128 && (s = t[s], s === void 0)) return; r[i] = s } return r } }; on.MACSTRING = function (n, e) { var t = ht.MACSTRING(n, e); return t !== void 0 ? t.length : 0 }; function _7(n) { return n >= -128 && n <= 127 } function uie(n, e, t) { for (var r = 0, i = n.length; e < i && r < 64 && n[e] === 0;)++e, ++r; return t.push(128 | r - 1), e } function cie(n, e, t) { for (var r = 0, i = n.length, s = e; s < i && r < 64;) { var a = n[s]; if (!_7(a) || a === 0 && s + 1 < i && n[s + 1] === 0) break; ++s, ++r } t.push(r - 1); for (var o = e; o < s; ++o)t.push(n[o] + 256 & 255); return s } function fie(n, e, t) { for (var r = 0, i = n.length, s = e; s < i && r < 64;) { var a = n[s]; if (a === 0 || _7(a) && s + 1 < i && _7(n[s + 1])) break; ++s, ++r } t.push(64 | r - 1); for (var o = e; o < s; ++o) { var l = n[o]; t.push(l + 65536 >> 8 & 255, l + 256 & 255) } return s } ht.VARDELTAS = function (n) { for (var e = 0, t = []; e < n.length;) { var r = n[e]; r === 0 ? e = uie(n, e, t) : r >= -128 && r <= 127 ? e = cie(n, e, t) : e = fie(n, e, t) } return t }; ht.INDEX = function (n) { for (var e = 1, t = [e], r = [], i = 0; i < n.length; i += 1) { var s = ht.OBJECT(n[i]); Array.prototype.push.apply(r, s), e += s.length, t.push(e) } if (r.length === 0) return [0, 0]; for (var a = [], o = 1 + Math.floor(Math.log(e) / Math.log(2)) / 8 | 0, l = [void 0, ht.BYTE, ht.USHORT, ht.UINT24, ht.ULONG][o], u = 0; u < t.length; u += 1) { var c = l(t[u]); Array.prototype.push.apply(a, c) } return Array.prototype.concat(ht.Card16(n.length), ht.OffSize(o), a, r) }; on.INDEX = function (n) { return ht.INDEX(n).length }; ht.DICT = function (n) { for (var e = [], t = Object.keys(n), r = t.length, i = 0; i < r; i += 1) { var s = parseInt(t[i], 0), a = n[s]; e = e.concat(ht.OPERAND(a.value, a.type)), e = e.concat(ht.OPERATOR(s)) } return e }; on.DICT = function (n) { return ht.DICT(n).length }; ht.OPERATOR = function (n) { return n < 1200 ? [n] : [12, n - 1200] }; ht.OPERAND = function (n, e) { var t = []; if (Array.isArray(e)) for (var r = 0; r < e.length; r += 1)An.argument(n.length === e.length, "Not enough arguments given for type" + e), t = t.concat(ht.OPERAND(n[r], e[r])); else if (e === "SID") t = t.concat(ht.NUMBER(n)); else if (e === "offset") t = t.concat(ht.NUMBER32(n)); else if (e === "number") t = t.concat(ht.NUMBER(n)); else if (e === "real") t = t.concat(ht.REAL(n)); else throw new Error("Unknown operand type " + e); return t }; ht.OP = ht.BYTE; on.OP = on.BYTE; var p5 = typeof WeakMap == "function" && new WeakMap; ht.CHARSTRING = function (n) { if (p5) { var e = p5.get(n); if (e !== void 0) return e } for (var t = [], r = n.length, i = 0; i < r; i += 1) { var s = n[i]; t = t.concat(ht[s.type](s.value)) } return p5 && p5.set(n, t), t }; on.CHARSTRING = function (n) { return ht.CHARSTRING(n).length }; ht.OBJECT = function (n) { var e = ht[n.type]; return An.argument(e !== void 0, "No encoding function for type " + n.type), e(n.value) }; on.OBJECT = function (n) { var e = on[n.type]; return An.argument(e !== void 0, "No sizeOf function for type " + n.type), e(n.value) }; ht.TABLE = function (n) { for (var e = [], t = n.fields.length, r = [], i = [], s = 0; s < t; s += 1) { var a = n.fields[s], o = ht[a.type]; An.argument(o !== void 0, "No encoding function for field type " + a.type + " (" + a.name + ")"); var l = n[a.name]; l === void 0 && (l = a.value); var u = o(l); a.type === "TABLE" ? (i.push(e.length), e = e.concat([0, 0]), r.push(u)) : e = e.concat(u) } for (var c = 0; c < r.length; c += 1) { var h = i[c], d = e.length; An.argument(d < 65536, "Table " + n.tableName + " too big."), e[h] = d >> 8, e[h + 1] = d & 255, e = e.concat(r[c]) } return e }; on.TABLE = function (n) { for (var e = 0, t = n.fields.length, r = 0; r < t; r += 1) { var i = n.fields[r], s = on[i.type]; An.argument(s !== void 0, "No sizeOf function for field type " + i.type + " (" + i.name + ")"); var a = n[i.name]; a === void 0 && (a = i.value), e += s(a), i.type === "TABLE" && (e += 2) } return e }; ht.RECORD = ht.TABLE; on.RECORD = on.TABLE; ht.LITERAL = function (n) { return n }; on.LITERAL = function (n) { return n.length }; function ks(n, e, t) { if (e.length && (e[0].name !== "coverageFormat" || e[0].value === 1)) for (var r = 0; r < e.length; r += 1) { var i = e[r]; this[i.name] = i.value } if (this.tableName = n, this.fields = e, t) for (var s = Object.keys(t), a = 0; a < s.length; a += 1) { var o = s[a], l = t[o]; this[o] !== void 0 && (this[o] = l) } } ks.prototype.encode = function () { return ht.TABLE(this) }; ks.prototype.sizeOf = function () { return on.TABLE(this) }; function d1(n, e, t) { t === void 0 && (t = e.length); var r = new Array(e.length + 1); r[0] = { name: n + "Count", type: "USHORT", value: t }; for (var i = 0; i < e.length; i++)r[i + 1] = { name: n + i, type: "USHORT", value: e[i] }; return r } function E7(n, e, t) { var r = e.length, i = new Array(r + 1); i[0] = { name: n + "Count", type: "USHORT", value: r }; for (var s = 0; s < r; s++)i[s + 1] = { name: n + s, type: "TABLE", value: t(e[s], s) }; return i } function p1(n, e, t) { var r = e.length, i = []; i[0] = { name: n + "Count", type: "USHORT", value: r }; for (var s = 0; s < r; s++)i = i.concat(t(e[s], s)); return i } function fy(n) { n.format === 1 ? ks.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(d1("glyph", n.glyphs))) : n.format === 2 ? ks.call(this, "coverageTable", [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(p1("rangeRecord", n.ranges, function (e) { return [{ name: "startGlyphID", type: "USHORT", value: e.start }, { name: "endGlyphID", type: "USHORT", value: e.end }, { name: "startCoverageIndex", type: "USHORT", value: e.index }] }))) : An.assert(!1, "Coverage format must be 1 or 2.") } fy.prototype = Object.create(ks.prototype); fy.prototype.constructor = fy; function hy(n) { ks.call(this, "scriptListTable", p1("scriptRecord", n, function (e, t) { var r = e.script, i = r.defaultLangSys; return An.assert(!!i, "Unable to write GSUB: script " + e.tag + " has no default language system."), [{ name: "scriptTag" + t, type: "TAG", value: e.tag }, { name: "script" + t, type: "TABLE", value: new ks("scriptTable", [{ name: "defaultLangSys", type: "TABLE", value: new ks("defaultLangSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: i.reqFeatureIndex }].concat(d1("featureIndex", i.featureIndexes))) }].concat(p1("langSys", r.langSysRecords, function (s, a) { var o = s.langSys; return [{ name: "langSysTag" + a, type: "TAG", value: s.tag }, { name: "langSys" + a, type: "TABLE", value: new ks("langSys", [{ name: "lookupOrder", type: "USHORT", value: 0 }, { name: "reqFeatureIndex", type: "USHORT", value: o.reqFeatureIndex }].concat(d1("featureIndex", o.featureIndexes))) }] }))) }] })) } hy.prototype = Object.create(ks.prototype); hy.prototype.constructor = hy; function dy(n) { ks.call(this, "featureListTable", p1("featureRecord", n, function (e, t) { var r = e.feature; return [{ name: "featureTag" + t, type: "TAG", value: e.tag }, { name: "feature" + t, type: "TABLE", value: new ks("featureTable", [{ name: "featureParams", type: "USHORT", value: r.featureParams }].concat(d1("lookupListIndex", r.lookupListIndexes))) }] })) } dy.prototype = Object.create(ks.prototype); dy.prototype.constructor = dy; function py(n, e) { ks.call(this, "lookupListTable", E7("lookup", n, function (t) { var r = e[t.lookupType]; return An.assert(!!r, "Unable to write GSUB lookup type " + t.lookupType + " tables."), new ks("lookupTable", [{ name: "lookupType", type: "USHORT", value: t.lookupType }, { name: "lookupFlag", type: "USHORT", value: t.lookupFlag }].concat(E7("subtable", t.subtables, r))) })) } py.prototype = Object.create(ks.prototype); py.prototype.constructor = py; var Rt = { Table: ks, Record: ks, Coverage: fy, ScriptList: hy, FeatureList: dy, LookupList: py, ushortList: d1, tableList: E7, recordList: p1 }; function uR(n, e) { return n.getUint8(e) } function my(n, e) { return n.getUint16(e, !1) } function hie(n, e) { return n.getInt16(e, !1) } function ET(n, e) { return n.getUint32(e, !1) } function mG(n, e) { var t = n.getInt16(e, !1), r = n.getUint16(e + 2, !1); return t + r / 65535 } function die(n, e) { for (var t = "", r = e; r < e + 4; r += 1)t += String.fromCharCode(n.getInt8(r)); return t } function pie(n, e, t) { for (var r = 0, i = 0; i < t; i += 1)r <<= 8, r += n.getUint8(e + i); return r } function mie(n, e, t) { for (var r = [], i = e; i < t; i += 1)r.push(n.getUint8(i)); return r } function gie(n) { for (var e = "", t = 0; t < n.length; t += 1)e += String.fromCharCode(n[t]); return e } var Aie = { byte: 1, uShort: 2, short: 2, uLong: 4, fixed: 4, longDateTime: 8, tag: 4 }; function be(n, e) { this.data = n, this.offset = e, this.relativeOffset = 0 } be.prototype.parseByte = function () { var n = this.data.getUint8(this.offset + this.relativeOffset); return this.relativeOffset += 1, n }; be.prototype.parseChar = function () { var n = this.data.getInt8(this.offset + this.relativeOffset); return this.relativeOffset += 1, n }; be.prototype.parseCard8 = be.prototype.parseByte; be.prototype.parseUShort = function () { var n = this.data.getUint16(this.offset + this.relativeOffset); return this.relativeOffset += 2, n }; be.prototype.parseCard16 = be.prototype.parseUShort; be.prototype.parseSID = be.prototype.parseUShort; be.prototype.parseOffset16 = be.prototype.parseUShort; be.prototype.parseShort = function () { var n = this.data.getInt16(this.offset + this.relativeOffset); return this.relativeOffset += 2, n }; be.prototype.parseF2Dot14 = function () { var n = this.data.getInt16(this.offset + this.relativeOffset) / 16384; return this.relativeOffset += 2, n }; be.prototype.parseULong = function () { var n = ET(this.data, this.offset + this.relativeOffset); return this.relativeOffset += 4, n }; be.prototype.parseOffset32 = be.prototype.parseULong; be.prototype.parseFixed = function () { var n = mG(this.data, this.offset + this.relativeOffset); return this.relativeOffset += 4, n }; be.prototype.parseString = function (n) { var e = this.data, t = this.offset + this.relativeOffset, r = ""; this.relativeOffset += n; for (var i = 0; i < n; i++)r += String.fromCharCode(e.getUint8(t + i)); return r }; be.prototype.parseTag = function () { return this.parseString(4) }; be.prototype.parseLongDateTime = function () { var n = ET(this.data, this.offset + this.relativeOffset + 4); return n -= 2082844800, this.relativeOffset += 8, n }; be.prototype.parseVersion = function (n) { var e = my(this.data, this.offset + this.relativeOffset), t = my(this.data, this.offset + this.relativeOffset + 2); return this.relativeOffset += 4, n === void 0 && (n = 4096), e + t / n / 10 }; be.prototype.skip = function (n, e) { e === void 0 && (e = 1), this.relativeOffset += Aie[n] * e }; be.prototype.parseULongList = function (n) { n === void 0 && (n = this.parseULong()); for (var e = new Array(n), t = this.data, r = this.offset + this.relativeOffset, i = 0; i < n; i++)e[i] = t.getUint32(r), r += 4; return this.relativeOffset += n * 4, e }; be.prototype.parseOffset16List = be.prototype.parseUShortList = function (n) { n === void 0 && (n = this.parseUShort()); for (var e = new Array(n), t = this.data, r = this.offset + this.relativeOffset, i = 0; i < n; i++)e[i] = t.getUint16(r), r += 2; return this.relativeOffset += n * 2, e }; be.prototype.parseShortList = function (n) { for (var e = new Array(n), t = this.data, r = this.offset + this.relativeOffset, i = 0; i < n; i++)e[i] = t.getInt16(r), r += 2; return this.relativeOffset += n * 2, e }; be.prototype.parseByteList = function (n) { for (var e = new Array(n), t = this.data, r = this.offset + this.relativeOffset, i = 0; i < n; i++)e[i] = t.getUint8(r++); return this.relativeOffset += n, e }; be.prototype.parseList = function (n, e) { e || (e = n, n = this.parseUShort()); for (var t = new Array(n), r = 0; r < n; r++)t[r] = e.call(this); return t }; be.prototype.parseList32 = function (n, e) { e || (e = n, n = this.parseULong()); for (var t = new Array(n), r = 0; r < n; r++)t[r] = e.call(this); return t }; be.prototype.parseRecordList = function (n, e) { e || (e = n, n = this.parseUShort()); for (var t = new Array(n), r = Object.keys(e), i = 0; i < n; i++) { for (var s = {}, a = 0; a < r.length; a++) { var o = r[a], l = e[o]; s[o] = l.call(this) } t[i] = s } return t }; be.prototype.parseRecordList32 = function (n, e) { e || (e = n, n = this.parseULong()); for (var t = new Array(n), r = Object.keys(e), i = 0; i < n; i++) { for (var s = {}, a = 0; a < r.length; a++) { var o = r[a], l = e[o]; s[o] = l.call(this) } t[i] = s } return t }; be.prototype.parseStruct = function (n) { if (typeof n == "function") return n.call(this); for (var e = Object.keys(n), t = {}, r = 0; r < e.length; r++) { var i = e[r], s = n[i]; t[i] = s.call(this) } return t }; be.prototype.parseValueRecord = function (n) { if (n === void 0 && (n = this.parseUShort()), n !== 0) { var e = {}; return n & 1 && (e.xPlacement = this.parseShort()), n & 2 && (e.yPlacement = this.parseShort()), n & 4 && (e.xAdvance = this.parseShort()), n & 8 && (e.yAdvance = this.parseShort()), n & 16 && (e.xPlaDevice = void 0, this.parseShort()), n & 32 && (e.yPlaDevice = void 0, this.parseShort()), n & 64 && (e.xAdvDevice = void 0, this.parseShort()), n & 128 && (e.yAdvDevice = void 0, this.parseShort()), e } }; be.prototype.parseValueRecordList = function () { for (var n = this.parseUShort(), e = this.parseUShort(), t = new Array(e), r = 0; r < e; r++)t[r] = this.parseValueRecord(n); return t }; be.prototype.parsePointer = function (n) { var e = this.parseOffset16(); if (e > 0) return new be(this.data, this.offset + e).parseStruct(n) }; be.prototype.parsePointer32 = function (n) { var e = this.parseOffset32(); if (e > 0) return new be(this.data, this.offset + e).parseStruct(n) }; be.prototype.parseListOfLists = function (n) { for (var e = this.parseOffset16List(), t = e.length, r = this.relativeOffset, i = new Array(t), s = 0; s < t; s++) { var a = e[s]; if (a === 0) { i[s] = void 0; continue } if (this.relativeOffset = a, n) { for (var o = this.parseOffset16List(), l = new Array(o.length), u = 0; u < o.length; u++)this.relativeOffset = a + o[u], l[u] = n.call(this); i[s] = l } else i[s] = this.parseUShortList() } return this.relativeOffset = r, i }; be.prototype.parseCoverage = function () { var n = this.offset + this.relativeOffset, e = this.parseUShort(), t = this.parseUShort(); if (e === 1) return { format: 1, glyphs: this.parseUShortList(t) }; if (e === 2) { for (var r = new Array(t), i = 0; i < t; i++)r[i] = { start: this.parseUShort(), end: this.parseUShort(), index: this.parseUShort() }; return { format: 2, ranges: r } } throw new Error("0x" + n.toString(16) + ": Coverage format must be 1 or 2.") }; be.prototype.parseClassDef = function () { var n = this.offset + this.relativeOffset, e = this.parseUShort(); if (e === 1) return { format: 1, startGlyph: this.parseUShort(), classes: this.parseUShortList() }; if (e === 2) return { format: 2, ranges: this.parseRecordList({ start: be.uShort, end: be.uShort, classId: be.uShort }) }; throw new Error("0x" + n.toString(16) + ": ClassDef format must be 1 or 2.") }; be.list = function (n, e) { return function () { return this.parseList(n, e) } }; be.list32 = function (n, e) { return function () { return this.parseList32(n, e) } }; be.recordList = function (n, e) { return function () { return this.parseRecordList(n, e) } }; be.recordList32 = function (n, e) { return function () { return this.parseRecordList32(n, e) } }; be.pointer = function (n) { return function () { return this.parsePointer(n) } }; be.pointer32 = function (n) { return function () { return this.parsePointer32(n) } }; be.tag = be.prototype.parseTag; be.byte = be.prototype.parseByte; be.uShort = be.offset16 = be.prototype.parseUShort; be.uShortList = be.prototype.parseUShortList; be.uLong = be.offset32 = be.prototype.parseULong; be.uLongList = be.prototype.parseULongList; be.struct = be.prototype.parseStruct; be.coverage = be.prototype.parseCoverage; be.classDef = be.prototype.parseClassDef; var cR = { reserved: be.uShort, reqFeatureIndex: be.uShort, featureIndexes: be.uShortList }; be.prototype.parseScriptList = function () { return this.parsePointer(be.recordList({ tag: be.tag, script: be.pointer({ defaultLangSys: be.pointer(cR), langSysRecords: be.recordList({ tag: be.tag, langSys: be.pointer(cR) }) }) })) || [] }; be.prototype.parseFeatureList = function () { return this.parsePointer(be.recordList({ tag: be.tag, feature: be.pointer({ featureParams: be.offset16, lookupListIndexes: be.uShortList }) })) || [] }; be.prototype.parseLookupList = function (n) { return this.parsePointer(be.list(be.pointer(function () { var e = this.parseUShort(); An.argument(1 <= e && e <= 9, "GPOS/GSUB lookup type " + e + " unknown."); var t = this.parseUShort(), r = t & 16; return { lookupType: e, lookupFlag: t, subtables: this.parseList(be.pointer(n[e])), markFilteringSet: r ? this.parseUShort() : void 0 } }))) || [] }; be.prototype.parseFeatureVariationsList = function () { return this.parsePointer32(function () { var n = this.parseUShort(), e = this.parseUShort(); An.argument(n === 1 && e < 1, "GPOS/GSUB feature variations table unknown."); var t = this.parseRecordList32({ conditionSetOffset: be.offset32, featureTableSubstitutionOffset: be.offset32 }); return t }) || [] }; var En = { getByte: uR, getCard8: uR, getUShort: my, getCard16: my, getShort: hie, getULong: ET, getFixed: mG, getTag: die, getOffset: pie, getBytes: mie, bytesToString: gie, Parser: be }; function vie(n, e) { e.parseUShort(), n.length = e.parseULong(), n.language = e.parseULong(); var t; n.groupCount = t = e.parseULong(), n.glyphIndexMap = {}; for (var r = 0; r < t; r += 1)for (var i = e.parseULong(), s = e.parseULong(), a = e.parseULong(), o = i; o <= s; o += 1)n.glyphIndexMap[o] = a, a++ } function yie(n, e, t, r, i) { n.length = e.parseUShort(), n.language = e.parseUShort(); var s; n.segCount = s = e.parseUShort() >> 1, e.skip("uShort", 3), n.glyphIndexMap = {}; for (var a = new En.Parser(t, r + i + 14), o = new En.Parser(t, r + i + 16 + s * 2), l = new En.Parser(t, r + i + 16 + s * 4), u = new En.Parser(t, r + i + 16 + s * 6), c = r + i + 16 + s * 8, h = 0; h < s - 1; h += 1)for (var d = void 0, m = a.parseUShort(), g = o.parseUShort(), v = l.parseShort(), y = u.parseUShort(), A = g; A <= m; A += 1)y !== 0 ? (c = u.offset + u.relativeOffset - 2, c += y, c += (A - g) * 2, d = En.getUShort(t, c), d !== 0 && (d = d + v & 65535)) : d = A + v & 65535, n.glyphIndexMap[A] = d } function xie(n, e) { var t = {}; t.version = En.getUShort(n, e), An.argument(t.version === 0, "cmap table version should be 0."), t.numTables = En.getUShort(n, e + 2); for (var r = -1, i = t.numTables - 1; i >= 0; i -= 1) { var s = En.getUShort(n, e + 4 + i * 8), a = En.getUShort(n, e + 4 + i * 8 + 2); if (s === 3 && (a === 0 || a === 1 || a === 10) || s === 0 && (a === 0 || a === 1 || a === 2 || a === 3 || a === 4)) { r = En.getULong(n, e + 4 + i * 8 + 4); break } } if (r === -1) throw new Error("No valid cmap sub-tables found."); var o = new En.Parser(n, e + r); if (t.format = o.parseUShort(), t.format === 12) vie(t, o); else if (t.format === 4) yie(t, o, n, e, r); else throw new Error("Only format 4 and 12 cmap tables are supported (found format " + t.format + ")."); return t } function _ie(n, e, t) { n.segments.push({ end: e, start: e, delta: -(e - t), offset: 0, glyphIndex: t }) } function Eie(n) { n.segments.push({ end: 65535, start: 65535, delta: 1, offset: 0 }) } function Cie(n) { var e = !0, t; for (t = n.length - 1; t > 0; t -= 1) { var r = n.get(t); if (r.unicode > 65535) { console.log("Adding CMAP format 12 (needed!)"), e = !1; break } } var i = [{ name: "version", type: "USHORT", value: 0 }, { name: "numTables", type: "USHORT", value: e ? 1 : 2 }, { name: "platformID", type: "USHORT", value: 3 }, { name: "encodingID", type: "USHORT", value: 1 }, { name: "offset", type: "ULONG", value: e ? 12 : 12 + 8 }]; e || (i = i.concat([{ name: "cmap12PlatformID", type: "USHORT", value: 3 }, { name: "cmap12EncodingID", type: "USHORT", value: 10 }, { name: "cmap12Offset", type: "ULONG", value: 0 }])), i = i.concat([{ name: "format", type: "USHORT", value: 4 }, { name: "cmap4Length", type: "USHORT", value: 0 }, { name: "language", type: "USHORT", value: 0 }, { name: "segCountX2", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]); var s = new Rt.Table("cmap", i); for (s.segments = [], t = 0; t < n.length; t += 1) { for (var a = n.get(t), o = 0; o < a.unicodes.length; o += 1)_ie(s, a.unicodes[o], t); s.segments = s.segments.sort(function (_, x) { return _.start - x.start }) } Eie(s); var l = s.segments.length, u = 0, c = [], h = [], d = [], m = [], g = [], v = []; for (t = 0; t < l; t += 1) { var y = s.segments[t]; y.end <= 65535 && y.start <= 65535 ? (c = c.concat({ name: "end_" + t, type: "USHORT", value: y.end }), h = h.concat({ name: "start_" + t, type: "USHORT", value: y.start }), d = d.concat({ name: "idDelta_" + t, type: "SHORT", value: y.delta }), m = m.concat({ name: "idRangeOffset_" + t, type: "USHORT", value: y.offset }), y.glyphId !== void 0 && (g = g.concat({ name: "glyph_" + t, type: "USHORT", value: y.glyphId }))) : u += 1, !e && y.glyphIndex !== void 0 && (v = v.concat({ name: "cmap12Start_" + t, type: "ULONG", value: y.start }), v = v.concat({ name: "cmap12End_" + t, type: "ULONG", value: y.end }), v = v.concat({ name: "cmap12Glyph_" + t, type: "ULONG", value: y.glyphIndex })) } if (s.segCountX2 = (l - u) * 2, s.searchRange = Math.pow(2, Math.floor(Math.log(l - u) / Math.log(2))) * 2, s.entrySelector = Math.log(s.searchRange / 2) / Math.log(2), s.rangeShift = s.segCountX2 - s.searchRange, s.fields = s.fields.concat(c), s.fields.push({ name: "reservedPad", type: "USHORT", value: 0 }), s.fields = s.fields.concat(h), s.fields = s.fields.concat(d), s.fields = s.fields.concat(m), s.fields = s.fields.concat(g), s.cmap4Length = 14 + c.length * 2 + 2 + h.length * 2 + d.length * 2 + m.length * 2 + g.length * 2, !e) { var A = 16 + v.length * 4; s.cmap12Offset = 12 + 2 * 2 + 4 + s.cmap4Length, s.fields = s.fields.concat([{ name: "cmap12Format", type: "USHORT", value: 12 }, { name: "cmap12Reserved", type: "USHORT", value: 0 }, { name: "cmap12Length", type: "ULONG", value: A }, { name: "cmap12Language", type: "ULONG", value: 0 }, { name: "cmap12nGroups", type: "ULONG", value: v.length / 3 }]), s.fields = s.fields.concat(v) } return s } var Sie = { parse: xie, make: Cie }, c6 = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "266 ff", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], Tie = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"], wie = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], fR = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"]; function gG(n) { this.font = n } gG.prototype.charToGlyphIndex = function (n) { var e = n.codePointAt(0), t = this.font.glyphs; if (t) { for (var r = 0; r < t.length; r += 1)for (var i = t.get(r), s = 0; s < i.unicodes.length; s += 1)if (i.unicodes[s] === e) return r } return null }; function gy(n, e) { this.encoding = n, this.charset = e } gy.prototype.charToGlyphIndex = function (n) { var e = n.codePointAt(0), t = this.encoding[e]; return this.charset.indexOf(t) }; function Iie(n, e, t, r, i) { n.beginPath(), n.moveTo(e, t), n.lineTo(r, i), n.stroke() } var Cd = { line: Iie }; function Mie(n, e) { var t = e || new Ts; return { configurable: !0, get: function () { return typeof t == "function" && (t = t()), t }, set: function (r) { t = r } } } function Nl(n) { this.bindConstructorValues(n) } Nl.prototype.bindConstructorValues = function (n) { this.index = n.index || 0, this.name = n.name || null, this.unicode = n.unicode || void 0, this.unicodes = n.unicodes || n.unicode !== void 0 ? [n.unicode] : [], "xMin" in n && (this.xMin = n.xMin), "yMin" in n && (this.yMin = n.yMin), "xMax" in n && (this.xMax = n.xMax), "yMax" in n && (this.yMax = n.yMax), "advanceWidth" in n && (this.advanceWidth = n.advanceWidth), Object.defineProperty(this, "path", Mie(this, n.path)) }; Nl.prototype.addUnicode = function (n) { this.unicodes.length === 0 && (this.unicode = n), this.unicodes.push(n) }; Nl.prototype.getBoundingBox = function () { return this.path.getBoundingBox() }; Nl.prototype.getPath = function (n, e, t, r, i) { n = n !== void 0 ? n : 0, e = e !== void 0 ? e : 0, t = t !== void 0 ? t : 72; var s, a; r || (r = {}); var o = r.xScale, l = r.yScale; if (r.hinting && i && i.hinting && (a = this.path && i.hinting.exec(this, t)), a) s = i.hinting.getCommands(a), n = Math.round(n), e = Math.round(e), o = l = 1; else { s = this.path.commands; var u = 1 / (this.path.unitsPerEm || 1e3) * t; o === void 0 && (o = u), l === void 0 && (l = u) } for (var c = new Ts, h = 0; h < s.length; h += 1) { var d = s[h]; d.type === "M" ? c.moveTo(n + d.x * o, e + -d.y * l) : d.type === "L" ? c.lineTo(n + d.x * o, e + -d.y * l) : d.type === "Q" ? c.quadraticCurveTo(n + d.x1 * o, e + -d.y1 * l, n + d.x * o, e + -d.y * l) : d.type === "C" ? c.curveTo(n + d.x1 * o, e + -d.y1 * l, n + d.x2 * o, e + -d.y2 * l, n + d.x * o, e + -d.y * l) : d.type === "Z" && c.closePath() } return c }; Nl.prototype.getContours = function () { if (this.points === void 0) return []; for (var n = [], e = [], t = 0; t < this.points.length; t += 1) { var r = this.points[t]; e.push(r), r.lastPointOfContour && (n.push(e), e = []) } return An.argument(e.length === 0, "There are still points left in the current contour."), n }; Nl.prototype.getMetrics = function () { for (var n = this.path.commands, e = [], t = [], r = 0; r < n.length; r += 1) { var i = n[r]; i.type !== "Z" && (e.push(i.x), t.push(i.y)), (i.type === "Q" || i.type === "C") && (e.push(i.x1), t.push(i.y1)), i.type === "C" && (e.push(i.x2), t.push(i.y2)) } var s = { xMin: Math.min.apply(null, e), yMin: Math.min.apply(null, t), xMax: Math.max.apply(null, e), yMax: Math.max.apply(null, t), leftSideBearing: this.leftSideBearing }; return isFinite(s.xMin) || (s.xMin = 0), isFinite(s.xMax) || (s.xMax = this.advanceWidth), isFinite(s.yMin) || (s.yMin = 0), isFinite(s.yMax) || (s.yMax = 0), s.rightSideBearing = this.advanceWidth - s.leftSideBearing - (s.xMax - s.xMin), s }; Nl.prototype.draw = function (n, e, t, r, i) { this.getPath(e, t, r, i).draw(n) }; Nl.prototype.drawPoints = function (n, e, t, r) { function i(h, d, m, g) { n.beginPath(); for (var v = 0; v < h.length; v += 1)n.moveTo(d + h[v].x * g, m + h[v].y * g), n.arc(d + h[v].x * g, m + h[v].y * g, 2, 0, Math.PI * 2, !1); n.closePath(), n.fill() } e = e !== void 0 ? e : 0, t = t !== void 0 ? t : 0, r = r !== void 0 ? r : 24; for (var s = 1 / this.path.unitsPerEm * r, a = [], o = [], l = this.path, u = 0; u < l.commands.length; u += 1) { var c = l.commands[u]; c.x !== void 0 && a.push({ x: c.x, y: -c.y }), c.x1 !== void 0 && o.push({ x: c.x1, y: -c.y1 }), c.x2 !== void 0 && o.push({ x: c.x2, y: -c.y2 }) } n.fillStyle = "blue", i(a, e, t, s), n.fillStyle = "red", i(o, e, t, s) }; Nl.prototype.drawMetrics = function (n, e, t, r) { var i; e = e !== void 0 ? e : 0, t = t !== void 0 ? t : 0, r = r !== void 0 ? r : 24, i = 1 / this.path.unitsPerEm * r, n.lineWidth = 1, n.strokeStyle = "black", Cd.line(n, e, -1e4, e, 1e4), Cd.line(n, -1e4, t, 1e4, t); var s = this.xMin || 0, a = this.yMin || 0, o = this.xMax || 0, l = this.yMax || 0, u = this.advanceWidth || 0; n.strokeStyle = "blue", Cd.line(n, e + s * i, -1e4, e + s * i, 1e4), Cd.line(n, e + o * i, -1e4, e + o * i, 1e4), Cd.line(n, -1e4, t + -a * i, 1e4, t + -a * i), Cd.line(n, -1e4, t + -l * i, 1e4, t + -l * i), n.strokeStyle = "green", Cd.line(n, e + u * i, -1e4, e + u * i, 1e4) }; function m5(n, e, t) { Object.defineProperty(n, e, { get: function () { return n.path, n[t] }, set: function (r) { n[t] = r }, enumerable: !0, configurable: !0 }) } function CT(n, e) { if (this.font = n, this.glyphs = {}, Array.isArray(e)) for (var t = 0; t < e.length; t++) { var r = e[t]; r.path.unitsPerEm = n.unitsPerEm, this.glyphs[t] = r } this.length = e && e.length || 0 } CT.prototype.get = function (n) { if (this.glyphs[n] === void 0) { this.font._push(n), typeof this.glyphs[n] == "function" && (this.glyphs[n] = this.glyphs[n]()); var e = this.glyphs[n], t = this.font._IndexToUnicodeMap[n]; if (t) for (var r = 0; r < t.unicodes.length; r++)e.addUnicode(t.unicodes[r]); this.font.cffEncoding ? this.font.isCIDFont ? e.name = "gid" + n : e.name = this.font.cffEncoding.charset[n] : this.font.glyphNames.names && (e.name = this.font.glyphNames.glyphIndexToName(n)), this.glyphs[n].advanceWidth = this.font._hmtxTableData[n].advanceWidth, this.glyphs[n].leftSideBearing = this.font._hmtxTableData[n].leftSideBearing } else typeof this.glyphs[n] == "function" && (this.glyphs[n] = this.glyphs[n]()); return this.glyphs[n] }; CT.prototype.push = function (n, e) { this.glyphs[n] = e, this.length++ }; function bie(n, e) { return new Nl({ index: e, font: n }) } function Bie(n, e, t, r, i, s) { return function () { var a = new Nl({ index: e, font: n }); return a.path = function () { t(a, r, i); var o = s(n.glyphs, a); return o.unitsPerEm = n.unitsPerEm, o }, m5(a, "xMin", "_xMin"), m5(a, "xMax", "_xMax"), m5(a, "yMin", "_yMin"), m5(a, "yMax", "_yMax"), a } } function Rie(n, e, t, r) { return function () { var i = new Nl({ index: e, font: n }); return i.path = function () { var s = t(n, i, r); return s.unitsPerEm = n.unitsPerEm, s }, i } } var uc = { GlyphSet: CT, glyphLoader: bie, ttfGlyphLoader: Bie, cffGlyphLoader: Rie }; function AG(n, e) { if (n === e) return !0; if (Array.isArray(n) && Array.isArray(e)) { if (n.length !== e.length) return !1; for (var t = 0; t < n.length; t += 1)if (!AG(n[t], e[t])) return !1; return !0 } else return !1 } function C7(n) { var e; return n.length < 1240 ? e = 107 : n.length < 33900 ? e = 1131 : e = 32768, e } function Kf(n, e, t) { var r = [], i = [], s = En.getCard16(n, e), a, o; if (s !== 0) { var l = En.getByte(n, e + 2); a = e + (s + 1) * l + 2; for (var u = e + 3, c = 0; c < s + 1; c += 1)r.push(En.getOffset(n, u, l)), u += l; o = a + r[s] } else o = e + 2; for (var h = 0; h < r.length - 1; h += 1) { var d = En.getBytes(n, a + r[h], a + r[h + 1]); t && (d = t(d)), i.push(d) } return { objects: i, startOffset: e, endOffset: o } } function Pie(n, e) { var t = [], r = En.getCard16(n, e), i, s; if (r !== 0) { var a = En.getByte(n, e + 2); i = e + (r + 1) * a + 2; for (var o = e + 3, l = 0; l < r + 1; l += 1)t.push(En.getOffset(n, o, a)), o += a; s = i + t[r] } else s = e + 2; return { offsets: t, startOffset: e, endOffset: s } } function Die(n, e, t, r, i) { var s = En.getCard16(t, r), a = 0; if (s !== 0) { var o = En.getByte(t, r + 2); a = r + (s + 1) * o + 2 } var l = En.getBytes(t, a + e[n], a + e[n + 1]); return i && (l = i(l)), l } function Lie(n) { for (var e = "", t = 15, r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"]; ;) { var i = n.parseByte(), s = i >> 4, a = i & 15; if (s === t || (e += r[s], a === t)) break; e += r[a] } return parseFloat(e) } function Fie(n, e) { var t, r, i, s; if (e === 28) return t = n.parseByte(), r = n.parseByte(), t << 8 | r; if (e === 29) return t = n.parseByte(), r = n.parseByte(), i = n.parseByte(), s = n.parseByte(), t << 24 | r << 16 | i << 8 | s; if (e === 30) return Lie(n); if (e >= 32 && e <= 246) return e - 139; if (e >= 247 && e <= 250) return t = n.parseByte(), (e - 247) * 256 + t + 108; if (e >= 251 && e <= 254) return t = n.parseByte(), -(e - 251) * 256 - t - 108; throw new Error("Invalid b0 " + e) } function kie(n) { for (var e = {}, t = 0; t < n.length; t += 1) { var r = n[t][0], i = n[t][1], s = void 0; if (i.length === 1 ? s = i[0] : s = i, e.hasOwnProperty(r) && !isNaN(e[r])) throw new Error("Object " + e + " already has key " + r); e[r] = s } return e } function vG(n, e, t) { e = e !== void 0 ? e : 0; var r = new En.Parser(n, e), i = [], s = []; for (t = t !== void 0 ? t : n.length; r.relativeOffset < t;) { var a = r.parseByte(); a <= 21 ? (a === 12 && (a = 1200 + r.parseByte()), i.push([a, s]), s = []) : s.push(Fie(r, a)) } return kie(i) } function fA(n, e) { return e <= 390 ? e = c6[e] : e = n[e - 391], e } function yG(n, e, t) { for (var r = {}, i, s = 0; s < e.length; s += 1) { var a = e[s]; if (Array.isArray(a.type)) { var o = []; o.length = a.type.length; for (var l = 0; l < a.type.length; l++)i = n[a.op] !== void 0 ? n[a.op][l] : void 0, i === void 0 && (i = a.value !== void 0 && a.value[l] !== void 0 ? a.value[l] : null), a.type[l] === "SID" && (i = fA(t, i)), o[l] = i; r[a.name] = o } else i = n[a.op], i === void 0 && (i = a.value !== void 0 ? a.value : null), a.type === "SID" && (i = fA(t, i)), r[a.name] = i } return r } function Nie(n, e) { var t = {}; return t.formatMajor = En.getCard8(n, e), t.formatMinor = En.getCard8(n, e + 1), t.size = En.getCard8(n, e + 2), t.offsetSize = En.getCard8(n, e + 3), t.startOffset = e, t.endOffset = e + 4, t } var xG = [{ name: "version", op: 0, type: "SID" }, { name: "notice", op: 1, type: "SID" }, { name: "copyright", op: 1200, type: "SID" }, { name: "fullName", op: 2, type: "SID" }, { name: "familyName", op: 3, type: "SID" }, { name: "weight", op: 4, type: "SID" }, { name: "isFixedPitch", op: 1201, type: "number", value: 0 }, { name: "italicAngle", op: 1202, type: "number", value: 0 }, { name: "underlinePosition", op: 1203, type: "number", value: -100 }, { name: "underlineThickness", op: 1204, type: "number", value: 50 }, { name: "paintType", op: 1205, type: "number", value: 0 }, { name: "charstringType", op: 1206, type: "number", value: 2 }, { name: "fontMatrix", op: 1207, type: ["real", "real", "real", "real", "real", "real"], value: [.001, 0, 0, .001, 0, 0] }, { name: "uniqueId", op: 13, type: "number" }, { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] }, { name: "strokeWidth", op: 1208, type: "number", value: 0 }, { name: "xuid", op: 14, type: [], value: null }, { name: "charset", op: 15, type: "offset", value: 0 }, { name: "encoding", op: 16, type: "offset", value: 0 }, { name: "charStrings", op: 17, type: "offset", value: 0 }, { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] }, { name: "ros", op: 1230, type: ["SID", "SID", "number"] }, { name: "cidFontVersion", op: 1231, type: "number", value: 0 }, { name: "cidFontRevision", op: 1232, type: "number", value: 0 }, { name: "cidFontType", op: 1233, type: "number", value: 0 }, { name: "cidCount", op: 1234, type: "number", value: 8720 }, { name: "uidBase", op: 1235, type: "number" }, { name: "fdArray", op: 1236, type: "offset" }, { name: "fdSelect", op: 1237, type: "offset" }, { name: "fontName", op: 1238, type: "SID" }], _G = [{ name: "subrs", op: 19, type: "offset", value: 0 }, { name: "defaultWidthX", op: 20, type: "number", value: 0 }, { name: "nominalWidthX", op: 21, type: "number", value: 0 }]; function Oie(n, e) { var t = vG(n, 0, n.byteLength); return yG(t, xG, e) } function EG(n, e, t, r) { var i = vG(n, e, t); return yG(i, _G, r) } function hR(n, e, t, r) { for (var i = [], s = 0; s < t.length; s += 1) { var a = new DataView(new Uint8Array(t[s]).buffer), o = Oie(a, r); o._subrs = [], o._subrsBias = 0, o._defaultWidthX = 0, o._nominalWidthX = 0; var l = o.private[0], u = o.private[1]; if (l !== 0 && u !== 0) { var c = EG(n, u + e, l, r); if (o._defaultWidthX = c.defaultWidthX, o._nominalWidthX = c.nominalWidthX, c.subrs !== 0) { var h = u + c.subrs, d = Kf(n, h + e); o._subrs = d.objects, o._subrsBias = C7(o._subrs) } o._privateDict = c } i.push(o) } return i } function Uie(n, e, t, r) { var i, s, a = new En.Parser(n, e); t -= 1; var o = [".notdef"], l = a.parseCard8(); if (l === 0) for (var u = 0; u < t; u += 1)i = a.parseSID(), o.push(fA(r, i)); else if (l === 1) for (; o.length <= t;) { i = a.parseSID(), s = a.parseCard8(); for (var c = 0; c <= s; c += 1)o.push(fA(r, i)), i += 1 } else if (l === 2) for (; o.length <= t;) { i = a.parseSID(), s = a.parseCard16(); for (var h = 0; h <= s; h += 1)o.push(fA(r, i)), i += 1 } else throw new Error("Unknown charset format " + l); return o } function Gie(n, e, t) { var r, i = {}, s = new En.Parser(n, e), a = s.parseCard8(); if (a === 0) for (var o = s.parseCard8(), l = 0; l < o; l += 1)r = s.parseCard8(), i[r] = l; else if (a === 1) { var u = s.parseCard8(); r = 1; for (var c = 0; c < u; c += 1)for (var h = s.parseCard8(), d = s.parseCard8(), m = h; m <= h + d; m += 1)i[m] = r, r += 1 } else throw new Error("Unknown encoding format " + a); return new gy(i, t) } function dR(n, e, t) { var r, i, s, a, o = new Ts, l = [], u = 0, c = !1, h = !1, d = 0, m = 0, g, v, y, A; if (n.isCIDFont) { var _ = n.tables.cff.topDict._fdSelect[e.index], x = n.tables.cff.topDict._fdArray[_]; g = x._subrs, v = x._subrsBias, y = x._defaultWidthX, A = x._nominalWidthX } else g = n.tables.cff.topDict._subrs, v = n.tables.cff.topDict._subrsBias, y = n.tables.cff.topDict._defaultWidthX, A = n.tables.cff.topDict._nominalWidthX; var C = y; function T(R, b) { h && o.closePath(), o.moveTo(R, b), h = !0 } function I() { var R; R = l.length % 2 !== 0, R && !c && (C = l.shift() + A), u += l.length >> 1, l.length = 0, c = !0 } function w(R) { for (var b, B, F, U, G, Y, Z, ne, $, L, Q, D, V = 0; V < R.length;) { var J = R[V]; switch (V += 1, J) { case 1: I(); break; case 3: I(); break; case 4: l.length > 1 && !c && (C = l.shift() + A, c = !0), m += l.pop(), T(d, m); break; case 5: for (; l.length > 0;)d += l.shift(), m += l.shift(), o.lineTo(d, m); break; case 6: for (; l.length > 0 && (d += l.shift(), o.lineTo(d, m), l.length !== 0);)m += l.shift(), o.lineTo(d, m); break; case 7: for (; l.length > 0 && (m += l.shift(), o.lineTo(d, m), l.length !== 0);)d += l.shift(), o.lineTo(d, m); break; case 8: for (; l.length > 0;)r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a + l.shift(), o.curveTo(r, i, s, a, d, m); break; case 10: G = l.pop() + v, Y = g[G], Y && w(Y); break; case 11: return; case 12: switch (J = R[V], V += 1, J) { case 35: r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), Z = s + l.shift(), ne = a + l.shift(), $ = Z + l.shift(), L = ne + l.shift(), Q = $ + l.shift(), D = L + l.shift(), d = Q + l.shift(), m = D + l.shift(), l.shift(), o.curveTo(r, i, s, a, Z, ne), o.curveTo($, L, Q, D, d, m); break; case 34: r = d + l.shift(), i = m, s = r + l.shift(), a = i + l.shift(), Z = s + l.shift(), ne = a, $ = Z + l.shift(), L = a, Q = $ + l.shift(), D = m, d = Q + l.shift(), o.curveTo(r, i, s, a, Z, ne), o.curveTo($, L, Q, D, d, m); break; case 36: r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), Z = s + l.shift(), ne = a, $ = Z + l.shift(), L = a, Q = $ + l.shift(), D = L + l.shift(), d = Q + l.shift(), o.curveTo(r, i, s, a, Z, ne), o.curveTo($, L, Q, D, d, m); break; case 37: r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), Z = s + l.shift(), ne = a + l.shift(), $ = Z + l.shift(), L = ne + l.shift(), Q = $ + l.shift(), D = L + l.shift(), Math.abs(Q - d) > Math.abs(D - m) ? d = Q + l.shift() : m = D + l.shift(), o.curveTo(r, i, s, a, Z, ne), o.curveTo($, L, Q, D, d, m); break; default: console.log("Glyph " + e.index + ": unknown operator 1200" + J), l.length = 0 }break; case 14: l.length > 0 && !c && (C = l.shift() + A, c = !0), h && (o.closePath(), h = !1); break; case 18: I(); break; case 19: case 20: I(), V += u + 7 >> 3; break; case 21: l.length > 2 && !c && (C = l.shift() + A, c = !0), m += l.pop(), d += l.pop(), T(d, m); break; case 22: l.length > 1 && !c && (C = l.shift() + A, c = !0), d += l.pop(), T(d, m); break; case 23: I(); break; case 24: for (; l.length > 2;)r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a + l.shift(), o.curveTo(r, i, s, a, d, m); d += l.shift(), m += l.shift(), o.lineTo(d, m); break; case 25: for (; l.length > 6;)d += l.shift(), m += l.shift(), o.lineTo(d, m); r = d + l.shift(), i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a + l.shift(), o.curveTo(r, i, s, a, d, m); break; case 26: for (l.length % 2 && (d += l.shift()); l.length > 0;)r = d, i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s, m = a + l.shift(), o.curveTo(r, i, s, a, d, m); break; case 27: for (l.length % 2 && (m += l.shift()); l.length > 0;)r = d + l.shift(), i = m, s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a, o.curveTo(r, i, s, a, d, m); break; case 28: b = R[V], B = R[V + 1], l.push((b << 24 | B << 16) >> 16), V += 2; break; case 29: G = l.pop() + n.gsubrsBias, Y = n.gsubrs[G], Y && w(Y); break; case 30: for (; l.length > 0 && (r = d, i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a + (l.length === 1 ? l.shift() : 0), o.curveTo(r, i, s, a, d, m), l.length !== 0);)r = d + l.shift(), i = m, s = r + l.shift(), a = i + l.shift(), m = a + l.shift(), d = s + (l.length === 1 ? l.shift() : 0), o.curveTo(r, i, s, a, d, m); break; case 31: for (; l.length > 0 && (r = d + l.shift(), i = m, s = r + l.shift(), a = i + l.shift(), m = a + l.shift(), d = s + (l.length === 1 ? l.shift() : 0), o.curveTo(r, i, s, a, d, m), l.length !== 0);)r = d, i = m + l.shift(), s = r + l.shift(), a = i + l.shift(), d = s + l.shift(), m = a + (l.length === 1 ? l.shift() : 0), o.curveTo(r, i, s, a, d, m); break; default: J < 32 ? console.log("Glyph " + e.index + ": unknown operator " + J) : J < 247 ? l.push(J - 139) : J < 251 ? (b = R[V], V += 1, l.push((J - 247) * 256 + b + 108)) : J < 255 ? (b = R[V], V += 1, l.push(-(J - 251) * 256 - b - 108)) : (b = R[V], B = R[V + 1], F = R[V + 2], U = R[V + 3], V += 4, l.push((b << 24 | B << 16 | F << 8 | U) / 65536)) } } } return w(t), e.advanceWidth = C, o } function Qie(n, e, t, r) { var i = [], s, a = new En.Parser(n, e), o = a.parseCard8(); if (o === 0) for (var l = 0; l < t; l++) { if (s = a.parseCard8(), s >= r) throw new Error("CFF table CID Font FDSelect has bad FD index value " + s + " (FD count " + r + ")"); i.push(s) } else if (o === 3) { var u = a.parseCard16(), c = a.parseCard16(); if (c !== 0) throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + c); for (var h, d = 0; d < u; d++) { if (s = a.parseCard8(), h = a.parseCard16(), s >= r) throw new Error("CFF table CID Font FDSelect has bad FD index value " + s + " (FD count " + r + ")"); if (h > t) throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + h); for (; c < h; c++)i.push(s); c = h } if (h !== t) throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + h) } else throw new Error("CFF Table CID Font FDSelect table has unsupported format " + o); return i } function Hie(n, e, t, r) { t.tables.cff = {}; var i = Nie(n, e), s = Kf(n, i.endOffset, En.bytesToString), a = Kf(n, s.endOffset), o = Kf(n, a.endOffset, En.bytesToString), l = Kf(n, o.endOffset); t.gsubrs = l.objects, t.gsubrsBias = C7(t.gsubrs); var u = hR(n, e, a.objects, o.objects); if (u.length !== 1) throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + u.length); var c = u[0]; if (t.tables.cff.topDict = c, c._privateDict && (t.defaultWidthX = c._privateDict.defaultWidthX, t.nominalWidthX = c._privateDict.nominalWidthX), c.ros[0] !== void 0 && c.ros[1] !== void 0 && (t.isCIDFont = !0), t.isCIDFont) { var h = c.fdArray, d = c.fdSelect; if (h === 0 || d === 0) throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing"); h += e; var m = Kf(n, h), g = hR(n, e, m.objects, o.objects); c._fdArray = g, d += e, c._fdSelect = Qie(n, d, t.numGlyphs, g.length) } var v = e + c.private[1], y = EG(n, v, c.private[0], o.objects); if (t.defaultWidthX = y.defaultWidthX, t.nominalWidthX = y.nominalWidthX, y.subrs !== 0) { var A = v + y.subrs, _ = Kf(n, A); t.subrs = _.objects, t.subrsBias = C7(t.subrs) } else t.subrs = [], t.subrsBias = 0; var x; r.lowMemory ? (x = Pie(n, e + c.charStrings), t.nGlyphs = x.offsets.length) : (x = Kf(n, e + c.charStrings), t.nGlyphs = x.objects.length); var C = Uie(n, e + c.charset, t.nGlyphs, o.objects); if (c.encoding === 0 ? t.cffEncoding = new gy(Tie, C) : c.encoding === 1 ? t.cffEncoding = new gy(wie, C) : t.cffEncoding = Gie(n, e + c.encoding, C), t.encoding = t.encoding || t.cffEncoding, t.glyphs = new uc.GlyphSet(t), r.lowMemory) t._push = function (w) { var R = Die(w, x.offsets, n, e + c.charStrings); t.glyphs.push(w, uc.cffGlyphLoader(t, w, dR, R)) }; else for (var T = 0; T < t.nGlyphs; T += 1) { var I = x.objects[T]; t.glyphs.push(T, uc.cffGlyphLoader(t, T, dR, I)) } } function CG(n, e) { var t, r = c6.indexOf(n); return r >= 0 && (t = r), r = e.indexOf(n), r >= 0 ? t = r + c6.length : (t = c6.length + e.length, e.push(n)), t } function zie() { return new Rt.Record("Header", [{ name: "major", type: "Card8", value: 1 }, { name: "minor", type: "Card8", value: 0 }, { name: "hdrSize", type: "Card8", value: 4 }, { name: "major", type: "Card8", value: 1 }]) } function Vie(n) { var e = new Rt.Record("Name INDEX", [{ name: "names", type: "INDEX", value: [] }]); e.names = []; for (var t = 0; t < n.length; t += 1)e.names.push({ name: "name_" + t, type: "NAME", value: n[t] }); return e } function SG(n, e, t) { for (var r = {}, i = 0; i < n.length; i += 1) { var s = n[i], a = e[s.name]; a !== void 0 && !AG(a, s.value) && (s.type === "SID" && (a = CG(a, t)), r[s.op] = { name: s.name, type: s.type, value: a }) } return r } function pR(n, e) { var t = new Rt.Record("Top DICT", [{ name: "dict", type: "DICT", value: {} }]); return t.dict = SG(xG, n, e), t } function mR(n) { var e = new Rt.Record("Top DICT INDEX", [{ name: "topDicts", type: "INDEX", value: [] }]); return e.topDicts = [{ name: "topDict_0", type: "TABLE", value: n }], e } function Wie(n) { var e = new Rt.Record("String INDEX", [{ name: "strings", type: "INDEX", value: [] }]); e.strings = []; for (var t = 0; t < n.length; t += 1)e.strings.push({ name: "string_" + t, type: "STRING", value: n[t] }); return e } function Xie() { return new Rt.Record("Global Subr INDEX", [{ name: "subrs", type: "INDEX", value: [] }]) } function Yie(n, e) { for (var t = new Rt.Record("Charsets", [{ name: "format", type: "Card8", value: 0 }]), r = 0; r < n.length; r += 1) { var i = n[r], s = CG(i, e); t.fields.push({ name: "glyph_" + r, type: "SID", value: s }) } return t } function jie(n) { var e = [], t = n.path; e.push({ name: "width", type: "NUMBER", value: n.advanceWidth }); for (var r = 0, i = 0, s = 0; s < t.commands.length; s += 1) { var a = void 0, o = void 0, l = t.commands[s]; if (l.type === "Q") { var u = .3333333333333333, c = 2 / 3; l = { type: "C", x: l.x, y: l.y, x1: Math.round(u * r + c * l.x1), y1: Math.round(u * i + c * l.y1), x2: Math.round(u * l.x + c * l.x1), y2: Math.round(u * l.y + c * l.y1) } } if (l.type === "M") a = Math.round(l.x - r), o = Math.round(l.y - i), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rmoveto", type: "OP", value: 21 }), r = Math.round(l.x), i = Math.round(l.y); else if (l.type === "L") a = Math.round(l.x - r), o = Math.round(l.y - i), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rlineto", type: "OP", value: 5 }), r = Math.round(l.x), i = Math.round(l.y); else if (l.type === "C") { var h = Math.round(l.x1 - r), d = Math.round(l.y1 - i), m = Math.round(l.x2 - l.x1), g = Math.round(l.y2 - l.y1); a = Math.round(l.x - l.x2), o = Math.round(l.y - l.y2), e.push({ name: "dx1", type: "NUMBER", value: h }), e.push({ name: "dy1", type: "NUMBER", value: d }), e.push({ name: "dx2", type: "NUMBER", value: m }), e.push({ name: "dy2", type: "NUMBER", value: g }), e.push({ name: "dx", type: "NUMBER", value: a }), e.push({ name: "dy", type: "NUMBER", value: o }), e.push({ name: "rrcurveto", type: "OP", value: 8 }), r = Math.round(l.x), i = Math.round(l.y) } } return e.push({ name: "endchar", type: "OP", value: 14 }), e } function Jie(n) { for (var e = new Rt.Record("CharStrings INDEX", [{ name: "charStrings", type: "INDEX", value: [] }]), t = 0; t < n.length; t += 1) { var r = n.get(t), i = jie(r); e.charStrings.push({ name: r.name, type: "CHARSTRING", value: i }) } return e } function Kie(n, e) { var t = new Rt.Record("Private DICT", [{ name: "dict", type: "DICT", value: {} }]); return t.dict = SG(_G, n, e), t } function qie(n, e) { for (var t = new Rt.Table("CFF ", [{ name: "header", type: "RECORD" }, { name: "nameIndex", type: "RECORD" }, { name: "topDictIndex", type: "RECORD" }, { name: "stringIndex", type: "RECORD" }, { name: "globalSubrIndex", type: "RECORD" }, { name: "charsets", type: "RECORD" }, { name: "charStringsIndex", type: "RECORD" }, { name: "privateDict", type: "RECORD" }]), r = 1 / e.unitsPerEm, i = { version: e.version, fullName: e.fullName, familyName: e.familyName, weight: e.weightName, fontBBox: e.fontBBox || [0, 0, 0, 0], fontMatrix: [r, 0, 0, r, 0, 0], charset: 999, encoding: 0, charStrings: 999, private: [0, 999] }, s = {}, a = [], o, l = 1; l < n.length; l += 1)o = n.get(l), a.push(o.name); var u = []; t.header = zie(), t.nameIndex = Vie([e.postScriptName]); var c = pR(i, u); t.topDictIndex = mR(c), t.globalSubrIndex = Xie(), t.charsets = Yie(a, u), t.charStringsIndex = Jie(n), t.privateDict = Kie(s, u), t.stringIndex = Wie(u); var h = t.header.sizeOf() + t.nameIndex.sizeOf() + t.topDictIndex.sizeOf() + t.stringIndex.sizeOf() + t.globalSubrIndex.sizeOf(); return i.charset = h, i.encoding = 0, i.charStrings = i.charset + t.charsets.sizeOf(), i.private[1] = i.charStrings + t.charStringsIndex.sizeOf(), c = pR(i, u), t.topDictIndex = mR(c), t } var Zie = { parse: Hie, make: qie }; function $ie(n, e) { var t = {}, r = new En.Parser(n, e); return t.version = r.parseVersion(), t.fontRevision = Math.round(r.parseFixed() * 1e3) / 1e3, t.checkSumAdjustment = r.parseULong(), t.magicNumber = r.parseULong(), An.argument(t.magicNumber === 1594834165, "Font header has wrong magic number."), t.flags = r.parseUShort(), t.unitsPerEm = r.parseUShort(), t.created = r.parseLongDateTime(), t.modified = r.parseLongDateTime(), t.xMin = r.parseShort(), t.yMin = r.parseShort(), t.xMax = r.parseShort(), t.yMax = r.parseShort(), t.macStyle = r.parseUShort(), t.lowestRecPPEM = r.parseUShort(), t.fontDirectionHint = r.parseShort(), t.indexToLocFormat = r.parseShort(), t.glyphDataFormat = r.parseShort(), t } function ese(n) { var e = Math.round(new Date().getTime() / 1e3) + 2082844800, t = e; return n.createdTimestamp && (t = n.createdTimestamp + 2082844800), new Rt.Table("head", [{ name: "version", type: "FIXED", value: 65536 }, { name: "fontRevision", type: "FIXED", value: 65536 }, { name: "checkSumAdjustment", type: "ULONG", value: 0 }, { name: "magicNumber", type: "ULONG", value: 1594834165 }, { name: "flags", type: "USHORT", value: 0 }, { name: "unitsPerEm", type: "USHORT", value: 1e3 }, { name: "created", type: "LONGDATETIME", value: t }, { name: "modified", type: "LONGDATETIME", value: e }, { name: "xMin", type: "SHORT", value: 0 }, { name: "yMin", type: "SHORT", value: 0 }, { name: "xMax", type: "SHORT", value: 0 }, { name: "yMax", type: "SHORT", value: 0 }, { name: "macStyle", type: "USHORT", value: 0 }, { name: "lowestRecPPEM", type: "USHORT", value: 0 }, { name: "fontDirectionHint", type: "SHORT", value: 2 }, { name: "indexToLocFormat", type: "SHORT", value: 0 }, { name: "glyphDataFormat", type: "SHORT", value: 0 }], n) } var tse = { parse: $ie, make: ese }; function nse(n, e) { var t = {}, r = new En.Parser(n, e); return t.version = r.parseVersion(), t.ascender = r.parseShort(), t.descender = r.parseShort(), t.lineGap = r.parseShort(), t.advanceWidthMax = r.parseUShort(), t.minLeftSideBearing = r.parseShort(), t.minRightSideBearing = r.parseShort(), t.xMaxExtent = r.parseShort(), t.caretSlopeRise = r.parseShort(), t.caretSlopeRun = r.parseShort(), t.caretOffset = r.parseShort(), r.relativeOffset += 8, t.metricDataFormat = r.parseShort(), t.numberOfHMetrics = r.parseUShort(), t } function rse(n) { return new Rt.Table("hhea", [{ name: "version", type: "FIXED", value: 65536 }, { name: "ascender", type: "FWORD", value: 0 }, { name: "descender", type: "FWORD", value: 0 }, { name: "lineGap", type: "FWORD", value: 0 }, { name: "advanceWidthMax", type: "UFWORD", value: 0 }, { name: "minLeftSideBearing", type: "FWORD", value: 0 }, { name: "minRightSideBearing", type: "FWORD", value: 0 }, { name: "xMaxExtent", type: "FWORD", value: 0 }, { name: "caretSlopeRise", type: "SHORT", value: 1 }, { name: "caretSlopeRun", type: "SHORT", value: 0 }, { name: "caretOffset", type: "SHORT", value: 0 }, { name: "reserved1", type: "SHORT", value: 0 }, { name: "reserved2", type: "SHORT", value: 0 }, { name: "reserved3", type: "SHORT", value: 0 }, { name: "reserved4", type: "SHORT", value: 0 }, { name: "metricDataFormat", type: "SHORT", value: 0 }, { name: "numberOfHMetrics", type: "USHORT", value: 0 }], n) } var ise = { parse: nse, make: rse }; function sse(n, e, t, r, i) { for (var s, a, o = new En.Parser(n, e), l = 0; l < r; l += 1) { l < t && (s = o.parseUShort(), a = o.parseShort()); var u = i.get(l); u.advanceWidth = s, u.leftSideBearing = a } } function ase(n, e, t, r, i) { n._hmtxTableData = {}; for (var s, a, o = new En.Parser(e, t), l = 0; l < i; l += 1)l < r && (s = o.parseUShort(), a = o.parseShort()), n._hmtxTableData[l] = { advanceWidth: s, leftSideBearing: a } } function ose(n, e, t, r, i, s, a) { a.lowMemory ? ase(n, e, t, r, i) : sse(e, t, r, i, s) } function lse(n) { for (var e = new Rt.Table("hmtx", []), t = 0; t < n.length; t += 1) { var r = n.get(t), i = r.advanceWidth || 0, s = r.leftSideBearing || 0; e.fields.push({ name: "advanceWidth_" + t, type: "USHORT", value: i }), e.fields.push({ name: "leftSideBearing_" + t, type: "SHORT", value: s }) } return e } var use = { parse: ose, make: lse }; function cse(n) { for (var e = new Rt.Table("ltag", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "numTags", type: "ULONG", value: n.length }]), t = "", r = 12 + n.length * 4, i = 0; i < n.length; ++i) { var s = t.indexOf(n[i]); s < 0 && (s = t.length, t += n[i]), e.fields.push({ name: "offset " + i, type: "USHORT", value: r + s }), e.fields.push({ name: "length " + i, type: "USHORT", value: n[i].length }) } return e.fields.push({ name: "stringPool", type: "CHARARRAY", value: t }), e } function fse(n, e) { var t = new En.Parser(n, e), r = t.parseULong(); An.argument(r === 1, "Unsupported ltag table version."), t.skip("uLong", 1); for (var i = t.parseULong(), s = [], a = 0; a < i; a++) { for (var o = "", l = e + t.parseUShort(), u = t.parseUShort(), c = l; c < l + u; ++c)o += String.fromCharCode(n.getInt8(c)); s.push(o) } return s } var hse = { make: cse, parse: fse }; function dse(n, e) { var t = {}, r = new En.Parser(n, e); return t.version = r.parseVersion(), t.numGlyphs = r.parseUShort(), t.version === 1 && (t.maxPoints = r.parseUShort(), t.maxContours = r.parseUShort(), t.maxCompositePoints = r.parseUShort(), t.maxCompositeContours = r.parseUShort(), t.maxZones = r.parseUShort(), t.maxTwilightPoints = r.parseUShort(), t.maxStorage = r.parseUShort(), t.maxFunctionDefs = r.parseUShort(), t.maxInstructionDefs = r.parseUShort(), t.maxStackElements = r.parseUShort(), t.maxSizeOfInstructions = r.parseUShort(), t.maxComponentElements = r.parseUShort(), t.maxComponentDepth = r.parseUShort()), t } function pse(n) { return new Rt.Table("maxp", [{ name: "version", type: "FIXED", value: 20480 }, { name: "numGlyphs", type: "USHORT", value: n }]) } var mse = { parse: dse, make: pse }, TG = ["copyright", "fontFamily", "fontSubfamily", "uniqueID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "manufacturerURL", "designerURL", "license", "licenseURL", "reserved", "preferredFamily", "preferredSubfamily", "compatibleFullName", "sampleText", "postScriptFindFontName", "wwsFamily", "wwsSubfamily"], wG = { 0: "en", 1: "fr", 2: "de", 3: "it", 4: "nl", 5: "sv", 6: "es", 7: "da", 8: "pt", 9: "no", 10: "he", 11: "ja", 12: "ar", 13: "fi", 14: "el", 15: "is", 16: "mt", 17: "tr", 18: "hr", 19: "zh-Hant", 20: "ur", 21: "hi", 22: "th", 23: "ko", 24: "lt", 25: "pl", 26: "hu", 27: "es", 28: "lv", 29: "se", 30: "fo", 31: "fa", 32: "ru", 33: "zh", 34: "nl-BE", 35: "ga", 36: "sq", 37: "ro", 38: "cz", 39: "sk", 40: "si", 41: "yi", 42: "sr", 43: "mk", 44: "bg", 45: "uk", 46: "be", 47: "uz", 48: "kk", 49: "az-Cyrl", 50: "az-Arab", 51: "hy", 52: "ka", 53: "mo", 54: "ky", 55: "tg", 56: "tk", 57: "mn-CN", 58: "mn", 59: "ps", 60: "ks", 61: "ku", 62: "sd", 63: "bo", 64: "ne", 65: "sa", 66: "mr", 67: "bn", 68: "as", 69: "gu", 70: "pa", 71: "or", 72: "ml", 73: "kn", 74: "ta", 75: "te", 76: "si", 77: "my", 78: "km", 79: "lo", 80: "vi", 81: "id", 82: "tl", 83: "ms", 84: "ms-Arab", 85: "am", 86: "ti", 87: "om", 88: "so", 89: "sw", 90: "rw", 91: "rn", 92: "ny", 93: "mg", 94: "eo", 128: "cy", 129: "eu", 130: "ca", 131: "la", 132: "qu", 133: "gn", 134: "ay", 135: "tt", 136: "ug", 137: "dz", 138: "jv", 139: "su", 140: "gl", 141: "af", 142: "br", 143: "iu", 144: "gd", 145: "gv", 146: "ga", 147: "to", 148: "el-polyton", 149: "kl", 150: "az", 151: "nn" }, gse = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 5, 11: 1, 12: 4, 13: 0, 14: 6, 15: 0, 16: 0, 17: 0, 18: 0, 19: 2, 20: 4, 21: 9, 22: 21, 23: 3, 24: 29, 25: 29, 26: 29, 27: 29, 28: 29, 29: 0, 30: 0, 31: 4, 32: 7, 33: 25, 34: 0, 35: 0, 36: 0, 37: 0, 38: 29, 39: 29, 40: 0, 41: 5, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 47: 7, 48: 7, 49: 7, 50: 4, 51: 24, 52: 23, 53: 7, 54: 7, 55: 7, 56: 7, 57: 27, 58: 7, 59: 4, 60: 4, 61: 4, 62: 4, 63: 26, 64: 9, 65: 9, 66: 9, 67: 13, 68: 13, 69: 11, 70: 10, 71: 12, 72: 17, 73: 16, 74: 14, 75: 15, 76: 18, 77: 19, 78: 20, 79: 22, 80: 30, 81: 0, 82: 0, 83: 0, 84: 4, 85: 28, 86: 28, 87: 28, 88: 0, 89: 0, 90: 0, 91: 0, 92: 0, 93: 0, 94: 0, 128: 0, 129: 0, 130: 0, 131: 0, 132: 0, 133: 0, 134: 0, 135: 7, 136: 4, 137: 26, 138: 0, 139: 0, 140: 0, 141: 0, 142: 0, 143: 28, 144: 0, 145: 0, 146: 0, 147: 0, 148: 6, 149: 0, 150: 0, 151: 0 }, IG = { 1078: "af", 1052: "sq", 1156: "gsw", 1118: "am", 5121: "ar-DZ", 15361: "ar-BH", 3073: "ar", 2049: "ar-IQ", 11265: "ar-JO", 13313: "ar-KW", 12289: "ar-LB", 4097: "ar-LY", 6145: "ary", 8193: "ar-OM", 16385: "ar-QA", 1025: "ar-SA", 10241: "ar-SY", 7169: "aeb", 14337: "ar-AE", 9217: "ar-YE", 1067: "hy", 1101: "as", 2092: "az-Cyrl", 1068: "az", 1133: "ba", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn-IN", 8218: "bs-Cyrl", 5146: "bs", 1150: "br", 1026: "bg", 1027: "ca", 3076: "zh-HK", 5124: "zh-MO", 2052: "zh", 4100: "zh-SG", 1028: "zh-TW", 1155: "co", 1050: "hr", 4122: "hr-BA", 1029: "cs", 1030: "da", 1164: "prs", 1125: "dv", 2067: "nl-BE", 1043: "nl", 3081: "en-AU", 10249: "en-BZ", 4105: "en-CA", 9225: "en-029", 16393: "en-IN", 6153: "en-IE", 8201: "en-JM", 17417: "en-MY", 5129: "en-NZ", 13321: "en-PH", 18441: "en-SG", 7177: "en-ZA", 11273: "en-TT", 2057: "en-GB", 1033: "en", 12297: "en-ZW", 1061: "et", 1080: "fo", 1124: "fil", 1035: "fi", 2060: "fr-BE", 3084: "fr-CA", 1036: "fr", 5132: "fr-LU", 6156: "fr-MC", 4108: "fr-CH", 1122: "fy", 1110: "gl", 1079: "ka", 3079: "de-AT", 1031: "de", 5127: "de-LI", 4103: "de-LU", 2055: "de-CH", 1032: "el", 1135: "kl", 1095: "gu", 1128: "ha", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig", 1057: "id", 1117: "iu", 2141: "iu-Latn", 2108: "ga", 1076: "xh", 1077: "zu", 1040: "it", 2064: "it-CH", 1041: "ja", 1099: "kn", 1087: "kk", 1107: "km", 1158: "quc", 1159: "rw", 1089: "sw", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1062: "lv", 1063: "lt", 2094: "dsb", 1134: "lb", 1071: "mk", 2110: "ms-BN", 1086: "ms", 1100: "ml", 1082: "mt", 1153: "mi", 1146: "arn", 1102: "mr", 1148: "moh", 1104: "mn", 2128: "mn-CN", 1121: "ne", 1044: "nb", 2068: "nn", 1154: "oc", 1096: "or", 1123: "ps", 1045: "pl", 1046: "pt", 2070: "pt-PT", 1094: "pa", 1131: "qu-BO", 2155: "qu-EC", 3179: "qu", 1048: "ro", 1047: "rm", 1049: "ru", 9275: "smn", 4155: "smj-NO", 5179: "smj", 3131: "se-FI", 1083: "se", 2107: "se-SE", 8251: "sms", 6203: "sma-NO", 7227: "sms", 1103: "sa", 7194: "sr-Cyrl-BA", 3098: "sr", 6170: "sr-Latn-BA", 2074: "sr-Latn", 1132: "nso", 1074: "tn", 1115: "si", 1051: "sk", 1060: "sl", 11274: "es-AR", 16394: "es-BO", 13322: "es-CL", 9226: "es-CO", 5130: "es-CR", 7178: "es-DO", 12298: "es-EC", 17418: "es-SV", 4106: "es-GT", 18442: "es-HN", 2058: "es-MX", 19466: "es-NI", 6154: "es-PA", 15370: "es-PY", 10250: "es-PE", 20490: "es-PR", 3082: "es", 1034: "es", 21514: "es-US", 14346: "es-UY", 8202: "es-VE", 2077: "sv-FI", 1053: "sv", 1114: "syr", 1064: "tg", 2143: "tzm", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1055: "tr", 1090: "tk", 1152: "ug", 1058: "uk", 1070: "hsb", 1056: "ur", 2115: "uz-Cyrl", 1091: "uz", 1066: "vi", 1106: "cy", 1160: "wo", 1157: "sah", 1144: "ii", 1130: "yo" }; function Ase(n, e, t) { switch (n) { case 0: if (e === 65535) return "und"; if (t) return t[e]; break; case 1: return wG[e]; case 3: return IG[e] } } var S7 = "utf-16", vse = { 0: "macintosh", 1: "x-mac-japanese", 2: "x-mac-chinesetrad", 3: "x-mac-korean", 6: "x-mac-greek", 7: "x-mac-cyrillic", 9: "x-mac-devanagai", 10: "x-mac-gurmukhi", 11: "x-mac-gujarati", 12: "x-mac-oriya", 13: "x-mac-bengali", 14: "x-mac-tamil", 15: "x-mac-telugu", 16: "x-mac-kannada", 17: "x-mac-malayalam", 18: "x-mac-sinhalese", 19: "x-mac-burmese", 20: "x-mac-khmer", 21: "x-mac-thai", 22: "x-mac-lao", 23: "x-mac-georgian", 24: "x-mac-armenian", 25: "x-mac-chinesesimp", 26: "x-mac-tibetan", 27: "x-mac-mongolian", 28: "x-mac-ethiopic", 29: "x-mac-ce", 30: "x-mac-vietnamese", 31: "x-mac-extarabic" }, yse = { 15: "x-mac-icelandic", 17: "x-mac-turkish", 18: "x-mac-croatian", 24: "x-mac-ce", 25: "x-mac-ce", 26: "x-mac-ce", 27: "x-mac-ce", 28: "x-mac-ce", 30: "x-mac-icelandic", 37: "x-mac-romanian", 38: "x-mac-ce", 39: "x-mac-ce", 40: "x-mac-ce", 143: "x-mac-inuit", 146: "x-mac-gaelic" }; function MG(n, e, t) { switch (n) { case 0: return S7; case 1: return yse[t] || vse[e]; case 3: if (e === 1 || e === 10) return S7; break } } function xse(n, e, t) { for (var r = {}, i = new En.Parser(n, e), s = i.parseUShort(), a = i.parseUShort(), o = i.offset + i.parseUShort(), l = 0; l < a; l++) { var u = i.parseUShort(), c = i.parseUShort(), h = i.parseUShort(), d = i.parseUShort(), m = TG[d] || d, g = i.parseUShort(), v = i.parseUShort(), y = Ase(u, h, t), A = MG(u, c, h); if (A !== void 0 && y !== void 0) { var _ = void 0; if (A === S7 ? _ = am.UTF16(n, o + v, g) : _ = am.MACSTRING(n, o + v, g, A), _) { var x = r[m]; x === void 0 && (x = r[m] = {}), x[y] = _ } } } return s === 1 && i.parseUShort(), r } function x_(n) { var e = {}; for (var t in n) e[n[t]] = parseInt(t); return e } function gR(n, e, t, r, i, s) { return new Rt.Record("NameRecord", [{ name: "platformID", type: "USHORT", value: n }, { name: "encodingID", type: "USHORT", value: e }, { name: "languageID", type: "USHORT", value: t }, { name: "nameID", type: "USHORT", value: r }, { name: "length", type: "USHORT", value: i }, { name: "offset", type: "USHORT", value: s }]) } function _se(n, e) { var t = n.length, r = e.length - t + 1; e: for (var i = 0; i < r; i++)for (; i < r; i++) { for (var s = 0; s < t; s++)if (e[i + s] !== n[s]) continue e; return i } return -1 } function AR(n, e) { var t = _se(n, e); if (t < 0) { t = e.length; for (var r = 0, i = n.length; r < i; ++r)e.push(n[r]) } return t } function Ese(n, e) { var t, r = [], i = {}, s = x_(TG); for (var a in n) { var o = s[a]; if (o === void 0 && (o = a), t = parseInt(o), isNaN(t)) throw new Error('Name table entry "' + a + '" does not exist, see nameTableNames for complete list.'); i[t] = n[a], r.push(t) } for (var l = x_(wG), u = x_(IG), c = [], h = [], d = 0; d < r.length; d++) { t = r[d]; var m = i[t]; for (var g in m) { var v = m[g], y = 1, A = l[g], _ = gse[A], x = MG(y, _, A), C = ht.MACSTRING(v, x); C === void 0 && (y = 0, A = e.indexOf(g), A < 0 && (A = e.length, e.push(g)), _ = 4, C = ht.UTF16(v)); var T = AR(C, h); c.push(gR(y, _, A, t, C.length, T)); var I = u[g]; if (I !== void 0) { var w = ht.UTF16(v), R = AR(w, h); c.push(gR(3, 1, I, t, w.length, R)) } } } c.sort(function (F, U) { return F.platformID - U.platformID || F.encodingID - U.encodingID || F.languageID - U.languageID || F.nameID - U.nameID }); for (var b = new Rt.Table("name", [{ name: "format", type: "USHORT", value: 0 }, { name: "count", type: "USHORT", value: c.length }, { name: "stringOffset", type: "USHORT", value: 6 + c.length * 12 }]), B = 0; B < c.length; B++)b.fields.push({ name: "record_" + B, type: "RECORD", value: c[B] }); return b.fields.push({ name: "strings", type: "LITERAL", value: h }), b } var Cse = { parse: xse, make: Ese }, T7 = [{ begin: 0, end: 127 }, { begin: 128, end: 255 }, { begin: 256, end: 383 }, { begin: 384, end: 591 }, { begin: 592, end: 687 }, { begin: 688, end: 767 }, { begin: 768, end: 879 }, { begin: 880, end: 1023 }, { begin: 11392, end: 11519 }, { begin: 1024, end: 1279 }, { begin: 1328, end: 1423 }, { begin: 1424, end: 1535 }, { begin: 42240, end: 42559 }, { begin: 1536, end: 1791 }, { begin: 1984, end: 2047 }, { begin: 2304, end: 2431 }, { begin: 2432, end: 2559 }, { begin: 2560, end: 2687 }, { begin: 2688, end: 2815 }, { begin: 2816, end: 2943 }, { begin: 2944, end: 3071 }, { begin: 3072, end: 3199 }, { begin: 3200, end: 3327 }, { begin: 3328, end: 3455 }, { begin: 3584, end: 3711 }, { begin: 3712, end: 3839 }, { begin: 4256, end: 4351 }, { begin: 6912, end: 7039 }, { begin: 4352, end: 4607 }, { begin: 7680, end: 7935 }, { begin: 7936, end: 8191 }, { begin: 8192, end: 8303 }, { begin: 8304, end: 8351 }, { begin: 8352, end: 8399 }, { begin: 8400, end: 8447 }, { begin: 8448, end: 8527 }, { begin: 8528, end: 8591 }, { begin: 8592, end: 8703 }, { begin: 8704, end: 8959 }, { begin: 8960, end: 9215 }, { begin: 9216, end: 9279 }, { begin: 9280, end: 9311 }, { begin: 9312, end: 9471 }, { begin: 9472, end: 9599 }, { begin: 9600, end: 9631 }, { begin: 9632, end: 9727 }, { begin: 9728, end: 9983 }, { begin: 9984, end: 10175 }, { begin: 12288, end: 12351 }, { begin: 12352, end: 12447 }, { begin: 12448, end: 12543 }, { begin: 12544, end: 12591 }, { begin: 12592, end: 12687 }, { begin: 43072, end: 43135 }, { begin: 12800, end: 13055 }, { begin: 13056, end: 13311 }, { begin: 44032, end: 55215 }, { begin: 55296, end: 57343 }, { begin: 67840, end: 67871 }, { begin: 19968, end: 40959 }, { begin: 57344, end: 63743 }, { begin: 12736, end: 12783 }, { begin: 64256, end: 64335 }, { begin: 64336, end: 65023 }, { begin: 65056, end: 65071 }, { begin: 65040, end: 65055 }, { begin: 65104, end: 65135 }, { begin: 65136, end: 65279 }, { begin: 65280, end: 65519 }, { begin: 65520, end: 65535 }, { begin: 3840, end: 4095 }, { begin: 1792, end: 1871 }, { begin: 1920, end: 1983 }, { begin: 3456, end: 3583 }, { begin: 4096, end: 4255 }, { begin: 4608, end: 4991 }, { begin: 5024, end: 5119 }, { begin: 5120, end: 5759 }, { begin: 5760, end: 5791 }, { begin: 5792, end: 5887 }, { begin: 6016, end: 6143 }, { begin: 6144, end: 6319 }, { begin: 10240, end: 10495 }, { begin: 40960, end: 42127 }, { begin: 5888, end: 5919 }, { begin: 66304, end: 66351 }, { begin: 66352, end: 66383 }, { begin: 66560, end: 66639 }, { begin: 118784, end: 119039 }, { begin: 119808, end: 120831 }, { begin: 1044480, end: 1048573 }, { begin: 65024, end: 65039 }, { begin: 917504, end: 917631 }, { begin: 6400, end: 6479 }, { begin: 6480, end: 6527 }, { begin: 6528, end: 6623 }, { begin: 6656, end: 6687 }, { begin: 11264, end: 11359 }, { begin: 11568, end: 11647 }, { begin: 19904, end: 19967 }, { begin: 43008, end: 43055 }, { begin: 65536, end: 65663 }, { begin: 65856, end: 65935 }, { begin: 66432, end: 66463 }, { begin: 66464, end: 66527 }, { begin: 66640, end: 66687 }, { begin: 66688, end: 66735 }, { begin: 67584, end: 67647 }, { begin: 68096, end: 68191 }, { begin: 119552, end: 119647 }, { begin: 73728, end: 74751 }, { begin: 119648, end: 119679 }, { begin: 7040, end: 7103 }, { begin: 7168, end: 7247 }, { begin: 7248, end: 7295 }, { begin: 43136, end: 43231 }, { begin: 43264, end: 43311 }, { begin: 43312, end: 43359 }, { begin: 43520, end: 43615 }, { begin: 65936, end: 65999 }, { begin: 66e3, end: 66047 }, { begin: 66208, end: 66271 }, { begin: 127024, end: 127135 }]; function Sse(n) { for (var e = 0; e < T7.length; e += 1) { var t = T7[e]; if (n >= t.begin && n < t.end) return e } return -1 } function Tse(n, e) { var t = {}, r = new En.Parser(n, e); t.version = r.parseUShort(), t.xAvgCharWidth = r.parseShort(), t.usWeightClass = r.parseUShort(), t.usWidthClass = r.parseUShort(), t.fsType = r.parseUShort(), t.ySubscriptXSize = r.parseShort(), t.ySubscriptYSize = r.parseShort(), t.ySubscriptXOffset = r.parseShort(), t.ySubscriptYOffset = r.parseShort(), t.ySuperscriptXSize = r.parseShort(), t.ySuperscriptYSize = r.parseShort(), t.ySuperscriptXOffset = r.parseShort(), t.ySuperscriptYOffset = r.parseShort(), t.yStrikeoutSize = r.parseShort(), t.yStrikeoutPosition = r.parseShort(), t.sFamilyClass = r.parseShort(), t.panose = []; for (var i = 0; i < 10; i++)t.panose[i] = r.parseByte(); return t.ulUnicodeRange1 = r.parseULong(), t.ulUnicodeRange2 = r.parseULong(), t.ulUnicodeRange3 = r.parseULong(), t.ulUnicodeRange4 = r.parseULong(), t.achVendID = String.fromCharCode(r.parseByte(), r.parseByte(), r.parseByte(), r.parseByte()), t.fsSelection = r.parseUShort(), t.usFirstCharIndex = r.parseUShort(), t.usLastCharIndex = r.parseUShort(), t.sTypoAscender = r.parseShort(), t.sTypoDescender = r.parseShort(), t.sTypoLineGap = r.parseShort(), t.usWinAscent = r.parseUShort(), t.usWinDescent = r.parseUShort(), t.version >= 1 && (t.ulCodePageRange1 = r.parseULong(), t.ulCodePageRange2 = r.parseULong()), t.version >= 2 && (t.sxHeight = r.parseShort(), t.sCapHeight = r.parseShort(), t.usDefaultChar = r.parseUShort(), t.usBreakChar = r.parseUShort(), t.usMaxContent = r.parseUShort()), t } function wse(n) { return new Rt.Table("OS/2", [{ name: "version", type: "USHORT", value: 3 }, { name: "xAvgCharWidth", type: "SHORT", value: 0 }, { name: "usWeightClass", type: "USHORT", value: 0 }, { name: "usWidthClass", type: "USHORT", value: 0 }, { name: "fsType", type: "USHORT", value: 0 }, { name: "ySubscriptXSize", type: "SHORT", value: 650 }, { name: "ySubscriptYSize", type: "SHORT", value: 699 }, { name: "ySubscriptXOffset", type: "SHORT", value: 0 }, { name: "ySubscriptYOffset", type: "SHORT", value: 140 }, { name: "ySuperscriptXSize", type: "SHORT", value: 650 }, { name: "ySuperscriptYSize", type: "SHORT", value: 699 }, { name: "ySuperscriptXOffset", type: "SHORT", value: 0 }, { name: "ySuperscriptYOffset", type: "SHORT", value: 479 }, { name: "yStrikeoutSize", type: "SHORT", value: 49 }, { name: "yStrikeoutPosition", type: "SHORT", value: 258 }, { name: "sFamilyClass", type: "SHORT", value: 0 }, { name: "bFamilyType", type: "BYTE", value: 0 }, { name: "bSerifStyle", type: "BYTE", value: 0 }, { name: "bWeight", type: "BYTE", value: 0 }, { name: "bProportion", type: "BYTE", value: 0 }, { name: "bContrast", type: "BYTE", value: 0 }, { name: "bStrokeVariation", type: "BYTE", value: 0 }, { name: "bArmStyle", type: "BYTE", value: 0 }, { name: "bLetterform", type: "BYTE", value: 0 }, { name: "bMidline", type: "BYTE", value: 0 }, { name: "bXHeight", type: "BYTE", value: 0 }, { name: "ulUnicodeRange1", type: "ULONG", value: 0 }, { name: "ulUnicodeRange2", type: "ULONG", value: 0 }, { name: "ulUnicodeRange3", type: "ULONG", value: 0 }, { name: "ulUnicodeRange4", type: "ULONG", value: 0 }, { name: "achVendID", type: "CHARARRAY", value: "XXXX" }, { name: "fsSelection", type: "USHORT", value: 0 }, { name: "usFirstCharIndex", type: "USHORT", value: 0 }, { name: "usLastCharIndex", type: "USHORT", value: 0 }, { name: "sTypoAscender", type: "SHORT", value: 0 }, { name: "sTypoDescender", type: "SHORT", value: 0 }, { name: "sTypoLineGap", type: "SHORT", value: 0 }, { name: "usWinAscent", type: "USHORT", value: 0 }, { name: "usWinDescent", type: "USHORT", value: 0 }, { name: "ulCodePageRange1", type: "ULONG", value: 0 }, { name: "ulCodePageRange2", type: "ULONG", value: 0 }, { name: "sxHeight", type: "SHORT", value: 0 }, { name: "sCapHeight", type: "SHORT", value: 0 }, { name: "usDefaultChar", type: "USHORT", value: 0 }, { name: "usBreakChar", type: "USHORT", value: 0 }, { name: "usMaxContext", type: "USHORT", value: 0 }], n) } var vR = { parse: Tse, make: wse, unicodeRanges: T7, getUnicodeRange: Sse }; function Ise(n, e) { var t = {}, r = new En.Parser(n, e); switch (t.version = r.parseVersion(), t.italicAngle = r.parseFixed(), t.underlinePosition = r.parseShort(), t.underlineThickness = r.parseShort(), t.isFixedPitch = r.parseULong(), t.minMemType42 = r.parseULong(), t.maxMemType42 = r.parseULong(), t.minMemType1 = r.parseULong(), t.maxMemType1 = r.parseULong(), t.version) { case 1: t.names = fR.slice(); break; case 2: t.numberOfGlyphs = r.parseUShort(), t.glyphNameIndex = new Array(t.numberOfGlyphs); for (var i = 0; i < t.numberOfGlyphs; i++)t.glyphNameIndex[i] = r.parseUShort(); t.names = []; for (var s = 0; s < t.numberOfGlyphs; s++)if (t.glyphNameIndex[s] >= fR.length) { var a = r.parseChar(); t.names.push(r.parseString(a)) } break; case 2.5: t.numberOfGlyphs = r.parseUShort(), t.offset = new Array(t.numberOfGlyphs); for (var o = 0; o < t.numberOfGlyphs; o++)t.offset[o] = r.parseChar(); break }return t } function Mse() { return new Rt.Table("post", [{ name: "version", type: "FIXED", value: 196608 }, { name: "italicAngle", type: "FIXED", value: 0 }, { name: "underlinePosition", type: "FWORD", value: 0 }, { name: "underlineThickness", type: "FWORD", value: 0 }, { name: "isFixedPitch", type: "ULONG", value: 0 }, { name: "minMemType42", type: "ULONG", value: 0 }, { name: "maxMemType42", type: "ULONG", value: 0 }, { name: "minMemType1", type: "ULONG", value: 0 }, { name: "maxMemType1", type: "ULONG", value: 0 }]) } var bse = { parse: Ise, make: Mse }, xu = new Array(9); xu[1] = function () { var e = this.offset + this.relativeOffset, t = this.parseUShort(); if (t === 1) return { substFormat: 1, coverage: this.parsePointer(be.coverage), deltaGlyphId: this.parseUShort() }; if (t === 2) return { substFormat: 2, coverage: this.parsePointer(be.coverage), substitute: this.parseOffset16List() }; An.assert(!1, "0x" + e.toString(16) + ": lookup type 1 format must be 1 or 2.") }; xu[2] = function () { var e = this.parseUShort(); return An.argument(e === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(be.coverage), sequences: this.parseListOfLists() } }; xu[3] = function () { var e = this.parseUShort(); return An.argument(e === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(be.coverage), alternateSets: this.parseListOfLists() } }; xu[4] = function () { var e = this.parseUShort(); return An.argument(e === 1, "GSUB ligature table identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(be.coverage), ligatureSets: this.parseListOfLists(function () { return { ligGlyph: this.parseUShort(), components: this.parseUShortList(this.parseUShort() - 1) } }) } }; var D3 = { sequenceIndex: be.uShort, lookupListIndex: be.uShort }; xu[5] = function () { var e = this.offset + this.relativeOffset, t = this.parseUShort(); if (t === 1) return { substFormat: t, coverage: this.parsePointer(be.coverage), ruleSets: this.parseListOfLists(function () { var s = this.parseUShort(), a = this.parseUShort(); return { input: this.parseUShortList(s - 1), lookupRecords: this.parseRecordList(a, D3) } }) }; if (t === 2) return { substFormat: t, coverage: this.parsePointer(be.coverage), classDef: this.parsePointer(be.classDef), classSets: this.parseListOfLists(function () { var s = this.parseUShort(), a = this.parseUShort(); return { classes: this.parseUShortList(s - 1), lookupRecords: this.parseRecordList(a, D3) } }) }; if (t === 3) { var r = this.parseUShort(), i = this.parseUShort(); return { substFormat: t, coverages: this.parseList(r, be.pointer(be.coverage)), lookupRecords: this.parseRecordList(i, D3) } } An.assert(!1, "0x" + e.toString(16) + ": lookup type 5 format must be 1, 2 or 3.") }; xu[6] = function () { var e = this.offset + this.relativeOffset, t = this.parseUShort(); if (t === 1) return { substFormat: 1, coverage: this.parsePointer(be.coverage), chainRuleSets: this.parseListOfLists(function () { return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(D3) } }) }; if (t === 2) return { substFormat: 2, coverage: this.parsePointer(be.coverage), backtrackClassDef: this.parsePointer(be.classDef), inputClassDef: this.parsePointer(be.classDef), lookaheadClassDef: this.parsePointer(be.classDef), chainClassSet: this.parseListOfLists(function () { return { backtrack: this.parseUShortList(), input: this.parseUShortList(this.parseShort() - 1), lookahead: this.parseUShortList(), lookupRecords: this.parseRecordList(D3) } }) }; if (t === 3) return { substFormat: 3, backtrackCoverage: this.parseList(be.pointer(be.coverage)), inputCoverage: this.parseList(be.pointer(be.coverage)), lookaheadCoverage: this.parseList(be.pointer(be.coverage)), lookupRecords: this.parseRecordList(D3) }; An.assert(!1, "0x" + e.toString(16) + ": lookup type 6 format must be 1, 2 or 3.") }; xu[7] = function () { var e = this.parseUShort(); An.argument(e === 1, "GSUB Extension Substitution subtable identifier-format must be 1"); var t = this.parseUShort(), r = new be(this.data, this.offset + this.parseULong()); return { substFormat: 1, lookupType: t, extension: xu[t].call(r) } }; xu[8] = function () { var e = this.parseUShort(); return An.argument(e === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1"), { substFormat: e, coverage: this.parsePointer(be.coverage), backtrackCoverage: this.parseList(be.pointer(be.coverage)), lookaheadCoverage: this.parseList(be.pointer(be.coverage)), substitutes: this.parseUShortList() } }; function Bse(n, e) { e = e || 0; var t = new be(n, e), r = t.parseVersion(1); return An.argument(r === 1 || r === 1.1, "Unsupported GSUB table version."), r === 1 ? { version: r, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(xu) } : { version: r, scripts: t.parseScriptList(), features: t.parseFeatureList(), lookups: t.parseLookupList(xu), variations: t.parseFeatureVariationsList() } } var Sm = new Array(9); Sm[1] = function (e) { return e.substFormat === 1 ? new Rt.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }, { name: "deltaGlyphID", type: "USHORT", value: e.deltaGlyphId }]) : new Rt.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 2 }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }].concat(Rt.ushortList("substitute", e.substitute))) }; Sm[2] = function (e) { return An.assert(e.substFormat === 1, "Lookup type 2 substFormat must be 1."), new Rt.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }].concat(Rt.tableList("seqSet", e.sequences, function (t) { return new Rt.Table("sequenceSetTable", Rt.ushortList("sequence", t)) }))) }; Sm[3] = function (e) { return An.assert(e.substFormat === 1, "Lookup type 3 substFormat must be 1."), new Rt.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }].concat(Rt.tableList("altSet", e.alternateSets, function (t) { return new Rt.Table("alternateSetTable", Rt.ushortList("alternate", t)) }))) }; Sm[4] = function (e) { return An.assert(e.substFormat === 1, "Lookup type 4 substFormat must be 1."), new Rt.Table("substitutionTable", [{ name: "substFormat", type: "USHORT", value: 1 }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }].concat(Rt.tableList("ligSet", e.ligatureSets, function (t) { return new Rt.Table("ligatureSetTable", Rt.tableList("ligature", t, function (r) { return new Rt.Table("ligatureTable", [{ name: "ligGlyph", type: "USHORT", value: r.ligGlyph }].concat(Rt.ushortList("component", r.components, r.components.length + 1))) })) }))) }; Sm[6] = function (e) { if (e.substFormat === 1) { var t = new Rt.Table("chainContextTable", [{ name: "substFormat", type: "USHORT", value: e.substFormat }, { name: "coverage", type: "TABLE", value: new Rt.Coverage(e.coverage) }].concat(Rt.tableList("chainRuleSet", e.chainRuleSets, function (s) { return new Rt.Table("chainRuleSetTable", Rt.tableList("chainRule", s, function (a) { var o = Rt.ushortList("backtrackGlyph", a.backtrack, a.backtrack.length).concat(Rt.ushortList("inputGlyph", a.input, a.input.length + 1)).concat(Rt.ushortList("lookaheadGlyph", a.lookahead, a.lookahead.length)).concat(Rt.ushortList("substitution", [], a.lookupRecords.length)); return a.lookupRecords.forEach(function (l, u) { o = o.concat({ name: "sequenceIndex" + u, type: "USHORT", value: l.sequenceIndex }).concat({ name: "lookupListIndex" + u, type: "USHORT", value: l.lookupListIndex }) }), new Rt.Table("chainRuleTable", o) })) }))); return t } else if (e.substFormat === 2) An.assert(!1, "lookup type 6 format 2 is not yet supported."); else if (e.substFormat === 3) { var r = [{ name: "substFormat", type: "USHORT", value: e.substFormat }]; r.push({ name: "backtrackGlyphCount", type: "USHORT", value: e.backtrackCoverage.length }), e.backtrackCoverage.forEach(function (s, a) { r.push({ name: "backtrackCoverage" + a, type: "TABLE", value: new Rt.Coverage(s) }) }), r.push({ name: "inputGlyphCount", type: "USHORT", value: e.inputCoverage.length }), e.inputCoverage.forEach(function (s, a) { r.push({ name: "inputCoverage" + a, type: "TABLE", value: new Rt.Coverage(s) }) }), r.push({ name: "lookaheadGlyphCount", type: "USHORT", value: e.lookaheadCoverage.length }), e.lookaheadCoverage.forEach(function (s, a) { r.push({ name: "lookaheadCoverage" + a, type: "TABLE", value: new Rt.Coverage(s) }) }), r.push({ name: "substitutionCount", type: "USHORT", value: e.lookupRecords.length }), e.lookupRecords.forEach(function (s, a) { r = r.concat({ name: "sequenceIndex" + a, type: "USHORT", value: s.sequenceIndex }).concat({ name: "lookupListIndex" + a, type: "USHORT", value: s.lookupListIndex }) }); var i = new Rt.Table("chainContextTable", r); return i } An.assert(!1, "lookup type 6 format must be 1, 2 or 3.") }; function Rse(n) { return new Rt.Table("GSUB", [{ name: "version", type: "ULONG", value: 65536 }, { name: "scripts", type: "TABLE", value: new Rt.ScriptList(n.scripts) }, { name: "features", type: "TABLE", value: new Rt.FeatureList(n.features) }, { name: "lookups", type: "TABLE", value: new Rt.LookupList(n.lookups, Sm) }]) } var Pse = { parse: Bse, make: Rse }; function Dse(n, e) { var t = new En.Parser(n, e), r = t.parseULong(); An.argument(r === 1, "Unsupported META table version."), t.parseULong(), t.parseULong(); for (var i = t.parseULong(), s = {}, a = 0; a < i; a++) { var o = t.parseTag(), l = t.parseULong(), u = t.parseULong(), c = am.UTF8(n, e + l, u); s[o] = c } return s } function Lse(n) { var e = Object.keys(n).length, t = "", r = 16 + e * 12, i = new Rt.Table("meta", [{ name: "version", type: "ULONG", value: 1 }, { name: "flags", type: "ULONG", value: 0 }, { name: "offset", type: "ULONG", value: r }, { name: "numTags", type: "ULONG", value: e }]); for (var s in n) { var a = t.length; t += n[s], i.fields.push({ name: "tag " + s, type: "TAG", value: s }), i.fields.push({ name: "offset " + s, type: "ULONG", value: r + a }), i.fields.push({ name: "length " + s, type: "ULONG", value: n[s].length }) } return i.fields.push({ name: "stringPool", type: "CHARARRAY", value: t }), i } var Fse = { parse: Dse, make: Lse }; function yR(n) { return Math.log(n) / Math.log(2) | 0 } function ST(n) { for (; n.length % 4 !== 0;)n.push(0); for (var e = 0, t = 0; t < n.length; t += 4)e += (n[t] << 24) + (n[t + 1] << 16) + (n[t + 2] << 8) + n[t + 3]; return e %= Math.pow(2, 32), e } function xR(n, e, t, r) { return new Rt.Record("Table Record", [{ name: "tag", type: "TAG", value: n !== void 0 ? n : "" }, { name: "checkSum", type: "ULONG", value: e !== void 0 ? e : 0 }, { name: "offset", type: "ULONG", value: t !== void 0 ? t : 0 }, { name: "length", type: "ULONG", value: r !== void 0 ? r : 0 }]) } function bG(n) { var e = new Rt.Table("sfnt", [{ name: "version", type: "TAG", value: "OTTO" }, { name: "numTables", type: "USHORT", value: 0 }, { name: "searchRange", type: "USHORT", value: 0 }, { name: "entrySelector", type: "USHORT", value: 0 }, { name: "rangeShift", type: "USHORT", value: 0 }]); e.tables = n, e.numTables = n.length; var t = Math.pow(2, yR(e.numTables)); e.searchRange = 16 * t, e.entrySelector = yR(t), e.rangeShift = e.numTables * 16 - e.searchRange; for (var r = [], i = [], s = e.sizeOf() + xR().sizeOf() * e.numTables; s % 4 !== 0;)s += 1, i.push({ name: "padding", type: "BYTE", value: 0 }); for (var a = 0; a < n.length; a += 1) { var o = n[a]; An.argument(o.tableName.length === 4, "Table name" + o.tableName + " is invalid."); var l = o.sizeOf(), u = xR(o.tableName, ST(o.encode()), s, l); for (r.push({ name: u.tag + " Table Record", type: "RECORD", value: u }), i.push({ name: o.tableName + " table", type: "RECORD", value: o }), s += l, An.argument(!isNaN(s), "Something went wrong calculating the offset."); s % 4 !== 0;)s += 1, i.push({ name: "padding", type: "BYTE", value: 0 }) } return r.sort(function (c, h) { return c.value.tag > h.value.tag ? 1 : -1 }), e.fields = e.fields.concat(r), e.fields = e.fields.concat(i), e } function _R(n, e, t) { for (var r = 0; r < e.length; r += 1) { var i = n.charToGlyphIndex(e[r]); if (i > 0) { var s = n.glyphs.get(i); return s.getMetrics() } } return t } function kse(n) { for (var e = 0, t = 0; t < n.length; t += 1)e += n[t]; return e / n.length } function Nse(n) { for (var e = [], t = [], r = [], i = [], s = [], a = [], o = [], l, u = 0, c = 0, h = 0, d = 0, m = 0, g = 0; g < n.glyphs.length; g += 1) { var v = n.glyphs.get(g), y = v.unicode | 0; if (isNaN(v.advanceWidth)) throw new Error("Glyph " + v.name + " (" + g + "): advanceWidth is not a number."); (l > y || l === void 0) && y > 0 && (l = y), u < y && (u = y); var A = vR.getUnicodeRange(y); if (A < 32) c |= 1 << A; else if (A < 64) h |= 1 << A - 32; else if (A < 96) d |= 1 << A - 64; else if (A < 123) m |= 1 << A - 96; else throw new Error("Unicode ranges bits > 123 are reserved for internal usage"); if (v.name !== ".notdef") { var _ = v.getMetrics(); e.push(_.xMin), t.push(_.yMin), r.push(_.xMax), i.push(_.yMax), a.push(_.leftSideBearing), o.push(_.rightSideBearing), s.push(v.advanceWidth) } } var x = { xMin: Math.min.apply(null, e), yMin: Math.min.apply(null, t), xMax: Math.max.apply(null, r), yMax: Math.max.apply(null, i), advanceWidthMax: Math.max.apply(null, s), advanceWidthAvg: kse(s), minLeftSideBearing: Math.min.apply(null, a), maxLeftSideBearing: Math.max.apply(null, a), minRightSideBearing: Math.min.apply(null, o) }; x.ascender = n.ascender, x.descender = n.descender; var C = tse.make({ flags: 3, unitsPerEm: n.unitsPerEm, xMin: x.xMin, yMin: x.yMin, xMax: x.xMax, yMax: x.yMax, lowestRecPPEM: 3, createdTimestamp: n.createdTimestamp }), T = ise.make({ ascender: x.ascender, descender: x.descender, advanceWidthMax: x.advanceWidthMax, minLeftSideBearing: x.minLeftSideBearing, minRightSideBearing: x.minRightSideBearing, xMaxExtent: x.maxLeftSideBearing + (x.xMax - x.xMin), numberOfHMetrics: n.glyphs.length }), I = mse.make(n.glyphs.length), w = vR.make(Object.assign({ xAvgCharWidth: Math.round(x.advanceWidthAvg), usFirstCharIndex: l, usLastCharIndex: u, ulUnicodeRange1: c, ulUnicodeRange2: h, ulUnicodeRange3: d, ulUnicodeRange4: m, sTypoAscender: x.ascender, sTypoDescender: x.descender, sTypoLineGap: 0, usWinAscent: x.yMax, usWinDescent: Math.abs(x.yMin), ulCodePageRange1: 1, sxHeight: _R(n, "xyvw", { yMax: Math.round(x.ascender / 2) }).yMax, sCapHeight: _R(n, "HIKLEFJMNTZBDPRAGOQSUVWXY", x).yMax, usDefaultChar: n.hasChar(" ") ? 32 : 0, usBreakChar: n.hasChar(" ") ? 32 : 0 }, n.tables.os2)), R = use.make(n.glyphs), b = Sie.make(n.glyphs), B = n.getEnglishName("fontFamily"), F = n.getEnglishName("fontSubfamily"), U = B + " " + F, G = n.getEnglishName("postScriptName"); G || (G = B.replace(/\s/g, "") + "-" + F); var Y = {}; for (var Z in n.names) Y[Z] = n.names[Z]; Y.uniqueID || (Y.uniqueID = { en: n.getEnglishName("manufacturer") + ":" + U }), Y.postScriptName || (Y.postScriptName = { en: G }), Y.preferredFamily || (Y.preferredFamily = n.names.fontFamily), Y.preferredSubfamily || (Y.preferredSubfamily = n.names.fontSubfamily); var ne = [], $ = Cse.make(Y, ne), L = ne.length > 0 ? hse.make(ne) : void 0, Q = bse.make(), D = Zie.make(n.glyphs, { version: n.getEnglishName("version"), fullName: U, familyName: B, weightName: F, postScriptName: G, unitsPerEm: n.unitsPerEm, fontBBox: [0, x.yMin, x.ascender, x.advanceWidthMax] }), V = n.metas && Object.keys(n.metas).length > 0 ? Fse.make(n.metas) : void 0, J = [C, T, I, w, $, b, Q, D, R]; L && J.push(L), n.tables.gsub && J.push(Pse.make(n.tables.gsub)), V && J.push(V); for (var Ee = bG(J), xe = Ee.encode(), Be = ST(xe), Fe = Ee.fields, we = !1, ge = 0; ge < Fe.length; ge += 1)if (Fe[ge].name === "head table") { Fe[ge].value.checkSumAdjustment = 2981146554 - Be, we = !0; break } if (!we) throw new Error("Could not find head table with checkSum to adjust."); return Ee } var Ose = { make: bG, fontToTable: Nse, computeCheckSum: ST }; function __(n, e) { for (var t = 0, r = n.length - 1; t <= r;) { var i = t + r >>> 1, s = n[i].tag; if (s === e) return i; s < e ? t = i + 1 : r = i - 1 } return -t - 1 } function ER(n, e) { for (var t = 0, r = n.length - 1; t <= r;) { var i = t + r >>> 1, s = n[i]; if (s === e) return i; s < e ? t = i + 1 : r = i - 1 } return -t - 1 } function CR(n, e) { for (var t, r = 0, i = n.length - 1; r <= i;) { var s = r + i >>> 1; t = n[s]; var a = t.start; if (a === e) return t; a < e ? r = s + 1 : i = s - 1 } if (r > 0) return t = n[r - 1], e > t.end ? 0 : t } function W1(n, e) { this.font = n, this.tableName = e } W1.prototype = { searchTag: __, binSearch: ER, getTable: function (n) { var e = this.font.tables[this.tableName]; return !e && n && (e = this.font.tables[this.tableName] = this.createDefaultTable()), e }, getScriptNames: function () { var n = this.getTable(); return n ? n.scripts.map(function (e) { return e.tag }) : [] }, getDefaultScriptName: function () { var n = this.getTable(); if (n) { for (var e = !1, t = 0; t < n.scripts.length; t++) { var r = n.scripts[t].tag; if (r === "DFLT") return r; r === "latn" && (e = !0) } if (e) return "latn" } }, getScriptTable: function (n, e) { var t = this.getTable(e); if (t) { n = n || "DFLT"; var r = t.scripts, i = __(t.scripts, n); if (i >= 0) return r[i].script; if (e) { var s = { tag: n, script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }; return r.splice(-1 - i, 0, s), s.script } } }, getLangSysTable: function (n, e, t) { var r = this.getScriptTable(n, t); if (r) { if (!e || e === "dflt" || e === "DFLT") return r.defaultLangSys; var i = __(r.langSysRecords, e); if (i >= 0) return r.langSysRecords[i].langSys; if (t) { var s = { tag: e, langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] } }; return r.langSysRecords.splice(-1 - i, 0, s), s.langSys } } }, getFeatureTable: function (n, e, t, r) { var i = this.getLangSysTable(n, e, r); if (i) { for (var s, a = i.featureIndexes, o = this.font.tables[this.tableName].features, l = 0; l < a.length; l++)if (s = o[a[l]], s.tag === t) return s.feature; if (r) { var u = o.length; return An.assert(u === 0 || t >= o[u - 1].tag, "Features must be added in alphabetical order."), s = { tag: t, feature: { params: 0, lookupListIndexes: [] } }, o.push(s), a.push(u), s.feature } } }, getLookupTables: function (n, e, t, r, i) { var s = this.getFeatureTable(n, e, t, i), a = []; if (s) { for (var o, l = s.lookupListIndexes, u = this.font.tables[this.tableName].lookups, c = 0; c < l.length; c++)o = u[l[c]], o.lookupType === r && a.push(o); if (a.length === 0 && i) { o = { lookupType: r, lookupFlag: 0, subtables: [], markFilteringSet: void 0 }; var h = u.length; return u.push(o), l.push(h), [o] } } return a }, getGlyphClass: function (n, e) { switch (n.format) { case 1: return n.startGlyph <= e && e < n.startGlyph + n.classes.length ? n.classes[e - n.startGlyph] : 0; case 2: var t = CR(n.ranges, e); return t ? t.classId : 0 } }, getCoverageIndex: function (n, e) { switch (n.format) { case 1: var t = ER(n.glyphs, e); return t >= 0 ? t : -1; case 2: var r = CR(n.ranges, e); return r ? r.index + e - r.start : -1 } }, expandCoverage: function (n) { if (n.format === 1) return n.glyphs; for (var e = [], t = n.ranges, r = 0; r < t.length; r++)for (var i = t[r], s = i.start, a = i.end, o = s; o <= a; o++)e.push(o); return e } }; function X1(n) { W1.call(this, n, "gpos") } X1.prototype = W1.prototype; X1.prototype.init = function () { var n = this.getDefaultScriptName(); this.defaultKerningTables = this.getKerningTables(n) }; X1.prototype.getKerningValue = function (n, e, t) { for (var r = 0; r < n.length; r++)for (var i = n[r].subtables, s = 0; s < i.length; s++) { var a = i[s], o = this.getCoverageIndex(a.coverage, e); if (!(o < 0)) switch (a.posFormat) { case 1: for (var l = a.pairSets[o], u = 0; u < l.length; u++) { var c = l[u]; if (c.secondGlyph === t) return c.value1 && c.value1.xAdvance || 0 } break; case 2: var h = this.getGlyphClass(a.classDef1, e), d = this.getGlyphClass(a.classDef2, t), m = a.classRecords[h][d]; return m.value1 && m.value1.xAdvance || 0 } } return 0 }; X1.prototype.getKerningTables = function (n, e) { if (this.font.tables.gpos) return this.getLookupTables(n, e, "kern", 2) }; function qo(n) { W1.call(this, n, "gsub") } function Use(n, e) { var t = n.length; if (t !== e.length) return !1; for (var r = 0; r < t; r++)if (n[r] !== e[r]) return !1; return !0 } function TT(n, e, t) { for (var r = n.subtables, i = 0; i < r.length; i++) { var s = r[i]; if (s.substFormat === e) return s } if (t) return r.push(t), t } qo.prototype = W1.prototype; qo.prototype.createDefaultTable = function () { return { version: 1, scripts: [{ tag: "DFLT", script: { defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }, langSysRecords: [] } }], features: [], lookups: [] } }; qo.prototype.getSingle = function (n, e, t) { for (var r = [], i = this.getLookupTables(e, t, n, 1), s = 0; s < i.length; s++)for (var a = i[s].subtables, o = 0; o < a.length; o++) { var l = a[o], u = this.expandCoverage(l.coverage), c = void 0; if (l.substFormat === 1) { var h = l.deltaGlyphId; for (c = 0; c < u.length; c++) { var d = u[c]; r.push({ sub: d, by: d + h }) } } else { var m = l.substitute; for (c = 0; c < u.length; c++)r.push({ sub: u[c], by: m[c] }) } } return r }; qo.prototype.getMultiple = function (n, e, t) { for (var r = [], i = this.getLookupTables(e, t, n, 2), s = 0; s < i.length; s++)for (var a = i[s].subtables, o = 0; o < a.length; o++) { var l = a[o], u = this.expandCoverage(l.coverage), c = void 0; for (c = 0; c < u.length; c++) { var h = u[c], d = l.sequences[c]; r.push({ sub: h, by: d }) } } return r }; qo.prototype.getAlternates = function (n, e, t) { for (var r = [], i = this.getLookupTables(e, t, n, 3), s = 0; s < i.length; s++)for (var a = i[s].subtables, o = 0; o < a.length; o++)for (var l = a[o], u = this.expandCoverage(l.coverage), c = l.alternateSets, h = 0; h < u.length; h++)r.push({ sub: u[h], by: c[h] }); return r }; qo.prototype.getLigatures = function (n, e, t) { for (var r = [], i = this.getLookupTables(e, t, n, 4), s = 0; s < i.length; s++)for (var a = i[s].subtables, o = 0; o < a.length; o++)for (var l = a[o], u = this.expandCoverage(l.coverage), c = l.ligatureSets, h = 0; h < u.length; h++)for (var d = u[h], m = c[h], g = 0; g < m.length; g++) { var v = m[g]; r.push({ sub: [d].concat(v.components), by: v.ligGlyph }) } return r }; qo.prototype.addSingle = function (n, e, t, r) { var i = this.getLookupTables(t, r, n, 1, !0)[0], s = TT(i, 2, { substFormat: 2, coverage: { format: 1, glyphs: [] }, substitute: [] }); An.assert(s.coverage.format === 1, "Single: unable to modify coverage table format " + s.coverage.format); var a = e.sub, o = this.binSearch(s.coverage.glyphs, a); o < 0 && (o = -1 - o, s.coverage.glyphs.splice(o, 0, a), s.substitute.splice(o, 0, 0)), s.substitute[o] = e.by }; qo.prototype.addMultiple = function (n, e, t, r) { An.assert(e.by instanceof Array && e.by.length > 1, 'Multiple: "by" must be an array of two or more ids'); var i = this.getLookupTables(t, r, n, 2, !0)[0], s = TT(i, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, sequences: [] }); An.assert(s.coverage.format === 1, "Multiple: unable to modify coverage table format " + s.coverage.format); var a = e.sub, o = this.binSearch(s.coverage.glyphs, a); o < 0 && (o = -1 - o, s.coverage.glyphs.splice(o, 0, a), s.sequences.splice(o, 0, 0)), s.sequences[o] = e.by }; qo.prototype.addAlternate = function (n, e, t, r) { var i = this.getLookupTables(t, r, n, 3, !0)[0], s = TT(i, 1, { substFormat: 1, coverage: { format: 1, glyphs: [] }, alternateSets: [] }); An.assert(s.coverage.format === 1, "Alternate: unable to modify coverage table format " + s.coverage.format); var a = e.sub, o = this.binSearch(s.coverage.glyphs, a); o < 0 && (o = -1 - o, s.coverage.glyphs.splice(o, 0, a), s.alternateSets.splice(o, 0, 0)), s.alternateSets[o] = e.by }; qo.prototype.addLigature = function (n, e, t, r) { var i = this.getLookupTables(t, r, n, 4, !0)[0], s = i.subtables[0]; s || (s = { substFormat: 1, coverage: { format: 1, glyphs: [] }, ligatureSets: [] }, i.subtables[0] = s), An.assert(s.coverage.format === 1, "Ligature: unable to modify coverage table format " + s.coverage.format); var a = e.sub[0], o = e.sub.slice(1), l = { ligGlyph: e.by, components: o }, u = this.binSearch(s.coverage.glyphs, a); if (u >= 0) { for (var c = s.ligatureSets[u], h = 0; h < c.length; h++)if (Use(c[h].components, o)) return; c.push(l) } else u = -1 - u, s.coverage.glyphs.splice(u, 0, a), s.ligatureSets.splice(u, 0, [l]) }; qo.prototype.getFeature = function (n, e, t) { if (/ss\d\d/.test(n)) return this.getSingle(n, e, t); switch (n) { case "aalt": case "salt": return this.getSingle(n, e, t).concat(this.getAlternates(n, e, t)); case "dlig": case "liga": case "rlig": return this.getLigatures(n, e, t); case "ccmp": return this.getMultiple(n, e, t).concat(this.getLigatures(n, e, t)); case "stch": return this.getMultiple(n, e, t) } }; qo.prototype.add = function (n, e, t, r) { if (/ss\d\d/.test(n)) return this.addSingle(n, e, t, r); switch (n) { case "aalt": case "salt": return typeof e.by == "number" ? this.addSingle(n, e, t, r) : this.addAlternate(n, e, t, r); case "dlig": case "liga": case "rlig": return this.addLigature(n, e, t, r); case "ccmp": return e.by instanceof Array ? this.addMultiple(n, e, t, r) : this.addLigature(n, e, t, r) } }; function Gse() { return typeof window < "u" } function Qse(n) { for (var e = new Buffer(n.byteLength), t = new Uint8Array(n), r = 0; r < e.length; ++r)e[r] = t[r]; return e } function cg(n, e) { if (!n) throw e } function SR(n, e, t, r, i) { var s; return (e & r) > 0 ? (s = n.parseByte(), e & i || (s = -s), s = t + s) : (e & i) > 0 ? s = t : s = t + n.parseShort(), s } function BG(n, e, t) { var r = new En.Parser(e, t); n.numberOfContours = r.parseShort(), n._xMin = r.parseShort(), n._yMin = r.parseShort(), n._xMax = r.parseShort(), n._yMax = r.parseShort(); var i, s; if (n.numberOfContours > 0) { for (var a = n.endPointIndices = [], o = 0; o < n.numberOfContours; o += 1)a.push(r.parseUShort()); n.instructionLength = r.parseUShort(), n.instructions = []; for (var l = 0; l < n.instructionLength; l += 1)n.instructions.push(r.parseByte()); var u = a[a.length - 1] + 1; i = []; for (var c = 0; c < u; c += 1)if (s = r.parseByte(), i.push(s), (s & 8) > 0) for (var h = r.parseByte(), d = 0; d < h; d += 1)i.push(s), c += 1; if (An.argument(i.length === u, "Bad flags."), a.length > 0) { var m = [], g; if (u > 0) { for (var v = 0; v < u; v += 1)s = i[v], g = {}, g.onCurve = !!(s & 1), g.lastPointOfContour = a.indexOf(v) >= 0, m.push(g); for (var y = 0, A = 0; A < u; A += 1)s = i[A], g = m[A], g.x = SR(r, s, y, 2, 16), y = g.x; for (var _ = 0, x = 0; x < u; x += 1)s = i[x], g = m[x], g.y = SR(r, s, _, 4, 32), _ = g.y } n.points = m } else n.points = [] } else if (n.numberOfContours === 0) n.points = []; else { n.isComposite = !0, n.points = [], n.components = []; for (var C = !0; C;) { i = r.parseUShort(); var T = { glyphIndex: r.parseUShort(), xScale: 1, scale01: 0, scale10: 0, yScale: 1, dx: 0, dy: 0 }; (i & 1) > 0 ? (i & 2) > 0 ? (T.dx = r.parseShort(), T.dy = r.parseShort()) : T.matchedPoints = [r.parseUShort(), r.parseUShort()] : (i & 2) > 0 ? (T.dx = r.parseChar(), T.dy = r.parseChar()) : T.matchedPoints = [r.parseByte(), r.parseByte()], (i & 8) > 0 ? T.xScale = T.yScale = r.parseF2Dot14() : (i & 64) > 0 ? (T.xScale = r.parseF2Dot14(), T.yScale = r.parseF2Dot14()) : (i & 128) > 0 && (T.xScale = r.parseF2Dot14(), T.scale01 = r.parseF2Dot14(), T.scale10 = r.parseF2Dot14(), T.yScale = r.parseF2Dot14()), n.components.push(T), C = !!(i & 32) } if (i & 256) { n.instructionLength = r.parseUShort(), n.instructions = []; for (var I = 0; I < n.instructionLength; I += 1)n.instructions.push(r.parseByte()) } } } function E_(n, e) { for (var t = [], r = 0; r < n.length; r += 1) { var i = n[r], s = { x: e.xScale * i.x + e.scale01 * i.y + e.dx, y: e.scale10 * i.x + e.yScale * i.y + e.dy, onCurve: i.onCurve, lastPointOfContour: i.lastPointOfContour }; t.push(s) } return t } function Hse(n) { for (var e = [], t = [], r = 0; r < n.length; r += 1) { var i = n[r]; t.push(i), i.lastPointOfContour && (e.push(t), t = []) } return An.argument(t.length === 0, "There are still points left in the current contour."), e } function RG(n) { var e = new Ts; if (!n) return e; for (var t = Hse(n), r = 0; r < t.length; ++r) { var i = t[r], s = null, a = i[i.length - 1], o = i[0]; if (a.onCurve) e.moveTo(a.x, a.y); else if (o.onCurve) e.moveTo(o.x, o.y); else { var l = { x: (a.x + o.x) * .5, y: (a.y + o.y) * .5 }; e.moveTo(l.x, l.y) } for (var u = 0; u < i.length; ++u)if (s = a, a = o, o = i[(u + 1) % i.length], a.onCurve) e.lineTo(a.x, a.y); else { var c = o; s.onCurve || ((a.x + s.x) * .5, (a.y + s.y) * .5), o.onCurve || (c = { x: (a.x + o.x) * .5, y: (a.y + o.y) * .5 }), e.quadraticCurveTo(a.x, a.y, c.x, c.y) } e.closePath() } return e } function PG(n, e) { if (e.isComposite) for (var t = 0; t < e.components.length; t += 1) { var r = e.components[t], i = n.get(r.glyphIndex); if (i.getPath(), i.points) { var s = void 0; if (r.matchedPoints === void 0) s = E_(i.points, r); else { if (r.matchedPoints[0] > e.points.length - 1 || r.matchedPoints[1] > i.points.length - 1) throw Error("Matched points out of range in " + e.name); var a = e.points[r.matchedPoints[0]], o = i.points[r.matchedPoints[1]], l = { xScale: r.xScale, scale01: r.scale01, scale10: r.scale10, yScale: r.yScale, dx: 0, dy: 0 }; o = E_([o], l)[0], l.dx = a.x - o.x, l.dy = a.y - o.y, s = E_(i.points, l) } e.points = e.points.concat(s) } } return RG(e.points) } function zse(n, e, t, r) { for (var i = new uc.GlyphSet(r), s = 0; s < t.length - 1; s += 1) { var a = t[s], o = t[s + 1]; a !== o ? i.push(s, uc.ttfGlyphLoader(r, s, BG, n, e + a, PG)) : i.push(s, uc.glyphLoader(r, s)) } return i } function Vse(n, e, t, r) { var i = new uc.GlyphSet(r); return r._push = function (s) { var a = t[s], o = t[s + 1]; a !== o ? i.push(s, uc.ttfGlyphLoader(r, s, BG, n, e + a, PG)) : i.push(s, uc.glyphLoader(r, s)) }, i } function Wse(n, e, t, r, i) { return i.lowMemory ? Vse(n, e, t, r) : zse(n, e, t, r) } var Xse = { getPath: RG, parse: Wse }, DG, Bp, LG, w7; function FG(n) { this.font = n, this.getCommands = function (e) { return Xse.getPath(e).commands }, this._fpgmState = this._prepState = void 0, this._errorState = 0 } function Yse(n) { return n } function kG(n) { return Math.sign(n) * Math.round(Math.abs(n)) } function jse(n) { return Math.sign(n) * Math.round(Math.abs(n * 2)) / 2 } function Jse(n) { return Math.sign(n) * (Math.round(Math.abs(n) + .5) - .5) } function Kse(n) { return Math.sign(n) * Math.ceil(Math.abs(n)) } function qse(n) { return Math.sign(n) * Math.floor(Math.abs(n)) } var NG = function (n) { var e = this.srPeriod, t = this.srPhase, r = this.srThreshold, i = 1; return n < 0 && (n = -n, i = -1), n += r - t, n = Math.trunc(n / e) * e, n += t, n < 0 ? t * i : n * i }, $u = { x: 1, y: 0, axis: "x", distance: function (n, e, t, r) { return (t ? n.xo : n.x) - (r ? e.xo : e.x) }, interpolate: function (n, e, t, r) { var i, s, a, o, l, u, c; if (!r || r === this) { if (i = n.xo - e.xo, s = n.xo - t.xo, l = e.x - e.xo, u = t.x - t.xo, a = Math.abs(i), o = Math.abs(s), c = a + o, c === 0) { n.x = n.xo + (l + u) / 2; return } n.x = n.xo + (l * o + u * a) / c; return } if (i = r.distance(n, e, !0, !0), s = r.distance(n, t, !0, !0), l = r.distance(e, e, !1, !0), u = r.distance(t, t, !1, !0), a = Math.abs(i), o = Math.abs(s), c = a + o, c === 0) { $u.setRelative(n, n, (l + u) / 2, r, !0); return } $u.setRelative(n, n, (l * o + u * a) / c, r, !0) }, normalSlope: Number.NEGATIVE_INFINITY, setRelative: function (n, e, t, r, i) { if (!r || r === this) { n.x = (i ? e.xo : e.x) + t; return } var s = i ? e.xo : e.x, a = i ? e.yo : e.y, o = s + t * r.x, l = a + t * r.y; n.x = o + (n.y - l) / r.normalSlope }, slope: 0, touch: function (n) { n.xTouched = !0 }, touched: function (n) { return n.xTouched }, untouch: function (n) { n.xTouched = !1 } }, tf = { x: 0, y: 1, axis: "y", distance: function (n, e, t, r) { return (t ? n.yo : n.y) - (r ? e.yo : e.y) }, interpolate: function (n, e, t, r) { var i, s, a, o, l, u, c; if (!r || r === this) { if (i = n.yo - e.yo, s = n.yo - t.yo, l = e.y - e.yo, u = t.y - t.yo, a = Math.abs(i), o = Math.abs(s), c = a + o, c === 0) { n.y = n.yo + (l + u) / 2; return } n.y = n.yo + (l * o + u * a) / c; return } if (i = r.distance(n, e, !0, !0), s = r.distance(n, t, !0, !0), l = r.distance(e, e, !1, !0), u = r.distance(t, t, !1, !0), a = Math.abs(i), o = Math.abs(s), c = a + o, c === 0) { tf.setRelative(n, n, (l + u) / 2, r, !0); return } tf.setRelative(n, n, (l * o + u * a) / c, r, !0) }, normalSlope: 0, setRelative: function (n, e, t, r, i) { if (!r || r === this) { n.y = (i ? e.yo : e.y) + t; return } var s = i ? e.xo : e.x, a = i ? e.yo : e.y, o = s + t * r.x, l = a + t * r.y; n.y = l + r.normalSlope * (n.x - o) }, slope: Number.POSITIVE_INFINITY, touch: function (n) { n.yTouched = !0 }, touched: function (n) { return n.yTouched }, untouch: function (n) { n.yTouched = !1 } }; Object.freeze($u); Object.freeze(tf); function Y1(n, e) { this.x = n, this.y = e, this.axis = void 0, this.slope = e / n, this.normalSlope = -n / e, Object.freeze(this) } Y1.prototype.distance = function (n, e, t, r) { return this.x * $u.distance(n, e, t, r) + this.y * tf.distance(n, e, t, r) }; Y1.prototype.interpolate = function (n, e, t, r) { var i, s, a, o, l, u, c; if (a = r.distance(n, e, !0, !0), o = r.distance(n, t, !0, !0), i = r.distance(e, e, !1, !0), s = r.distance(t, t, !1, !0), l = Math.abs(a), u = Math.abs(o), c = l + u, c === 0) { this.setRelative(n, n, (i + s) / 2, r, !0); return } this.setRelative(n, n, (i * u + s * l) / c, r, !0) }; Y1.prototype.setRelative = function (n, e, t, r, i) { r = r || this; var s = i ? e.xo : e.x, a = i ? e.yo : e.y, o = s + t * r.x, l = a + t * r.y, u = r.normalSlope, c = this.slope, h = n.x, d = n.y; n.x = (c * h - u * o + l - d) / (c - u), n.y = c * (n.x - h) + d }; Y1.prototype.touch = function (n) { n.xTouched = !0, n.yTouched = !0 }; function j1(n, e) { var t = Math.sqrt(n * n + e * e); return n /= t, e /= t, n === 1 && e === 0 ? $u : n === 0 && e === 1 ? tf : new Y1(n, e) } function af(n, e, t, r) { this.x = this.xo = Math.round(n * 64) / 64, this.y = this.yo = Math.round(e * 64) / 64, this.lastPointOfContour = t, this.onCurve = r, this.prevPointOnContour = void 0, this.nextPointOnContour = void 0, this.xTouched = !1, this.yTouched = !1, Object.preventExtensions(this) } af.prototype.nextTouched = function (n) { for (var e = this.nextPointOnContour; !n.touched(e) && e !== this;)e = e.nextPointOnContour; return e }; af.prototype.prevTouched = function (n) { for (var e = this.prevPointOnContour; !n.touched(e) && e !== this;)e = e.prevPointOnContour; return e }; var m1 = Object.freeze(new af(0, 0)), Zse = { cvCutIn: 17 / 16, deltaBase: 9, deltaShift: .125, loop: 1, minDis: 1, autoFlip: !0 }; function ch(n, e) { switch (this.env = n, this.stack = [], this.prog = e, n) { case "glyf": this.zp0 = this.zp1 = this.zp2 = 1, this.rp0 = this.rp1 = this.rp2 = 0; case "prep": this.fv = this.pv = this.dpv = $u, this.round = kG } } FG.prototype.exec = function (n, e) { if (typeof e != "number") throw new Error("Point size is not a number!"); if (!(this._errorState > 2)) { var t = this.font, r = this._prepState; if (!r || r.ppem !== e) { var i = this._fpgmState; if (!i) { ch.prototype = Zse, i = this._fpgmState = new ch("fpgm", t.tables.fpgm), i.funcs = [], i.font = t, ke.DEBUG && (console.log("---EXEC FPGM---"), i.step = -1); try { Bp(i) } catch (u) { console.log("Hinting error in FPGM:" + u), this._errorState = 3; return } } ch.prototype = i, r = this._prepState = new ch("prep", t.tables.prep), r.ppem = e; var s = t.tables.cvt; if (s) for (var a = r.cvt = new Array(s.length), o = e / t.unitsPerEm, l = 0; l < s.length; l++)a[l] = s[l] * o; else r.cvt = []; ke.DEBUG && (console.log("---EXEC PREP---"), r.step = -1); try { Bp(r) } catch (u) { this._errorState < 2 && console.log("Hinting error in PREP:" + u), this._errorState = 2 } } if (!(this._errorState > 1)) try { return LG(n, r) } catch (u) { this._errorState < 1 && (console.log("Hinting error:" + u), console.log("Note: further hinting errors are silenced")), this._errorState = 1; return } } }; LG = function (n, e) { var t = e.ppem / e.font.unitsPerEm, r = t, i = n.components, s, a, o; if (ch.prototype = e, !i) o = new ch("glyf", n.instructions), ke.DEBUG && (console.log("---EXEC GLYPH---"), o.step = -1), w7(n, o, t, r), a = o.gZone; else { var l = e.font; a = [], s = []; for (var u = 0; u < i.length; u++) { var c = i[u], h = l.glyphs.get(c.glyphIndex); o = new ch("glyf", h.instructions), ke.DEBUG && (console.log("---EXEC COMP " + u + "---"), o.step = -1), w7(h, o, t, r); for (var d = Math.round(c.dx * t), m = Math.round(c.dy * r), g = o.gZone, v = o.contours, y = 0; y < g.length; y++) { var A = g[y]; A.xTouched = A.yTouched = !1, A.xo = A.x = A.x + d, A.yo = A.y = A.y + m } var _ = a.length; a.push.apply(a, g); for (var x = 0; x < v.length; x++)s.push(v[x] + _) } n.instructions && !o.inhibitGridFit && (o = new ch("glyf", n.instructions), o.gZone = o.z0 = o.z1 = o.z2 = a, o.contours = s, a.push(new af(0, 0), new af(Math.round(n.advanceWidth * t), 0)), ke.DEBUG && (console.log("---EXEC COMPOSITE---"), o.step = -1), Bp(o), a.length -= 2) } return a }; w7 = function (n, e, t, r) { for (var i = n.points || [], s = i.length, a = e.gZone = e.z0 = e.z1 = e.z2 = [], o = e.contours = [], l, u = 0; u < s; u++)l = i[u], a[u] = new af(l.x * t, l.y * r, l.lastPointOfContour, l.onCurve); for (var c, h, d = 0; d < s; d++)l = a[d], c || (c = l, o.push(d)), l.lastPointOfContour ? (l.nextPointOnContour = c, c.prevPointOnContour = l, c = void 0) : (h = a[d + 1], l.nextPointOnContour = h, h.prevPointOnContour = l); if (!e.inhibitGridFit) { if (ke.DEBUG) { console.log("PROCESSING GLYPH", e.stack); for (var m = 0; m < s; m++)console.log(m, a[m].x, a[m].y) } if (a.push(new af(0, 0), new af(Math.round(n.advanceWidth * t), 0)), Bp(e), a.length -= 2, ke.DEBUG) { console.log("FINISHED GLYPH", e.stack); for (var g = 0; g < s; g++)console.log(g, a[g].x, a[g].y) } } }; Bp = function (n) { var e = n.prog; if (e) { var t = e.length, r; for (n.ip = 0; n.ip < t; n.ip++) { if (ke.DEBUG && n.step++, r = DG[e[n.ip]], !r) throw new Error("unknown instruction: 0x" + Number(e[n.ip]).toString(16)); r(n) } } }; function F8(n) { for (var e = n.tZone = new Array(n.gZone.length), t = 0; t < e.length; t++)e[t] = new af(0, 0) } function OG(n, e) { var t = n.prog, r = n.ip, i = 1, s; do if (s = t[++r], s === 88) i++; else if (s === 89) i--; else if (s === 64) r += t[r + 1] + 1; else if (s === 65) r += 2 * t[r + 1] + 1; else if (s >= 176 && s <= 183) r += s - 176 + 1; else if (s >= 184 && s <= 191) r += (s - 184 + 1) * 2; else if (e && i === 1 && s === 27) break; while (i > 0); n.ip = r } function TR(n, e) { ke.DEBUG && console.log(e.step, "SVTCA[" + n.axis + "]"), e.fv = e.pv = e.dpv = n } function wR(n, e) { ke.DEBUG && console.log(e.step, "SPVTCA[" + n.axis + "]"), e.pv = e.dpv = n } function IR(n, e) { ke.DEBUG && console.log(e.step, "SFVTCA[" + n.axis + "]"), e.fv = n } function MR(n, e) { var t = e.stack, r = t.pop(), i = t.pop(), s = e.z2[r], a = e.z1[i]; ke.DEBUG && console.log("SPVTL[" + n + "]", r, i); var o, l; n ? (o = s.y - a.y, l = a.x - s.x) : (o = a.x - s.x, l = a.y - s.y), e.pv = e.dpv = j1(o, l) } function bR(n, e) { var t = e.stack, r = t.pop(), i = t.pop(), s = e.z2[r], a = e.z1[i]; ke.DEBUG && console.log("SFVTL[" + n + "]", r, i); var o, l; n ? (o = s.y - a.y, l = a.x - s.x) : (o = a.x - s.x, l = a.y - s.y), e.fv = j1(o, l) } function $se(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "SPVFS[]", t, r), n.pv = n.dpv = j1(r, t) } function eae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "SPVFS[]", t, r), n.fv = j1(r, t) } function tae(n) { var e = n.stack, t = n.pv; ke.DEBUG && console.log(n.step, "GPV[]"), e.push(t.x * 16384), e.push(t.y * 16384) } function nae(n) { var e = n.stack, t = n.fv; ke.DEBUG && console.log(n.step, "GFV[]"), e.push(t.x * 16384), e.push(t.y * 16384) } function rae(n) { n.fv = n.pv, ke.DEBUG && console.log(n.step, "SFVTPV[]") } function iae(n) { var e = n.stack, t = e.pop(), r = e.pop(), i = e.pop(), s = e.pop(), a = e.pop(), o = n.z0, l = n.z1, u = o[t], c = o[r], h = l[i], d = l[s], m = n.z2[a]; ke.DEBUG && console.log("ISECT[], ", t, r, i, s, a); var g = u.x, v = u.y, y = c.x, A = c.y, _ = h.x, x = h.y, C = d.x, T = d.y, I = (g - y) * (x - T) - (v - A) * (_ - C), w = g * A - v * y, R = _ * T - x * C; m.x = (w * (_ - C) - R * (g - y)) / I, m.y = (w * (x - T) - R * (v - A)) / I } function sae(n) { n.rp0 = n.stack.pop(), ke.DEBUG && console.log(n.step, "SRP0[]", n.rp0) } function aae(n) { n.rp1 = n.stack.pop(), ke.DEBUG && console.log(n.step, "SRP1[]", n.rp1) } function oae(n) { n.rp2 = n.stack.pop(), ke.DEBUG && console.log(n.step, "SRP2[]", n.rp2) } function lae(n) { var e = n.stack.pop(); switch (ke.DEBUG && console.log(n.step, "SZP0[]", e), n.zp0 = e, e) { case 0: n.tZone || F8(n), n.z0 = n.tZone; break; case 1: n.z0 = n.gZone; break; default: throw new Error("Invalid zone pointer") } } function uae(n) { var e = n.stack.pop(); switch (ke.DEBUG && console.log(n.step, "SZP1[]", e), n.zp1 = e, e) { case 0: n.tZone || F8(n), n.z1 = n.tZone; break; case 1: n.z1 = n.gZone; break; default: throw new Error("Invalid zone pointer") } } function cae(n) { var e = n.stack.pop(); switch (ke.DEBUG && console.log(n.step, "SZP2[]", e), n.zp2 = e, e) { case 0: n.tZone || F8(n), n.z2 = n.tZone; break; case 1: n.z2 = n.gZone; break; default: throw new Error("Invalid zone pointer") } } function fae(n) { var e = n.stack.pop(); switch (ke.DEBUG && console.log(n.step, "SZPS[]", e), n.zp0 = n.zp1 = n.zp2 = e, e) { case 0: n.tZone || F8(n), n.z0 = n.z1 = n.z2 = n.tZone; break; case 1: n.z0 = n.z1 = n.z2 = n.gZone; break; default: throw new Error("Invalid zone pointer") } } function hae(n) { n.loop = n.stack.pop(), ke.DEBUG && console.log(n.step, "SLOOP[]", n.loop) } function dae(n) { ke.DEBUG && console.log(n.step, "RTG[]"), n.round = kG } function pae(n) { ke.DEBUG && console.log(n.step, "RTHG[]"), n.round = Jse } function mae(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "SMD[]", e), n.minDis = e / 64 } function gae(n) { ke.DEBUG && console.log(n.step, "ELSE[]"), OG(n, !1) } function Aae(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "JMPR[]", e), n.ip += e - 1 } function vae(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "SCVTCI[]", e), n.cvCutIn = e / 64 } function yae(n) { var e = n.stack; ke.DEBUG && console.log(n.step, "DUP[]"), e.push(e[e.length - 1]) } function C_(n) { ke.DEBUG && console.log(n.step, "POP[]"), n.stack.pop() } function xae(n) { ke.DEBUG && console.log(n.step, "CLEAR[]"), n.stack.length = 0 } function _ae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "SWAP[]"), e.push(t), e.push(r) } function Eae(n) { var e = n.stack; ke.DEBUG && console.log(n.step, "DEPTH[]"), e.push(e.length) } function Cae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "LOOPCALL[]", t, r); var i = n.ip, s = n.prog; n.prog = n.funcs[t]; for (var a = 0; a < r; a++)Bp(n), ke.DEBUG && console.log(++n.step, a + 1 < r ? "next loopcall" : "done loopcall", a); n.ip = i, n.prog = s } function Sae(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "CALL[]", e); var t = n.ip, r = n.prog; n.prog = n.funcs[e], Bp(n), n.ip = t, n.prog = r, ke.DEBUG && console.log(++n.step, "returning from", e) } function Tae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "CINDEX[]", t), e.push(e[e.length - t]) } function wae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "MINDEX[]", t), e.push(e.splice(e.length - t, 1)[0]) } function Iae(n) { if (n.env !== "fpgm") throw new Error("FDEF not allowed here"); var e = n.stack, t = n.prog, r = n.ip, i = e.pop(), s = r; for (ke.DEBUG && console.log(n.step, "FDEF[]", i); t[++r] !== 45;); n.ip = r, n.funcs[i] = t.slice(s + 1, r) } function BR(n, e) { var t = e.stack.pop(), r = e.z0[t], i = e.fv, s = e.pv; ke.DEBUG && console.log(e.step, "MDAP[" + n + "]", t); var a = s.distance(r, m1); n && (a = e.round(a)), i.setRelative(r, m1, a, s), i.touch(r), e.rp0 = e.rp1 = t } function RR(n, e) { var t = e.z2, r = t.length - 2, i, s, a; ke.DEBUG && console.log(e.step, "IUP[" + n.axis + "]"); for (var o = 0; o < r; o++)i = t[o], !n.touched(i) && (s = i.prevTouched(n), s !== i && (a = i.nextTouched(n), s === a && n.setRelative(i, i, n.distance(s, s, !1, !0), n, !0), n.interpolate(i, s, a, n))) } function PR(n, e) { for (var t = e.stack, r = n ? e.rp1 : e.rp2, i = (n ? e.z0 : e.z1)[r], s = e.fv, a = e.pv, o = e.loop, l = e.z2; o--;) { var u = t.pop(), c = l[u], h = a.distance(i, i, !1, !0); s.setRelative(c, c, h, a), s.touch(c), ke.DEBUG && console.log(e.step, (e.loop > 1 ? "loop " + (e.loop - o) + ": " : "") + "SHP[" + (n ? "rp1" : "rp2") + "]", u) } e.loop = 1 } function DR(n, e) { var t = e.stack, r = n ? e.rp1 : e.rp2, i = (n ? e.z0 : e.z1)[r], s = e.fv, a = e.pv, o = t.pop(), l = e.z2[e.contours[o]], u = l; ke.DEBUG && console.log(e.step, "SHC[" + n + "]", o); var c = a.distance(i, i, !1, !0); do u !== i && s.setRelative(u, u, c, a), u = u.nextPointOnContour; while (u !== l) } function LR(n, e) { var t = e.stack, r = n ? e.rp1 : e.rp2, i = (n ? e.z0 : e.z1)[r], s = e.fv, a = e.pv, o = t.pop(); ke.DEBUG && console.log(e.step, "SHZ[" + n + "]", o); var l; switch (o) { case 0: l = e.tZone; break; case 1: l = e.gZone; break; default: throw new Error("Invalid zone") }for (var u, c = a.distance(i, i, !1, !0), h = l.length - 2, d = 0; d < h; d++)u = l[d], s.setRelative(u, u, c, a) } function Mae(n) { for (var e = n.stack, t = n.loop, r = n.fv, i = e.pop() / 64, s = n.z2; t--;) { var a = e.pop(), o = s[a]; ke.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - t) + ": " : "") + "SHPIX[]", a, i), r.setRelative(o, o, i), r.touch(o) } n.loop = 1 } function bae(n) { for (var e = n.stack, t = n.rp1, r = n.rp2, i = n.loop, s = n.z0[t], a = n.z1[r], o = n.fv, l = n.dpv, u = n.z2; i--;) { var c = e.pop(), h = u[c]; ke.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - i) + ": " : "") + "IP[]", c, t, "<->", r), o.interpolate(h, s, a, l), o.touch(h) } n.loop = 1 } function FR(n, e) { var t = e.stack, r = t.pop() / 64, i = t.pop(), s = e.z1[i], a = e.z0[e.rp0], o = e.fv, l = e.pv; o.setRelative(s, a, r, l), o.touch(s), ke.DEBUG && console.log(e.step, "MSIRP[" + n + "]", r, i), e.rp1 = e.rp0, e.rp2 = i, n && (e.rp0 = i) } function Bae(n) { for (var e = n.stack, t = n.rp0, r = n.z0[t], i = n.loop, s = n.fv, a = n.pv, o = n.z1; i--;) { var l = e.pop(), u = o[l]; ke.DEBUG && console.log(n.step, (n.loop > 1 ? "loop " + (n.loop - i) + ": " : "") + "ALIGNRP[]", l), s.setRelative(u, r, 0, a), s.touch(u) } n.loop = 1 } function Rae(n) { ke.DEBUG && console.log(n.step, "RTDG[]"), n.round = jse } function kR(n, e) { var t = e.stack, r = t.pop(), i = t.pop(), s = e.z0[i], a = e.fv, o = e.pv, l = e.cvt[r]; ke.DEBUG && console.log(e.step, "MIAP[" + n + "]", r, "(", l, ")", i); var u = o.distance(s, m1); n && (Math.abs(u - l) < e.cvCutIn && (u = l), u = e.round(u)), a.setRelative(s, m1, u, o), e.zp0 === 0 && (s.xo = s.x, s.yo = s.y), a.touch(s), e.rp0 = e.rp1 = i } function Pae(n) { var e = n.prog, t = n.ip, r = n.stack, i = e[++t]; ke.DEBUG && console.log(n.step, "NPUSHB[]", i); for (var s = 0; s < i; s++)r.push(e[++t]); n.ip = t } function Dae(n) { var e = n.ip, t = n.prog, r = n.stack, i = t[++e]; ke.DEBUG && console.log(n.step, "NPUSHW[]", i); for (var s = 0; s < i; s++) { var a = t[++e] << 8 | t[++e]; a & 32768 && (a = -((a ^ 65535) + 1)), r.push(a) } n.ip = e } function Lae(n) { var e = n.stack, t = n.store; t || (t = n.store = []); var r = e.pop(), i = e.pop(); ke.DEBUG && console.log(n.step, "WS", r, i), t[i] = r } function Fae(n) { var e = n.stack, t = n.store, r = e.pop(); ke.DEBUG && console.log(n.step, "RS", r); var i = t && t[r] || 0; e.push(i) } function kae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "WCVTP", t, r), n.cvt[r] = t / 64 } function Nae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "RCVT", t), e.push(n.cvt[t] * 64) } function NR(n, e) { var t = e.stack, r = t.pop(), i = e.z2[r]; ke.DEBUG && console.log(e.step, "GC[" + n + "]", r), t.push(e.dpv.distance(i, m1, n, !1) * 64) } function OR(n, e) { var t = e.stack, r = t.pop(), i = t.pop(), s = e.z1[r], a = e.z0[i], o = e.dpv.distance(a, s, n, n); ke.DEBUG && console.log(e.step, "MD[" + n + "]", r, i, "->", o), e.stack.push(Math.round(o * 64)) } function Oae(n) { ke.DEBUG && console.log(n.step, "MPPEM[]"), n.stack.push(n.ppem) } function Uae(n) { ke.DEBUG && console.log(n.step, "FLIPON[]"), n.autoFlip = !0 } function Gae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "LT[]", t, r), e.push(r < t ? 1 : 0) } function Qae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "LTEQ[]", t, r), e.push(r <= t ? 1 : 0) } function Hae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "GT[]", t, r), e.push(r > t ? 1 : 0) } function zae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "GTEQ[]", t, r), e.push(r >= t ? 1 : 0) } function Vae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "EQ[]", t, r), e.push(t === r ? 1 : 0) } function Wae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "NEQ[]", t, r), e.push(t !== r ? 1 : 0) } function Xae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "ODD[]", t), e.push(Math.trunc(t) % 2 ? 1 : 0) } function Yae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "EVEN[]", t), e.push(Math.trunc(t) % 2 ? 0 : 1) } function jae(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "IF[]", e), e || (OG(n, !0), ke.DEBUG && console.log(n.step, "EIF[]")) } function Jae(n) { ke.DEBUG && console.log(n.step, "EIF[]") } function Kae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "AND[]", t, r), e.push(t && r ? 1 : 0) } function qae(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "OR[]", t, r), e.push(t || r ? 1 : 0) } function Zae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "NOT[]", t), e.push(t ? 0 : 1) } function S_(n, e) { var t = e.stack, r = t.pop(), i = e.fv, s = e.pv, a = e.ppem, o = e.deltaBase + (n - 1) * 16, l = e.deltaShift, u = e.z0; ke.DEBUG && console.log(e.step, "DELTAP[" + n + "]", r, t); for (var c = 0; c < r; c++) { var h = t.pop(), d = t.pop(), m = o + ((d & 240) >> 4); if (m === a) { var g = (d & 15) - 8; g >= 0 && g++, ke.DEBUG && console.log(e.step, "DELTAPFIX", h, "by", g * l); var v = u[h]; i.setRelative(v, v, g * l, s) } } } function $ae(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "SDB[]", t), n.deltaBase = t } function eoe(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "SDS[]", t), n.deltaShift = Math.pow(.5, t) } function toe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "ADD[]", t, r), e.push(r + t) } function noe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "SUB[]", t, r), e.push(r - t) } function roe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "DIV[]", t, r), e.push(r * 64 / t) } function ioe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "MUL[]", t, r), e.push(r * t / 64) } function soe(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "ABS[]", t), e.push(Math.abs(t)) } function aoe(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "NEG[]", t), e.push(-t) } function ooe(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "FLOOR[]", t), e.push(Math.floor(t / 64) * 64) } function loe(n) { var e = n.stack, t = e.pop(); ke.DEBUG && console.log(n.step, "CEILING[]", t), e.push(Math.ceil(t / 64) * 64) } function g5(n, e) { var t = e.stack, r = t.pop(); ke.DEBUG && console.log(e.step, "ROUND[]"), t.push(e.round(r / 64) * 64) } function uoe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "WCVTF[]", t, r), n.cvt[r] = t * n.ppem / n.font.unitsPerEm } function T_(n, e) { var t = e.stack, r = t.pop(), i = e.ppem, s = e.deltaBase + (n - 1) * 16, a = e.deltaShift; ke.DEBUG && console.log(e.step, "DELTAC[" + n + "]", r, t); for (var o = 0; o < r; o++) { var l = t.pop(), u = t.pop(), c = s + ((u & 240) >> 4); if (c === i) { var h = (u & 15) - 8; h >= 0 && h++; var d = h * a; ke.DEBUG && console.log(e.step, "DELTACFIX", l, "by", d), e.cvt[l] += d } } } function coe(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "SROUND[]", e), n.round = NG; var t; switch (e & 192) { case 0: t = .5; break; case 64: t = 1; break; case 128: t = 2; break; default: throw new Error("invalid SROUND value") }switch (n.srPeriod = t, e & 48) { case 0: n.srPhase = 0; break; case 16: n.srPhase = .25 * t; break; case 32: n.srPhase = .5 * t; break; case 48: n.srPhase = .75 * t; break; default: throw new Error("invalid SROUND value") }e &= 15, e === 0 ? n.srThreshold = 0 : n.srThreshold = (e / 8 - .5) * t } function foe(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "S45ROUND[]", e), n.round = NG; var t; switch (e & 192) { case 0: t = Math.sqrt(2) / 2; break; case 64: t = Math.sqrt(2); break; case 128: t = 2 * Math.sqrt(2); break; default: throw new Error("invalid S45ROUND value") }switch (n.srPeriod = t, e & 48) { case 0: n.srPhase = 0; break; case 16: n.srPhase = .25 * t; break; case 32: n.srPhase = .5 * t; break; case 48: n.srPhase = .75 * t; break; default: throw new Error("invalid S45ROUND value") }e &= 15, e === 0 ? n.srThreshold = 0 : n.srThreshold = (e / 8 - .5) * t } function hoe(n) { ke.DEBUG && console.log(n.step, "ROFF[]"), n.round = Yse } function doe(n) { ke.DEBUG && console.log(n.step, "RUTG[]"), n.round = Kse } function poe(n) { ke.DEBUG && console.log(n.step, "RDTG[]"), n.round = qse } function moe(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "SCANCTRL[]", e) } function UR(n, e) { var t = e.stack, r = t.pop(), i = t.pop(), s = e.z2[r], a = e.z1[i]; ke.DEBUG && console.log(e.step, "SDPVTL[" + n + "]", r, i); var o, l; n ? (o = s.y - a.y, l = a.x - s.x) : (o = a.x - s.x, l = a.y - s.y), e.dpv = j1(o, l) } function goe(n) { var e = n.stack, t = e.pop(), r = 0; ke.DEBUG && console.log(n.step, "GETINFO[]", t), t & 1 && (r = 35), t & 32 && (r |= 4096), e.push(r) } function Aoe(n) { var e = n.stack, t = e.pop(), r = e.pop(), i = e.pop(); ke.DEBUG && console.log(n.step, "ROLL[]"), e.push(r), e.push(t), e.push(i) } function voe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "MAX[]", t, r), e.push(Math.max(r, t)) } function yoe(n) { var e = n.stack, t = e.pop(), r = e.pop(); ke.DEBUG && console.log(n.step, "MIN[]", t, r), e.push(Math.min(r, t)) } function xoe(n) { var e = n.stack.pop(); ke.DEBUG && console.log(n.step, "SCANTYPE[]", e) } function _oe(n) { var e = n.stack.pop(), t = n.stack.pop(); switch (ke.DEBUG && console.log(n.step, "INSTCTRL[]", e, t), e) { case 1: n.inhibitGridFit = !!t; return; case 2: n.ignoreCvt = !!t; return; default: throw new Error("invalid INSTCTRL[] selector") } } function Vf(n, e) { var t = e.stack, r = e.prog, i = e.ip; ke.DEBUG && console.log(e.step, "PUSHB[" + n + "]"); for (var s = 0; s < n; s++)t.push(r[++i]); e.ip = i } function Wf(n, e) { var t = e.ip, r = e.prog, i = e.stack; ke.DEBUG && console.log(e.ip, "PUSHW[" + n + "]"); for (var s = 0; s < n; s++) { var a = r[++t] << 8 | r[++t]; a & 32768 && (a = -((a ^ 65535) + 1)), i.push(a) } e.ip = t } function Bt(n, e, t, r, i, s) { var a = s.stack, o = n && a.pop(), l = a.pop(), u = s.rp0, c = s.z0[u], h = s.z1[l], d = s.minDis, m = s.fv, g = s.dpv, v, y, A, _; y = v = g.distance(h, c, !0, !0), A = y >= 0 ? 1 : -1, y = Math.abs(y), n && (_ = s.cvt[o], r && Math.abs(y - _) < s.cvCutIn && (y = _)), t && y < d && (y = d), r && (y = s.round(y)), m.setRelative(h, c, A * y, g), m.touch(h), ke.DEBUG && console.log(s.step, (n ? "MIRP[" : "MDRP[") + (e ? "M" : "m") + (t ? ">" : "_") + (r ? "R" : "_") + (i === 0 ? "Gr" : i === 1 ? "Bl" : i === 2 ? "Wh" : "") + "]", n ? o + "(" + s.cvt[o] + "," + _ + ")" : "", l, "(d =", v, "->", A * y, ")"), s.rp1 = s.rp0, s.rp2 = l, e && (s.rp0 = l) } DG = [TR.bind(void 0, tf), TR.bind(void 0, $u), wR.bind(void 0, tf), wR.bind(void 0, $u), IR.bind(void 0, tf), IR.bind(void 0, $u), MR.bind(void 0, 0), MR.bind(void 0, 1), bR.bind(void 0, 0), bR.bind(void 0, 1), $se, eae, tae, nae, rae, iae, sae, aae, oae, lae, uae, cae, fae, hae, dae, pae, mae, gae, Aae, vae, void 0, void 0, yae, C_, xae, _ae, Eae, Tae, wae, void 0, void 0, void 0, Cae, Sae, Iae, void 0, BR.bind(void 0, 0), BR.bind(void 0, 1), RR.bind(void 0, tf), RR.bind(void 0, $u), PR.bind(void 0, 0), PR.bind(void 0, 1), DR.bind(void 0, 0), DR.bind(void 0, 1), LR.bind(void 0, 0), LR.bind(void 0, 1), Mae, bae, FR.bind(void 0, 0), FR.bind(void 0, 1), Bae, Rae, kR.bind(void 0, 0), kR.bind(void 0, 1), Pae, Dae, Lae, Fae, kae, Nae, NR.bind(void 0, 0), NR.bind(void 0, 1), void 0, OR.bind(void 0, 0), OR.bind(void 0, 1), Oae, void 0, Uae, void 0, void 0, Gae, Qae, Hae, zae, Vae, Wae, Xae, Yae, jae, Jae, Kae, qae, Zae, S_.bind(void 0, 1), $ae, eoe, toe, noe, roe, ioe, soe, aoe, ooe, loe, g5.bind(void 0, 0), g5.bind(void 0, 1), g5.bind(void 0, 2), g5.bind(void 0, 3), void 0, void 0, void 0, void 0, uoe, S_.bind(void 0, 2), S_.bind(void 0, 3), T_.bind(void 0, 1), T_.bind(void 0, 2), T_.bind(void 0, 3), coe, foe, void 0, void 0, hoe, void 0, doe, poe, C_, C_, void 0, void 0, void 0, void 0, void 0, moe, UR.bind(void 0, 0), UR.bind(void 0, 1), goe, void 0, Aoe, voe, yoe, xoe, _oe, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, Vf.bind(void 0, 1), Vf.bind(void 0, 2), Vf.bind(void 0, 3), Vf.bind(void 0, 4), Vf.bind(void 0, 5), Vf.bind(void 0, 6), Vf.bind(void 0, 7), Vf.bind(void 0, 8), Wf.bind(void 0, 1), Wf.bind(void 0, 2), Wf.bind(void 0, 3), Wf.bind(void 0, 4), Wf.bind(void 0, 5), Wf.bind(void 0, 6), Wf.bind(void 0, 7), Wf.bind(void 0, 8), Bt.bind(void 0, 0, 0, 0, 0, 0), Bt.bind(void 0, 0, 0, 0, 0, 1), Bt.bind(void 0, 0, 0, 0, 0, 2), Bt.bind(void 0, 0, 0, 0, 0, 3), Bt.bind(void 0, 0, 0, 0, 1, 0), Bt.bind(void 0, 0, 0, 0, 1, 1), Bt.bind(void 0, 0, 0, 0, 1, 2), Bt.bind(void 0, 0, 0, 0, 1, 3), Bt.bind(void 0, 0, 0, 1, 0, 0), Bt.bind(void 0, 0, 0, 1, 0, 1), Bt.bind(void 0, 0, 0, 1, 0, 2), Bt.bind(void 0, 0, 0, 1, 0, 3), Bt.bind(void 0, 0, 0, 1, 1, 0), Bt.bind(void 0, 0, 0, 1, 1, 1), Bt.bind(void 0, 0, 0, 1, 1, 2), Bt.bind(void 0, 0, 0, 1, 1, 3), Bt.bind(void 0, 0, 1, 0, 0, 0), Bt.bind(void 0, 0, 1, 0, 0, 1), Bt.bind(void 0, 0, 1, 0, 0, 2), Bt.bind(void 0, 0, 1, 0, 0, 3), Bt.bind(void 0, 0, 1, 0, 1, 0), Bt.bind(void 0, 0, 1, 0, 1, 1), Bt.bind(void 0, 0, 1, 0, 1, 2), Bt.bind(void 0, 0, 1, 0, 1, 3), Bt.bind(void 0, 0, 1, 1, 0, 0), Bt.bind(void 0, 0, 1, 1, 0, 1), Bt.bind(void 0, 0, 1, 1, 0, 2), Bt.bind(void 0, 0, 1, 1, 0, 3), Bt.bind(void 0, 0, 1, 1, 1, 0), Bt.bind(void 0, 0, 1, 1, 1, 1), Bt.bind(void 0, 0, 1, 1, 1, 2), Bt.bind(void 0, 0, 1, 1, 1, 3), Bt.bind(void 0, 1, 0, 0, 0, 0), Bt.bind(void 0, 1, 0, 0, 0, 1), Bt.bind(void 0, 1, 0, 0, 0, 2), Bt.bind(void 0, 1, 0, 0, 0, 3), Bt.bind(void 0, 1, 0, 0, 1, 0), Bt.bind(void 0, 1, 0, 0, 1, 1), Bt.bind(void 0, 1, 0, 0, 1, 2), Bt.bind(void 0, 1, 0, 0, 1, 3), Bt.bind(void 0, 1, 0, 1, 0, 0), Bt.bind(void 0, 1, 0, 1, 0, 1), Bt.bind(void 0, 1, 0, 1, 0, 2), Bt.bind(void 0, 1, 0, 1, 0, 3), Bt.bind(void 0, 1, 0, 1, 1, 0), Bt.bind(void 0, 1, 0, 1, 1, 1), Bt.bind(void 0, 1, 0, 1, 1, 2), Bt.bind(void 0, 1, 0, 1, 1, 3), Bt.bind(void 0, 1, 1, 0, 0, 0), Bt.bind(void 0, 1, 1, 0, 0, 1), Bt.bind(void 0, 1, 1, 0, 0, 2), Bt.bind(void 0, 1, 1, 0, 0, 3), Bt.bind(void 0, 1, 1, 0, 1, 0), Bt.bind(void 0, 1, 1, 0, 1, 1), Bt.bind(void 0, 1, 1, 0, 1, 2), Bt.bind(void 0, 1, 1, 0, 1, 3), Bt.bind(void 0, 1, 1, 1, 0, 0), Bt.bind(void 0, 1, 1, 1, 0, 1), Bt.bind(void 0, 1, 1, 1, 0, 2), Bt.bind(void 0, 1, 1, 1, 0, 3), Bt.bind(void 0, 1, 1, 1, 1, 0), Bt.bind(void 0, 1, 1, 1, 1, 1), Bt.bind(void 0, 1, 1, 1, 1, 2), Bt.bind(void 0, 1, 1, 1, 1, 3)]; function Tm(n) { this.char = n, this.state = {}, this.activeState = null } function wT(n, e, t) { this.contextName = t, this.startIndex = n, this.endOffset = e } function Eoe(n, e, t) { this.contextName = n, this.openRange = null, this.ranges = [], this.checkStart = e, this.checkEnd = t } function _u(n, e) { this.context = n, this.index = e, this.length = n.length, this.current = n[e], this.backtrack = n.slice(0, e), this.lookahead = n.slice(e + 1) } function k8(n) { this.eventId = n, this.subscribers = [] } function Coe(n) { var e = this, t = ["start", "end", "next", "newToken", "contextStart", "contextEnd", "insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD", "updateContextsRanges"]; t.forEach(function (i) { Object.defineProperty(e.events, i, { value: new k8(i) }) }), n && t.forEach(function (i) { var s = n[i]; typeof s == "function" && e.events[i].subscribe(s) }); var r = ["insertToken", "removeToken", "removeRange", "replaceToken", "replaceRange", "composeRUD"]; r.forEach(function (i) { e.events[i].subscribe(e.updateContextsRanges) }) } function Li(n) { this.tokens = [], this.registeredContexts = {}, this.contextCheckers = [], this.events = {}, this.registeredModifiers = [], Coe.call(this, n) } Tm.prototype.setState = function (n, e) { return this.state[n] = e, this.activeState = { key: n, value: this.state[n] }, this.activeState }; Tm.prototype.getState = function (n) { return this.state[n] || null }; Li.prototype.inboundIndex = function (n) { return n >= 0 && n < this.tokens.length }; Li.prototype.composeRUD = function (n) { var e = this, t = !0, r = n.map(function (s) { return e[s[0]].apply(e, s.slice(1).concat(t)) }), i = function (s) { return typeof s == "object" && s.hasOwnProperty("FAIL") }; if (r.every(i)) return { FAIL: "composeRUD: one or more operations hasn't completed successfully", report: r.filter(i) }; this.dispatch("composeRUD", [r.filter(function (s) { return !i(s) })]) }; Li.prototype.replaceRange = function (n, e, t, r) { e = e !== null ? e : this.tokens.length; var i = t.every(function (a) { return a instanceof Tm }); if (!isNaN(n) && this.inboundIndex(n) && i) { var s = this.tokens.splice.apply(this.tokens, [n, e].concat(t)); return r || this.dispatch("replaceToken", [n, e, t]), [s, t] } else return { FAIL: "replaceRange: invalid tokens or startIndex." } }; Li.prototype.replaceToken = function (n, e, t) { if (!isNaN(n) && this.inboundIndex(n) && e instanceof Tm) { var r = this.tokens.splice(n, 1, e); return t || this.dispatch("replaceToken", [n, e]), [r[0], e] } else return { FAIL: "replaceToken: invalid token or index." } }; Li.prototype.removeRange = function (n, e, t) { e = isNaN(e) ? this.tokens.length : e; var r = this.tokens.splice(n, e); return t || this.dispatch("removeRange", [r, n, e]), r }; Li.prototype.removeToken = function (n, e) { if (!isNaN(n) && this.inboundIndex(n)) { var t = this.tokens.splice(n, 1); return e || this.dispatch("removeToken", [t, n]), t } else return { FAIL: "removeToken: invalid token index." } }; Li.prototype.insertToken = function (n, e, t) { var r = n.every(function (i) { return i instanceof Tm }); return r ? (this.tokens.splice.apply(this.tokens, [e, 0].concat(n)), t || this.dispatch("insertToken", [n, e]), n) : { FAIL: "insertToken: invalid token(s)." } }; Li.prototype.registerModifier = function (n, e, t) { this.events.newToken.subscribe(function (r, i) { var s = [r, i], a = e === null || e.apply(this, s) === !0, o = [r, i]; if (a) { var l = t.apply(this, o); r.setState(n, l) } }), this.registeredModifiers.push(n) }; k8.prototype.subscribe = function (n) { return typeof n == "function" ? this.subscribers.push(n) - 1 : { FAIL: "invalid '" + this.eventId + "' event handler" } }; k8.prototype.unsubscribe = function (n) { this.subscribers.splice(n, 1) }; _u.prototype.setCurrentIndex = function (n) { this.index = n, this.current = this.context[n], this.backtrack = this.context.slice(0, n), this.lookahead = this.context.slice(n + 1) }; _u.prototype.get = function (n) { switch (!0) { case n === 0: return this.current; case (n < 0 && Math.abs(n) <= this.backtrack.length): return this.backtrack.slice(n)[0]; case (n > 0 && n <= this.lookahead.length): return this.lookahead[n - 1]; default: return null } }; Li.prototype.rangeToText = function (n) { if (n instanceof wT) return this.getRangeTokens(n).map(function (e) { return e.char }).join("") }; Li.prototype.getText = function () { return this.tokens.map(function (n) { return n.char }).join("") }; Li.prototype.getContext = function (n) { var e = this.registeredContexts[n]; return e || null }; Li.prototype.on = function (n, e) { var t = this.events[n]; return t ? t.subscribe(e) : null }; Li.prototype.dispatch = function (n, e) { var t = this, r = this.events[n]; r instanceof k8 && r.subscribers.forEach(function (i) { i.apply(t, e || []) }) }; Li.prototype.registerContextChecker = function (n, e, t) { if (this.getContext(n)) return { FAIL: "context name '" + n + "' is already registered." }; if (typeof e != "function") return { FAIL: "missing context start check." }; if (typeof t != "function") return { FAIL: "missing context end check." }; var r = new Eoe(n, e, t); return this.registeredContexts[n] = r, this.contextCheckers.push(r), r }; Li.prototype.getRangeTokens = function (n) { var e = n.startIndex + n.endOffset; return [].concat(this.tokens.slice(n.startIndex, e)) }; Li.prototype.getContextRanges = function (n) { var e = this.getContext(n); return e ? e.ranges : { FAIL: "context checker '" + n + "' is not registered." } }; Li.prototype.resetContextsRanges = function () { var n = this.registeredContexts; for (var e in n) if (n.hasOwnProperty(e)) { var t = n[e]; t.ranges = [] } }; Li.prototype.updateContextsRanges = function () { this.resetContextsRanges(); for (var n = this.tokens.map(function (r) { return r.char }), e = 0; e < n.length; e++) { var t = new _u(n, e); this.runContextCheck(t) } this.dispatch("updateContextsRanges", [this.registeredContexts]) }; Li.prototype.setEndOffset = function (n, e) { var t = this.getContext(e).openRange.startIndex, r = new wT(t, n, e), i = this.getContext(e).ranges; return r.rangeId = e + "." + i.length, i.push(r), this.getContext(e).openRange = null, r }; Li.prototype.runContextCheck = function (n) { var e = this, t = n.index; this.contextCheckers.forEach(function (r) { var i = r.contextName, s = e.getContext(i).openRange; if (!s && r.checkStart(n) && (s = new wT(t, null, i), e.getContext(i).openRange = s, e.dispatch("contextStart", [i, t])), s && r.checkEnd(n)) { var a = t - s.startIndex + 1, o = e.setEndOffset(a, i); e.dispatch("contextEnd", [i, o]) } }) }; Li.prototype.tokenize = function (n) { this.tokens = [], this.resetContextsRanges(); var e = Array.from(n); this.dispatch("start"); for (var t = 0; t < e.length; t++) { var r = e[t], i = new _u(e, t); this.dispatch("next", [i]), this.runContextCheck(i); var s = new Tm(r); this.tokens.push(s), this.dispatch("newToken", [s, i]) } return this.dispatch("end", [this.tokens]), this.tokens }; function Th(n) { return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(n) } function UG(n) { return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(n) } function Uh(n) { return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(n) } function f6(n) { return /[A-z]/.test(n) } function Soe(n) { return /\s/.test(n) } function Zo(n) { this.font = n, this.features = {} } function Gd(n) { this.id = n.id, this.tag = n.tag, this.substitution = n.substitution } function J1(n, e) { if (!n) return -1; switch (e.format) { case 1: return e.glyphs.indexOf(n); case 2: for (var t = e.ranges, r = 0; r < t.length; r++) { var i = t[r]; if (n >= i.start && n <= i.end) { var s = n - i.start; return i.index + s } } break; default: return -1 }return -1 } function Toe(n, e) { var t = J1(n, e.coverage); return t === -1 ? null : n + e.deltaGlyphId } function woe(n, e) { var t = J1(n, e.coverage); return t === -1 ? null : e.substitute[t] } function w_(n, e) { for (var t = [], r = 0; r < n.length; r++) { var i = n[r], s = e.current; s = Array.isArray(s) ? s[0] : s; var a = J1(s, i); a !== -1 && t.push(a) } return t.length !== n.length ? -1 : t } function Ioe(n, e) { var t = e.inputCoverage.length + e.lookaheadCoverage.length + e.backtrackCoverage.length; if (n.context.length < t) return []; var r = w_(e.inputCoverage, n); if (r === -1) return []; var i = e.inputCoverage.length - 1; if (n.lookahead.length < e.lookaheadCoverage.length) return []; for (var s = n.lookahead.slice(i); s.length && Uh(s[0].char);)s.shift(); var a = new _u(s, 0), o = w_(e.lookaheadCoverage, a), l = [].concat(n.backtrack); for (l.reverse(); l.length && Uh(l[0].char);)l.shift(); if (l.length < e.backtrackCoverage.length) return []; var u = new _u(l, 0), c = w_(e.backtrackCoverage, u), h = r.length === e.inputCoverage.length && o.length === e.lookaheadCoverage.length && c.length === e.backtrackCoverage.length, d = []; if (h) for (var m = 0; m < e.lookupRecords.length; m++)for (var g = e.lookupRecords[m], v = g.lookupListIndex, y = this.getLookupByIndex(v), A = 0; A < y.subtables.length; A++) { var _ = y.subtables[A], x = this.getLookupMethod(y, _), C = this.getSubstitutionType(y, _); if (C === "12") for (var T = 0; T < r.length; T++) { var I = n.get(T), w = x(I); w && d.push(w) } } return d } function Moe(n, e) { var t = n.current, r = J1(t, e.coverage); if (r === -1) return null; for (var i, s = e.ligatureSets[r], a = 0; a < s.length; a++) { i = s[a]; for (var o = 0; o < i.components.length; o++) { var l = n.lookahead[o], u = i.components[o]; if (l !== u) break; if (o === i.components.length - 1) return i } } return null } function boe(n, e) { var t = J1(n, e.coverage); return t === -1 ? null : e.sequences[t] } Zo.prototype.getDefaultScriptFeaturesIndexes = function () { for (var n = this.font.tables.gsub.scripts, e = 0; e < n.length; e++) { var t = n[e]; if (t.tag === "DFLT") return t.script.defaultLangSys.featureIndexes } return [] }; Zo.prototype.getScriptFeaturesIndexes = function (n) { var e = this.font.tables; if (!e.gsub) return []; if (!n) return this.getDefaultScriptFeaturesIndexes(); for (var t = this.font.tables.gsub.scripts, r = 0; r < t.length; r++) { var i = t[r]; if (i.tag === n && i.script.defaultLangSys) return i.script.defaultLangSys.featureIndexes; var s = i.langSysRecords; if (s) for (var a = 0; a < s.length; a++) { var o = s[a]; if (o.tag === n) { var l = o.langSys; return l.featureIndexes } } } return this.getDefaultScriptFeaturesIndexes() }; Zo.prototype.mapTagsToFeatures = function (n, e) { for (var t = {}, r = 0; r < n.length; r++) { var i = n[r].tag, s = n[r].feature; t[i] = s } this.features[e].tags = t }; Zo.prototype.getScriptFeatures = function (n) { var e = this.features[n]; if (this.features.hasOwnProperty(n)) return e; var t = this.getScriptFeaturesIndexes(n); if (!t) return null; var r = this.font.tables.gsub; return e = t.map(function (i) { return r.features[i] }), this.features[n] = e, this.mapTagsToFeatures(e, n), e }; Zo.prototype.getSubstitutionType = function (n, e) { var t = n.lookupType.toString(), r = e.substFormat.toString(); return t + r }; Zo.prototype.getLookupMethod = function (n, e) { var t = this, r = this.getSubstitutionType(n, e); switch (r) { case "11": return function (i) { return Toe.apply(t, [i, e]) }; case "12": return function (i) { return woe.apply(t, [i, e]) }; case "63": return function (i) { return Ioe.apply(t, [i, e]) }; case "41": return function (i) { return Moe.apply(t, [i, e]) }; case "21": return function (i) { return boe.apply(t, [i, e]) }; default: throw new Error("lookupType: " + n.lookupType + " - substFormat: " + e.substFormat + " is not yet supported") } }; Zo.prototype.lookupFeature = function (n) { var e = n.contextParams, t = e.index, r = this.getFeature({ tag: n.tag, script: n.script }); if (!r) return new Error("font '" + this.font.names.fullName.en + "' doesn't support feature '" + n.tag + "' for script '" + n.script + "'."); for (var i = this.getFeatureLookups(r), s = [].concat(e.context), a = 0; a < i.length; a++)for (var o = i[a], l = this.getLookupSubtables(o), u = 0; u < l.length; u++) { var c = l[u], h = this.getSubstitutionType(o, c), d = this.getLookupMethod(o, c), m = void 0; switch (h) { case "11": m = d(e.current), m && s.splice(t, 1, new Gd({ id: 11, tag: n.tag, substitution: m })); break; case "12": m = d(e.current), m && s.splice(t, 1, new Gd({ id: 12, tag: n.tag, substitution: m })); break; case "63": m = d(e), Array.isArray(m) && m.length && s.splice(t, 1, new Gd({ id: 63, tag: n.tag, substitution: m })); break; case "41": m = d(e), m && s.splice(t, 1, new Gd({ id: 41, tag: n.tag, substitution: m })); break; case "21": m = d(e.current), m && s.splice(t, 1, new Gd({ id: 21, tag: n.tag, substitution: m })); break }e = new _u(s, t), !(Array.isArray(m) && !m.length) && (m = null) } return s.length ? s : null }; Zo.prototype.supports = function (n) { if (!n.script) return !1; this.getScriptFeatures(n.script); var e = this.features.hasOwnProperty(n.script); if (!n.tag) return e; var t = this.features[n.script].some(function (r) { return r.tag === n.tag }); return e && t }; Zo.prototype.getLookupSubtables = function (n) { return n.subtables || null }; Zo.prototype.getLookupByIndex = function (n) { var e = this.font.tables.gsub.lookups; return e[n] || null }; Zo.prototype.getFeatureLookups = function (n) { return n.lookupListIndexes.map(this.getLookupByIndex.bind(this)) }; Zo.prototype.getFeature = function (e) { if (!this.font) return { FAIL: "No font was found" }; this.features.hasOwnProperty(e.script) || this.getScriptFeatures(e.script); var t = this.features[e.script]; return t ? t.tags[e.tag] ? this.features[e.script].tags[e.tag] : null : { FAIL: "No feature for script " + e.script } }; function Boe(n) { var e = n.current, t = n.get(-1); return t === null && Th(e) || !Th(t) && Th(e) } function Roe(n) { var e = n.get(1); return e === null || !Th(e) } var Poe = { startCheck: Boe, endCheck: Roe }; function Doe(n) { var e = n.current, t = n.get(-1); return (Th(e) || Uh(e)) && !Th(t) } function Loe(n) { var e = n.get(1); switch (!0) { case e === null: return !0; case (!Th(e) && !Uh(e)): var t = Soe(e); if (!t) return !0; if (t) { var r = !1; if (r = n.lookahead.some(function (i) { return Th(i) || Uh(i) }), !r) return !0 } break; default: return !1 } } var Foe = { startCheck: Doe, endCheck: Loe }; function koe(n, e, t) { e[t].setState(n.tag, n.substitution) } function Noe(n, e, t) { e[t].setState(n.tag, n.substitution) } function Ooe(n, e, t) { n.substitution.forEach(function (r, i) { var s = e[t + i]; s.setState(n.tag, r) }) } function Uoe(n, e, t) { var r = e[t]; r.setState(n.tag, n.substitution.ligGlyph); for (var i = n.substitution.components.length, s = 0; s < i; s++)r = e[t + s + 1], r.setState("deleted", !0) } var GR = { 11: koe, 12: Noe, 63: Ooe, 41: Uoe }; function IT(n, e, t) { n instanceof Gd && GR[n.id] && GR[n.id](n, e, t) } function Goe(n) { for (var e = [].concat(n.backtrack), t = e.length - 1; t >= 0; t--) { var r = e[t], i = UG(r), s = Uh(r); if (!i && !s) return !0; if (i) return !1 } return !1 } function Qoe(n) { if (UG(n.current)) return !1; for (var e = 0; e < n.lookahead.length; e++) { var t = n.lookahead[e], r = Uh(t); if (!r) return !0 } return !1 } function Hoe(n) { var e = this, t = "arab", r = this.featuresTags[t], i = this.tokenizer.getRangeTokens(n); if (i.length !== 1) { var s = new _u(i.map(function (o) { return o.getState("glyphIndex") }), 0), a = new _u(i.map(function (o) { return o.char }), 0); i.forEach(function (o, l) { if (!Uh(o.char)) { s.setCurrentIndex(l), a.setCurrentIndex(l); var u = 0; Goe(a) && (u |= 1), Qoe(a) && (u |= 2); var c; switch (u) { case 1: c = "fina"; break; case 2: c = "init"; break; case 3: c = "medi"; break }if (r.indexOf(c) !== -1) { var h = e.query.lookupFeature({ tag: c, script: t, contextParams: s }); if (h instanceof Error) return console.info(h.message); h.forEach(function (d, m) { d instanceof Gd && (IT(d, i, m), s.context[m] = d.substitution) }) } } }) } } function QR(n, e) { var t = n.map(function (r) { return r.activeState.value }); return new _u(t, e || 0) } function zoe(n) { var e = this, t = "arab", r = this.tokenizer.getRangeTokens(n), i = QR(r); i.context.forEach(function (s, a) { i.setCurrentIndex(a); var o = e.query.lookupFeature({ tag: "rlig", script: t, contextParams: i }); o.length && (o.forEach(function (l) { return IT(l, r, a) }), i = QR(r)) }) } function Voe(n) { var e = n.current, t = n.get(-1); return t === null && f6(e) || !f6(t) && f6(e) } function Woe(n) { var e = n.get(1); return e === null || !f6(e) } var Xoe = { startCheck: Voe, endCheck: Woe }; function HR(n, e) { var t = n.map(function (r) { return r.activeState.value }); return new _u(t, e || 0) } function Yoe(n) { var e = this, t = "latn", r = this.tokenizer.getRangeTokens(n), i = HR(r); i.context.forEach(function (s, a) { i.setCurrentIndex(a); var o = e.query.lookupFeature({ tag: "liga", script: t, contextParams: i }); o.length && (o.forEach(function (l) { return IT(l, r, a) }), i = HR(r)) }) } function Bu(n) { this.baseDir = n || "ltr", this.tokenizer = new Li, this.featuresTags = {} } Bu.prototype.setText = function (n) { this.text = n }; Bu.prototype.contextChecks = { latinWordCheck: Xoe, arabicWordCheck: Poe, arabicSentenceCheck: Foe }; function I_(n) { var e = this.contextChecks[n + "Check"]; return this.tokenizer.registerContextChecker(n, e.startCheck, e.endCheck) } function joe() { return I_.call(this, "latinWord"), I_.call(this, "arabicWord"), I_.call(this, "arabicSentence"), this.tokenizer.tokenize(this.text) } function Joe() { var n = this, e = this.tokenizer.getContextRanges("arabicSentence"); e.forEach(function (t) { var r = n.tokenizer.getRangeTokens(t); n.tokenizer.replaceRange(t.startIndex, t.endOffset, r.reverse()) }) } Bu.prototype.registerFeatures = function (n, e) { var t = this, r = e.filter(function (i) { return t.query.supports({ script: n, tag: i }) }); this.featuresTags.hasOwnProperty(n) ? this.featuresTags[n] = this.featuresTags[n].concat(r) : this.featuresTags[n] = r }; Bu.prototype.applyFeatures = function (n, e) { if (!n) throw new Error("No valid font was provided to apply features"); this.query || (this.query = new Zo(n)); for (var t = 0; t < e.length; t++) { var r = e[t]; this.query.supports({ script: r.script }) && this.registerFeatures(r.script, r.tags) } }; Bu.prototype.registerModifier = function (n, e, t) { this.tokenizer.registerModifier(n, e, t) }; function MT() { if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) throw new Error("glyphIndex modifier is required to apply arabic presentation features.") } function Koe() { var n = this, e = "arab"; if (this.featuresTags.hasOwnProperty(e)) { MT.call(this); var t = this.tokenizer.getContextRanges("arabicWord"); t.forEach(function (r) { Hoe.call(n, r) }) } } function qoe() { var n = this, e = "arab"; if (this.featuresTags.hasOwnProperty(e)) { var t = this.featuresTags[e]; if (t.indexOf("rlig") !== -1) { MT.call(this); var r = this.tokenizer.getContextRanges("arabicWord"); r.forEach(function (i) { zoe.call(n, i) }) } } } function Zoe() { var n = this, e = "latn"; if (this.featuresTags.hasOwnProperty(e)) { var t = this.featuresTags[e]; if (t.indexOf("liga") !== -1) { MT.call(this); var r = this.tokenizer.getContextRanges("latinWord"); r.forEach(function (i) { Yoe.call(n, i) }) } } } Bu.prototype.checkContextReady = function (n) { return !!this.tokenizer.getContext(n) }; Bu.prototype.applyFeaturesToContexts = function () { this.checkContextReady("arabicWord") && (Koe.call(this), qoe.call(this)), this.checkContextReady("latinWord") && Zoe.call(this), this.checkContextReady("arabicSentence") && Joe.call(this) }; Bu.prototype.processText = function (n) { (!this.text || this.text !== n) && (this.setText(n), joe.call(this), this.applyFeaturesToContexts()) }; Bu.prototype.getBidiText = function (n) { return this.processText(n), this.tokenizer.getText() }; Bu.prototype.getTextGlyphs = function (n) { this.processText(n); for (var e = [], t = 0; t < this.tokenizer.tokens.length; t++) { var r = this.tokenizer.tokens[t]; if (!r.state.deleted) { var i = r.activeState.value; e.push(Array.isArray(i) ? i[0] : i) } } return e }; function zr(n) { n = n || {}, n.tables = n.tables || {}, n.empty || (cg(n.familyName, "When creating a new Font object, familyName is required."), cg(n.styleName, "When creating a new Font object, styleName is required."), cg(n.unitsPerEm, "When creating a new Font object, unitsPerEm is required."), cg(n.ascender, "When creating a new Font object, ascender is required."), cg(n.descender <= 0, "When creating a new Font object, negative descender value is required."), this.names = { fontFamily: { en: n.familyName || " " }, fontSubfamily: { en: n.styleName || " " }, fullName: { en: n.fullName || n.familyName + " " + n.styleName }, postScriptName: { en: n.postScriptName || (n.familyName + n.styleName).replace(/\s/g, "") }, designer: { en: n.designer || " " }, designerURL: { en: n.designerURL || " " }, manufacturer: { en: n.manufacturer || " " }, manufacturerURL: { en: n.manufacturerURL || " " }, license: { en: n.license || " " }, licenseURL: { en: n.licenseURL || " " }, version: { en: n.version || "Version 0.1" }, description: { en: n.description || " " }, copyright: { en: n.copyright || " " }, trademark: { en: n.trademark || " " } }, this.unitsPerEm = n.unitsPerEm || 1e3, this.ascender = n.ascender, this.descender = n.descender, this.createdTimestamp = n.createdTimestamp, this.tables = Object.assign(n.tables, { os2: Object.assign({ usWeightClass: n.weightClass || this.usWeightClasses.MEDIUM, usWidthClass: n.widthClass || this.usWidthClasses.MEDIUM, fsSelection: n.fsSelection || this.fsSelectionValues.REGULAR }, n.tables.os2) })), this.supported = !0, this.glyphs = new uc.GlyphSet(this, n.glyphs || []), this.encoding = new gG(this), this.position = new X1(this), this.substitution = new qo(this), this.tables = this.tables || {}, this._push = null, this._hmtxTableData = {}, Object.defineProperty(this, "hinting", { get: function () { if (this._hinting) return this._hinting; if (this.outlinesFormat === "truetype") return this._hinting = new FG(this) } }) } zr.prototype.hasChar = function (n) { return this.encoding.charToGlyphIndex(n) !== null }; zr.prototype.charToGlyphIndex = function (n) { return this.encoding.charToGlyphIndex(n) }; zr.prototype.charToGlyph = function (n) { var e = this.charToGlyphIndex(n), t = this.glyphs.get(e); return t || (t = this.glyphs.get(0)), t }; zr.prototype.updateFeatures = function (n) { return this.defaultRenderOptions.features.map(function (e) { return e.script === "latn" ? { script: "latn", tags: e.tags.filter(function (t) { return n[t] }) } : e }) }; zr.prototype.stringToGlyphs = function (n, e) { var t = this, r = new Bu, i = function (h) { return t.charToGlyphIndex(h.char) }; r.registerModifier("glyphIndex", null, i); var s = e ? this.updateFeatures(e.features) : this.defaultRenderOptions.features; r.applyFeatures(this, s); for (var a = r.getTextGlyphs(n), o = a.length, l = new Array(o), u = this.glyphs.get(0), c = 0; c < o; c += 1)l[c] = this.glyphs.get(a[c]) || u; return l }; zr.prototype.nameToGlyphIndex = function (n) { return this.glyphNames.nameToGlyphIndex(n) }; zr.prototype.nameToGlyph = function (n) { var e = this.nameToGlyphIndex(n), t = this.glyphs.get(e); return t || (t = this.glyphs.get(0)), t }; zr.prototype.glyphIndexToName = function (n) { return this.glyphNames.glyphIndexToName ? this.glyphNames.glyphIndexToName(n) : "" }; zr.prototype.getKerningValue = function (n, e) { n = n.index || n, e = e.index || e; var t = this.position.defaultKerningTables; return t ? this.position.getKerningValue(t, n, e) : this.kerningPairs[n + "," + e] || 0 }; zr.prototype.defaultRenderOptions = { kerning: !0, features: [{ script: "arab", tags: ["init", "medi", "fina", "rlig"] }, { script: "latn", tags: ["liga", "rlig"] }] }; zr.prototype.forEachGlyph = function (n, e, t, r, i, s) { e = e !== void 0 ? e : 0, t = t !== void 0 ? t : 0, r = r !== void 0 ? r : 72, i = Object.assign({}, this.defaultRenderOptions, i); var a = 1 / this.unitsPerEm * r, o = this.stringToGlyphs(n, i), l; if (i.kerning) { var u = i.script || this.position.getDefaultScriptName(); l = this.position.getKerningTables(u, i.language) } for (var c = 0; c < o.length; c += 1) { var h = o[c]; if (s.call(this, h, e, t, r, i), h.advanceWidth && (e += h.advanceWidth * a), i.kerning && c < o.length - 1) { var d = l ? this.position.getKerningValue(l, h.index, o[c + 1].index) : this.getKerningValue(h, o[c + 1]); e += d * a } i.letterSpacing ? e += i.letterSpacing * r : i.tracking && (e += i.tracking / 1e3 * r) } return e }; zr.prototype.getPath = function (n, e, t, r, i) { var s = new Ts; return this.forEachGlyph(n, e, t, r, i, function (a, o, l, u) { var c = a.getPath(o, l, u, i, this); s.extend(c) }), s }; zr.prototype.getPaths = function (n, e, t, r, i) { var s = []; return this.forEachGlyph(n, e, t, r, i, function (a, o, l, u) { var c = a.getPath(o, l, u, i, this); s.push(c) }), s }; zr.prototype.getAdvanceWidth = function (n, e, t) { return this.forEachGlyph(n, 0, 0, e, t, function () { }) }; zr.prototype.draw = function (n, e, t, r, i, s) { this.getPath(e, t, r, i, s).draw(n) }; zr.prototype.drawPoints = function (n, e, t, r, i, s) { this.forEachGlyph(e, t, r, i, s, function (a, o, l, u) { a.drawPoints(n, o, l, u) }) }; zr.prototype.drawMetrics = function (n, e, t, r, i, s) { this.forEachGlyph(e, t, r, i, s, function (a, o, l, u) { a.drawMetrics(n, o, l, u) }) }; zr.prototype.getEnglishName = function (n) { var e = this.names[n]; if (e) return e.en }; zr.prototype.validate = function () { var n = this; function e(r, i) { } function t(r) { var i = n.getEnglishName(r); i && i.trim().length > 0 } t("fontFamily"), t("weightName"), t("manufacturer"), t("copyright"), t("version"), this.unitsPerEm > 0 }; zr.prototype.toTables = function () { return Ose.fontToTable(this) }; zr.prototype.toBuffer = function () { return console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead."), this.toArrayBuffer() }; zr.prototype.toArrayBuffer = function () { for (var n = this.toTables(), e = n.encode(), t = new ArrayBuffer(e.length), r = new Uint8Array(t), i = 0; i < e.length; i++)r[i] = e[i]; return t }; zr.prototype.download = function (n) { var e = this.getEnglishName("fontFamily"), t = this.getEnglishName("fontSubfamily"); n = n || e.replace(/\s/g, "") + "-" + t + ".otf"; var r = this.toArrayBuffer(); if (Gse()) if (window.URL = window.URL || window.webkitURL, window.URL) { var i = new DataView(r), s = new Blob([i], { type: "font/opentype" }), a = document.createElement("a"); a.href = window.URL.createObjectURL(s), a.download = n; var o = document.createEvent("MouseEvents"); o.initEvent("click", !0, !1), a.dispatchEvent(o) } else console.warn("Font file could not be downloaded. Try using a different browser."); else { var l = require("fs"), u = Qse(r); l.writeFileSync(n, u) } }; zr.prototype.fsSelectionValues = { ITALIC: 1, UNDERSCORE: 2, NEGATIVE: 4, OUTLINED: 8, STRIKEOUT: 16, BOLD: 32, REGULAR: 64, USER_TYPO_METRICS: 128, WWS: 256, OBLIQUE: 512 }; zr.prototype.usWidthClasses = { ULTRA_CONDENSED: 1, EXTRA_CONDENSED: 2, CONDENSED: 3, SEMI_CONDENSED: 4, MEDIUM: 5, SEMI_EXPANDED: 6, EXPANDED: 7, EXTRA_EXPANDED: 8, ULTRA_EXPANDED: 9 }; zr.prototype.usWeightClasses = { THIN: 100, EXTRA_LIGHT: 200, LIGHT: 300, NORMAL: 400, MEDIUM: 500, SEMI_BOLD: 600, BOLD: 700, EXTRA_BOLD: 800, BLACK: 900 }; var Ef = new Array(10); Ef[1] = function () { var e = this.offset + this.relativeOffset, t = this.parseUShort(); if (t === 1) return { posFormat: 1, coverage: this.parsePointer(be.coverage), value: this.parseValueRecord() }; if (t === 2) return { posFormat: 2, coverage: this.parsePointer(be.coverage), values: this.parseValueRecordList() }; An.assert(!1, "0x" + e.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.") }; Ef[2] = function () { var e = this.offset + this.relativeOffset, t = this.parseUShort(); An.assert(t === 1 || t === 2, "0x" + e.toString(16) + ": GPOS lookup type 2 format must be 1 or 2."); var r = this.parsePointer(be.coverage), i = this.parseUShort(), s = this.parseUShort(); if (t === 1) return { posFormat: t, coverage: r, valueFormat1: i, valueFormat2: s, pairSets: this.parseList(be.pointer(be.list(function () { return { secondGlyph: this.parseUShort(), value1: this.parseValueRecord(i), value2: this.parseValueRecord(s) } }))) }; if (t === 2) { var a = this.parsePointer(be.classDef), o = this.parsePointer(be.classDef), l = this.parseUShort(), u = this.parseUShort(); return { posFormat: t, coverage: r, valueFormat1: i, valueFormat2: s, classDef1: a, classDef2: o, class1Count: l, class2Count: u, classRecords: this.parseList(l, be.list(u, function () { return { value1: this.parseValueRecord(i), value2: this.parseValueRecord(s) } })) } } }; Ef[3] = function () { return { error: "GPOS Lookup 3 not supported" } }; Ef[4] = function () { return { error: "GPOS Lookup 4 not supported" } }; Ef[5] = function () { return { error: "GPOS Lookup 5 not supported" } }; Ef[6] = function () { return { error: "GPOS Lookup 6 not supported" } }; Ef[7] = function () { return { error: "GPOS Lookup 7 not supported" } }; Ef[8] = function () { return { error: "GPOS Lookup 8 not supported" } }; Ef[9] = function () { return { error: "GPOS Lookup 9 not supported" } }; new Array(10); var $oe = Object.defineProperty, ele = (n, e, t) => e in n ? $oe(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Xe = (n, e, t) => (ele(n, typeof e != "symbol" ? e + "" : e, t), t); function zR(n, e) { if (e === mO) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n; if (e === ay || e === FS) { let t = n.getIndex(); if (t === null) { const a = [], o = n.getAttribute("position"); if (o !== void 0) { for (let l = 0; l < o.count; l++)a.push(l); n.setIndex(a), t = n.getIndex() } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n } const r = t.count - 2, i = []; if (t) if (e === ay) for (let a = 1; a <= r; a++)i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1)); else for (let a = 0; a < r; a++)a % 2 === 0 ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2))) : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a))); i.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = n.clone(); return s.setIndex(i), s.clearGroups(), s } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n } new Je; const GG = class { parse(n, e = { decodeSpeed: 5, encodeSpeed: 5, encoderMethod: GG.MESH_EDGEBREAKER_ENCODING, quantization: [16, 8, 8, 8, 8], exportUvs: !0, exportNormals: !0, exportColor: !1 }) { if (n instanceof pn && n.isBufferGeometry) throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points."); if (DracoEncoderModule === void 0) throw new Error("THREE.DRACOExporter: required the draco_encoder to work."); const t = n.geometry, r = DracoEncoderModule(), i = new r.Encoder; let s, a; if (!t.isBufferGeometry) throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance."); if (n instanceof gr && n.isMesh) { s = new r.MeshBuilder, a = new r.Mesh; const d = t.getAttribute("position"); s.AddFloatAttributeToMesh(a, r.POSITION, d.count, d.itemSize, d.array); const m = t.getIndex(); if (m !== null) s.AddFacesToMesh(a, m.count / 3, m.array); else { const g = new (d.count > 65535 ? Uint32Array : Uint16Array)(d.count); for (let v = 0; v < g.length; v++)g[v] = v; s.AddFacesToMesh(a, d.count, g) } if (e.exportNormals) { const g = t.getAttribute("normal"); g !== void 0 && s.AddFloatAttributeToMesh(a, r.NORMAL, g.count, g.itemSize, g.array) } if (e.exportUvs) { const g = t.getAttribute("uv"); g !== void 0 && s.AddFloatAttributeToMesh(a, r.TEX_COORD, g.count, g.itemSize, g.array) } if (e.exportColor) { const g = t.getAttribute("color"); g !== void 0 && s.AddFloatAttributeToMesh(a, r.COLOR, g.count, g.itemSize, g.array) } } else if (n instanceof g8 && n.isPoints) { s = new r.PointCloudBuilder, a = new r.PointCloud; const d = t.getAttribute("position"); if (s.AddFloatAttribute(a, r.POSITION, d.count, d.itemSize, d.array), e.exportColor) { const m = t.getAttribute("color"); m !== void 0 && s.AddFloatAttribute(a, r.COLOR, m.count, m.itemSize, m.array) } } else throw new Error("DRACOExporter: Unsupported object type."); const o = new r.DracoInt8Array, l = e.encodeSpeed !== void 0 ? e.encodeSpeed : 5, u = e.decodeSpeed !== void 0 ? e.decodeSpeed : 5; if (i.SetSpeedOptions(l, u), e.encoderMethod !== void 0 && i.SetEncodingMethod(e.encoderMethod), e.quantization !== void 0) for (let d = 0; d < 5; d++)e.quantization[d] !== void 0 && i.SetAttributeQuantization(d, e.quantization[d]); let c; if (n instanceof gr && n.isMesh ? c = i.EncodeMeshToDracoBuffer(a, o) : c = i.EncodePointCloudToDracoBuffer(a, !0, o), r.destroy(a), c === 0) throw new Error("THREE.DRACOExporter: Draco encoding failed."); const h = new Int8Array(new ArrayBuffer(c)); for (let d = 0; d < c; d++)h[d] = o.GetValue(d); return r.destroy(o), r.destroy(i), r.destroy(s), h } }; let Ac = GG; Xe(Ac, "MESH_EDGEBREAKER_ENCODING", 1); Xe(Ac, "MESH_SEQUENTIAL_ENCODING", 0); Xe(Ac, "POINT_CLOUD", 0); Xe(Ac, "TRIANGULAR_MESH", 1); Xe(Ac, "INVALID", -1); Xe(Ac, "POSITION", 0); Xe(Ac, "NORMAL", 1); Xe(Ac, "COLOR", 2); Xe(Ac, "TEX_COORD", 3); Xe(Ac, "GENERIC", 4); const QG = class extends gr { constructor(n, e = {}) { super(n), this.isReflector = !0, this.type = "Reflector", this.camera = new Gr; const t = this, r = e.color !== void 0 ? new Je(e.color) : new Je(8355711), i = e.textureWidth || 512, s = e.textureHeight || 512, a = e.clipBias || 0, o = e.shader || QG.ReflectorShader, l = e.multisample !== void 0 ? e.multisample : 4, u = new Do, c = new N, h = new N, d = new N, m = new bt, g = new N(0, 0, -1), v = new Jn, y = new N, A = new N, _ = new Jn, x = new bt, C = this.camera, T = new Ir(i, s, { samples: l, type: Wi }), I = new tr({ uniforms: mi.clone(o.uniforms), fragmentShader: o.fragmentShader, vertexShader: o.vertexShader }); I.uniforms.tDiffuse.value = T.texture, I.uniforms.color.value = r, I.uniforms.textureMatrix.value = x, this.material = I, this.onBeforeRender = function (w, R, b) { if (h.setFromMatrixPosition(t.matrixWorld), d.setFromMatrixPosition(b.matrixWorld), m.extractRotation(t.matrixWorld), c.set(0, 0, 1), c.applyMatrix4(m), y.subVectors(h, d), y.dot(c) > 0) return; y.reflect(c).negate(), y.add(h), m.extractRotation(b.matrixWorld), g.set(0, 0, -1), g.applyMatrix4(m), g.add(d), A.subVectors(h, g), A.reflect(c).negate(), A.add(h), C.position.copy(y), C.up.set(0, 1, 0), C.up.applyMatrix4(m), C.up.reflect(c), C.lookAt(A), C.far = b.far, C.updateMatrixWorld(), C.projectionMatrix.copy(b.projectionMatrix), x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(C.projectionMatrix), x.multiply(C.matrixWorldInverse), x.multiply(t.matrixWorld), u.setFromNormalAndCoplanarPoint(c, h), u.applyMatrix4(C.matrixWorldInverse), v.set(u.normal.x, u.normal.y, u.normal.z, u.constant); const B = C.projectionMatrix; _.x = (Math.sign(v.x) + B.elements[8]) / B.elements[0], _.y = (Math.sign(v.y) + B.elements[9]) / B.elements[5], _.z = -1, _.w = (1 + B.elements[10]) / B.elements[14], v.multiplyScalar(2 / v.dot(_)), B.elements[2] = v.x, B.elements[6] = v.y, B.elements[10] = v.z + 1 - a, B.elements[14] = v.w, t.visible = !1; const F = w.getRenderTarget(), U = w.xr.enabled, G = w.shadowMap.autoUpdate, Y = w.toneMapping; let Z = !1; "outputColorSpace" in w ? Z = w.outputColorSpace === "srgb" : Z = w.outputEncoding === 3001, w.xr.enabled = !1, w.shadowMap.autoUpdate = !1, "outputColorSpace" in w ? w.outputColorSpace = "linear-srgb" : w.outputEncoding = 3e3, w.toneMapping = wl, w.setRenderTarget(T), w.state.buffers.depth.setMask(!0), w.autoClear === !1 && w.clear(), w.render(R, C), w.xr.enabled = U, w.shadowMap.autoUpdate = G, w.toneMapping = Y, "outputColorSpace" in w ? w.outputColorSpace = Z ? "srgb" : "srgb-linear" : w.outputEncoding = Z ? 3001 : 3e3, w.setRenderTarget(F); const ne = b.viewport; ne !== void 0 && w.state.viewport(ne), t.visible = !0 }, this.getRenderTarget = function () { return T }, this.dispose = function () { T.dispose(), t.material.dispose() } } }; let I7 = QG; Xe(I7, "ReflectorShader", {
		uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`, fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${parseInt(Su.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`}); const HG = class extends gr { constructor(n, e = {}) { super(n), this.isRefractor = !0, this.type = "Refractor", this.camera = new Gr; const t = this, r = e.color !== void 0 ? new Je(e.color) : new Je(8355711), i = e.textureWidth || 512, s = e.textureHeight || 512, a = e.clipBias || 0, o = e.shader || HG.RefractorShader, l = e.multisample !== void 0 ? e.multisample : 4, u = this.camera; u.matrixAutoUpdate = !1, u.userData.refractor = !0; const c = new Do, h = new bt, d = new Ir(i, s, { samples: l, type: Wi }); this.material = new tr({ uniforms: mi.clone(o.uniforms), vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, transparent: !0 }), this.material.uniforms.color.value = r, this.material.uniforms.tDiffuse.value = d.texture, this.material.uniforms.textureMatrix.value = h; const m = function () { const _ = new N, x = new N, C = new bt, T = new N, I = new N; return function (R) { return _.setFromMatrixPosition(t.matrixWorld), x.setFromMatrixPosition(R.matrixWorld), T.subVectors(_, x), C.extractRotation(t.matrixWorld), I.set(0, 0, 1), I.applyMatrix4(C), T.dot(I) < 0 } }(), g = function () { const _ = new N, x = new N, C = new xs, T = new N; return function () { t.matrixWorld.decompose(x, C, T), _.set(0, 0, 1).applyQuaternion(C).normalize(), _.negate(), c.setFromNormalAndCoplanarPoint(_, x) } }(), v = function () { const _ = new Do, x = new Jn, C = new Jn; return function (I) { u.matrixWorld.copy(I.matrixWorld), u.matrixWorldInverse.copy(u.matrixWorld).invert(), u.projectionMatrix.copy(I.projectionMatrix), u.far = I.far, _.copy(c), _.applyMatrix4(u.matrixWorldInverse), x.set(_.normal.x, _.normal.y, _.normal.z, _.constant); const w = u.projectionMatrix; C.x = (Math.sign(x.x) + w.elements[8]) / w.elements[0], C.y = (Math.sign(x.y) + w.elements[9]) / w.elements[5], C.z = -1, C.w = (1 + w.elements[10]) / w.elements[14], x.multiplyScalar(2 / x.dot(C)), w.elements[2] = x.x, w.elements[6] = x.y, w.elements[10] = x.z + 1 - a, w.elements[14] = x.w } }(); function y(_) { h.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), h.multiply(_.projectionMatrix), h.multiply(_.matrixWorldInverse), h.multiply(t.matrixWorld) } function A(_, x, C) { t.visible = !1; const T = _.getRenderTarget(), I = _.xr.enabled, w = _.shadowMap.autoUpdate, R = _.toneMapping; let b = !1; "outputColorSpace" in _ ? b = _.outputColorSpace === "srgb" : b = _.outputEncoding === 3001, _.xr.enabled = !1, _.shadowMap.autoUpdate = !1, "outputColorSpace" in _ ? _.outputColorSpace = "linear-srgb" : _.outputEncoding = 3e3, _.toneMapping = wl, _.setRenderTarget(d), _.autoClear === !1 && _.clear(), _.render(x, u), _.xr.enabled = I, _.shadowMap.autoUpdate = w, _.toneMapping = R, _.setRenderTarget(T), "outputColorSpace" in _ ? _.outputColorSpace = b ? "srgb" : "srgb-linear" : _.outputEncoding = b ? 3001 : 3e3; const B = C.viewport; B !== void 0 && _.state.viewport(B), t.visible = !0 } this.onBeforeRender = function (_, x, C) { C.userData.refractor !== !0 && m(C) && (g(), y(C), v(C), A(_, x, C)) }, this.getRenderTarget = function () { return d }, this.dispose = function () { d.dispose(), t.material.dispose() } } }; let M7 = HG; Xe(M7, "RefractorShader", {
			uniforms: { color: { value: null }, tDiffuse: { value: null }, textureMatrix: { value: null } }, vertexShader: `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${parseInt(Su.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`}); const tle = new pn, b7 = class extends gr {
		constructor() {
			super(b7.Geometry, new qs({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0; const n = new N, e = new N, t = new ac(new Uint8Array(16 * 16 * 3), 16, 16, Ri); t.minFilter = cn, t.magFilter = cn, t.wrapS = pi, t.wrapT = pi; const r = new ac(new Uint8Array(16 * 16 * 3), 16, 16, Ri); r.minFilter = cn, r.magFilter = cn, r.wrapS = pi, r.wrapT = pi; const i = b7.Geometry, s = new cA({
				uniforms: { scale: { value: null }, screenPosition: { value: null } }, vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`, fragmentShader: `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`, depthTest: !0, depthWrite: !1, transparent: !1
			}), a = new cA({
				uniforms: { map: { value: t }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`, fragmentShader: `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`, depthTest: !1, depthWrite: !1, transparent: !1
			}), o = new gr(i, s), l = [], u = zG.Shader, c = new cA({ uniforms: { map: { value: null }, occlusionMap: { value: r }, color: { value: new Je(16777215) }, scale: { value: new Se }, screenPosition: { value: new N } }, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, blending: XA, transparent: !0, depthWrite: !1 }), h = new gr(i, c); this.addElement = function (y) { l.push(y) }; const d = new Se, m = new Se, g = new SU, v = new Jn; this.onBeforeRender = function (y, A, _) { y.getCurrentViewport(v); const x = v.w / v.z, C = v.z / 2, T = v.w / 2; let I = 16 / v.w; if (d.set(I * x, I), g.min.set(v.x, v.y), g.max.set(v.x + (v.z - 16), v.y + (v.w - 16)), e.setFromMatrixPosition(this.matrixWorld), e.applyMatrix4(_.matrixWorldInverse), !(e.z > 0) && (n.copy(e).applyMatrix4(_.projectionMatrix), m.x = v.x + n.x * C + C - 8, m.y = v.y + n.y * T + T - 8, g.containsPoint(m))) { y.copyFramebufferToTexture(m, t); let w = s.uniforms; w.scale.value = d, w.screenPosition.value = n, y.renderBufferDirect(_, null, i, s, o, null), y.copyFramebufferToTexture(m, r), w = a.uniforms, w.scale.value = d, w.screenPosition.value = n, y.renderBufferDirect(_, null, i, a, o, null); const R = -n.x * 2, b = -n.y * 2; for (let B = 0, F = l.length; B < F; B++) { const U = l[B], G = c.uniforms; G.color.value.copy(U.color), G.map.value = U.texture, G.screenPosition.value.x = n.x + R * U.distance, G.screenPosition.value.y = n.y + b * U.distance, I = U.size / v.w; const Y = v.w / v.z; G.scale.value.set(I * Y, I), c.uniformsNeedUpdate = !0, y.renderBufferDirect(_, null, i, c, h, null) } } }, this.dispose = function () { s.dispose(), a.dispose(), c.dispose(), t.dispose(), r.dispose(); for (let y = 0, A = l.length; y < A; y++)l[y].texture.dispose() }
		}
	}; let nle = b7; Xe(nle, "Geometry", tle); class zG { constructor(e, t = 1, r = 0, i = new Je(16777215)) { this.texture = e, this.size = t, this.distance = r, this.color = i } } Xe(zG, "Shader", {
		uniforms: { map: { value: null }, occlusionMap: { value: null }, color: { value: null }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`, fragmentShader: `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`}); class hA { constructor(e = Math) { Xe(this, "grad3", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]), Xe(this, "grad4", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]), Xe(this, "p", []), Xe(this, "perm", []), Xe(this, "simplex", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]), Xe(this, "dot", (t, r, i) => t[0] * r + t[1] * i), Xe(this, "dot3", (t, r, i, s) => t[0] * r + t[1] * i + t[2] * s), Xe(this, "dot4", (t, r, i, s, a) => t[0] * r + t[1] * i + t[2] * s + t[3] * a), Xe(this, "noise", (t, r) => { let i, s, a; const o = .5 * (Math.sqrt(3) - 1), l = (t + r) * o, u = Math.floor(t + l), c = Math.floor(r + l), h = (3 - Math.sqrt(3)) / 6, d = (u + c) * h, m = u - d, g = c - d, v = t - m, y = r - g; let A = 0, _ = 1; v > y && (A = 1, _ = 0); const x = v - A + h, C = y - _ + h, T = v - 1 + 2 * h, I = y - 1 + 2 * h, w = u & 255, R = c & 255, b = this.perm[w + this.perm[R]] % 12, B = this.perm[w + A + this.perm[R + _]] % 12, F = this.perm[w + 1 + this.perm[R + 1]] % 12; let U = .5 - v * v - y * y; U < 0 ? i = 0 : (U *= U, i = U * U * this.dot(this.grad3[b], v, y)); let G = .5 - x * x - C * C; G < 0 ? s = 0 : (G *= G, s = G * G * this.dot(this.grad3[B], x, C)); let Y = .5 - T * T - I * I; return Y < 0 ? a = 0 : (Y *= Y, a = Y * Y * this.dot(this.grad3[F], T, I)), 70 * (i + s + a) }), Xe(this, "noise3d", (t, r, i) => { let s, a, o, l; const u = .3333333333333333, c = (t + r + i) * u, h = Math.floor(t + c), d = Math.floor(r + c), m = Math.floor(i + c), g = 1 / 6, v = (h + d + m) * g, y = h - v, A = d - v, _ = m - v, x = t - y, C = r - A, T = i - _; let I, w, R, b, B, F; x >= C ? C >= T ? (I = 1, w = 0, R = 0, b = 1, B = 1, F = 0) : x >= T ? (I = 1, w = 0, R = 0, b = 1, B = 0, F = 1) : (I = 0, w = 0, R = 1, b = 1, B = 0, F = 1) : C < T ? (I = 0, w = 0, R = 1, b = 0, B = 1, F = 1) : x < T ? (I = 0, w = 1, R = 0, b = 0, B = 1, F = 1) : (I = 0, w = 1, R = 0, b = 1, B = 1, F = 0); const U = x - I + g, G = C - w + g, Y = T - R + g, Z = x - b + 2 * g, ne = C - B + 2 * g, $ = T - F + 2 * g, L = x - 1 + 3 * g, Q = C - 1 + 3 * g, D = T - 1 + 3 * g, V = h & 255, J = d & 255, Ee = m & 255, xe = this.perm[V + this.perm[J + this.perm[Ee]]] % 12, Be = this.perm[V + I + this.perm[J + w + this.perm[Ee + R]]] % 12, Fe = this.perm[V + b + this.perm[J + B + this.perm[Ee + F]]] % 12, we = this.perm[V + 1 + this.perm[J + 1 + this.perm[Ee + 1]]] % 12; let ge = .6 - x * x - C * C - T * T; ge < 0 ? s = 0 : (ge *= ge, s = ge * ge * this.dot3(this.grad3[xe], x, C, T)); let tt = .6 - U * U - G * G - Y * Y; tt < 0 ? a = 0 : (tt *= tt, a = tt * tt * this.dot3(this.grad3[Be], U, G, Y)); let je = .6 - Z * Z - ne * ne - $ * $; je < 0 ? o = 0 : (je *= je, o = je * je * this.dot3(this.grad3[Fe], Z, ne, $)); let Oe = .6 - L * L - Q * Q - D * D; return Oe < 0 ? l = 0 : (Oe *= Oe, l = Oe * Oe * this.dot3(this.grad3[we], L, Q, D)), 32 * (s + a + o + l) }), Xe(this, "noise4d", (t, r, i, s) => { const a = this.grad4, o = this.simplex, l = this.perm, u = (Math.sqrt(5) - 1) / 4, c = (5 - Math.sqrt(5)) / 20; let h, d, m, g, v; const y = (t + r + i + s) * u, A = Math.floor(t + y), _ = Math.floor(r + y), x = Math.floor(i + y), C = Math.floor(s + y), T = (A + _ + x + C) * c, I = A - T, w = _ - T, R = x - T, b = C - T, B = t - I, F = r - w, U = i - R, G = s - b, Y = B > F ? 32 : 0, Z = B > U ? 16 : 0, ne = F > U ? 8 : 0, $ = B > G ? 4 : 0, L = F > G ? 2 : 0, Q = U > G ? 1 : 0, D = Y + Z + ne + $ + L + Q; let V, J, Ee, xe, Be, Fe, we, ge, tt, je, Oe, K; V = o[D][0] >= 3 ? 1 : 0, J = o[D][1] >= 3 ? 1 : 0, Ee = o[D][2] >= 3 ? 1 : 0, xe = o[D][3] >= 3 ? 1 : 0, Be = o[D][0] >= 2 ? 1 : 0, Fe = o[D][1] >= 2 ? 1 : 0, we = o[D][2] >= 2 ? 1 : 0, ge = o[D][3] >= 2 ? 1 : 0, tt = o[D][0] >= 1 ? 1 : 0, je = o[D][1] >= 1 ? 1 : 0, Oe = o[D][2] >= 1 ? 1 : 0, K = o[D][3] >= 1 ? 1 : 0; const de = B - V + c, Ce = F - J + c, Qe = U - Ee + c, De = G - xe + c, ie = B - Be + 2 * c, qe = F - Fe + 2 * c, nt = U - we + 2 * c, it = G - ge + 2 * c, xt = B - tt + 3 * c, mn = F - je + 3 * c, X = U - Oe + 3 * c, O = G - K + 3 * c, fe = B - 1 + 4 * c, Ne = F - 1 + 4 * c, Ue = U - 1 + 4 * c, We = G - 1 + 4 * c, ut = A & 255, Ge = _ & 255, Ae = x & 255, st = C & 255, vt = l[ut + l[Ge + l[Ae + l[st]]]] % 32, dt = l[ut + V + l[Ge + J + l[Ae + Ee + l[st + xe]]]] % 32, at = l[ut + Be + l[Ge + Fe + l[Ae + we + l[st + ge]]]] % 32, ee = l[ut + tt + l[Ge + je + l[Ae + Oe + l[st + K]]]] % 32, Ie = l[ut + 1 + l[Ge + 1 + l[Ae + 1 + l[st + 1]]]] % 32; let Ke = .6 - B * B - F * F - U * U - G * G; Ke < 0 ? h = 0 : (Ke *= Ke, h = Ke * Ke * this.dot4(a[vt], B, F, U, G)); let j = .6 - de * de - Ce * Ce - Qe * Qe - De * De; j < 0 ? d = 0 : (j *= j, d = j * j * this.dot4(a[dt], de, Ce, Qe, De)); let Ve = .6 - ie * ie - qe * qe - nt * nt - it * it; Ve < 0 ? m = 0 : (Ve *= Ve, m = Ve * Ve * this.dot4(a[at], ie, qe, nt, it)); let oe = .6 - xt * xt - mn * mn - X * X - O * O; oe < 0 ? g = 0 : (oe *= oe, g = oe * oe * this.dot4(a[ee], xt, mn, X, O)); let ze = .6 - fe * fe - Ne * Ne - Ue * Ue - We * We; return ze < 0 ? v = 0 : (ze *= ze, v = ze * ze * this.dot4(a[Ie], fe, Ne, Ue, We)), 27 * (h + d + m + g + v) }); for (let t = 0; t < 256; t++)this.p[t] = Math.floor(e.random() * 256); for (let t = 0; t < 512; t++)this.perm[t] = this.p[t & 255] } } const Ba = class extends pn { constructor(n = {}) { super(), this.isLightningStrike = !0, this.type = "LightningStrike", this.init(Ba.copyParameters(n, n)), this.createMesh() } static createRandomGenerator() { const e = []; for (let r = 0; r < 2053; r++)e.push(Math.random()); const t = { currentSeed: 0, random: function () { const r = e[t.currentSeed]; return t.currentSeed = (t.currentSeed + 1) % 2053, r }, getSeed: function () { return t.currentSeed / 2053 }, setSeed: function (r) { t.currentSeed = Math.floor(r * 2053) % 2053 } }; return t } static copyParameters(n = {}, e = {}) { const t = function (r) { return e === n ? r : r.clone() }; return n.sourceOffset = e.sourceOffset !== void 0 ? t(e.sourceOffset) : new N(0, 100, 0), n.destOffset = e.destOffset !== void 0 ? t(e.destOffset) : new N(0, 0, 0), n.timeScale = e.timeScale !== void 0 ? e.timeScale : 1, n.roughness = e.roughness !== void 0 ? e.roughness : .9, n.straightness = e.straightness !== void 0 ? e.straightness : .7, n.up0 = e.up0 !== void 0 ? t(e.up0) : new N(0, 0, 1), n.up1 = e.up1 !== void 0 ? t(e.up1) : new N(0, 0, 1), n.radius0 = e.radius0 !== void 0 ? e.radius0 : 1, n.radius1 = e.radius1 !== void 0 ? e.radius1 : 1, n.radius0Factor = e.radius0Factor !== void 0 ? e.radius0Factor : .5, n.radius1Factor = e.radius1Factor !== void 0 ? e.radius1Factor : .2, n.minRadius = e.minRadius !== void 0 ? e.minRadius : .2, n.isEternal = e.isEternal !== void 0 ? e.isEternal : e.birthTime === void 0 || e.deathTime === void 0, n.birthTime = e.birthTime, n.deathTime = e.deathTime, n.propagationTimeFactor = e.propagationTimeFactor !== void 0 ? e.propagationTimeFactor : .1, n.vanishingTimeFactor = e.vanishingTimeFactor !== void 0 ? e.vanishingTimeFactor : .9, n.subrayPeriod = e.subrayPeriod !== void 0 ? e.subrayPeriod : 4, n.subrayDutyCycle = e.subrayDutyCycle !== void 0 ? e.subrayDutyCycle : .6, n.maxIterations = e.maxIterations !== void 0 ? e.maxIterations : 9, n.isStatic = e.isStatic !== void 0 ? e.isStatic : !1, n.ramification = e.ramification !== void 0 ? e.ramification : 5, n.maxSubrayRecursion = e.maxSubrayRecursion !== void 0 ? e.maxSubrayRecursion : 3, n.recursionProbability = e.recursionProbability !== void 0 ? e.recursionProbability : .6, n.generateUVs = e.generateUVs !== void 0 ? e.generateUVs : !1, n.randomGenerator = e.randomGenerator, n.noiseSeed = e.noiseSeed, n.onDecideSubrayCreation = e.onDecideSubrayCreation, n.onSubrayCreation = e.onSubrayCreation, n } update(n) { this.isStatic || (this.rayParameters.isEternal || this.rayParameters.birthTime <= n && n <= this.rayParameters.deathTime ? (this.updateMesh(n), n < this.subrays[0].endPropagationTime ? this.state = Ba.RAY_PROPAGATING : n > this.subrays[0].beginVanishingTime ? this.state = Ba.RAY_VANISHING : this.state = Ba.RAY_STEADY, this.visible = !0) : (this.visible = !1, n < this.rayParameters.birthTime ? this.state = Ba.RAY_UNBORN : this.state = Ba.RAY_EXTINGUISHED)) } init(n) { this.rayParameters = n, this.maxIterations = n.maxIterations !== void 0 ? Math.floor(n.maxIterations) : 9, n.maxIterations = this.maxIterations, this.isStatic = n.isStatic !== void 0 ? n.isStatic : !1, n.isStatic = this.isStatic, this.ramification = n.ramification !== void 0 ? Math.floor(n.ramification) : 5, n.ramification = this.ramification, this.maxSubrayRecursion = n.maxSubrayRecursion !== void 0 ? Math.floor(n.maxSubrayRecursion) : 3, n.maxSubrayRecursion = this.maxSubrayRecursion, this.recursionProbability = n.recursionProbability !== void 0 ? n.recursionProbability : .6, n.recursionProbability = this.recursionProbability, this.generateUVs = n.generateUVs !== void 0 ? n.generateUVs : !1, n.generateUVs = this.generateUVs, n.randomGenerator !== void 0 ? (this.randomGenerator = n.randomGenerator, this.seedGenerator = n.randomGenerator, n.noiseSeed !== void 0 && this.seedGenerator.setSeed(n.noiseSeed)) : (this.randomGenerator = Ba.createRandomGenerator(), this.seedGenerator = Math), n.onDecideSubrayCreation !== void 0 ? this.onDecideSubrayCreation = n.onDecideSubrayCreation : (this.createDefaultSubrayCreationCallbacks(), n.onSubrayCreation !== void 0 && (this.onSubrayCreation = n.onSubrayCreation)), this.state = Ba.RAY_INITIALIZED, this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1))), n.maxSubrays = this.maxSubrays, this.maxRaySegments = 2 * (1 << this.maxIterations), this.subrays = []; for (let e = 0; e < this.maxSubrays; e++)this.subrays.push(this.createSubray()); this.raySegments = []; for (let e = 0; e < this.maxRaySegments; e++)this.raySegments.push(this.createSegment()); this.time = 0, this.timeFraction = 0, this.currentSegmentCallback = null, this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs, this.numSubrays = 0, this.currentSubray = null, this.currentSegmentIndex = 0, this.isInitialSegment = !1, this.subrayProbability = 0, this.currentVertex = 0, this.currentIndex = 0, this.currentCoordinate = 0, this.currentUVCoordinate = 0, this.vertices = null, this.uvs = null, this.indices = null, this.positionAttribute = null, this.uvsAttribute = null, this.simplexX = new hA(this.seedGenerator), this.simplexY = new hA(this.seedGenerator), this.simplexZ = new hA(this.seedGenerator), this.forwards = new N, this.forwardsFill = new N, this.side = new N, this.down = new N, this.middlePos = new N, this.middleLinPos = new N, this.newPos = new N, this.vPos = new N, this.cross1 = new N } createMesh() { const n = 1 << this.maxIterations, e = 3 * (n + 1) * this.maxSubrays, t = 18 * n * this.maxSubrays; this.vertices = new Float32Array(e * 3), this.indices = new Uint32Array(t), this.generateUVs && (this.uvs = new Float32Array(e * 2)), this.fillMesh(0), this.setIndex(new u8(this.indices, 1)), this.positionAttribute = new Pt(this.vertices, 3), this.setAttribute("position", this.positionAttribute), this.generateUVs && (this.uvsAttribute = new Pt(new Float32Array(this.uvs), 2), this.setAttribute("uv", this.uvsAttribute)), this.isStatic || (this.index.usage = sc, this.positionAttribute.usage = sc, this.generateUVs && (this.uvsAttribute.usage = sc)), this.vertices = this.positionAttribute.array, this.indices = this.index.array, this.generateUVs && (this.uvs = this.uvsAttribute.array) } updateMesh(n) { this.fillMesh(n), this.drawRange.count = this.currentIndex, this.index.needsUpdate = !0, this.positionAttribute.needsUpdate = !0, this.generateUVs && (this.uvsAttribute.needsUpdate = !0) } fillMesh(n) { const e = this; this.currentVertex = 0, this.currentIndex = 0, this.currentCoordinate = 0, this.currentUVCoordinate = 0, this.fractalRay(n, function (r) { const i = e.currentSubray; n < i.birthTime || (this.rayParameters.isEternal && e.currentSubray.recursion == 0 ? (e.createPrism(r), e.onDecideSubrayCreation(r, e)) : n < i.endPropagationTime ? e.timeFraction >= r.fraction0 * i.propagationTimeFactor && (e.createPrism(r), e.onDecideSubrayCreation(r, e)) : n < i.beginVanishingTime ? (e.createPrism(r), e.onDecideSubrayCreation(r, e)) : (e.timeFraction <= i.vanishingTimeFactor + r.fraction1 * (1 - i.vanishingTimeFactor) && e.createPrism(r), e.onDecideSubrayCreation(r, e))) }) } addNewSubray() { return this.subrays[this.numSubrays++] } initSubray(n, e) { n.pos0.copy(e.sourceOffset), n.pos1.copy(e.destOffset), n.up0.copy(e.up0), n.up1.copy(e.up1), n.radius0 = e.radius0, n.radius1 = e.radius1, n.birthTime = e.birthTime, n.deathTime = e.deathTime, n.timeScale = e.timeScale, n.roughness = e.roughness, n.straightness = e.straightness, n.propagationTimeFactor = e.propagationTimeFactor, n.vanishingTimeFactor = e.vanishingTimeFactor, n.maxIterations = this.maxIterations, n.seed = e.noiseSeed !== void 0 ? e.noiseSeed : 0, n.recursion = 0 } fractalRay(n, e) { this.time = n, this.currentSegmentCallback = e, this.numSubrays = 0, this.initSubray(this.addNewSubray(), this.rayParameters); for (let t = 0; t < this.numSubrays; t++) { const r = this.subrays[t]; this.currentSubray = r, this.randomGenerator.setSeed(r.seed), r.endPropagationTime = hp.lerp(r.birthTime, r.deathTime, r.propagationTimeFactor), r.beginVanishingTime = hp.lerp(r.deathTime, r.birthTime, 1 - r.vanishingTimeFactor); const i = this.randomGenerator.random; r.linPos0.set(i(), i(), i()).multiplyScalar(1e3), r.linPos1.set(i(), i(), i()).multiplyScalar(1e3), this.timeFraction = (n - r.birthTime) / (r.deathTime - r.birthTime), this.currentSegmentIndex = 0, this.isInitialSegment = !0; const s = this.getNewSegment(); s.iteration = 0, s.pos0.copy(r.pos0), s.pos1.copy(r.pos1), s.linPos0.copy(r.linPos0), s.linPos1.copy(r.linPos1), s.up0.copy(r.up0), s.up1.copy(r.up1), s.radius0 = r.radius0, s.radius1 = r.radius1, s.fraction0 = 0, s.fraction1 = 1, s.positionVariationFactor = 1 - r.straightness, this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, r.recursion) / (1 << r.maxIterations), this.fractalRayRecursive(s) } this.currentSegmentCallback = null, this.currentSubray = null } fractalRayRecursive(n) { if (n.iteration >= this.currentSubray.maxIterations) { this.currentSegmentCallback(n); return } this.forwards.subVectors(n.pos1, n.pos0); let e = this.forwards.length(); e < 1e-6 && (this.forwards.set(0, 0, .01), e = this.forwards.length()); const t = (n.radius0 + n.radius1) * .5, r = (n.fraction0 + n.fraction1) * .5, i = this.time * this.currentSubray.timeScale * Math.pow(2, n.iteration); this.middlePos.lerpVectors(n.pos0, n.pos1, .5), this.middleLinPos.lerpVectors(n.linPos0, n.linPos1, .5); const s = this.middleLinPos; this.newPos.set(this.simplexX.noise4d(s.x, s.y, s.z, i), this.simplexY.noise4d(s.x, s.y, s.z, i), this.simplexZ.noise4d(s.x, s.y, s.z, i)), this.newPos.multiplyScalar(n.positionVariationFactor * e), this.newPos.add(this.middlePos); const a = this.getNewSegment(); a.pos0.copy(n.pos0), a.pos1.copy(this.newPos), a.linPos0.copy(n.linPos0), a.linPos1.copy(this.middleLinPos), a.up0.copy(n.up0), a.up1.copy(n.up1), a.radius0 = n.radius0, a.radius1 = t, a.fraction0 = n.fraction0, a.fraction1 = r, a.positionVariationFactor = n.positionVariationFactor * this.currentSubray.roughness, a.iteration = n.iteration + 1; const o = this.getNewSegment(); o.pos0.copy(this.newPos), o.pos1.copy(n.pos1), o.linPos0.copy(this.middleLinPos), o.linPos1.copy(n.linPos1), this.cross1.crossVectors(n.up0, this.forwards.normalize()), o.up0.crossVectors(this.forwards, this.cross1).normalize(), o.up1.copy(n.up1), o.radius0 = t, o.radius1 = n.radius1, o.fraction0 = r, o.fraction1 = n.fraction1, o.positionVariationFactor = n.positionVariationFactor * this.currentSubray.roughness, o.iteration = n.iteration + 1, this.fractalRayRecursive(a), this.fractalRayRecursive(o) } createPrism(n) { this.forwardsFill.subVectors(n.pos1, n.pos0).normalize(), this.isInitialSegment && (this.currentCreateTriangleVertices(n.pos0, n.up0, this.forwardsFill, n.radius0, 0), this.isInitialSegment = !1), this.currentCreateTriangleVertices(n.pos1, n.up0, this.forwardsFill, n.radius1, n.fraction1), this.createPrismFaces() } createTriangleVerticesWithoutUVs(n, e, t, r) { this.side.crossVectors(e, t).multiplyScalar(r * Ba.COS30DEG), this.down.copy(e).multiplyScalar(-r * Ba.SIN30DEG); const i = this.vPos, s = this.vertices; i.copy(n).sub(this.side).add(this.down), s[this.currentCoordinate++] = i.x, s[this.currentCoordinate++] = i.y, s[this.currentCoordinate++] = i.z, i.copy(n).add(this.side).add(this.down), s[this.currentCoordinate++] = i.x, s[this.currentCoordinate++] = i.y, s[this.currentCoordinate++] = i.z, i.copy(e).multiplyScalar(r).add(n), s[this.currentCoordinate++] = i.x, s[this.currentCoordinate++] = i.y, s[this.currentCoordinate++] = i.z, this.currentVertex += 3 } createTriangleVerticesWithUVs(n, e, t, r, i) { this.side.crossVectors(e, t).multiplyScalar(r * Ba.COS30DEG), this.down.copy(e).multiplyScalar(-r * Ba.SIN30DEG); const s = this.vPos, a = this.vertices, o = this.uvs; s.copy(n).sub(this.side).add(this.down), a[this.currentCoordinate++] = s.x, a[this.currentCoordinate++] = s.y, a[this.currentCoordinate++] = s.z, o[this.currentUVCoordinate++] = i, o[this.currentUVCoordinate++] = 0, s.copy(n).add(this.side).add(this.down), a[this.currentCoordinate++] = s.x, a[this.currentCoordinate++] = s.y, a[this.currentCoordinate++] = s.z, o[this.currentUVCoordinate++] = i, o[this.currentUVCoordinate++] = .5, s.copy(e).multiplyScalar(r).add(n), a[this.currentCoordinate++] = s.x, a[this.currentCoordinate++] = s.y, a[this.currentCoordinate++] = s.z, o[this.currentUVCoordinate++] = i, o[this.currentUVCoordinate++] = 1, this.currentVertex += 3 } createPrismFaces(n) { const e = this.indices; n = this.currentVertex - 6, e[this.currentIndex++] = n + 1, e[this.currentIndex++] = n + 2, e[this.currentIndex++] = n + 5, e[this.currentIndex++] = n + 1, e[this.currentIndex++] = n + 5, e[this.currentIndex++] = n + 4, e[this.currentIndex++] = n + 0, e[this.currentIndex++] = n + 1, e[this.currentIndex++] = n + 4, e[this.currentIndex++] = n + 0, e[this.currentIndex++] = n + 4, e[this.currentIndex++] = n + 3, e[this.currentIndex++] = n + 2, e[this.currentIndex++] = n + 0, e[this.currentIndex++] = n + 3, e[this.currentIndex++] = n + 2, e[this.currentIndex++] = n + 3, e[this.currentIndex++] = n + 5 } createDefaultSubrayCreationCallbacks() { const n = this.randomGenerator.random; this.onDecideSubrayCreation = function (s, a) { const o = a.currentSubray, l = a.rayParameters.subrayPeriod, u = a.rayParameters.subrayDutyCycle, c = a.rayParameters.isEternal && o.recursion == 0 ? -n() * l : hp.lerp(o.birthTime, o.endPropagationTime, s.fraction0) - n() * l, h = a.time - c, d = Math.floor(h / l), m = n() * (d + 1), g = h % l <= u * l; let v = 0; if (g && (v = a.subrayProbability), o.recursion < a.maxSubrayRecursion && a.numSubrays < a.maxSubrays && n() < v) { const y = a.addNewSubray(), A = a.randomGenerator.getSeed(); y.seed = m, a.randomGenerator.setSeed(m), y.recursion = o.recursion + 1, y.maxIterations = Math.max(1, o.maxIterations - 1), y.linPos0.set(n(), n(), n()).multiplyScalar(1e3), y.linPos1.set(n(), n(), n()).multiplyScalar(1e3), y.up0.copy(o.up0), y.up1.copy(o.up1), y.radius0 = s.radius0 * a.rayParameters.radius0Factor, y.radius1 = Math.min(a.rayParameters.minRadius, s.radius1 * a.rayParameters.radius1Factor), y.birthTime = c + d * l, y.deathTime = y.birthTime + l * u, !a.rayParameters.isEternal && o.recursion == 0 && (y.birthTime = Math.max(y.birthTime, o.birthTime), y.deathTime = Math.min(y.deathTime, o.deathTime)), y.timeScale = o.timeScale * 2, y.roughness = o.roughness, y.straightness = o.straightness, y.propagationTimeFactor = o.propagationTimeFactor, y.vanishingTimeFactor = o.vanishingTimeFactor, a.onSubrayCreation(s, o, y, a), a.randomGenerator.setSeed(A) } }; const e = new N, t = new N, r = new N, i = new N; this.onSubrayCreation = function (s, a, o, l) { l.subrayCylinderPosition(s, a, o, .5, .6, .2) }, this.subrayConePosition = function (s, a, o, l, u, c) { o.pos0.copy(s.pos0), e.subVectors(a.pos1, a.pos0), t.copy(e).normalize(), e.multiplyScalar(s.fraction0 + (1 - s.fraction0) * (n() * l)); const h = e.length(); r.crossVectors(a.up0, t); const d = 2 * Math.PI * n(); r.multiplyScalar(Math.cos(d)), i.copy(a.up0).multiplyScalar(Math.sin(d)), o.pos1.copy(r).add(i).multiplyScalar(h * u * (c + n() * (1 - c))).add(e).add(a.pos0) }, this.subrayCylinderPosition = function (s, a, o, l, u, c) { o.pos0.copy(s.pos0), e.subVectors(a.pos1, a.pos0), t.copy(e).normalize(), e.multiplyScalar(s.fraction0 + (1 - s.fraction0) * ((2 * n() - 1) * l)); const h = e.length(); r.crossVectors(a.up0, t); const d = 2 * Math.PI * n(); r.multiplyScalar(Math.cos(d)), i.copy(a.up0).multiplyScalar(Math.sin(d)), o.pos1.copy(r).add(i).multiplyScalar(h * u * (c + n() * (1 - c))).add(e).add(a.pos0) } } createSubray() { return { seed: 0, maxIterations: 0, recursion: 0, pos0: new N, pos1: new N, linPos0: new N, linPos1: new N, up0: new N, up1: new N, radius0: 0, radius1: 0, birthTime: 0, deathTime: 0, timeScale: 0, roughness: 0, straightness: 0, propagationTimeFactor: 0, vanishingTimeFactor: 0, endPropagationTime: 0, beginVanishingTime: 0 } } createSegment() { return { iteration: 0, pos0: new N, pos1: new N, linPos0: new N, linPos1: new N, up0: new N, up1: new N, radius0: 0, radius1: 0, fraction0: 0, fraction1: 0, positionVariationFactor: 0 } } getNewSegment() { return this.raySegments[this.currentSegmentIndex++] } copy(n) { return super.copy(n), this.init(Ba.copyParameters({}, n.rayParameters)), this } clone() { return new this.constructor(Ba.copyParameters({}, this.rayParameters)) } }; let Zh = Ba; Xe(Zh, "RAY_INITIALIZED", 0); Xe(Zh, "RAY_UNBORN", 1); Xe(Zh, "RAY_PROPAGATING", 2); Xe(Zh, "RAY_STEADY", 3); Xe(Zh, "RAY_VANISHING", 4); Xe(Zh, "RAY_EXTINGUISHED", 5); Xe(Zh, "COS30DEG", Math.cos(30 * Math.PI / 180)); Xe(Zh, "SIN30DEG", Math.sin(30 * Math.PI / 180)); const Ld = class extends gr { constructor(n, e = {}) { super(n), this.isReflectorForSSRPass = !0, this.type = "ReflectorForSSRPass"; const t = this, r = e.color !== void 0 ? new Je(e.color) : new Je(8355711), i = e.textureWidth || 512, s = e.textureHeight || 512, a = e.clipBias || 0, o = e.shader || Ld.ReflectorShader, l = e.useDepthTexture === !0, u = new N(0, 1, 0), c = new N, h = new N; t.needsUpdate = !1, t.maxDistance = Ld.ReflectorShader.uniforms.maxDistance.value, t.opacity = Ld.ReflectorShader.uniforms.opacity.value, t.color = r, t.resolution = e.resolution || new Se(window.innerWidth, window.innerHeight), t._distanceAttenuation = Ld.ReflectorShader.defines.DISTANCE_ATTENUATION, Object.defineProperty(t, "distanceAttenuation", { get() { return t._distanceAttenuation }, set(F) { t._distanceAttenuation !== F && (t._distanceAttenuation = F, t.material.defines.DISTANCE_ATTENUATION = F, t.material.needsUpdate = !0) } }), t._fresnel = Ld.ReflectorShader.defines.FRESNEL, Object.defineProperty(t, "fresnel", { get() { return t._fresnel }, set(F) { t._fresnel !== F && (t._fresnel = F, t.material.defines.FRESNEL = F, t.material.needsUpdate = !0) } }); const d = new N, m = new N, g = new N, v = new bt, y = new N(0, 0, -1), A = new N, _ = new N, x = new bt, C = new Gr; let T; l && (T = new xm, T.type = Np, T.minFilter = cn, T.magFilter = cn); const I = { depthTexture: l ? T : null, type: Wi }, w = new Ir(i, s, I), R = new tr({ transparent: l, defines: Object.assign({}, Ld.ReflectorShader.defines, { useDepthTexture: l }), uniforms: mi.clone(o.uniforms), fragmentShader: o.fragmentShader, vertexShader: o.vertexShader }); R.uniforms.tDiffuse.value = w.texture, R.uniforms.color.value = t.color, R.uniforms.textureMatrix.value = x, l && (R.uniforms.tDepth.value = w.depthTexture), this.material = R; const B = [new Do(new N(0, 1, 0), a)]; this.doRender = function (F, U, G) { if (R.uniforms.maxDistance.value = t.maxDistance, R.uniforms.color.value = t.color, R.uniforms.opacity.value = t.opacity, c.copy(G.position).normalize(), h.copy(c).reflect(u), R.uniforms.fresnelCoe.value = (c.dot(h) + 1) / 2, m.setFromMatrixPosition(t.matrixWorld), g.setFromMatrixPosition(G.matrixWorld), v.extractRotation(t.matrixWorld), d.set(0, 0, 1), d.applyMatrix4(v), A.subVectors(m, g), A.dot(d) > 0) return; A.reflect(d).negate(), A.add(m), v.extractRotation(G.matrixWorld), y.set(0, 0, -1), y.applyMatrix4(v), y.add(g), _.subVectors(m, y), _.reflect(d).negate(), _.add(m), C.position.copy(A), C.up.set(0, 1, 0), C.up.applyMatrix4(v), C.up.reflect(d), C.lookAt(_), C.far = G.far, C.updateMatrixWorld(), C.projectionMatrix.copy(G.projectionMatrix), R.uniforms.virtualCameraNear.value = G.near, R.uniforms.virtualCameraFar.value = G.far, R.uniforms.virtualCameraMatrixWorld.value = C.matrixWorld, R.uniforms.virtualCameraProjectionMatrix.value = G.projectionMatrix, R.uniforms.virtualCameraProjectionMatrixInverse.value = G.projectionMatrixInverse, R.uniforms.resolution.value = t.resolution, x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), x.multiply(C.projectionMatrix), x.multiply(C.matrixWorldInverse), x.multiply(t.matrixWorld); const Y = F.getRenderTarget(), Z = F.xr.enabled, ne = F.shadowMap.autoUpdate, $ = F.clippingPlanes; F.xr.enabled = !1, F.shadowMap.autoUpdate = !1, F.clippingPlanes = B, F.setRenderTarget(w), F.state.buffers.depth.setMask(!0), F.autoClear === !1 && F.clear(), F.render(U, C), F.xr.enabled = Z, F.shadowMap.autoUpdate = ne, F.clippingPlanes = $, F.setRenderTarget(Y); const L = G.viewport; L !== void 0 && F.state.viewport(L) }, this.getRenderTarget = function () { return w } } }; let rle = Ld; Xe(rle, "ReflectorShader", {
			defines: { DISTANCE_ATTENUATION: !0, FRESNEL: !0 }, uniforms: { color: { value: null }, tDiffuse: { value: null }, tDepth: { value: null }, textureMatrix: { value: new bt }, maxDistance: { value: 180 }, opacity: { value: .5 }, fresnelCoe: { value: null }, virtualCameraNear: { value: null }, virtualCameraFar: { value: null }, virtualCameraProjectionMatrix: { value: new bt }, virtualCameraMatrixWorld: { value: new bt }, virtualCameraProjectionMatrixInverse: { value: new bt }, resolution: { value: new Se } }, vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`}); const h6 = {
		uniforms: { turbidity: { value: 2 }, rayleigh: { value: 1 }, mieCoefficient: { value: .005 }, mieDirectionalG: { value: .8 }, sunPosition: { value: new N }, up: { value: new N(0, 1, 0) } }, vertexShader: `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `, fragmentShader: `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${parseInt(Su.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

      }
    `}, VG = new tr({ name: "SkyShader", fragmentShader: h6.fragmentShader, vertexShader: h6.vertexShader, uniforms: mi.clone(h6.uniforms), side: pa, depthWrite: !1 }); class WG extends gr { constructor() { super(new jh(1, 1, 1), VG) } } Xe(WG, "SkyShader", h6); Xe(WG, "material", VG); const XG = class extends gr { constructor(n, e = {}) { super(n), this.isWater = !0, this.type = "Water"; const t = this, r = e.color !== void 0 ? new Je(e.color) : new Je(16777215), i = e.textureWidth || 512, s = e.textureHeight || 512, a = e.clipBias || 0, o = e.flowDirection || new Se(1, 0), l = e.flowSpeed || .03, u = e.reflectivity || .02, c = e.scale || 1, h = e.shader || XG.WaterShader, d = e.encoding !== void 0 ? e.encoding : 3e3, m = e.flowMap || void 0, g = e.normalMap0, v = e.normalMap1, y = .15, A = y * .5, _ = new bt, x = new L8; if (I7 === void 0) { console.error("THREE.Water: Required component Reflector not found."); return } if (M7 === void 0) { console.error("THREE.Water: Required component Refractor not found."); return } const C = new I7(n, { textureWidth: i, textureHeight: s, clipBias: a, encoding: d }), T = new M7(n, { textureWidth: i, textureHeight: s, clipBias: a, encoding: d }); C.matrixAutoUpdate = !1, T.matrixAutoUpdate = !1, this.material = new tr({ uniforms: mi.merge([ot.fog, h.uniforms]), vertexShader: h.vertexShader, fragmentShader: h.fragmentShader, transparent: !0, fog: !0 }), m !== void 0 ? (this.material.defines.USE_FLOWMAP = "", this.material.uniforms.tFlowMap = { type: "t", value: m }) : this.material.uniforms.flowDirection = { type: "v2", value: o }, g.wrapS = g.wrapT = Pl, v.wrapS = v.wrapT = Pl, this.material.uniforms.tReflectionMap.value = C.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = T.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = g, this.material.uniforms.tNormalMap1.value = v, this.material.uniforms.color.value = r, this.material.uniforms.reflectivity.value = u, this.material.uniforms.textureMatrix.value = _, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = A, this.material.uniforms.config.value.z = A, this.material.uniforms.config.value.w = c; function I(R) { _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), _.multiply(R.projectionMatrix), _.multiply(R.matrixWorldInverse), _.multiply(t.matrixWorld) } function w() { const R = x.getDelta(), b = t.material.uniforms.config; b.value.x += l * R, b.value.y = b.value.x + A, b.value.x >= y ? (b.value.x = 0, b.value.y = A) : b.value.y >= y && (b.value.y = b.value.y - y) } this.onBeforeRender = function (R, b, B) { I(B), w(), t.visible = !1, C.matrixWorld.copy(t.matrixWorld), T.matrixWorld.copy(t.matrixWorld), C.onBeforeRender(R, b, B), T.onBeforeRender(R, b, B), t.visible = !0 } } }; let ile = XG; Xe(ile, "WaterShader", {
			uniforms: { color: { value: null }, reflectivity: { value: 0 }, tReflectionMap: { value: null }, tRefractionMap: { value: null }, tNormalMap0: { value: null }, tNormalMap1: { value: null }, textureMatrix: { value: null }, config: { value: new Jn } }, vertexShader: `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`, fragmentShader: `

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <${parseInt(Su.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
			#include <fog_fragment>

		}`}); const M_ = {
		uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "	float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "	gl_FragColor = vec4( vec3( depth ), opacity );", "}"].join(`
`)
	}, A5 = new Op, VR = new Do, sle = Math.cos(70 * hp.DEG2RAD), WR = (n, e) => (n % e + e) % e; let ale = class extends mc { constructor(e, t) { super(), Xe(this, "object"), Xe(this, "domElement"), Xe(this, "enabled", !0), Xe(this, "target", new N), Xe(this, "minDistance", 0), Xe(this, "maxDistance", 1 / 0), Xe(this, "minZoom", 0), Xe(this, "maxZoom", 1 / 0), Xe(this, "minPolarAngle", 0), Xe(this, "maxPolarAngle", Math.PI), Xe(this, "minAzimuthAngle", -1 / 0), Xe(this, "maxAzimuthAngle", 1 / 0), Xe(this, "enableDamping", !1), Xe(this, "dampingFactor", .05), Xe(this, "enableZoom", !0), Xe(this, "zoomSpeed", 1), Xe(this, "enableRotate", !0), Xe(this, "rotateSpeed", 1), Xe(this, "enablePan", !0), Xe(this, "panSpeed", 1), Xe(this, "screenSpacePanning", !0), Xe(this, "keyPanSpeed", 7), Xe(this, "zoomToCursor", !1), Xe(this, "autoRotate", !1), Xe(this, "autoRotateSpeed", 2), Xe(this, "reverseOrbit", !1), Xe(this, "reverseHorizontalOrbit", !1), Xe(this, "reverseVerticalOrbit", !1), Xe(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), Xe(this, "mouseButtons", { LEFT: Rd.ROTATE, MIDDLE: Rd.DOLLY, RIGHT: Rd.PAN }), Xe(this, "touches", { ONE: Pd.ROTATE, TWO: Pd.DOLLY_PAN }), Xe(this, "target0"), Xe(this, "position0"), Xe(this, "zoom0"), Xe(this, "_domElementKeyEvents", null), Xe(this, "getPolarAngle"), Xe(this, "getAzimuthalAngle"), Xe(this, "setPolarAngle"), Xe(this, "setAzimuthalAngle"), Xe(this, "getDistance"), Xe(this, "listenToKeyEvents"), Xe(this, "stopListenToKeyEvents"), Xe(this, "saveState"), Xe(this, "reset"), Xe(this, "update"), Xe(this, "connect"), Xe(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => c.phi, this.getAzimuthalAngle = () => c.theta, this.setPolarAngle = ee => { let Ie = WR(ee, 2 * Math.PI), Ke = c.phi; Ke < 0 && (Ke += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI); let j = Math.abs(Ie - Ke); 2 * Math.PI - j < j && (Ie < Ke ? Ie += 2 * Math.PI : Ke += 2 * Math.PI), h.phi = Ie - Ke, r.update() }, this.setAzimuthalAngle = ee => { let Ie = WR(ee, 2 * Math.PI), Ke = c.theta; Ke < 0 && (Ke += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI); let j = Math.abs(Ie - Ke); 2 * Math.PI - j < j && (Ie < Ke ? Ie += 2 * Math.PI : Ke += 2 * Math.PI), h.theta = Ie - Ke, r.update() }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = ee => { ee.addEventListener("keydown", We), this._domElementKeyEvents = ee }, this.stopListenToKeyEvents = () => { this._domElementKeyEvents.removeEventListener("keydown", We), this._domElementKeyEvents = null }, this.saveState = () => { r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object.zoom }, this.reset = () => { r.target.copy(r.target0), r.object.position.copy(r.position0), r.object.zoom = r.zoom0, r.object.updateProjectionMatrix(), r.dispatchEvent(i), r.update(), l = o.NONE }, this.update = (() => { const ee = new N, Ie = new N(0, 1, 0), Ke = new xs().setFromUnitVectors(e.up, Ie), j = Ke.clone().invert(), Ve = new N, oe = new xs, ze = 2 * Math.PI; return function () { const jt = r.object.position; Ke.setFromUnitVectors(e.up, Ie), j.copy(Ke).invert(), ee.copy(jt).sub(r.target), ee.applyQuaternion(Ke), c.setFromVector3(ee), r.autoRotate && l === o.NONE && Y(U()), r.enableDamping ? (c.theta += h.theta * r.dampingFactor, c.phi += h.phi * r.dampingFactor) : (c.theta += h.theta, c.phi += h.phi); let ln = r.minAzimuthAngle, fn = r.maxAzimuthAngle; isFinite(ln) && isFinite(fn) && (ln < -Math.PI ? ln += ze : ln > Math.PI && (ln -= ze), fn < -Math.PI ? fn += ze : fn > Math.PI && (fn -= ze), ln <= fn ? c.theta = Math.max(ln, Math.min(fn, c.theta)) : c.theta = c.theta > (ln + fn) / 2 ? Math.max(ln, c.theta) : Math.min(fn, c.theta)), c.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, c.phi)), c.makeSafe(), r.enableDamping === !0 ? r.target.addScaledVector(m, r.dampingFactor) : r.target.add(m), r.zoomToCursor && b || r.object.isOrthographicCamera ? c.radius = J(c.radius) : c.radius = J(c.radius * d), ee.setFromSpherical(c), ee.applyQuaternion(j), jt.copy(r.target).add(ee), r.object.lookAt(r.target), r.enableDamping === !0 ? (h.theta *= 1 - r.dampingFactor, h.phi *= 1 - r.dampingFactor, m.multiplyScalar(1 - r.dampingFactor)) : (h.set(0, 0, 0), m.set(0, 0, 0)); let Dt = !1; if (r.zoomToCursor && b) { let $e = null; if (r.object instanceof Gr && r.object.isPerspectiveCamera) { const Xt = ee.length(); $e = J(Xt * d); const Qt = Xt - $e; r.object.position.addScaledVector(w, Qt), r.object.updateMatrixWorld() } else if (r.object.isOrthographicCamera) { const Xt = new N(R.x, R.y, 0); Xt.unproject(r.object), r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / d)), r.object.updateProjectionMatrix(), Dt = !0; const Qt = new N(R.x, R.y, 0); Qt.unproject(r.object), r.object.position.sub(Qt).add(Xt), r.object.updateMatrixWorld(), $e = ee.length() } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), r.zoomToCursor = !1; $e !== null && (r.screenSpacePanning ? r.target.set(0, 0, -1).transformDirection(r.object.matrix).multiplyScalar($e).add(r.object.position) : (A5.origin.copy(r.object.position), A5.direction.set(0, 0, -1).transformDirection(r.object.matrix), Math.abs(r.object.up.dot(A5.direction)) < sle ? e.lookAt(r.target) : (VR.setFromNormalAndCoplanarPoint(r.object.up, r.target), A5.intersectPlane(VR, r.target)))) } else r.object instanceof hu && r.object.isOrthographicCamera && (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / d)), r.object.updateProjectionMatrix(), Dt = !0); return d = 1, b = !1, Dt || Ve.distanceToSquared(r.object.position) > u || 8 * (1 - oe.dot(r.object.quaternion)) > u ? (r.dispatchEvent(i), Ve.copy(r.object.position), oe.copy(r.object.quaternion), Dt = !1, !0) : !1 } })(), this.connect = ee => { ee === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), r.domElement = ee, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Ae), r.domElement.addEventListener("pointerdown", xt), r.domElement.addEventListener("pointercancel", O), r.domElement.addEventListener("wheel", Ue) }, this.dispose = () => { var ee, Ie, Ke, j, Ve, oe; (ee = r.domElement) == null || ee.removeEventListener("contextmenu", Ae), (Ie = r.domElement) == null || Ie.removeEventListener("pointerdown", xt), (Ke = r.domElement) == null || Ke.removeEventListener("pointercancel", O), (j = r.domElement) == null || j.removeEventListener("wheel", Ue), (Ve = r.domElement) == null || Ve.ownerDocument.removeEventListener("pointermove", mn), (oe = r.domElement) == null || oe.ownerDocument.removeEventListener("pointerup", X), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", We) }; const r = this, i = { type: "change" }, s = { type: "start" }, a = { type: "end" }, o = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let l = o.NONE; const u = 1e-6, c = new p7, h = new p7; let d = 1; const m = new N, g = new Se, v = new Se, y = new Se, A = new Se, _ = new Se, x = new Se, C = new Se, T = new Se, I = new Se, w = new N, R = new Se; let b = !1; const B = [], F = {}; function U() { return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed } function G() { return Math.pow(.95, r.zoomSpeed) } function Y(ee) { r.reverseOrbit || r.reverseHorizontalOrbit ? h.theta += ee : h.theta -= ee } function Z(ee) { r.reverseOrbit || r.reverseVerticalOrbit ? h.phi += ee : h.phi -= ee } const ne = (() => { const ee = new N; return function (Ke, j) { ee.setFromMatrixColumn(j, 0), ee.multiplyScalar(-Ke), m.add(ee) } })(), $ = (() => { const ee = new N; return function (Ke, j) { r.screenSpacePanning === !0 ? ee.setFromMatrixColumn(j, 1) : (ee.setFromMatrixColumn(j, 0), ee.crossVectors(r.object.up, ee)), ee.multiplyScalar(Ke), m.add(ee) } })(), L = (() => { const ee = new N; return function (Ke, j) { const Ve = r.domElement; if (Ve && r.object instanceof Gr && r.object.isPerspectiveCamera) { const oe = r.object.position; ee.copy(oe).sub(r.target); let ze = ee.length(); ze *= Math.tan(r.object.fov / 2 * Math.PI / 180), ne(2 * Ke * ze / Ve.clientHeight, r.object.matrix), $(2 * j * ze / Ve.clientHeight, r.object.matrix) } else Ve && r.object instanceof hu && r.object.isOrthographicCamera ? (ne(Ke * (r.object.right - r.object.left) / r.object.zoom / Ve.clientWidth, r.object.matrix), $(j * (r.object.top - r.object.bottom) / r.object.zoom / Ve.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1) } })(); function Q(ee) { r.object instanceof Gr && r.object.isPerspectiveCamera || r.object instanceof hu && r.object.isOrthographicCamera ? d /= ee : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function D(ee) { r.object instanceof Gr && r.object.isPerspectiveCamera || r.object instanceof hu && r.object.isOrthographicCamera ? d *= ee : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1) } function V(ee) { if (!r.zoomToCursor || !r.domElement) return; b = !0; const Ie = r.domElement.getBoundingClientRect(), Ke = ee.clientX - Ie.left, j = ee.clientY - Ie.top, Ve = Ie.width, oe = Ie.height; R.x = Ke / Ve * 2 - 1, R.y = -(j / oe) * 2 + 1, w.set(R.x, R.y, 1).unproject(r.object).sub(r.object.position).normalize() } function J(ee) { return Math.max(r.minDistance, Math.min(r.maxDistance, ee)) } function Ee(ee) { g.set(ee.clientX, ee.clientY) } function xe(ee) { V(ee), C.set(ee.clientX, ee.clientY) } function Be(ee) { A.set(ee.clientX, ee.clientY) } function Fe(ee) { v.set(ee.clientX, ee.clientY), y.subVectors(v, g).multiplyScalar(r.rotateSpeed); const Ie = r.domElement; Ie && (Y(2 * Math.PI * y.x / Ie.clientHeight), Z(2 * Math.PI * y.y / Ie.clientHeight)), g.copy(v), r.update() } function we(ee) { T.set(ee.clientX, ee.clientY), I.subVectors(T, C), I.y > 0 ? Q(G()) : I.y < 0 && D(G()), C.copy(T), r.update() } function ge(ee) { _.set(ee.clientX, ee.clientY), x.subVectors(_, A).multiplyScalar(r.panSpeed), L(x.x, x.y), A.copy(_), r.update() } function tt(ee) { V(ee), ee.deltaY < 0 ? D(G()) : ee.deltaY > 0 && Q(G()), r.update() } function je(ee) { let Ie = !1; switch (ee.code) { case r.keys.UP: L(0, r.keyPanSpeed), Ie = !0; break; case r.keys.BOTTOM: L(0, -r.keyPanSpeed), Ie = !0; break; case r.keys.LEFT: L(r.keyPanSpeed, 0), Ie = !0; break; case r.keys.RIGHT: L(-r.keyPanSpeed, 0), Ie = !0; break }Ie && (ee.preventDefault(), r.update()) } function Oe() { if (B.length == 1) g.set(B[0].pageX, B[0].pageY); else { const ee = .5 * (B[0].pageX + B[1].pageX), Ie = .5 * (B[0].pageY + B[1].pageY); g.set(ee, Ie) } } function K() { if (B.length == 1) A.set(B[0].pageX, B[0].pageY); else { const ee = .5 * (B[0].pageX + B[1].pageX), Ie = .5 * (B[0].pageY + B[1].pageY); A.set(ee, Ie) } } function de() { const ee = B[0].pageX - B[1].pageX, Ie = B[0].pageY - B[1].pageY, Ke = Math.sqrt(ee * ee + Ie * Ie); C.set(0, Ke) } function Ce() { r.enableZoom && de(), r.enablePan && K() } function Qe() { r.enableZoom && de(), r.enableRotate && Oe() } function De(ee) { if (B.length == 1) v.set(ee.pageX, ee.pageY); else { const Ke = at(ee), j = .5 * (ee.pageX + Ke.x), Ve = .5 * (ee.pageY + Ke.y); v.set(j, Ve) } y.subVectors(v, g).multiplyScalar(r.rotateSpeed); const Ie = r.domElement; Ie && (Y(2 * Math.PI * y.x / Ie.clientHeight), Z(2 * Math.PI * y.y / Ie.clientHeight)), g.copy(v) } function ie(ee) { if (B.length == 1) _.set(ee.pageX, ee.pageY); else { const Ie = at(ee), Ke = .5 * (ee.pageX + Ie.x), j = .5 * (ee.pageY + Ie.y); _.set(Ke, j) } x.subVectors(_, A).multiplyScalar(r.panSpeed), L(x.x, x.y), A.copy(_) } function qe(ee) { const Ie = at(ee), Ke = ee.pageX - Ie.x, j = ee.pageY - Ie.y, Ve = Math.sqrt(Ke * Ke + j * j); T.set(0, Ve), I.set(0, Math.pow(T.y / C.y, r.zoomSpeed)), Q(I.y), C.copy(T) } function nt(ee) { r.enableZoom && qe(ee), r.enablePan && ie(ee) } function it(ee) { r.enableZoom && qe(ee), r.enableRotate && De(ee) } function xt(ee) { var Ie, Ke; r.enabled !== !1 && (B.length === 0 && ((Ie = r.domElement) == null || Ie.ownerDocument.addEventListener("pointermove", mn), (Ke = r.domElement) == null || Ke.ownerDocument.addEventListener("pointerup", X)), st(ee), ee.pointerType === "touch" ? ut(ee) : fe(ee)) } function mn(ee) { r.enabled !== !1 && (ee.pointerType === "touch" ? Ge(ee) : Ne(ee)) } function X(ee) { var Ie, Ke, j; vt(ee), B.length === 0 && ((Ie = r.domElement) == null || Ie.releasePointerCapture(ee.pointerId), (Ke = r.domElement) == null || Ke.ownerDocument.removeEventListener("pointermove", mn), (j = r.domElement) == null || j.ownerDocument.removeEventListener("pointerup", X)), r.dispatchEvent(a), l = o.NONE } function O(ee) { vt(ee) } function fe(ee) { let Ie; switch (ee.button) { case 0: Ie = r.mouseButtons.LEFT; break; case 1: Ie = r.mouseButtons.MIDDLE; break; case 2: Ie = r.mouseButtons.RIGHT; break; default: Ie = -1 }switch (Ie) { case Rd.DOLLY: if (r.enableZoom === !1) return; xe(ee), l = o.DOLLY; break; case Rd.ROTATE: if (ee.ctrlKey || ee.metaKey || ee.shiftKey) { if (r.enablePan === !1) return; Be(ee), l = o.PAN } else { if (r.enableRotate === !1) return; Ee(ee), l = o.ROTATE } break; case Rd.PAN: if (ee.ctrlKey || ee.metaKey || ee.shiftKey) { if (r.enableRotate === !1) return; Ee(ee), l = o.ROTATE } else { if (r.enablePan === !1) return; Be(ee), l = o.PAN } break; default: l = o.NONE }l !== o.NONE && r.dispatchEvent(s) } function Ne(ee) { if (r.enabled !== !1) switch (l) { case o.ROTATE: if (r.enableRotate === !1) return; Fe(ee); break; case o.DOLLY: if (r.enableZoom === !1) return; we(ee); break; case o.PAN: if (r.enablePan === !1) return; ge(ee); break } } function Ue(ee) { r.enabled === !1 || r.enableZoom === !1 || l !== o.NONE && l !== o.ROTATE || (ee.preventDefault(), r.dispatchEvent(s), tt(ee), r.dispatchEvent(a)) } function We(ee) { r.enabled === !1 || r.enablePan === !1 || je(ee) } function ut(ee) { switch (dt(ee), B.length) { case 1: switch (r.touches.ONE) { case Pd.ROTATE: if (r.enableRotate === !1) return; Oe(), l = o.TOUCH_ROTATE; break; case Pd.PAN: if (r.enablePan === !1) return; K(), l = o.TOUCH_PAN; break; default: l = o.NONE }break; case 2: switch (r.touches.TWO) { case Pd.DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; Ce(), l = o.TOUCH_DOLLY_PAN; break; case Pd.DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; Qe(), l = o.TOUCH_DOLLY_ROTATE; break; default: l = o.NONE }break; default: l = o.NONE }l !== o.NONE && r.dispatchEvent(s) } function Ge(ee) { switch (dt(ee), l) { case o.TOUCH_ROTATE: if (r.enableRotate === !1) return; De(ee), r.update(); break; case o.TOUCH_PAN: if (r.enablePan === !1) return; ie(ee), r.update(); break; case o.TOUCH_DOLLY_PAN: if (r.enableZoom === !1 && r.enablePan === !1) return; nt(ee), r.update(); break; case o.TOUCH_DOLLY_ROTATE: if (r.enableZoom === !1 && r.enableRotate === !1) return; it(ee), r.update(); break; default: l = o.NONE } } function Ae(ee) { r.enabled !== !1 && ee.preventDefault() } function st(ee) { B.push(ee) } function vt(ee) { delete F[ee.pointerId]; for (let Ie = 0; Ie < B.length; Ie++)if (B[Ie].pointerId == ee.pointerId) { B.splice(Ie, 1); return } } function dt(ee) { let Ie = F[ee.pointerId]; Ie === void 0 && (Ie = new Se, F[ee.pointerId] = Ie), Ie.set(ee.pageX, ee.pageY) } function at(ee) { const Ie = ee.pointerId === B[0].pointerId ? B[1] : B[0]; return F[Ie.pointerId] } t !== void 0 && this.connect(t), this.update() } }; class N8 { constructor() { Xe(this, "enabled", !0), Xe(this, "needsSwap", !0), Xe(this, "clear", !1), Xe(this, "renderToScreen", !1) } setSize(e, t) { } render(e, t, r, i, s) { console.error("THREE.Pass: .render() must be implemented in derived pass.") } } class O8 { constructor(e) { Xe(this, "camera", new hu(-1, 1, 1, -1, 0, 1)), Xe(this, "geometry", new vm(2, 2)), Xe(this, "mesh"), this.mesh = new gr(this.geometry, e) } get material() { return this.mesh.material } set material(e) { this.mesh.material = e } dispose() { this.mesh.geometry.dispose() } render(e) { e.render(this.mesh, this.camera) } } const cc = {
		uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	gl_FragColor = opacity * texel;", "}"].join(`
`)
	}, fg = {
		defines: { PERSPECTIVE_CAMERA: 1, KERNEL_SIZE: 32 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tDepth: { value: null }, tNoise: { value: null }, kernel: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new Se }, cameraProjectionMatrix: { value: new bt }, cameraInverseProjectionMatrix: { value: new bt }, kernelRadius: { value: 8 }, minDistance: { value: .005 }, maxDistance: { value: .05 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDiffuse;", "uniform sampler2D tNormal;", "uniform sampler2D tDepth;", "uniform sampler2D tNoise;", "uniform vec3 kernel[ KERNEL_SIZE ];", "uniform vec2 resolution;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float kernelRadius;", "uniform float minDistance;", "uniform float maxDistance;", "varying vec2 vUv;", "#include <packing>", "float getDepth( const in vec2 screenPosition ) {", "	return texture2D( tDepth, screenPosition ).x;", "}", "float getLinearDepth( const in vec2 screenPosition ) {", "	#if PERSPECTIVE_CAMERA == 1", "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;", "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );", "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );", "	#else", "		return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec2 screenPosition ) {", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "}", "void main() {", "	float depth = getDepth( vUv );", "	float viewZ = getViewZ( depth );", "	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );", "	vec3 viewNormal = getViewNormal( vUv );", " vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );", "	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;", "	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );", "	vec3 bitangent = cross( viewNormal, tangent );", "	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );", " float occlusion = 0.0;", " for ( int i = 0; i < KERNEL_SIZE; i ++ ) {", "		vec3 sampleVector = kernelMatrix * kernel[ i ];", "		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );", "		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );", "		samplePointNDC /= samplePointNDC.w;", "		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;", "		float realDepth = getLinearDepth( samplePointUv );", "		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );", "		float delta = sampleDepth - realDepth;", "		if ( delta > minDistance && delta < maxDistance ) {", "			occlusion += 1.0;", "		}", "	}", "	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );", "	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );", "}"].join(`
`)
	}, v5 = {
		defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "varying vec2 vUv;", "#include <packing>", "float getLinearDepth( const in vec2 screenPosition ) {", "	#if PERSPECTIVE_CAMERA == 1", "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;", "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );", "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );", "	#else", "		return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "void main() {", "	float depth = getLinearDepth( vUv );", "	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );", "}"].join(`
`)
	}, y5 = {
		uniforms: { tDiffuse: { value: null }, resolution: { value: new Se } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "	vec2 texelSize = ( 1.0 / resolution );", "	float result = 0.0;", "	for ( int i = - 2; i <= 2; i ++ ) {", "		for ( int j = - 2; j <= 2; j ++ ) {", "			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;", "			result += texture2D( tDiffuse, vUv + offset ).r;", "		}", "	}", "	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );", "}"].join(`
`)
	}, Fd = class extends N8 { constructor(n, e, t, r) { super(), this.width = t !== void 0 ? t : 512, this.height = r !== void 0 ? r : 512, this.clear = !0, this.camera = e, this.scene = n, this.kernelRadius = 8, this.kernelSize = 32, this.kernel = [], this.noiseTexture = null, this.output = 0, this.minDistance = .005, this.maxDistance = .1, this._visibilityCache = new Map, this.generateSampleKernel(), this.generateRandomKernelRotations(); const i = new xm; i.format = Fh, i.type = sf, this.beautyRenderTarget = new Ir(this.width, this.height), this.normalRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn, depthTexture: i }), this.ssaoRenderTarget = new Ir(this.width, this.height), this.blurRenderTarget = this.ssaoRenderTarget.clone(), fg === void 0 && console.error("THREE.SSAOPass: The pass relies on SSAOShader."), this.ssaoMaterial = new tr({ defines: Object.assign({}, fg.defines), uniforms: mi.clone(fg.uniforms), vertexShader: fg.vertexShader, fragmentShader: fg.fragmentShader, blending: On }), this.ssaoMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssaoMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture, this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.ssaoMaterial.uniforms.cameraNear.value = this.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = this.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new H1, this.normalMaterial.blending = On, this.blurMaterial = new tr({ defines: Object.assign({}, y5.defines), uniforms: mi.clone(y5.uniforms), vertexShader: y5.vertexShader, fragmentShader: y5.fragmentShader }), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new tr({ defines: Object.assign({}, v5.defines), uniforms: mi.clone(v5.uniforms), vertexShader: v5.vertexShader, fragmentShader: v5.fragmentShader, blending: On }), this.depthRenderMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new tr({ uniforms: mi.clone(cc.uniforms), vertexShader: cc.vertexShader, fragmentShader: cc.fragmentShader, transparent: !0, depthTest: !1, depthWrite: !1, blendSrc: r8, blendDst: K3, blendEquation: ko, blendSrcAlpha: n8, blendDstAlpha: K3, blendEquationAlpha: ko }), this.fsQuad = new O8(null), this.originalClearColor = new Je } dispose() { this.beautyRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose() } render(n, e) { switch (n.capabilities.isWebGL2 === !1 && (this.noiseTexture.format = BS), n.setRenderTarget(this.beautyRenderTarget), n.clear(), n.render(this.scene, this.camera), this.overrideVisibility(), this.renderOverride(n, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.restoreVisibility(), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.renderPass(n, this.ssaoMaterial, this.ssaoRenderTarget), this.renderPass(n, this.blurMaterial, this.blurRenderTarget), this.output) { case Fd.OUTPUT.SSAO: this.copyMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case Fd.OUTPUT.Blur: this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case Fd.OUTPUT.Beauty: this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case Fd.OUTPUT.Depth: this.renderPass(n, this.depthRenderMaterial, this.renderToScreen ? null : e); break; case Fd.OUTPUT.Normal: this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case Fd.OUTPUT.Default: this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = YA, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; default: console.warn("THREE.SSAOPass: Unknown output type.") } } renderPass(n, e, t, r, i) { n.getClearColor(this.originalClearColor); const s = n.getClearAlpha(), a = n.autoClear; n.setRenderTarget(t), n.autoClear = !1, r != null && (n.setClearColor(r), n.setClearAlpha(i || 0), n.clear()), this.fsQuad.material = e, this.fsQuad.render(n), n.autoClear = a, n.setClearColor(this.originalClearColor), n.setClearAlpha(s) } renderOverride(n, e, t, r, i) { n.getClearColor(this.originalClearColor); const s = n.getClearAlpha(), a = n.autoClear; n.setRenderTarget(t), n.autoClear = !1, r = e.clearColor || r, i = e.clearAlpha || i, r != null && (n.setClearColor(r), n.setClearAlpha(i || 0), n.clear()), this.scene.overrideMaterial = e, n.render(this.scene, this.camera), this.scene.overrideMaterial = null, n.autoClear = a, n.setClearColor(this.originalClearColor), n.setClearAlpha(s) } setSize(n, e) { this.width = n, this.height = e, this.beautyRenderTarget.setSize(n, e), this.ssaoRenderTarget.setSize(n, e), this.normalRenderTarget.setSize(n, e), this.blurRenderTarget.setSize(n, e), this.ssaoMaterial.uniforms.resolution.value.set(n, e), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(n, e) } generateSampleKernel() { const n = this.kernelSize, e = this.kernel; for (let t = 0; t < n; t++) { const r = new N; r.x = Math.random() * 2 - 1, r.y = Math.random() * 2 - 1, r.z = Math.random(), r.normalize(); let i = t / n; i = hp.lerp(.1, 1, i * i), r.multiplyScalar(i), e.push(r) } } generateRandomKernelRotations() { hA === void 0 && console.error("THREE.SSAOPass: The pass relies on SimplexNoise."); const t = new hA, r = 4 * 4, i = new Float32Array(r); for (let s = 0; s < r; s++) { const a = Math.random() * 2 - 1, o = Math.random() * 2 - 1, l = 0; i[s] = t.noise3d(a, o, l) } this.noiseTexture = new ac(i, 4, 4, Jd, Oa), this.noiseTexture.wrapS = Pl, this.noiseTexture.wrapT = Pl, this.noiseTexture.needsUpdate = !0 } overrideVisibility() { const n = this.scene, e = this._visibilityCache; n.traverse(function (t) { e.set(t, t.visible), (t.isPoints || t.isLine) && (t.visible = !1) }) } restoreVisibility() { const n = this.scene, e = this._visibilityCache; n.traverse(function (t) { const r = e.get(t); t.visible = r }), e.clear() } }; let ole = Fd; Xe(ole, "OUTPUT", { Default: 0, SSAO: 1, Blur: 2, Beauty: 3, Depth: 4, Normal: 5 }); const lle = {
		shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new Je(0) }, defaultOpacity: { value: 0 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "	gl_FragColor = mix( outputColor, texel, alpha );", "}"].join(`
`)
	}, B7 = class extends N8 {
		constructor(n, e, t, r) { super(), this.strength = e !== void 0 ? e : 1, this.radius = t, this.threshold = r, this.resolution = n !== void 0 ? new Se(n.x, n.y) : new Se(256, 256), this.clearColor = new Je(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; let i = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2); this.renderTargetBright = new Ir(i, s, { type: Wi }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1; for (let c = 0; c < this.nMips; c++) { const h = new Ir(i, s, { type: Wi }); h.texture.name = "UnrealBloomPass.h" + c, h.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(h); const d = new Ir(i, s, { type: Wi }); d.texture.name = "UnrealBloomPass.v" + c, d.texture.generateMipmaps = !1, this.renderTargetsVertical.push(d), i = Math.round(i / 2), s = Math.round(s / 2) } const a = lle; this.highPassUniforms = mi.clone(a.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new tr({ uniforms: this.highPassUniforms, vertexShader: a.vertexShader, fragmentShader: a.fragmentShader, defines: {} }), this.separableBlurMaterials = []; const o = [3, 5, 7, 9, 11]; i = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2); for (let c = 0; c < this.nMips; c++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[c])), this.separableBlurMaterials[c].uniforms.texSize.value = new Se(i, s), i = Math.round(i / 2), s = Math.round(s / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0; const l = [1, .8, .6, .4, .2]; this.compositeMaterial.uniforms.bloomFactors.value = l, this.bloomTintColors = [new N(1, 1, 1), new N(1, 1, 1), new N(1, 1, 1), new N(1, 1, 1), new N(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors; const u = cc; this.copyUniforms = mi.clone(u.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new tr({ uniforms: this.copyUniforms, vertexShader: u.vertexShader, fragmentShader: u.fragmentShader, blending: XA, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Je, this.oldClearAlpha = 1, this.basic = new qs, this.fsQuad = new O8(null) } dispose() { for (let n = 0; n < this.renderTargetsHorizontal.length; n++)this.renderTargetsHorizontal[n].dispose(); for (let n = 0; n < this.renderTargetsVertical.length; n++)this.renderTargetsVertical[n].dispose(); this.renderTargetBright.dispose(); for (let n = 0; n < this.separableBlurMaterials.length; n++)this.separableBlurMaterials[n].dispose(); this.compositeMaterial.dispose(), this.materialCopy.dispose(), this.basic.dispose(), this.fsQuad.dispose() } setSize(n, e) { let t = Math.round(n / 2), r = Math.round(e / 2); this.renderTargetBright.setSize(t, r); for (let i = 0; i < this.nMips; i++)this.renderTargetsHorizontal[i].setSize(t, r), this.renderTargetsVertical[i].setSize(t, r), this.separableBlurMaterials[i].uniforms.texSize.value = new Se(t, r), t = Math.round(t / 2), r = Math.round(r / 2) } render(n, e, t, r, i) { n.getClearColor(this._oldClearColor), this.oldClearAlpha = n.getClearAlpha(); const s = n.autoClear; n.autoClear = !1, n.setClearColor(this.clearColor, 0), i && n.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = t.texture, n.setRenderTarget(null), n.clear(), this.fsQuad.render(n)), this.highPassUniforms.tDiffuse.value = t.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, n.setRenderTarget(this.renderTargetBright), n.clear(), this.fsQuad.render(n); let a = this.renderTargetBright; for (let o = 0; o < this.nMips; o++)this.fsQuad.material = this.separableBlurMaterials[o], this.separableBlurMaterials[o].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[o].uniforms.direction.value = B7.BlurDirectionX, n.setRenderTarget(this.renderTargetsHorizontal[o]), n.clear(), this.fsQuad.render(n), this.separableBlurMaterials[o].uniforms.colorTexture.value = this.renderTargetsHorizontal[o].texture, this.separableBlurMaterials[o].uniforms.direction.value = B7.BlurDirectionY, n.setRenderTarget(this.renderTargetsVertical[o]), n.clear(), this.fsQuad.render(n), a = this.renderTargetsVertical[o]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, n.setRenderTarget(this.renderTargetsHorizontal[0]), n.clear(), this.fsQuad.render(n), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, i && n.state.buffers.stencil.setTest(!0), this.renderToScreen ? (n.setRenderTarget(null), this.fsQuad.render(n)) : (n.setRenderTarget(t), this.fsQuad.render(n)), n.setClearColor(this._oldClearColor, this.oldClearAlpha), n.autoClear = s } getSeperableBlurMaterial(n) {
			return new tr({
				defines: { KERNEL_RADIUS: n, SIGMA: n }, uniforms: { colorTexture: { value: null }, texSize: { value: new Se(.5, .5) }, direction: { value: new Se(.5, .5) } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})
		} getCompositeMaterial(n) {
			return new tr({
				defines: { NUM_MIPS: n }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})
		}
	}; let YG = B7; Xe(YG, "BlurDirectionX", new Se(1, 0)); Xe(YG, "BlurDirectionY", new Se(0, 1)); const x5 = {
		defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, NORMAL_TEXTURE: 0, DIFFUSE_TEXTURE: 0, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, tDiffuse: { value: null }, tNormal: { value: null }, size: { value: new Se(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new bt }, cameraInverseProjectionMatrix: { value: new bt }, scale: { value: 1 }, intensity: { value: .1 }, bias: { value: .5 }, minResolution: { value: 0 }, kernelRadius: { value: 100 }, randomSeed: { value: 0 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "uniform sampler2D tDepth;", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float scale;", "uniform float intensity;", "uniform float bias;", "uniform float kernelRadius;", "uniform float minResolution;", "uniform vec2 size;", "uniform float randomSeed;", "// RGBA depth", "#include <packing>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "	#if DIFFUSE_TEXTURE == 1", "	return texture2D( tDiffuse, vUv );", "	#else", "	return vec4( 1.0 );", "	#endif", "}", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "	#if NORMAL_TEXTURE == 1", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "	#else", "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "	#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "	vec3 viewDelta = sampleViewPosition - centerViewPosition;", "	float viewDistance = length( viewDelta );", "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;", "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );", "}", "// moving costly divides into consts", "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {", "	// precompute some variables require in getOcclusion.", "	scaleDividedByCameraFar = scale / cameraFar;", "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;", "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/", "	float angle = rand( vUv + randomSeed ) * PI2;", "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;", "	vec2 radiusStep = radius;", "	float occlusionSum = 0.0;", "	float weightSum = 0.0;", "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;", "		radius += radiusStep;", "		angle += ANGLE_STEP;", "		float sampleDepth = getDepth( sampleUv );", "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "			continue;", "		}", "		float sampleViewZ = getViewZ( sampleDepth );", "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "		weightSum += 1.0;", "	}", "	if( weightSum == 0.0 ) discard;", "	return occlusionSum * ( intensity / weightSum );", "}", "void main() {", "	float centerDepth = getDepth( vUv );", "	if( centerDepth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = getViewZ( centerDepth );", "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "	float ambientOcclusion = getAmbientOcclusion( viewPosition );", "	gl_FragColor = getDefaultColor( vUv );", "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;", "}"].join(`
`)
	}, Xf = {
		defines: { KERNEL_RADIUS: 4, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDiffuse: { value: null }, size: { value: new Se(512, 512) }, sampleUvOffsets: { value: [new Se(0, 0)] }, sampleWeights: { value: [1] }, tDepth: { value: null }, cameraNear: { value: 10 }, cameraFar: { value: 1e3 }, depthCutoff: { value: 10 } }, vertexShader: ["#include <common>", "uniform vec2 size;", "varying vec2 vUv;", "varying vec2 vInvSize;", "void main() {", "	vUv = uv;", "	vInvSize = 1.0 / size;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join(`
`), fragmentShader: ["#include <common>", "#include <packing>", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float depthCutoff;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "varying vec2 vInvSize;", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "void main() {", "	float depth = getDepth( vUv );", "	if( depth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = -getViewZ( depth );", "	bool rBreak = false, lBreak = false;", "	float weightSum = sampleWeights[0];", "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "		float sampleWeight = sampleWeights[i];", "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;", "		vec2 sampleUv = vUv + sampleUvOffset;", "		float viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;", "		if( ! rBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "		sampleUv = vUv - sampleUvOffset;", "		viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;", "		if( ! lBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "	}", "	gl_FragColor = diffuseSum / weightSum;", "}"].join(`
`)
	}, Ay = { createSampleWeights: (n, e) => { const t = (i, s) => Math.exp(-(i * i) / (2 * (s * s))) / (Math.sqrt(2 * Math.PI) * s), r = []; for (let i = 0; i <= n; i++)r.push(t(i, e)); return r }, createSampleOffsets: (n, e) => { const t = []; for (let r = 0; r <= n; r++)t.push(e.clone().multiplyScalar(r)); return t }, configure: (n, e, t, r) => { n.defines.KERNEL_RADIUS = e, n.uniforms.sampleUvOffsets.value = Ay.createSampleOffsets(e, r), n.uniforms.sampleWeights.value = Ay.createSampleWeights(e, t), n.needsUpdate = !0 } }; class ule extends N8 { constructor(e, t, r = !1, i = !1, s = new Se(256, 256)) { super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.supportsDepthTextureExtension = r, this.supportsNormalTexture = i, this.originalClearColor = new Je, this._oldClearColor = new Je, this.oldClearAlpha = 1, this.params = { output: 0, saoBias: .5, saoIntensity: .18, saoScale: 1, saoKernelRadius: 100, saoMinResolution: 0, saoBlur: !0, saoBlurRadius: 8, saoBlurStdDev: 4, saoBlurDepthCutoff: .01 }, this.resolution = new Se(s.x, s.y), this.saoRenderTarget = new Ir(this.resolution.x, this.resolution.y, { type: Wi }), this.blurIntermediateRenderTarget = this.saoRenderTarget.clone(), this.beautyRenderTarget = this.saoRenderTarget.clone(), this.normalRenderTarget = new Ir(this.resolution.x, this.resolution.y, { minFilter: cn, magFilter: cn, type: Wi }), this.depthRenderTarget = this.normalRenderTarget.clone(); let a; this.supportsDepthTextureExtension && (a = new xm, a.type = Np, this.beautyRenderTarget.depthTexture = a, this.beautyRenderTarget.depthBuffer = !0), this.depthMaterial = new h8, this.depthMaterial.depthPacking = NS, this.depthMaterial.blending = On, this.normalMaterial = new H1, this.normalMaterial.blending = On, this.saoMaterial = new tr({ defines: Object.assign({}, x5.defines), fragmentShader: x5.fragmentShader, vertexShader: x5.vertexShader, uniforms: mi.clone(x5.uniforms) }), this.saoMaterial.extensions.derivatives = !0, this.saoMaterial.defines.DEPTH_PACKING = this.supportsDepthTextureExtension ? 0 : 1, this.saoMaterial.defines.NORMAL_TEXTURE = this.supportsNormalTexture ? 1 : 0, this.saoMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.saoMaterial.uniforms.tDepth.value = this.supportsDepthTextureExtension ? a : this.depthRenderTarget.texture, this.saoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.saoMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.blending = On, this.vBlurMaterial = new tr({ uniforms: mi.clone(Xf.uniforms), defines: Object.assign({}, Xf.defines), vertexShader: Xf.vertexShader, fragmentShader: Xf.fragmentShader }), this.vBlurMaterial.defines.DEPTH_PACKING = this.supportsDepthTextureExtension ? 0 : 1, this.vBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.vBlurMaterial.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.vBlurMaterial.uniforms.tDepth.value = this.supportsDepthTextureExtension ? a : this.depthRenderTarget.texture, this.vBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.vBlurMaterial.blending = On, this.hBlurMaterial = new tr({ uniforms: mi.clone(Xf.uniforms), defines: Object.assign({}, Xf.defines), vertexShader: Xf.vertexShader, fragmentShader: Xf.fragmentShader }), this.hBlurMaterial.defines.DEPTH_PACKING = this.supportsDepthTextureExtension ? 0 : 1, this.hBlurMaterial.defines.PERSPECTIVE_CAMERA = this.camera.isPerspectiveCamera ? 1 : 0, this.hBlurMaterial.uniforms.tDiffuse.value = this.blurIntermediateRenderTarget.texture, this.hBlurMaterial.uniforms.tDepth.value = this.supportsDepthTextureExtension ? a : this.depthRenderTarget.texture, this.hBlurMaterial.uniforms.size.value.set(this.resolution.x, this.resolution.y), this.hBlurMaterial.blending = On, this.materialCopy = new tr({ uniforms: mi.clone(cc.uniforms), vertexShader: cc.vertexShader, fragmentShader: cc.fragmentShader, blending: On }), this.materialCopy.transparent = !0, this.materialCopy.depthTest = !1, this.materialCopy.depthWrite = !1, this.materialCopy.blending = YA, this.materialCopy.blendSrc = r8, this.materialCopy.blendDst = K3, this.materialCopy.blendEquation = ko, this.materialCopy.blendSrcAlpha = n8, this.materialCopy.blendDstAlpha = K3, this.materialCopy.blendEquationAlpha = ko, this.depthCopy = new tr({ uniforms: mi.clone(M_.uniforms), vertexShader: M_.vertexShader, fragmentShader: M_.fragmentShader, blending: On }), this.fsQuad = new O8(null) } render(e, t, r) { if (this.renderToScreen && (this.materialCopy.blending = On, this.materialCopy.uniforms.tDiffuse.value = r.texture, this.materialCopy.needsUpdate = !0, this.renderPass(e, this.materialCopy, null)), this.params.output === 1) return; e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha(); const i = e.autoClear; e.autoClear = !1, e.setRenderTarget(this.depthRenderTarget), e.clear(), this.saoMaterial.uniforms.bias.value = this.params.saoBias, this.saoMaterial.uniforms.intensity.value = this.params.saoIntensity, this.saoMaterial.uniforms.scale.value = this.params.saoScale, this.saoMaterial.uniforms.kernelRadius.value = this.params.saoKernelRadius, this.saoMaterial.uniforms.minResolution.value = this.params.saoMinResolution, this.saoMaterial.uniforms.cameraNear.value = this.camera.near, this.saoMaterial.uniforms.cameraFar.value = this.camera.far; const s = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near); this.vBlurMaterial.uniforms.depthCutoff.value = s, this.hBlurMaterial.uniforms.depthCutoff.value = s, this.vBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.vBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.hBlurMaterial.uniforms.cameraNear.value = this.camera.near, this.hBlurMaterial.uniforms.cameraFar.value = this.camera.far, this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius), (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) && (Ay.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Se(0, 1)), Ay.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Se(1, 0)), this.prevStdDev = this.params.saoBlurStdDev, this.prevNumSamples = this.params.saoBlurRadius), e.setClearColor(0), e.setRenderTarget(this.beautyRenderTarget), e.clear(), e.render(this.scene, this.camera), this.supportsDepthTextureExtension || this.renderOverride(e, this.depthMaterial, this.depthRenderTarget, 0, 1), this.supportsNormalTexture && this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.renderPass(e, this.saoMaterial, this.saoRenderTarget, 16777215, 1), this.params.saoBlur && (this.renderPass(e, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1), this.renderPass(e, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1)); let a = this.materialCopy; this.params.output === 3 ? this.supportsDepthTextureExtension ? (this.materialCopy.uniforms.tDiffuse.value = this.beautyRenderTarget.depthTexture, this.materialCopy.needsUpdate = !0) : (this.depthCopy.uniforms.tDiffuse.value = this.depthRenderTarget.texture, this.depthCopy.needsUpdate = !0, a = this.depthCopy) : this.params.output === 4 ? (this.materialCopy.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.materialCopy.needsUpdate = !0) : (this.materialCopy.uniforms.tDiffuse.value = this.saoRenderTarget.texture, this.materialCopy.needsUpdate = !0), this.params.output === 0 ? a.blending = YA : a.blending = On, this.renderPass(e, a, this.renderToScreen ? null : r), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = i } renderPass(e, t, r, i, s) { e.getClearColor(this.originalClearColor); const a = e.getClearAlpha(), o = e.autoClear; e.setRenderTarget(r), e.autoClear = !1, i != null && (e.setClearColor(i), e.setClearAlpha(s || 0), e.clear()), this.fsQuad.material = t, this.fsQuad.render(e), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a) } renderOverride(e, t, r, i, s) { e.getClearColor(this.originalClearColor); const a = e.getClearAlpha(), o = e.autoClear; e.setRenderTarget(r), e.autoClear = !1, i = t.clearColor || i, s = t.clearAlpha || s, i != null && (e.setClearColor(i), e.setClearAlpha(s || 0), e.clear()), this.scene.overrideMaterial = t, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a) } setSize(e, t) { this.beautyRenderTarget.setSize(e, t), this.saoRenderTarget.setSize(e, t), this.blurIntermediateRenderTarget.setSize(e, t), this.normalRenderTarget.setSize(e, t), this.depthRenderTarget.setSize(e, t), this.saoMaterial.uniforms.size.value.set(e, t), this.saoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.saoMaterial.uniforms.cameraProjectionMatrix.value = this.camera.projectionMatrix, this.saoMaterial.needsUpdate = !0, this.vBlurMaterial.uniforms.size.value.set(e, t), this.vBlurMaterial.needsUpdate = !0, this.hBlurMaterial.uniforms.size.value.set(e, t), this.hBlurMaterial.needsUpdate = !0 } dispose() { this.saoRenderTarget.dispose(), this.blurIntermediateRenderTarget.dispose(), this.beautyRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.depthRenderTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.saoMaterial.dispose(), this.vBlurMaterial.dispose(), this.hBlurMaterial.dispose(), this.materialCopy.dispose(), this.depthCopy.dispose(), this.fsQuad.dispose() } } Xe(ule, "OUTPUT", { Beauty: 1, Default: 0, SAO: 2, Depth: 3, Normal: 4 }); const Vu = {
		defines: { MAX_STEP: 0, isPerspectiveCamera: !0, isDistanceAttenuation: !0, isFresnel: !0, isInfiniteThick: !1, isSelective: !1 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tMetalness: { value: null }, tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new Se }, cameraProjectionMatrix: { value: new bt }, cameraInverseProjectionMatrix: { value: new bt }, opacity: { value: .5 }, maxDistance: { value: 180 }, cameraRange: { value: 0 }, surfDist: { value: .007 }, thickTolerance: { value: .03 } }, vertexShader: `

    varying vec2 vUv;

    void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `, fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float surfDist;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float thickTolerance;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef isPerspectiveCamera
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef isSelective
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef isPerspectiveCamera
				vec3 viewIncidenceDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#else
				vec3 viewIncidenceDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef isPerspectiveCamera
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<MAX_STEP;i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef isPerspectiveCamera
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif
				if(viewReflectRayZ-sD>vZ) continue;

				#ifdef isInfiniteThick
					if(viewReflectRayZ+thickTolerance*clipW<vP.z) break;
				#endif
				float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

				float op=opacity;

				if(away<sD){
					vec3 vN=getViewNormal( uv );
					if(dot(viewReflectDir,vN)>=0.) continue;
					float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
					if(distance>maxDistance) break;
					#ifdef isDistanceAttenuation
						float ratio=1.-(distance/maxDistance);
						float attenuation=ratio*ratio;
						op=opacity*attenuation;
					#endif
					#ifdef isFresnel
						float fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;
						op*=fresnel;
					#endif
					vec4 reflectColor=texture2D(tDiffuse,uv);
					gl_FragColor.xyz=reflectColor.xyz;
					gl_FragColor.a=op;
					break;
				}
			}
		}
	`}, _5 = {
			defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `, fragmentShader: `

    uniform sampler2D tDepth;

    uniform float cameraNear;
    uniform float cameraFar;

    varying vec2 vUv;

    #include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

    void main() {

    	float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
    	gl_FragColor = vec4( vec3( d ), 1.0 );

    }

  `}, Yf = {
			uniforms: { tDiffuse: { value: null }, resolution: { value: new Se }, opacity: { value: .5 } }, vertexShader: `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `, fragmentShader: `

    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

    	vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`}, kd = class extends N8 { constructor({ renderer: n, scene: e, camera: t, width: r, height: i, selects: s, bouncing: a = !1, groundReflector: o }) { super(), this.width = r !== void 0 ? r : 512, this.height = i !== void 0 ? i : 512, this.clear = !0, this.renderer = n, this.scene = e, this.camera = t, this.groundReflector = o, this.opacity = Vu.uniforms.opacity.value, this.output = 0, this.maxDistance = Vu.uniforms.maxDistance.value, this.thickness = Vu.uniforms.thickness.value, this.tempColor = new Je, this._selects = s, this.selective = Array.isArray(this._selects), Object.defineProperty(this, "selects", { get() { return this._selects }, set(u) { this._selects !== u && (this._selects = u, Array.isArray(u) ? (this.selective = !0, this.ssrMaterial.defines.SELECTIVE = !0, this.ssrMaterial.needsUpdate = !0) : (this.selective = !1, this.ssrMaterial.defines.SELECTIVE = !1, this.ssrMaterial.needsUpdate = !0)) } }), this._bouncing = a, Object.defineProperty(this, "bouncing", { get() { return this._bouncing }, set(u) { this._bouncing !== u && (this._bouncing = u, u ? this.ssrMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture : this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture) } }), this.blur = !0, this._distanceAttenuation = Vu.defines.DISTANCE_ATTENUATION, Object.defineProperty(this, "distanceAttenuation", { get() { return this._distanceAttenuation }, set(u) { this._distanceAttenuation !== u && (this._distanceAttenuation = u, this.ssrMaterial.defines.DISTANCE_ATTENUATION = u, this.ssrMaterial.needsUpdate = !0) } }), this._fresnel = Vu.defines.FRESNEL, Object.defineProperty(this, "fresnel", { get() { return this._fresnel }, set(u) { this._fresnel !== u && (this._fresnel = u, this.ssrMaterial.defines.FRESNEL = u, this.ssrMaterial.needsUpdate = !0) } }), this._infiniteThick = Vu.defines.INFINITE_THICK, Object.defineProperty(this, "infiniteThick", { get() { return this._infiniteThick }, set(u) { this._infiniteThick !== u && (this._infiniteThick = u, this.ssrMaterial.defines.INFINITE_THICK = u, this.ssrMaterial.needsUpdate = !0) } }); const l = new xm; l.type = Np, l.minFilter = cn, l.magFilter = cn, this.beautyRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn, type: Wi, depthTexture: l, depthBuffer: !0 }), this.prevRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn }), this.normalRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn, type: Wi }), this.metalnessRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn, type: Wi }), this.ssrRenderTarget = new Ir(this.width, this.height, { minFilter: cn, magFilter: cn }), this.blurRenderTarget = this.ssrRenderTarget.clone(), this.blurRenderTarget2 = this.ssrRenderTarget.clone(), this.ssrMaterial = new tr({ defines: Object.assign({}, Vu.defines, { MAX_STEP: Math.sqrt(this.width * this.width + this.height * this.height) }), uniforms: mi.clone(Vu.uniforms), vertexShader: Vu.vertexShader, fragmentShader: Vu.fragmentShader, blending: On }), this.ssrMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.ssrMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssrMaterial.defines.SELECTIVE = this.selective, this.ssrMaterial.needsUpdate = !0, this.ssrMaterial.uniforms.tMetalness.value = this.metalnessRenderTarget.texture, this.ssrMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.ssrMaterial.uniforms.cameraNear.value = this.camera.near, this.ssrMaterial.uniforms.cameraFar.value = this.camera.far, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.ssrMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new H1, this.normalMaterial.blending = On, this.metalnessOnMaterial = new qs({ color: "white" }), this.metalnessOffMaterial = new qs({ color: "black" }), this.blurMaterial = new tr({ defines: Object.assign({}, Yf.defines), uniforms: mi.clone(Yf.uniforms), vertexShader: Yf.vertexShader, fragmentShader: Yf.fragmentShader }), this.blurMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.blurMaterial2 = new tr({ defines: Object.assign({}, Yf.defines), uniforms: mi.clone(Yf.uniforms), vertexShader: Yf.vertexShader, fragmentShader: Yf.fragmentShader }), this.blurMaterial2.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.blurMaterial2.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new tr({ defines: Object.assign({}, _5.defines), uniforms: mi.clone(_5.uniforms), vertexShader: _5.vertexShader, fragmentShader: _5.fragmentShader, blending: On }), this.depthRenderMaterial.uniforms.tDepth.value = this.beautyRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new tr({ uniforms: mi.clone(cc.uniforms), vertexShader: cc.vertexShader, fragmentShader: cc.fragmentShader, transparent: !0, depthTest: !1, depthWrite: !1, blendSrc: jA, blendDst: JA, blendEquation: ko, blendSrcAlpha: jA, blendDstAlpha: JA, blendEquationAlpha: ko }), this.fsQuad = new O8(null), this.originalClearColor = new Je } dispose() { this.beautyRenderTarget.dispose(), this.prevRenderTarget.dispose(), this.normalRenderTarget.dispose(), this.metalnessRenderTarget.dispose(), this.ssrRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.blurRenderTarget2.dispose(), this.normalMaterial.dispose(), this.metalnessOnMaterial.dispose(), this.metalnessOffMaterial.dispose(), this.blurMaterial.dispose(), this.blurMaterial2.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose() } render(n, e) { switch (n.setRenderTarget(this.beautyRenderTarget), n.clear(), this.groundReflector && (this.groundReflector.visible = !1, this.groundReflector.doRender(this.renderer, this.scene, this.camera), this.groundReflector.visible = !0), n.render(this.scene, this.camera), this.groundReflector && (this.groundReflector.visible = !1), this.renderOverride(n, this.normalMaterial, this.normalRenderTarget, 0, 0), this.selective && this.renderMetalness(n, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0), this.ssrMaterial.uniforms.opacity.value = this.opacity, this.ssrMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssrMaterial.uniforms.thickness.value = this.thickness, this.renderPass(n, this.ssrMaterial, this.ssrRenderTarget), this.blur && (this.renderPass(n, this.blurMaterial, this.blurRenderTarget), this.renderPass(n, this.blurMaterial2, this.blurRenderTarget2)), this.output) { case kd.OUTPUT.Default: this.bouncing ? (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.prevRenderTarget), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = ic, this.renderPass(n, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.prevRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e)) : (this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e), this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = ic, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e)); break; case kd.OUTPUT.SSR: this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e), this.bouncing && (this.blur ? this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget2.texture : this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.prevRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = this.ssrRenderTarget.texture, this.copyMaterial.blending = ic, this.renderPass(n, this.copyMaterial, this.prevRenderTarget)); break; case kd.OUTPUT.Beauty: this.copyMaterial.uniforms.tDiffuse.value = this.beautyRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case kd.OUTPUT.Depth: this.renderPass(n, this.depthRenderMaterial, this.renderToScreen ? null : e); break; case kd.OUTPUT.Normal: this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; case kd.OUTPUT.Metalness: this.copyMaterial.uniforms.tDiffuse.value = this.metalnessRenderTarget.texture, this.copyMaterial.blending = On, this.renderPass(n, this.copyMaterial, this.renderToScreen ? null : e); break; default: console.warn("THREE.SSRPass: Unknown output type.") } } renderPass(n, e, t, r, i) { this.originalClearColor.copy(n.getClearColor(this.tempColor)); const s = n.getClearAlpha(this.tempColor), a = n.autoClear; n.setRenderTarget(t), n.autoClear = !1, r != null && (n.setClearColor(r), n.setClearAlpha(i || 0), n.clear()), this.fsQuad.material = e, this.fsQuad.render(n), n.autoClear = a, n.setClearColor(this.originalClearColor), n.setClearAlpha(s) } renderOverride(n, e, t, r, i) { this.originalClearColor.copy(n.getClearColor(this.tempColor)); const s = n.getClearAlpha(this.tempColor), a = n.autoClear; n.setRenderTarget(t), n.autoClear = !1, r = e.clearColor || r, i = e.clearAlpha || i, r != null && (n.setClearColor(r), n.setClearAlpha(i || 0), n.clear()), this.scene.overrideMaterial = e, n.render(this.scene, this.camera), this.scene.overrideMaterial = null, n.autoClear = a, n.setClearColor(this.originalClearColor), n.setClearAlpha(s) } renderMetalness(n, e, t, r, i) { this.originalClearColor.copy(n.getClearColor(this.tempColor)); const s = n.getClearAlpha(this.tempColor), a = n.autoClear; n.setRenderTarget(t), n.autoClear = !1, r = e.clearColor || r, i = e.clearAlpha || i, r != null && (n.setClearColor(r), n.setClearAlpha(i || 0), n.clear()), this.scene.traverseVisible(o => { o._SSRPassBackupMaterial = o.material, this._selects.includes(o) ? o.material = this.metalnessOnMaterial : o.material = this.metalnessOffMaterial }), n.render(this.scene, this.camera), this.scene.traverseVisible(o => { o.material = o._SSRPassBackupMaterial }), n.autoClear = a, n.setClearColor(this.originalClearColor), n.setClearAlpha(s) } setSize(n, e) { this.width = n, this.height = e, this.ssrMaterial.defines.MAX_STEP = Math.sqrt(n * n + e * e), this.ssrMaterial.needsUpdate = !0, this.beautyRenderTarget.setSize(n, e), this.prevRenderTarget.setSize(n, e), this.ssrRenderTarget.setSize(n, e), this.normalRenderTarget.setSize(n, e), this.metalnessRenderTarget.setSize(n, e), this.blurRenderTarget.setSize(n, e), this.blurRenderTarget2.setSize(n, e), this.ssrMaterial.uniforms.resolution.value.set(n, e), this.ssrMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssrMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(n, e), this.blurMaterial2.uniforms.resolution.value.set(n, e) } }; let cle = kd; Xe(cle, "OUTPUT", { Default: 0, SSR: 1, Beauty: 3, Depth: 4, Normal: 5, Metalness: 7 }); class bT extends Us { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new mle(t) }), this.register(function (t) { return new Cle(t) }), this.register(function (t) { return new Sle(t) }), this.register(function (t) { return new Tle(t) }), this.register(function (t) { return new Ale(t) }), this.register(function (t) { return new vle(t) }), this.register(function (t) { return new yle(t) }), this.register(function (t) { return new xle(t) }), this.register(function (t) { return new ple(t) }), this.register(function (t) { return new _le(t) }), this.register(function (t) { return new gle(t) }), this.register(function (t) { return new Ele(t) }), this.register(function (t) { return new hle(t) }), this.register(function (t) { return new wle(t) }), this.register(function (t) { return new Ile(t) }) } load(e, t, r, i) { const s = this; let a; this.resourcePath !== "" ? a = this.resourcePath : this.path !== "" ? a = this.path : a = lc.extractUrlBase(e), this.manager.itemStart(e); const o = function (u) { i ? i(u) : console.error(u), s.manager.itemError(e), s.manager.itemEnd(e) }, l = new _s(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (u) { try { s.parse(u, a, function (c) { t(c), s.manager.itemEnd(e) }, o) } catch (c) { o(c) } }, r, o) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this } unregister(e) { return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, r, i) { let s; const a = {}, o = {}; if (typeof e == "string") s = JSON.parse(e); else if (e instanceof ArrayBuffer) if (lc.decodeText(new Uint8Array(e.slice(0, 4))) === jG) { try { a[jn.KHR_BINARY_GLTF] = new Mle(e) } catch (c) { i && i(c); return } s = JSON.parse(a[jn.KHR_BINARY_GLTF].content) } else s = JSON.parse(lc.decodeText(new Uint8Array(e))); else s = e; if (s.asset === void 0 || s.asset.version[0] < 2) { i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); return } const l = new Qle(s, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let u = 0; u < this.pluginCallbacks.length; u++) { const c = this.pluginCallbacks[u](l); o[c.name] = c, a[c.name] = !0 } if (s.extensionsUsed) for (let u = 0; u < s.extensionsUsed.length; ++u) { const c = s.extensionsUsed[u], h = s.extensionsRequired || []; switch (c) { case jn.KHR_MATERIALS_UNLIT: a[c] = new dle; break; case jn.KHR_DRACO_MESH_COMPRESSION: a[c] = new ble(s, this.dracoLoader); break; case jn.KHR_TEXTURE_TRANSFORM: a[c] = new Ble; break; case jn.KHR_MESH_QUANTIZATION: a[c] = new Rle; break; default: h.indexOf(c) >= 0 && o[c] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".') } } l.setExtensions(a), l.setPlugins(o), l.parse(r, i) } parseAsync(e, t) { const r = this; return new Promise(function (i, s) { r.parse(e, t, i, s) }) } } function fle() { let n = {}; return { get: function (e) { return n[e] }, add: function (e, t) { n[e] = t }, remove: function (e) { delete n[e] }, removeAll: function () { n = {} } } } const jn = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_TEXTURE_AVIF: "EXT_texture_avif", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression", EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing" }; class hle { constructor(e) { this.parser = e, this.name = jn.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let r = 0, i = t.length; r < i; r++) { const s = t[r]; s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, r = "light:" + e; let i = t.cache.get(r); if (i) return i; const s = t.json, l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e]; let u; const c = new Je(16777215); l.color !== void 0 && c.fromArray(l.color); const h = l.range !== void 0 ? l.range : 0; switch (l.type) { case "directional": u = new fT(c), u.target.position.set(0, 0, -1), u.add(u.target); break; case "point": u = new cT(c), u.distance = h; break; case "spot": u = new uT(c), u.distance = h, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, u.angle = l.spot.outerConeAngle, u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, u.target.position.set(0, 0, -1), u.add(u.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type) }return u.position.set(0, 0, 0), u.decay = 2, $f(u, l), l.intensity !== void 0 && (u.intensity = l.intensity), u.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(u), t.cache.add(r, i), i } getDependency(e, t) { if (e === "light") return this._loadLight(t) } createNodeAttachment(e) { const t = this, r = this.parser, s = r.json.nodes[e], o = (s.extensions && s.extensions[this.name] || {}).light; return o === void 0 ? null : this._loadLight(o).then(function (l) { return r._getNodeRef(t.cache, o, l) }) } } class dle { constructor() { this.name = jn.KHR_MATERIALS_UNLIT } getMaterialType() { return qs } extendParams(e, t, r) { const i = []; e.color = new Je(1, 1, 1), e.opacity = 1; const s = t.pbrMetallicRoughness; if (s) { if (Array.isArray(s.baseColorFactor)) { const a = s.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } s.baseColorTexture !== void 0 && i.push(r.assignTexture(e, "map", s.baseColorTexture, 3001)) } return Promise.all(i) } } class ple { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_EMISSIVE_STRENGTH } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = i.extensions[this.name].emissiveStrength; return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve() } } class mle { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(r.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) { const o = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Se(o, o) } return Promise.all(s) } } class gle { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_IRIDESCENCE } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(r.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s) } } class Ale { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_SHEEN } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = []; t.sheenColor = new Je(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const a = i.extensions[this.name]; return a.sheenColorFactor !== void 0 && t.sheenColor.fromArray(a.sheenColorFactor), a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(r.assignTexture(t, "sheenColorMap", a.sheenColorTexture, 3001)), a.sheenRoughnessTexture !== void 0 && s.push(r.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s) } } class vle { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(r.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s) } } class yle { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_VOLUME } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(r.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0; const o = a.attenuationColor || [1, 1, 1]; return t.attenuationColor = new Je(o[0], o[1], o[2]), Promise.all(s) } } class xle { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_IOR } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const i = this.parser.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = i.extensions[this.name]; return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve() } } class _le { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(r.assignTexture(t, "specularIntensityMap", a.specularTexture)); const o = a.specularColorFactor || [1, 1, 1]; return t.specularColor = new Je(o[0], o[1], o[2]), a.specularColorTexture !== void 0 && s.push(r.assignTexture(t, "specularColorMap", a.specularColorTexture, 3001)), Promise.all(s) } } class Ele { constructor(e) { this.parser = e, this.name = jn.KHR_MATERIALS_ANISOTROPY } getMaterialType(e) { const r = this.parser.json.materials[e]; return !r.extensions || !r.extensions[this.name] ? null : gc } extendMaterialParams(e, t) { const r = this.parser, i = r.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const s = [], a = i.extensions[this.name]; return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(r.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s) } } class Cle { constructor(e) { this.parser = e, this.name = jn.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, r = t.json, i = r.textures[e]; if (!i.extensions || !i.extensions[this.name]) return null; const s = i.extensions[this.name], a = t.options.ktx2Loader; if (!a) { if (r.extensionsRequired && r.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, s.source, a) } } class Sle { constructor(e) { this.parser = e, this.name = jn.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, r = this.parser, i = r.json, s = i.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const a = s.extensions[t], o = i.images[a.source]; let l = r.textureLoader; if (o.uri) { const u = r.options.manager.getHandler(o.uri); u !== null && (l = u) } return this.detectSupport().then(function (u) { if (u) return r.loadTextureImage(e, a.source, l); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return r.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class Tle { constructor(e) { this.parser = e, this.name = jn.EXT_TEXTURE_AVIF, this.isSupported = null } loadTexture(e) { const t = this.name, r = this.parser, i = r.json, s = i.textures[e]; if (!s.extensions || !s.extensions[t]) return null; const a = s.extensions[t], o = i.images[a.source]; let l = r.textureLoader; if (o.uri) { const u = r.options.manager.getHandler(o.uri); u !== null && (l = u) } return this.detectSupport().then(function (u) { if (u) return r.loadTextureImage(e, a.source, l); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported."); return r.loadTexture(e) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () { e(t.height === 1) } })), this.isSupported } } class wle { constructor(e) { this.name = jn.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, r = t.bufferViews[e]; if (r.extensions && r.extensions[this.name]) { const i = r.extensions[this.name], s = this.parser.getDependency("buffer", i.buffer), a = this.parser.options.meshoptDecoder; if (!a || !a.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return s.then(function (o) { const l = i.byteOffset || 0, u = i.byteLength || 0, c = i.count, h = i.byteStride, d = new Uint8Array(o, l, u); return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(c, h, d, i.mode, i.filter).then(function (m) { return m.buffer }) : a.ready.then(function () { const m = new ArrayBuffer(c * h); return a.decodeGltfBuffer(new Uint8Array(m), c, h, d, i.mode, i.filter), m }) }) } else return null } } class Ile { constructor(e) { this.name = jn.EXT_MESH_GPU_INSTANCING, this.parser = e } createNodeMesh(e) { const t = this.parser.json, r = t.nodes[e]; if (!r.extensions || !r.extensions[this.name] || r.mesh === void 0) return null; const i = t.meshes[r.mesh]; for (const u of i.primitives) if (u.mode !== pl.TRIANGLES && u.mode !== pl.TRIANGLE_STRIP && u.mode !== pl.TRIANGLE_FAN && u.mode !== void 0) return null; const a = r.extensions[this.name].attributes, o = [], l = {}; for (const u in a) o.push(this.parser.getDependency("accessor", a[u]).then(c => (l[u] = c, l[u]))); return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then(u => { const c = u.pop(), h = c.isGroup ? c.children : [c], d = u[0].count, m = []; for (const g of h) { const v = new bt, y = new N, A = new xs, _ = new N(1, 1, 1), x = new JS(g.geometry, g.material, d); for (let C = 0; C < d; C++)l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, C), l.ROTATION && A.fromBufferAttribute(l.ROTATION, C), l.SCALE && _.fromBufferAttribute(l.SCALE, C), x.setMatrixAt(C, v.compose(y, A, _)); for (const C in l) C !== "TRANSLATION" && C !== "ROTATION" && C !== "SCALE" && g.geometry.setAttribute(C, l[C]); Hn.prototype.copy.call(x, g), this.parser.assignFinalMaterial(x), m.push(x) } return c.isGroup ? (c.clear(), c.add(...m), c) : m[0] })) } } const jG = "glTF", hg = 12, XR = { JSON: 1313821514, BIN: 5130562 }; class Mle { constructor(e) { this.name = jn.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, hg); if (this.header = { magic: lc.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== jG) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const r = this.header.length - hg, i = new DataView(e, hg); let s = 0; for (; s < r;) { const a = i.getUint32(s, !0); s += 4; const o = i.getUint32(s, !0); if (s += 4, o === XR.JSON) { const l = new Uint8Array(e, hg + s, a); this.content = lc.decodeText(l) } else if (o === XR.BIN) { const l = hg + s; this.body = e.slice(l, l + a) } s += a } if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class ble { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = jn.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const r = this.json, i = this.dracoLoader, s = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, u = {}; for (const c in a) { const h = R7[c] || c.toLowerCase(); o[h] = a[c] } for (const c in e.attributes) { const h = R7[c] || c.toLowerCase(); if (a[c] !== void 0) { const d = r.accessors[e.attributes[c]], m = L3[d.componentType]; u[h] = m.name, l[h] = d.normalized === !0 } } return t.getDependency("bufferView", s).then(function (c) { return new Promise(function (h) { i.decodeDracoFile(c, function (d) { for (const m in d.attributes) { const g = d.attributes[m], v = l[m]; v !== void 0 && (g.normalized = v) } h(d) }, o, u) }) }) } } class Ble { constructor() { this.name = jn.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class Rle { constructor() { this.name = jn.KHR_MESH_QUANTIZATION } } class JG extends Em { constructor(e, t, r, i) { super(e, t, r, i) } copySampleValue_(e) { const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, s = e * i * 3 + i; for (let a = 0; a !== i; a++)t[a] = r[s + a]; return t } interpolate_(e, t, r, i) { const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, u = o * 3, c = i - t, h = (r - t) / c, d = h * h, m = d * h, g = e * u, v = g - u, y = -2 * m + 3 * d, A = m - d, _ = 1 - y, x = A - d + h; for (let C = 0; C !== o; C++) { const T = a[v + C + o], I = a[v + C + l] * c, w = a[g + C + o], R = a[g + C] * c; s[C] = _ * T + x * I + y * w + A * R } return s } } const Ple = new xs; class Dle extends JG { interpolate_(e, t, r, i) { const s = super.interpolate_(e, t, r, i); return Ple.fromArray(s).normalize().toArray(s), s } } const pl = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, L3 = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, YR = { 9728: cn, 9729: wr, 9984: ZA, 9985: s8, 9986: I3, 9987: Dl }, jR = { 33071: pi, 33648: q3, 10497: Pl }, b_ = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, R7 = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", ...Su.replace(/\D+/g, "") >= 152 ? { TEXCOORD_0: "uv", TEXCOORD_1: "uv1", TEXCOORD_2: "uv2", TEXCOORD_3: "uv3" } : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }, COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, jf = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, Lle = { CUBICSPLINE: void 0, LINEAR: Ip, STEP: Z3 }, B_ = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function Fle(n) { return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Q1({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: pc })), n.DefaultMaterial } function Sd(n, e, t) { for (const r in t.extensions) n[r] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = t.extensions[r]) } function $f(n, e) { e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function kle(n, e, t) { let r = !1, i = !1, s = !1; for (let u = 0, c = e.length; u < c; u++) { const h = e[u]; if (h.POSITION !== void 0 && (r = !0), h.NORMAL !== void 0 && (i = !0), h.COLOR_0 !== void 0 && (s = !0), r && i && s) break } if (!r && !i && !s) return Promise.resolve(n); const a = [], o = [], l = []; for (let u = 0, c = e.length; u < c; u++) { const h = e[u]; if (r) { const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position; a.push(d) } if (i) { const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal; o.push(d) } if (s) { const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color; l.push(d) } } return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(function (u) { const c = u[0], h = u[1], d = u[2]; return r && (n.morphAttributes.position = c), i && (n.morphAttributes.normal = h), s && (n.morphAttributes.color = d), n.morphTargetsRelative = !0, n }) } function Nle(n, e) { if (n.updateMorphTargets(), e.weights !== void 0) for (let t = 0, r = e.weights.length; t < r; t++)n.morphTargetInfluences[t] = e.weights[t]; if (e.extras && Array.isArray(e.extras.targetNames)) { const t = e.extras.targetNames; if (n.morphTargetInfluences.length === t.length) { n.morphTargetDictionary = {}; for (let r = 0, i = t.length; r < i; r++)n.morphTargetDictionary[t[r]] = r } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function Ole(n) { let e; const t = n.extensions && n.extensions[jn.KHR_DRACO_MESH_COMPRESSION]; if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + R_(t.attributes) : e = n.indices + ":" + R_(n.attributes) + ":" + n.mode, n.targets !== void 0) for (let r = 0, i = n.targets.length; r < i; r++)e += ":" + R_(n.targets[r]); return e } function R_(n) { let e = ""; const t = Object.keys(n).sort(); for (let r = 0, i = t.length; r < i; r++)e += t[r] + ":" + n[t[r]] + ";"; return e } function P7(n) { switch (n) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } function Ule(n) { return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png" } const Gle = new bt; class Qle { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new fle, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}; let r = !1, i = !1, s = -1; typeof navigator < "u" && typeof navigator.userAgent < "u" && (r = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || r || i && s < 98 ? this.textureLoader = new fU(this.options.manager) : this.textureLoader = new vU(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new _s(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const r = this, i = this.json, s = this.extensions; this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function (a) { return a._markDefs && a._markDefs() }), Promise.all(this._invokeAll(function (a) { return a.beforeRoot && a.beforeRoot() })).then(function () { return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")]) }).then(function (a) { const o = { scene: a[0][i.scene || 0], scenes: a[0], animations: a[1], cameras: a[2], asset: i.asset, parser: r, userData: {} }; Sd(s, o, i), $f(o, i), Promise.all(r._invokeAll(function (l) { return l.afterRoot && l.afterRoot(o) })).then(function () { e(o) }) }).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], r = this.json.meshes || []; for (let i = 0, s = t.length; i < s; i++) { const a = t[i].joints; for (let o = 0, l = a.length; o < l; o++)e[a[o]].isBone = !0 } for (let i = 0, s = e.length; i < s; i++) { const a = e[i]; a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (r[a.mesh].isSkinnedMesh = !0)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera) } } _addNodeRef(e, t) { t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, r) { if (e.refs[t] <= 1) return r; const i = r.clone(), s = (a, o) => { const l = this.associations.get(a); l != null && this.associations.set(o, l); for (const [u, c] of a.children.entries()) s(c, o.children[u]) }; return s(r, i), i.name += "_instance_" + e.uses[t]++, i } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let r = 0; r < t.length; r++) { const i = e(t[r]); if (i) return i } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const r = []; for (let i = 0; i < t.length; i++) { const s = e(t[i]); s && r.push(s) } return r } getDependency(e, t) { const r = e + ":" + t; let i = this.cache.get(r); if (!i) { switch (e) { case "scene": i = this.loadScene(t); break; case "node": i = this._invokeOne(function (s) { return s.loadNode && s.loadNode(t) }); break; case "mesh": i = this._invokeOne(function (s) { return s.loadMesh && s.loadMesh(t) }); break; case "accessor": i = this.loadAccessor(t); break; case "bufferView": i = this._invokeOne(function (s) { return s.loadBufferView && s.loadBufferView(t) }); break; case "buffer": i = this.loadBuffer(t); break; case "material": i = this._invokeOne(function (s) { return s.loadMaterial && s.loadMaterial(t) }); break; case "texture": i = this._invokeOne(function (s) { return s.loadTexture && s.loadTexture(t) }); break; case "skin": i = this.loadSkin(t); break; case "animation": i = this._invokeOne(function (s) { return s.loadAnimation && s.loadAnimation(t) }); break; case "camera": i = this.loadCamera(t); break; default: if (i = this._invokeOne(function (s) { return s != this && s.getDependency && s.getDependency(e, t) }), !i) throw new Error("Unknown type: " + e); break }this.cache.add(r, i) } return i } getDependencies(e) { let t = this.cache.get(e); if (!t) { const r = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || []; t = Promise.all(i.map(function (s, a) { return r.getDependency(e, a) })), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], r = this.fileLoader; if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[jn.KHR_BINARY_GLTF].body); const i = this.options; return new Promise(function (s, a) { r.load(lc.resolveURL(t.uri, i.path), s, void 0, function () { a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) }) }) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then(function (r) { const i = t.byteLength || 0, s = t.byteOffset || 0; return r.slice(s, s + i) }) } loadAccessor(e) { const t = this, r = this.json, i = this.json.accessors[e]; if (i.bufferView === void 0 && i.sparse === void 0) { const a = b_[i.type], o = L3[i.componentType], l = i.normalized === !0, u = new o(i.count * a); return Promise.resolve(new lr(u, a, l)) } const s = []; return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function (a) { const o = a[0], l = b_[i.type], u = L3[i.componentType], c = u.BYTES_PER_ELEMENT, h = c * l, d = i.byteOffset || 0, m = i.bufferView !== void 0 ? r.bufferViews[i.bufferView].byteStride : void 0, g = i.normalized === !0; let v, y; if (m && m !== h) { const A = Math.floor(d / m), _ = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + A + ":" + i.count; let x = t.cache.get(_); x || (v = new u(o, A * m, i.count * m / c), x = new F1(v, m / c), t.cache.add(_, x)), y = new kh(x, l, d % m / c, g) } else o === null ? v = new u(i.count * l) : v = new u(o, d, i.count * l), y = new lr(v, l, g); if (i.sparse !== void 0) { const A = b_.SCALAR, _ = L3[i.sparse.indices.componentType], x = i.sparse.indices.byteOffset || 0, C = i.sparse.values.byteOffset || 0, T = new _(a[1], x, i.sparse.count * A), I = new u(a[2], C, i.sparse.count * l); o !== null && (y = new lr(y.array.slice(), y.itemSize, y.normalized)); for (let w = 0, R = T.length; w < R; w++) { const b = T[w]; if (y.setX(b, I[w * l]), l >= 2 && y.setY(b, I[w * l + 1]), l >= 3 && y.setZ(b, I[w * l + 2]), l >= 4 && y.setW(b, I[w * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return y }) } loadTexture(e) { const t = this.json, r = this.options, s = t.textures[e].source, a = t.images[s]; let o = this.textureLoader; if (a.uri) { const l = r.manager.getHandler(a.uri); l !== null && (o = l) } return this.loadTextureImage(e, s, o) } loadTextureImage(e, t, r) { const i = this, s = this.json, a = s.textures[e], o = s.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler; if (this.textureCache[l]) return this.textureCache[l]; const u = this.loadImageSource(t, r).then(function (c) { c.flipY = !1, c.name = a.name || o.name || "", c.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === !1 && (c.name = o.uri); const d = (s.samplers || {})[a.sampler] || {}; return c.magFilter = YR[d.magFilter] || wr, c.minFilter = YR[d.minFilter] || Dl, c.wrapS = jR[d.wrapS] || Pl, c.wrapT = jR[d.wrapT] || Pl, i.associations.set(c, { textures: e }), c }).catch(function () { return null }); return this.textureCache[l] = u, u } loadImageSource(e, t) { const r = this, i = this.json, s = this.options; if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(h => h.clone()); const a = i.images[e], o = self.URL || self.webkitURL; let l = a.uri || "", u = !1; if (a.bufferView !== void 0) l = r.getDependency("bufferView", a.bufferView).then(function (h) { u = !0; const d = new Blob([h], { type: a.mimeType }); return l = o.createObjectURL(d), l }); else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const c = Promise.resolve(l).then(function (h) { return new Promise(function (d, m) { let g = d; t.isImageBitmapLoader === !0 && (g = function (v) { const y = new ri(v); y.needsUpdate = !0, d(y) }), t.load(lc.resolveURL(h, s.path), g, void 0, m) }) }).then(function (h) { return u === !0 && o.revokeObjectURL(l), h.userData.mimeType = a.mimeType || Ule(a.uri), h }).catch(function (h) { throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h }); return this.sourceCache[e] = c, c } assignTexture(e, t, r, i) { const s = this; return this.getDependency("texture", r.index).then(function (a) { if (!a) return null; if (r.texCoord !== void 0 && r.texCoord > 0 && (a = a.clone(), a.channel = r.texCoord), s.extensions[jn.KHR_TEXTURE_TRANSFORM]) { const o = r.extensions !== void 0 ? r.extensions[jn.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { const l = s.associations.get(a); a = s.extensions[jn.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l) } } return i !== void 0 && ("colorSpace" in a ? a.colorSpace = i === 3001 ? "srgb" : "srgb-linear" : a.encoding = i), e[t] = a, a }) } assignFinalMaterial(e) { const t = e.geometry; let r = e.material; const i = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, a = t.attributes.normal === void 0; if (e.isPoints) { const o = "PointsMaterial:" + r.uuid; let l = this.cache.get(o); l || (l = new N1, as.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, l.sizeAttenuation = !1, this.cache.add(o, l)), r = l } else if (e.isLine) { const o = "LineBasicMaterial:" + r.uuid; let l = this.cache.get(o); l || (l = new Aa, as.prototype.copy.call(l, r), l.color.copy(r.color), l.map = r.map, this.cache.add(o, l)), r = l } if (i || s || a) { let o = "ClonedMaterial:" + r.uuid + ":"; i && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:"); let l = this.cache.get(o); l || (l = r.clone(), s && (l.vertexColors = !0), a && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(r))), r = l } e.material = r } getMaterialType() { return Q1 } loadMaterial(e) { const t = this, r = this.json, i = this.extensions, s = r.materials[e]; let a; const o = {}, l = s.extensions || {}, u = []; if (l[jn.KHR_MATERIALS_UNLIT]) { const h = i[jn.KHR_MATERIALS_UNLIT]; a = h.getMaterialType(), u.push(h.extendParams(o, s, t)) } else { const h = s.pbrMetallicRoughness || {}; if (o.color = new Je(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) { const d = h.baseColorFactor; o.color.fromArray(d), o.opacity = d[3] } h.baseColorTexture !== void 0 && u.push(t.assignTexture(o, "map", h.baseColorTexture, 3001)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (u.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), u.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function (d) { return d.getMaterialType && d.getMaterialType(e) }), u.push(Promise.all(this._invokeAll(function (d) { return d.extendMaterialParams && d.extendMaterialParams(e, o) }))) } s.doubleSided === !0 && (o.side = cu); const c = s.alphaMode || B_.OPAQUE; if (c === B_.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, c === B_.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && a !== qs && (u.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new Se(1, 1), s.normalTexture.scale !== void 0)) { const h = s.normalTexture.scale; o.normalScale.set(h, h) } return s.occlusionTexture !== void 0 && a !== qs && (u.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== qs && (o.emissive = new Je().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && a !== qs && u.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, 3001)), Promise.all(u).then(function () { const h = new a(o); return s.name && (h.name = s.name), $f(h, s), t.associations.set(h, { materials: e }), s.extensions && Sd(i, h, s), h }) } createUniqueName(e) { const t = Zn.sanitizeNodeName(e || ""); return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t) } loadGeometries(e) { const t = this, r = this.extensions, i = this.primitiveCache; function s(o) { return r[jn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function (l) { return JR(l, o, t) }) } const a = []; for (let o = 0, l = e.length; o < l; o++) { const u = e[o], c = Ole(u), h = i[c]; if (h) a.push(h.promise); else { let d; u.extensions && u.extensions[jn.KHR_DRACO_MESH_COMPRESSION] ? d = s(u) : d = JR(new pn, u, t), i[c] = { primitive: u, promise: d }, a.push(d) } } return Promise.all(a) } loadMesh(e) { const t = this, r = this.json, i = this.extensions, s = r.meshes[e], a = s.primitives, o = []; for (let l = 0, u = a.length; l < u; l++) { const c = a[l].material === void 0 ? Fle(this.cache) : this.getDependency("material", a[l].material); o.push(c) } return o.push(t.loadGeometries(a)), Promise.all(o).then(function (l) { const u = l.slice(0, l.length - 1), c = l[l.length - 1], h = []; for (let m = 0, g = c.length; m < g; m++) { const v = c[m], y = a[m]; let A; const _ = u[m]; if (y.mode === pl.TRIANGLES || y.mode === pl.TRIANGLE_STRIP || y.mode === pl.TRIANGLE_FAN || y.mode === void 0) A = s.isSkinnedMesh === !0 ? new jS(v, _) : new gr(v, _), A.isSkinnedMesh === !0 && A.normalizeSkinWeights(), y.mode === pl.TRIANGLE_STRIP ? A.geometry = zR(A.geometry, FS) : y.mode === pl.TRIANGLE_FAN && (A.geometry = zR(A.geometry, ay)); else if (y.mode === pl.LINES) A = new wu(v, _); else if (y.mode === pl.LINE_STRIP) A = new Af(v, _); else if (y.mode === pl.LINE_LOOP) A = new KS(v, _); else if (y.mode === pl.POINTS) A = new g8(v, _); else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode); Object.keys(A.geometry.morphAttributes).length > 0 && Nle(A, s), A.name = t.createUniqueName(s.name || "mesh_" + e), $f(A, s), y.extensions && Sd(i, A, y), t.assignFinalMaterial(A), h.push(A) } for (let m = 0, g = h.length; m < g; m++)t.associations.set(h[m], { meshes: e, primitives: m }); if (h.length === 1) return s.extensions && Sd(i, h[0], s), h[0]; const d = new ef; s.extensions && Sd(i, d, s), t.associations.set(d, { meshes: e }); for (let m = 0, g = h.length; m < g; m++)d.add(h[m]); return d }) } loadCamera(e) { let t; const r = this.json.cameras[e], i = r[r.type]; if (!i) { console.warn("THREE.GLTFLoader: Missing camera parameters."); return } return r.type === "perspective" ? t = new Gr(hp.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : r.type === "orthographic" && (t = new hu(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), r.name && (t.name = this.createUniqueName(r.name)), $f(t, r), Promise.resolve(t) } loadSkin(e) { const t = this.json.skins[e], r = []; for (let i = 0, s = t.joints.length; i < s; i++)r.push(this._loadNodeShallow(t.joints[i])); return t.inverseBindMatrices !== void 0 ? r.push(this.getDependency("accessor", t.inverseBindMatrices)) : r.push(null), Promise.all(r).then(function (i) { const s = i.pop(), a = i, o = [], l = []; for (let u = 0, c = a.length; u < c; u++) { const h = a[u]; if (h) { o.push(h); const d = new bt; s !== null && d.fromArray(s.array, u * 16), l.push(d) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[u]) } return new k1(o, l) }) } loadAnimation(e) { const r = this.json.animations[e], i = r.name ? r.name : "animation_" + e, s = [], a = [], o = [], l = [], u = []; for (let c = 0, h = r.channels.length; c < h; c++) { const d = r.channels[c], m = r.samplers[d.sampler], g = d.target, v = g.node, y = r.parameters !== void 0 ? r.parameters[m.input] : m.input, A = r.parameters !== void 0 ? r.parameters[m.output] : m.output; g.node !== void 0 && (s.push(this.getDependency("node", v)), a.push(this.getDependency("accessor", y)), o.push(this.getDependency("accessor", A)), l.push(m), u.push(g)) } return Promise.all([Promise.all(s), Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(u)]).then(function (c) { const h = c[0], d = c[1], m = c[2], g = c[3], v = c[4], y = []; for (let A = 0, _ = h.length; A < _; A++) { const x = h[A], C = d[A], T = m[A], I = g[A], w = v[A]; if (x === void 0) continue; x.updateMatrix(); let R; switch (jf[w.path]) { case jf.weights: R = nm; break; case jf.rotation: R = Oh; break; case jf.position: case jf.scale: default: R = rm; break }const b = x.name ? x.name : x.uuid, B = I.interpolation !== void 0 ? Lle[I.interpolation] : Ip, F = []; jf[w.path] === jf.weights ? x.traverse(function (G) { G.morphTargetInfluences && F.push(G.name ? G.name : G.uuid) }) : F.push(b); let U = T.array; if (T.normalized) { const G = P7(U.constructor), Y = new Float32Array(U.length); for (let Z = 0, ne = U.length; Z < ne; Z++)Y[Z] = U[Z] * G; U = Y } for (let G = 0, Y = F.length; G < Y; G++) { const Z = new R(F[G] + "." + jf[w.path], C.array, U, B); I.interpolation === "CUBICSPLINE" && (Z.createInterpolant = function ($) { const L = this instanceof Oh ? Dle : JG; return new L(this.times, this.values, this.getValueSize() / 3, $) }, Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), y.push(Z) } } return new im(i, void 0, y) }) } createNodeMesh(e) { const t = this.json, r = this, i = t.nodes[e]; return i.mesh === void 0 ? null : r.getDependency("mesh", i.mesh).then(function (s) { const a = r._getNodeRef(r.meshCache, i.mesh, s); return i.weights !== void 0 && a.traverse(function (o) { if (o.isMesh) for (let l = 0, u = i.weights.length; l < u; l++)o.morphTargetInfluences[l] = i.weights[l] }), a }) } loadNode(e) { const t = this.json, r = this, i = t.nodes[e], s = r._loadNodeShallow(e), a = [], o = i.children || []; for (let u = 0, c = o.length; u < c; u++)a.push(r.getDependency("node", o[u])); const l = i.skin === void 0 ? Promise.resolve(null) : r.getDependency("skin", i.skin); return Promise.all([s, Promise.all(a), l]).then(function (u) { const c = u[0], h = u[1], d = u[2]; d !== null && c.traverse(function (m) { m.isSkinnedMesh && m.bind(d, Gle) }); for (let m = 0, g = h.length; m < g; m++)c.add(h[m]); return c }) } _loadNodeShallow(e) { const t = this.json, r = this.extensions, i = this; if (this.nodeCache[e] !== void 0) return this.nodeCache[e]; const s = t.nodes[e], a = s.name ? i.createUniqueName(s.name) : "", o = [], l = i._invokeOne(function (u) { return u.createNodeMesh && u.createNodeMesh(e) }); return l && o.push(l), s.camera !== void 0 && o.push(i.getDependency("camera", s.camera).then(function (u) { return i._getNodeRef(i.cameraCache, s.camera, u) })), i._invokeAll(function (u) { return u.createNodeAttachment && u.createNodeAttachment(e) }).forEach(function (u) { o.push(u) }), this.nodeCache[e] = Promise.all(o).then(function (u) { let c; if (s.isBone === !0 ? c = new m8 : u.length > 1 ? c = new ef : u.length === 1 ? c = u[0] : c = new Hn, c !== u[0]) for (let h = 0, d = u.length; h < d; h++)c.add(u[h]); if (s.name && (c.userData.name = s.name, c.name = a), $f(c, s), s.extensions && Sd(r, c, s), s.matrix !== void 0) { const h = new bt; h.fromArray(s.matrix), c.applyMatrix4(h) } else s.translation !== void 0 && c.position.fromArray(s.translation), s.rotation !== void 0 && c.quaternion.fromArray(s.rotation), s.scale !== void 0 && c.scale.fromArray(s.scale); return i.associations.has(c) || i.associations.set(c, {}), i.associations.get(c).nodes = e, c }), this.nodeCache[e] } loadScene(e) { const t = this.extensions, r = this.json.scenes[e], i = this, s = new ef; r.name && (s.name = i.createUniqueName(r.name)), $f(s, r), r.extensions && Sd(t, s, r); const a = r.nodes || [], o = []; for (let l = 0, u = a.length; l < u; l++)o.push(i.getDependency("node", a[l])); return Promise.all(o).then(function (l) { for (let c = 0, h = l.length; c < h; c++)s.add(l[c]); const u = c => { const h = new Map; for (const [d, m] of i.associations) (d instanceof as || d instanceof ri) && h.set(d, m); return c.traverse(d => { const m = i.associations.get(d); m != null && h.set(d, m) }), h }; return i.associations = u(s), s }) } } function Hle(n, e, t) { const r = e.attributes, i = new Tu; if (r.POSITION !== void 0) { const o = t.json.accessors[r.POSITION], l = o.min, u = o.max; if (l !== void 0 && u !== void 0) { if (i.set(new N(l[0], l[1], l[2]), new N(u[0], u[1], u[2])), o.normalized) { const c = P7(L3[o.componentType]); i.min.multiplyScalar(c), i.max.multiplyScalar(c) } } else { console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); return } } else return; const s = e.targets; if (s !== void 0) { const o = new N, l = new N; for (let u = 0, c = s.length; u < c; u++) { const h = s[u]; if (h.POSITION !== void 0) { const d = t.json.accessors[h.POSITION], m = d.min, g = d.max; if (m !== void 0 && g !== void 0) { if (l.setX(Math.max(Math.abs(m[0]), Math.abs(g[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(g[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(g[2]))), d.normalized) { const v = P7(L3[d.componentType]); l.multiplyScalar(v) } o.max(l) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(o) } n.boundingBox = i; const a = new kl; i.getCenter(a.center), a.radius = i.min.distanceTo(i.max) / 2, n.boundingSphere = a } function JR(n, e, t) { const r = e.attributes, i = []; function s(a, o) { return t.getDependency("accessor", a).then(function (l) { n.setAttribute(o, l) }) } for (const a in r) { const o = R7[a] || a.toLowerCase(); o in n.attributes || i.push(s(r[a], o)) } if (e.indices !== void 0 && !n.index) { const a = t.getDependency("accessor", e.indices).then(function (o) { n.setIndex(o) }); i.push(a) } return $f(n, e), Hle(n, e, t), Promise.all(i).then(function () { return e.targets !== void 0 ? kle(n, e.targets, t) : n }) } const D7 = class { static createButton(n, e = {}) { const t = document.createElement("button"); function r() { let o = null; async function l(c) { c.addEventListener("end", u), await n.xr.setSession(c), t.textContent = "EXIT VR", o = c } function u() { o.removeEventListener("end", u), t.textContent = "ENTER VR", o = null } t.style.display = "", t.style.cursor = "pointer", t.style.left = "calc(50% - 50px)", t.style.width = "100px", t.textContent = "ENTER VR", t.onmouseenter = () => { t.style.opacity = "1.0" }, t.onmouseleave = () => { t.style.opacity = "0.5" }, t.onclick = () => { var c; if (o === null) { const h = [e.optionalFeatures, "local-floor", "bounded-floor", "hand-tracking"].flat().filter(Boolean); (c = navigator.xr) == null || c.requestSession("immersive-vr", { ...e, optionalFeatures: h }).then(l) } else o.end() } } function i() { t.style.display = "", t.style.cursor = "auto", t.style.left = "calc(50% - 75px)", t.style.width = "150px", t.onmouseenter = null, t.onmouseleave = null, t.onclick = null } function s() { i(), t.textContent = "VR NOT SUPPORTED" } function a(o) { o.style.position = "absolute", o.style.bottom = "20px", o.style.padding = "12px 6px", o.style.border = "1px solid #fff", o.style.borderRadius = "4px", o.style.background = "rgba(0,0,0,0.1)", o.style.color = "#fff", o.style.font = "normal 13px sans-serif", o.style.textAlign = "center", o.style.opacity = "0.5", o.style.outline = "none", o.style.zIndex = "999" } if ("xr" in navigator) return a(t), t.id = "VRButton", t.style.display = "none", navigator.xr.isSessionSupported("immersive-vr").then(o => { o ? r() : s(), o && D7.xrSessionIsGranted && t.click() }), t; { const o = document.createElement("a"); return window.isSecureContext === !1 ? (o.href = document.location.href.replace(/^http:/, "https:"), o.innerHTML = "WEBXR NEEDS HTTPS") : (o.href = "https://immersiveweb.dev/", o.innerHTML = "WEBXR NOT AVAILABLE"), o.style.left = "calc(50% - 90px)", o.style.width = "180px", o.style.textDecoration = "none", a(o), o } } static registerSessionGrantedListener() { "xr" in navigator && navigator.xr.addEventListener("sessiongranted", () => { D7.xrSessionIsGranted = !0 }) } }; let zle = D7; Xe(zle, "xrSessionIsGranted", !1); class KG { constructor(e) { Xe(this, "data"), this.data = e } generateShapes(e, t = 100, r) { const i = [], s = { letterSpacing: 0, lineHeight: 1, ...r }, a = Vle(e, t, this.data, s); for (let o = 0, l = a.length; o < l; o++)Array.prototype.push.apply(i, a[o].toShapes(!1)); return i } } Xe(KG, "isFont"); Xe(KG, "type"); function Vle(n, e, t, r) {
		const i = Array.from(n), s = e / t.resolution, a = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * s, o = []; let l = 0, u = 0; for (let c = 0; c < i.length; c++) {
			const h = i[c]; if (h === `
`) l = 0, u -= a * r.lineHeight; else { const d = Wle(h, s, l, u, t); d && (l += d.offsetX + r.letterSpacing, o.push(d.path)) }
		} return o
	} function Wle(n, e, t, r, i) { const s = i.glyphs[n] || i.glyphs["?"]; if (!s) { console.error('THREE.Font: character "' + n + '" does not exists in font family ' + i.familyName + "."); return } const a = new wU; let o, l, u, c, h, d, m, g; if (s.o) { const v = s._cachedOutline || (s._cachedOutline = s.o.split(" ")); for (let y = 0, A = v.length; y < A;)switch (v[y++]) { case "m": o = parseInt(v[y++]) * e + t, l = parseInt(v[y++]) * e + r, a.moveTo(o, l); break; case "l": o = parseInt(v[y++]) * e + t, l = parseInt(v[y++]) * e + r, a.lineTo(o, l); break; case "q": u = parseInt(v[y++]) * e + t, c = parseInt(v[y++]) * e + r, h = parseInt(v[y++]) * e + t, d = parseInt(v[y++]) * e + r, a.quadraticCurveTo(h, d, u, c); break; case "b": u = parseInt(v[y++]) * e + t, c = parseInt(v[y++]) * e + r, h = parseInt(v[y++]) * e + t, d = parseInt(v[y++]) * e + r, m = parseInt(v[y++]) * e + t, g = parseInt(v[y++]) * e + r, a.bezierCurveTo(h, d, m, g, u, c); break } } return { offsetX: s.ha * e, path: a } } class Xle extends ri { constructor(e = null, t = 1, r = 1, i = 1) { super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = cn, this.minFilter = cn, this.wrapR = pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } var Yle = typeof global == "object" && global && global.Object === Object && global; const qG = Yle; var jle = typeof self == "object" && self && self.Object === Object && self, Jle = qG || jle || Function("return this")(); const vc = Jle; var Kle = vc.Symbol; const Ll = Kle; var ZG = Object.prototype, qle = ZG.hasOwnProperty, Zle = ZG.toString, dg = Ll ? Ll.toStringTag : void 0; function $le(n) { var e = qle.call(n, dg), t = n[dg]; try { n[dg] = void 0; var r = !0 } catch { } var i = Zle.call(n); return r && (e ? n[dg] = t : delete n[dg]), i } var eue = Object.prototype, tue = eue.toString; function nue(n) { return tue.call(n) } var rue = "[object Null]", iue = "[object Undefined]", KR = Ll ? Ll.toStringTag : void 0; function $h(n) { return n == null ? n === void 0 ? iue : rue : KR && KR in Object(n) ? $le(n) : nue(n) } function Eu(n) { return n != null && typeof n == "object" } var sue = "[object Symbol]"; function U8(n) { return typeof n == "symbol" || Eu(n) && $h(n) == sue } function K1(n, e) { for (var t = -1, r = n == null ? 0 : n.length, i = Array(r); ++t < r;)i[t] = e(n[t], t, n); return i } var aue = Array.isArray; const nr = aue; var oue = 1 / 0, qR = Ll ? Ll.prototype : void 0, ZR = qR ? qR.toString : void 0; function $G(n) { if (typeof n == "string") return n; if (nr(n)) return K1(n, $G) + ""; if (U8(n)) return ZR ? ZR.call(n) : ""; var e = n + ""; return e == "0" && 1 / n == -oue ? "-0" : e } var lue = /\s/; function uue(n) { for (var e = n.length; e-- && lue.test(n.charAt(e));); return e } var cue = /^\s+/; function fue(n) { return n && n.slice(0, uue(n) + 1).replace(cue, "") } function Fl(n) { var e = typeof n; return n != null && (e == "object" || e == "function") } var $R = 0 / 0, hue = /^[-+]0x[0-9a-f]+$/i, due = /^0b[01]+$/i, pue = /^0o[0-7]+$/i, mue = parseInt; function gue(n) { if (typeof n == "number") return n; if (U8(n)) return $R; if (Fl(n)) { var e = typeof n.valueOf == "function" ? n.valueOf() : n; n = Fl(e) ? e + "" : e } if (typeof n != "string") return n === 0 ? n : +n; n = fue(n); var t = due.test(n); return t || pue.test(n) ? mue(n.slice(2), t ? 2 : 8) : hue.test(n) ? $R : +n } var eP = 1 / 0, Aue = 17976931348623157e292; function vue(n) { if (!n) return n === 0 ? n : 0; if (n = gue(n), n === eP || n === -eP) { var e = n < 0 ? -1 : 1; return e * Aue } return n === n ? n : 0 } function q1(n) { var e = vue(n), t = e % 1; return e === e ? t ? e - t : e : 0 } function om(n) { return n } var yue = "[object AsyncFunction]", xue = "[object Function]", _ue = "[object GeneratorFunction]", Eue = "[object Proxy]"; function Cf(n) { if (!Fl(n)) return !1; var e = $h(n); return e == xue || e == _ue || e == yue || e == Eue } var Cue = vc["__core-js_shared__"]; const P_ = Cue; var tP = function () { var n = /[^.]+$/.exec(P_ && P_.keys && P_.keys.IE_PROTO || ""); return n ? "Symbol(src)_1." + n : "" }(); function Sue(n) { return !!tP && tP in n } var Tue = Function.prototype, wue = Tue.toString; function Hp(n) { if (n != null) { try { return wue.call(n) } catch { } try { return n + "" } catch { } } return "" } var Iue = /[\\^$.*+?()[\]{}|]/g, Mue = /^\[object .+?Constructor\]$/, bue = Function.prototype, Bue = Object.prototype, Rue = bue.toString, Pue = Bue.hasOwnProperty, Due = RegExp("^" + Rue.call(Pue).replace(Iue, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function Lue(n) { if (!Fl(n) || Sue(n)) return !1; var e = Cf(n) ? Due : Mue; return e.test(Hp(n)) } function Fue(n, e) { return n == null ? void 0 : n[e] } function zp(n, e) { var t = Fue(n, e); return Lue(t) ? t : void 0 } var kue = zp(vc, "WeakMap"); const L7 = kue; var nP = Object.create, Nue = function () { function n() { } return function (e) { if (!Fl(e)) return {}; if (nP) return nP(e); n.prototype = e; var t = new n; return n.prototype = void 0, t } }(); const Oue = Nue; function Uue(n, e, t) { switch (t.length) { case 0: return n.call(e); case 1: return n.call(e, t[0]); case 2: return n.call(e, t[0], t[1]); case 3: return n.call(e, t[0], t[1], t[2]) }return n.apply(e, t) } function ds() { } function Gue(n, e) { var t = -1, r = n.length; for (e || (e = Array(r)); ++t < r;)e[t] = n[t]; return e } var Que = 800, Hue = 16, zue = Date.now; function Vue(n) { var e = 0, t = 0; return function () { var r = zue(), i = Hue - (r - t); if (t = r, i > 0) { if (++e >= Que) return arguments[0] } else e = 0; return n.apply(void 0, arguments) } } function Wue(n) { return function () { return n } } var Xue = function () { try { var n = zp(Object, "defineProperty"); return n({}, "", {}), n } catch { } }(); const vy = Xue; var Yue = vy ? function (n, e) { return vy(n, "toString", { configurable: !0, enumerable: !1, value: Wue(e), writable: !0 }) } : om; const jue = Yue; var Jue = Vue(jue); const Kue = Jue; function eQ(n, e) { for (var t = -1, r = n == null ? 0 : n.length; ++t < r && e(n[t], t, n) !== !1;); return n } function tQ(n, e, t, r) { for (var i = n.length, s = t + (r ? 1 : -1); r ? s-- : ++s < i;)if (e(n[s], s, n)) return s; return -1 } function que(n) { return n !== n } function Zue(n, e, t) { for (var r = t - 1, i = n.length; ++r < i;)if (n[r] === e) return r; return -1 } function BT(n, e, t) { return e === e ? Zue(n, e, t) : tQ(n, que, t) } function nQ(n, e) { var t = n == null ? 0 : n.length; return !!t && BT(n, e, 0) > -1 } var $ue = 9007199254740991, ece = /^(?:0|[1-9]\d*)$/; function G8(n, e) { var t = typeof n; return e = e ?? $ue, !!e && (t == "number" || t != "symbol" && ece.test(n)) && n > -1 && n % 1 == 0 && n < e } function RT(n, e, t) { e == "__proto__" && vy ? vy(n, e, { configurable: !0, enumerable: !0, value: t, writable: !0 }) : n[e] = t } function Z1(n, e) { return n === e || n !== n && e !== e } var tce = Object.prototype, nce = tce.hasOwnProperty; function Q8(n, e, t) { var r = n[e]; (!(nce.call(n, e) && Z1(r, t)) || t === void 0 && !(e in n)) && RT(n, e, t) } function $1(n, e, t, r) { var i = !t; t || (t = {}); for (var s = -1, a = e.length; ++s < a;) { var o = e[s], l = r ? r(t[o], n[o], o, t, n) : void 0; l === void 0 && (l = n[o]), i ? RT(t, o, l) : Q8(t, o, l) } return t } var rP = Math.max; function rce(n, e, t) { return e = rP(e === void 0 ? n.length - 1 : e, 0), function () { for (var r = arguments, i = -1, s = rP(r.length - e, 0), a = Array(s); ++i < s;)a[i] = r[e + i]; i = -1; for (var o = Array(e + 1); ++i < e;)o[i] = r[i]; return o[e] = t(a), Uue(n, this, o) } } function PT(n, e) { return Kue(rce(n, e, om), n + "") } var ice = 9007199254740991; function DT(n) { return typeof n == "number" && n > -1 && n % 1 == 0 && n <= ice } function yc(n) { return n != null && DT(n.length) && !Cf(n) } function H8(n, e, t) { if (!Fl(t)) return !1; var r = typeof e; return (r == "number" ? yc(t) && G8(e, t.length) : r == "string" && e in t) ? Z1(t[e], n) : !1 } function sce(n) { return PT(function (e, t) { var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, a = i > 2 ? t[2] : void 0; for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && H8(t[0], t[1], a) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i;) { var o = t[r]; o && n(e, o, r, s) } return e }) } var ace = Object.prototype; function e2(n) { var e = n && n.constructor, t = typeof e == "function" && e.prototype || ace; return n === t } function oce(n, e) { for (var t = -1, r = Array(n); ++t < n;)r[t] = e(t); return r } var lce = "[object Arguments]"; function iP(n) { return Eu(n) && $h(n) == lce } var rQ = Object.prototype, uce = rQ.hasOwnProperty, cce = rQ.propertyIsEnumerable, fce = iP(function () { return arguments }()) ? iP : function (n) { return Eu(n) && uce.call(n, "callee") && !cce.call(n, "callee") }; const z8 = fce; function hce() { return !1 } var iQ = typeof ke == "object" && ke && !ke.nodeType && ke, sP = iQ && typeof Oo == "object" && Oo && !Oo.nodeType && Oo, dce = sP && sP.exports === iQ, aP = dce ? vc.Buffer : void 0, pce = aP ? aP.isBuffer : void 0, mce = pce || hce; const g1 = mce; var gce = "[object Arguments]", Ace = "[object Array]", vce = "[object Boolean]", yce = "[object Date]", xce = "[object Error]", _ce = "[object Function]", Ece = "[object Map]", Cce = "[object Number]", Sce = "[object Object]", Tce = "[object RegExp]", wce = "[object Set]", Ice = "[object String]", Mce = "[object WeakMap]", bce = "[object ArrayBuffer]", Bce = "[object DataView]", Rce = "[object Float32Array]", Pce = "[object Float64Array]", Dce = "[object Int8Array]", Lce = "[object Int16Array]", Fce = "[object Int32Array]", kce = "[object Uint8Array]", Nce = "[object Uint8ClampedArray]", Oce = "[object Uint16Array]", Uce = "[object Uint32Array]", qr = {}; qr[Rce] = qr[Pce] = qr[Dce] = qr[Lce] = qr[Fce] = qr[kce] = qr[Nce] = qr[Oce] = qr[Uce] = !0; qr[gce] = qr[Ace] = qr[bce] = qr[vce] = qr[Bce] = qr[yce] = qr[xce] = qr[_ce] = qr[Ece] = qr[Cce] = qr[Sce] = qr[Tce] = qr[wce] = qr[Ice] = qr[Mce] = !1; function Gce(n) { return Eu(n) && DT(n.length) && !!qr[$h(n)] } function t2(n) { return function (e) { return n(e) } } var sQ = typeof ke == "object" && ke && !ke.nodeType && ke, dA = sQ && typeof Oo == "object" && Oo && !Oo.nodeType && Oo, Qce = dA && dA.exports === sQ, D_ = Qce && qG.process, Hce = function () { try { var n = dA && dA.require && dA.require("util").types; return n || D_ && D_.binding && D_.binding("util") } catch { } }(); const Gh = Hce; var oP = Gh && Gh.isTypedArray, zce = oP ? t2(oP) : Gce; const LT = zce; var Vce = Object.prototype, Wce = Vce.hasOwnProperty; function aQ(n, e) { var t = nr(n), r = !t && z8(n), i = !t && !r && g1(n), s = !t && !r && !i && LT(n), a = t || r || i || s, o = a ? oce(n.length, String) : [], l = o.length; for (var u in n) (e || Wce.call(n, u)) && !(a && (u == "length" || i && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || G8(u, l))) && o.push(u); return o } function oQ(n, e) { return function (t) { return n(e(t)) } } var Xce = oQ(Object.keys, Object); const Yce = Xce; var jce = Object.prototype, Jce = jce.hasOwnProperty; function lQ(n) { if (!e2(n)) return Yce(n); var e = []; for (var t in Object(n)) Jce.call(n, t) && t != "constructor" && e.push(t); return e } function Vo(n) { return yc(n) ? aQ(n) : lQ(n) } var Kce = Object.prototype, qce = Kce.hasOwnProperty, Zce = sce(function (n, e) { if (e2(e) || yc(e)) { $1(e, Vo(e), n); return } for (var t in e) qce.call(e, t) && Q8(n, t, e[t]) }); const Wo = Zce; function $ce(n) { var e = []; if (n != null) for (var t in Object(n)) e.push(t); return e } var efe = Object.prototype, tfe = efe.hasOwnProperty; function nfe(n) { if (!Fl(n)) return $ce(n); var e = e2(n), t = []; for (var r in n) r == "constructor" && (e || !tfe.call(n, r)) || t.push(r); return t } function V8(n) { return yc(n) ? aQ(n, !0) : nfe(n) } var rfe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ife = /^\w*$/; function FT(n, e) { if (nr(n)) return !1; var t = typeof n; return t == "number" || t == "symbol" || t == "boolean" || n == null || U8(n) ? !0 : ife.test(n) || !rfe.test(n) || e != null && n in Object(e) } var sfe = zp(Object, "create"); const A1 = sfe; function afe() { this.__data__ = A1 ? A1(null) : {}, this.size = 0 } function ofe(n) { var e = this.has(n) && delete this.__data__[n]; return this.size -= e ? 1 : 0, e } var lfe = "__lodash_hash_undefined__", ufe = Object.prototype, cfe = ufe.hasOwnProperty; function ffe(n) { var e = this.__data__; if (A1) { var t = e[n]; return t === lfe ? void 0 : t } return cfe.call(e, n) ? e[n] : void 0 } var hfe = Object.prototype, dfe = hfe.hasOwnProperty; function pfe(n) { var e = this.__data__; return A1 ? e[n] !== void 0 : dfe.call(e, n) } var mfe = "__lodash_hash_undefined__"; function gfe(n, e) { var t = this.__data__; return this.size += this.has(n) ? 0 : 1, t[n] = A1 && e === void 0 ? mfe : e, this } function Rp(n) { var e = -1, t = n == null ? 0 : n.length; for (this.clear(); ++e < t;) { var r = n[e]; this.set(r[0], r[1]) } } Rp.prototype.clear = afe; Rp.prototype.delete = ofe; Rp.prototype.get = ffe; Rp.prototype.has = pfe; Rp.prototype.set = gfe; function Afe() { this.__data__ = [], this.size = 0 } function W8(n, e) { for (var t = n.length; t--;)if (Z1(n[t][0], e)) return t; return -1 } var vfe = Array.prototype, yfe = vfe.splice; function xfe(n) { var e = this.__data__, t = W8(e, n); if (t < 0) return !1; var r = e.length - 1; return t == r ? e.pop() : yfe.call(e, t, 1), --this.size, !0 } function _fe(n) { var e = this.__data__, t = W8(e, n); return t < 0 ? void 0 : e[t][1] } function Efe(n) { return W8(this.__data__, n) > -1 } function Cfe(n, e) { var t = this.__data__, r = W8(t, n); return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this } function Sf(n) { var e = -1, t = n == null ? 0 : n.length; for (this.clear(); ++e < t;) { var r = n[e]; this.set(r[0], r[1]) } } Sf.prototype.clear = Afe; Sf.prototype.delete = xfe; Sf.prototype.get = _fe; Sf.prototype.has = Efe; Sf.prototype.set = Cfe; var Sfe = zp(vc, "Map"); const v1 = Sfe; function Tfe() { this.size = 0, this.__data__ = { hash: new Rp, map: new (v1 || Sf), string: new Rp } } function wfe(n) { var e = typeof n; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null } function X8(n, e) { var t = n.__data__; return wfe(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map } function Ife(n) { var e = X8(this, n).delete(n); return this.size -= e ? 1 : 0, e } function Mfe(n) { return X8(this, n).get(n) } function bfe(n) { return X8(this, n).has(n) } function Bfe(n, e) { var t = X8(this, n), r = t.size; return t.set(n, e), this.size += t.size == r ? 0 : 1, this } function Tf(n) { var e = -1, t = n == null ? 0 : n.length; for (this.clear(); ++e < t;) { var r = n[e]; this.set(r[0], r[1]) } } Tf.prototype.clear = Tfe; Tf.prototype.delete = Ife; Tf.prototype.get = Mfe; Tf.prototype.has = bfe; Tf.prototype.set = Bfe; var Rfe = "Expected a function"; function kT(n, e) { if (typeof n != "function" || e != null && typeof e != "function") throw new TypeError(Rfe); var t = function () { var r = arguments, i = e ? e.apply(this, r) : r[0], s = t.cache; if (s.has(i)) return s.get(i); var a = n.apply(this, r); return t.cache = s.set(i, a) || s, a }; return t.cache = new (kT.Cache || Tf), t } kT.Cache = Tf; var Pfe = 500; function Dfe(n) { var e = kT(n, function (r) { return t.size === Pfe && t.clear(), r }), t = e.cache; return e } var Lfe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ffe = /\\(\\)?/g, kfe = Dfe(function (n) { var e = []; return n.charCodeAt(0) === 46 && e.push(""), n.replace(Lfe, function (t, r, i, s) { e.push(i ? s.replace(Ffe, "$1") : r || t) }), e }); const Nfe = kfe; function Ofe(n) { return n == null ? "" : $G(n) } function Y8(n, e) { return nr(n) ? n : FT(n, e) ? [n] : Nfe(Ofe(n)) } var Ufe = 1 / 0; function n2(n) { if (typeof n == "string" || U8(n)) return n; var e = n + ""; return e == "0" && 1 / n == -Ufe ? "-0" : e } function NT(n, e) { e = Y8(e, n); for (var t = 0, r = e.length; n != null && t < r;)n = n[n2(e[t++])]; return t && t == r ? n : void 0 } function Gfe(n, e, t) { var r = n == null ? void 0 : NT(n, e); return r === void 0 ? t : r } function OT(n, e) { for (var t = -1, r = e.length, i = n.length; ++t < r;)n[i + t] = e[t]; return n } var lP = Ll ? Ll.isConcatSpreadable : void 0; function Qfe(n) { return nr(n) || z8(n) || !!(lP && n && n[lP]) } function j8(n, e, t, r, i) { var s = -1, a = n.length; for (t || (t = Qfe), i || (i = []); ++s < a;) { var o = n[s]; e > 0 && t(o) ? e > 1 ? j8(o, e - 1, t, r, i) : OT(i, o) : r || (i[i.length] = o) } return i } function gu(n) { var e = n == null ? 0 : n.length; return e ? j8(n, 1) : [] } var Hfe = oQ(Object.getPrototypeOf, Object); const uQ = Hfe; function cQ(n, e, t) { var r = -1, i = n.length; e < 0 && (e = -e > i ? 0 : i + e), t = t > i ? i : t, t < 0 && (t += i), i = e > t ? 0 : t - e >>> 0, e >>>= 0; for (var s = Array(i); ++r < i;)s[r] = n[r + e]; return s } function zfe(n, e, t, r) { var i = -1, s = n == null ? 0 : n.length; for (r && s && (t = n[++i]); ++i < s;)t = e(t, n[i], i, n); return t } function Vfe() { this.__data__ = new Sf, this.size = 0 } function Wfe(n) { var e = this.__data__, t = e.delete(n); return this.size = e.size, t } function Xfe(n) { return this.__data__.get(n) } function Yfe(n) { return this.__data__.has(n) } var jfe = 200; function Jfe(n, e) { var t = this.__data__; if (t instanceof Sf) { var r = t.__data__; if (!v1 || r.length < jfe - 1) return r.push([n, e]), this.size = ++t.size, this; t = this.__data__ = new Tf(r) } return t.set(n, e), this.size = t.size, this } function fc(n) { var e = this.__data__ = new Sf(n); this.size = e.size } fc.prototype.clear = Vfe; fc.prototype.delete = Wfe; fc.prototype.get = Xfe; fc.prototype.has = Yfe; fc.prototype.set = Jfe; function Kfe(n, e) { return n && $1(e, Vo(e), n) } function qfe(n, e) { return n && $1(e, V8(e), n) } var fQ = typeof ke == "object" && ke && !ke.nodeType && ke, uP = fQ && typeof Oo == "object" && Oo && !Oo.nodeType && Oo, Zfe = uP && uP.exports === fQ, cP = Zfe ? vc.Buffer : void 0, fP = cP ? cP.allocUnsafe : void 0; function $fe(n, e) { if (e) return n.slice(); var t = n.length, r = fP ? fP(t) : new n.constructor(t); return n.copy(r), r } function UT(n, e) { for (var t = -1, r = n == null ? 0 : n.length, i = 0, s = []; ++t < r;) { var a = n[t]; e(a, t, n) && (s[i++] = a) } return s } function hQ() { return [] } var ehe = Object.prototype, the = ehe.propertyIsEnumerable, hP = Object.getOwnPropertySymbols, nhe = hP ? function (n) { return n == null ? [] : (n = Object(n), UT(hP(n), function (e) { return the.call(n, e) })) } : hQ; const GT = nhe; function rhe(n, e) { return $1(n, GT(n), e) } var ihe = Object.getOwnPropertySymbols, she = ihe ? function (n) { for (var e = []; n;)OT(e, GT(n)), n = uQ(n); return e } : hQ; const dQ = she; function ahe(n, e) { return $1(n, dQ(n), e) } function pQ(n, e, t) { var r = e(n); return nr(n) ? r : OT(r, t(n)) } function F7(n) { return pQ(n, Vo, GT) } function mQ(n) { return pQ(n, V8, dQ) } var ohe = zp(vc, "DataView"); const k7 = ohe; var lhe = zp(vc, "Promise"); const N7 = lhe; var uhe = zp(vc, "Set"); const F3 = uhe; var dP = "[object Map]", che = "[object Object]", pP = "[object Promise]", mP = "[object Set]", gP = "[object WeakMap]", AP = "[object DataView]", fhe = Hp(k7), hhe = Hp(v1), dhe = Hp(N7), phe = Hp(F3), mhe = Hp(L7), Nd = $h; (k7 && Nd(new k7(new ArrayBuffer(1))) != AP || v1 && Nd(new v1) != dP || N7 && Nd(N7.resolve()) != pP || F3 && Nd(new F3) != mP || L7 && Nd(new L7) != gP) && (Nd = function (n) { var e = $h(n), t = e == che ? n.constructor : void 0, r = t ? Hp(t) : ""; if (r) switch (r) { case fhe: return AP; case hhe: return dP; case dhe: return pP; case phe: return mP; case mhe: return gP }return e }); const lm = Nd; var ghe = Object.prototype, Ahe = ghe.hasOwnProperty; function vhe(n) { var e = n.length, t = new n.constructor(e); return e && typeof n[0] == "string" && Ahe.call(n, "index") && (t.index = n.index, t.input = n.input), t } var yhe = vc.Uint8Array; const yy = yhe; function QT(n) { var e = new n.constructor(n.byteLength); return new yy(e).set(new yy(n)), e } function xhe(n, e) { var t = e ? QT(n.buffer) : n.buffer; return new n.constructor(t, n.byteOffset, n.byteLength) } var _he = /\w*$/; function Ehe(n) { var e = new n.constructor(n.source, _he.exec(n)); return e.lastIndex = n.lastIndex, e } var vP = Ll ? Ll.prototype : void 0, yP = vP ? vP.valueOf : void 0; function Che(n) { return yP ? Object(yP.call(n)) : {} } function She(n, e) { var t = e ? QT(n.buffer) : n.buffer; return new n.constructor(t, n.byteOffset, n.length) } var The = "[object Boolean]", whe = "[object Date]", Ihe = "[object Map]", Mhe = "[object Number]", bhe = "[object RegExp]", Bhe = "[object Set]", Rhe = "[object String]", Phe = "[object Symbol]", Dhe = "[object ArrayBuffer]", Lhe = "[object DataView]", Fhe = "[object Float32Array]", khe = "[object Float64Array]", Nhe = "[object Int8Array]", Ohe = "[object Int16Array]", Uhe = "[object Int32Array]", Ghe = "[object Uint8Array]", Qhe = "[object Uint8ClampedArray]", Hhe = "[object Uint16Array]", zhe = "[object Uint32Array]"; function Vhe(n, e, t) { var r = n.constructor; switch (e) { case Dhe: return QT(n); case The: case whe: return new r(+n); case Lhe: return xhe(n, t); case Fhe: case khe: case Nhe: case Ohe: case Uhe: case Ghe: case Qhe: case Hhe: case zhe: return She(n, t); case Ihe: return new r; case Mhe: case Rhe: return new r(n); case bhe: return Ehe(n); case Bhe: return new r; case Phe: return Che(n) } } function Whe(n) { return typeof n.constructor == "function" && !e2(n) ? Oue(uQ(n)) : {} } var Xhe = "[object Map]"; function Yhe(n) { return Eu(n) && lm(n) == Xhe } var xP = Gh && Gh.isMap, jhe = xP ? t2(xP) : Yhe; const Jhe = jhe; var Khe = "[object Set]"; function qhe(n) { return Eu(n) && lm(n) == Khe } var _P = Gh && Gh.isSet, Zhe = _P ? t2(_P) : qhe; const $he = Zhe; var ede = 1, tde = 2, nde = 4, gQ = "[object Arguments]", rde = "[object Array]", ide = "[object Boolean]", sde = "[object Date]", ade = "[object Error]", AQ = "[object Function]", ode = "[object GeneratorFunction]", lde = "[object Map]", ude = "[object Number]", vQ = "[object Object]", cde = "[object RegExp]", fde = "[object Set]", hde = "[object String]", dde = "[object Symbol]", pde = "[object WeakMap]", mde = "[object ArrayBuffer]", gde = "[object DataView]", Ade = "[object Float32Array]", vde = "[object Float64Array]", yde = "[object Int8Array]", xde = "[object Int16Array]", _de = "[object Int32Array]", Ede = "[object Uint8Array]", Cde = "[object Uint8ClampedArray]", Sde = "[object Uint16Array]", Tde = "[object Uint32Array]", Or = {}; Or[gQ] = Or[rde] = Or[mde] = Or[gde] = Or[ide] = Or[sde] = Or[Ade] = Or[vde] = Or[yde] = Or[xde] = Or[_de] = Or[lde] = Or[ude] = Or[vQ] = Or[cde] = Or[fde] = Or[hde] = Or[dde] = Or[Ede] = Or[Cde] = Or[Sde] = Or[Tde] = !0; Or[ade] = Or[AQ] = Or[pde] = !1; function d6(n, e, t, r, i, s) { var a, o = e & ede, l = e & tde, u = e & nde; if (t && (a = i ? t(n, r, i, s) : t(n)), a !== void 0) return a; if (!Fl(n)) return n; var c = nr(n); if (c) { if (a = vhe(n), !o) return Gue(n, a) } else { var h = lm(n), d = h == AQ || h == ode; if (g1(n)) return $fe(n, o); if (h == vQ || h == gQ || d && !i) { if (a = l || d ? {} : Whe(n), !o) return l ? ahe(n, qfe(a, n)) : rhe(n, Kfe(a, n)) } else { if (!Or[h]) return i ? n : {}; a = Vhe(n, h, o) } } s || (s = new fc); var m = s.get(n); if (m) return m; s.set(n, a), $he(n) ? n.forEach(function (y) { a.add(d6(y, e, t, y, n, s)) }) : Jhe(n) && n.forEach(function (y, A) { a.set(A, d6(y, e, t, A, n, s)) }); var g = u ? l ? mQ : F7 : l ? V8 : Vo, v = c ? void 0 : g(n); return eQ(v || n, function (y, A) { v && (A = y, y = n[A]), Q8(a, A, d6(y, e, t, A, n, s)) }), a } var wde = 4; function ga(n) { return d6(n, wde) } function r2(n) { for (var e = -1, t = n == null ? 0 : n.length, r = 0, i = []; ++e < t;) { var s = n[e]; s && (i[r++] = s) } return i } var Ide = "__lodash_hash_undefined__"; function Mde(n) { return this.__data__.set(n, Ide), this } function bde(n) { return this.__data__.has(n) } function um(n) { var e = -1, t = n == null ? 0 : n.length; for (this.__data__ = new Tf; ++e < t;)this.add(n[e]) } um.prototype.add = um.prototype.push = Mde; um.prototype.has = bde; function yQ(n, e) { for (var t = -1, r = n == null ? 0 : n.length; ++t < r;)if (e(n[t], t, n)) return !0; return !1 } function HT(n, e) { return n.has(e) } var Bde = 1, Rde = 2; function xQ(n, e, t, r, i, s) { var a = t & Bde, o = n.length, l = e.length; if (o != l && !(a && l > o)) return !1; var u = s.get(n), c = s.get(e); if (u && c) return u == e && c == n; var h = -1, d = !0, m = t & Rde ? new um : void 0; for (s.set(n, e), s.set(e, n); ++h < o;) { var g = n[h], v = e[h]; if (r) var y = a ? r(v, g, h, e, n, s) : r(g, v, h, n, e, s); if (y !== void 0) { if (y) continue; d = !1; break } if (m) { if (!yQ(e, function (A, _) { if (!HT(m, _) && (g === A || i(g, A, t, r, s))) return m.push(_) })) { d = !1; break } } else if (!(g === v || i(g, v, t, r, s))) { d = !1; break } } return s.delete(n), s.delete(e), d } function Pde(n) { var e = -1, t = Array(n.size); return n.forEach(function (r, i) { t[++e] = [i, r] }), t } function zT(n) { var e = -1, t = Array(n.size); return n.forEach(function (r) { t[++e] = r }), t } var Dde = 1, Lde = 2, Fde = "[object Boolean]", kde = "[object Date]", Nde = "[object Error]", Ode = "[object Map]", Ude = "[object Number]", Gde = "[object RegExp]", Qde = "[object Set]", Hde = "[object String]", zde = "[object Symbol]", Vde = "[object ArrayBuffer]", Wde = "[object DataView]", EP = Ll ? Ll.prototype : void 0, L_ = EP ? EP.valueOf : void 0; function Xde(n, e, t, r, i, s, a) { switch (t) { case Wde: if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset) return !1; n = n.buffer, e = e.buffer; case Vde: return !(n.byteLength != e.byteLength || !s(new yy(n), new yy(e))); case Fde: case kde: case Ude: return Z1(+n, +e); case Nde: return n.name == e.name && n.message == e.message; case Gde: case Hde: return n == e + ""; case Ode: var o = Pde; case Qde: var l = r & Dde; if (o || (o = zT), n.size != e.size && !l) return !1; var u = a.get(n); if (u) return u == e; r |= Lde, a.set(n, e); var c = xQ(o(n), o(e), r, i, s, a); return a.delete(n), c; case zde: if (L_) return L_.call(n) == L_.call(e) }return !1 } var Yde = 1, jde = Object.prototype, Jde = jde.hasOwnProperty; function Kde(n, e, t, r, i, s) { var a = t & Yde, o = F7(n), l = o.length, u = F7(e), c = u.length; if (l != c && !a) return !1; for (var h = l; h--;) { var d = o[h]; if (!(a ? d in e : Jde.call(e, d))) return !1 } var m = s.get(n), g = s.get(e); if (m && g) return m == e && g == n; var v = !0; s.set(n, e), s.set(e, n); for (var y = a; ++h < l;) { d = o[h]; var A = n[d], _ = e[d]; if (r) var x = a ? r(_, A, d, e, n, s) : r(A, _, d, n, e, s); if (!(x === void 0 ? A === _ || i(A, _, t, r, s) : x)) { v = !1; break } y || (y = d == "constructor") } if (v && !y) { var C = n.constructor, T = e.constructor; C != T && "constructor" in n && "constructor" in e && !(typeof C == "function" && C instanceof C && typeof T == "function" && T instanceof T) && (v = !1) } return s.delete(n), s.delete(e), v } var qde = 1, CP = "[object Arguments]", SP = "[object Array]", E5 = "[object Object]", Zde = Object.prototype, TP = Zde.hasOwnProperty; function $de(n, e, t, r, i, s) { var a = nr(n), o = nr(e), l = a ? SP : lm(n), u = o ? SP : lm(e); l = l == CP ? E5 : l, u = u == CP ? E5 : u; var c = l == E5, h = u == E5, d = l == u; if (d && g1(n)) { if (!g1(e)) return !1; a = !0, c = !1 } if (d && !c) return s || (s = new fc), a || LT(n) ? xQ(n, e, t, r, i, s) : Xde(n, e, l, t, r, i, s); if (!(t & qde)) { var m = c && TP.call(n, "__wrapped__"), g = h && TP.call(e, "__wrapped__"); if (m || g) { var v = m ? n.value() : n, y = g ? e.value() : e; return s || (s = new fc), i(v, y, t, r, s) } } return d ? (s || (s = new fc), Kde(n, e, t, r, i, s)) : !1 } function VT(n, e, t, r, i) { return n === e ? !0 : n == null || e == null || !Eu(n) && !Eu(e) ? n !== n && e !== e : $de(n, e, t, r, VT, i) } var epe = 1, tpe = 2; function npe(n, e, t, r) { var i = t.length, s = i, a = !r; if (n == null) return !s; for (n = Object(n); i--;) { var o = t[i]; if (a && o[2] ? o[1] !== n[o[0]] : !(o[0] in n)) return !1 } for (; ++i < s;) { o = t[i]; var l = o[0], u = n[l], c = o[1]; if (a && o[2]) { if (u === void 0 && !(l in n)) return !1 } else { var h = new fc; if (r) var d = r(u, c, l, n, e, h); if (!(d === void 0 ? VT(c, u, epe | tpe, r, h) : d)) return !1 } } return !0 } function _Q(n) { return n === n && !Fl(n) } function rpe(n) { for (var e = Vo(n), t = e.length; t--;) { var r = e[t], i = n[r]; e[t] = [r, i, _Q(i)] } return e } function EQ(n, e) { return function (t) { return t == null ? !1 : t[n] === e && (e !== void 0 || n in Object(t)) } } function ipe(n) { var e = rpe(n); return e.length == 1 && e[0][2] ? EQ(e[0][0], e[0][1]) : function (t) { return t === n || npe(t, n, e) } } function spe(n, e) { return n != null && e in Object(n) } function CQ(n, e, t) { e = Y8(e, n); for (var r = -1, i = e.length, s = !1; ++r < i;) { var a = n2(e[r]); if (!(s = n != null && t(n, a))) break; n = n[a] } return s || ++r != i ? s : (i = n == null ? 0 : n.length, !!i && DT(i) && G8(a, i) && (nr(n) || z8(n))) } function ape(n, e) { return n != null && CQ(n, e, spe) } var ope = 1, lpe = 2; function upe(n, e) { return FT(n) && _Q(e) ? EQ(n2(n), e) : function (t) { var r = Gfe(t, n); return r === void 0 && r === e ? ape(t, n) : VT(e, r, ope | lpe) } } function cpe(n) { return function (e) { return e == null ? void 0 : e[n] } } function fpe(n) { return function (e) { return NT(e, n) } } function hpe(n) { return FT(n) ? cpe(n2(n)) : fpe(n) } function xc(n) { return typeof n == "function" ? n : n == null ? om : typeof n == "object" ? nr(n) ? upe(n[0], n[1]) : ipe(n) : hpe(n) } function dpe(n, e, t, r) { for (var i = -1, s = n == null ? 0 : n.length; ++i < s;) { var a = n[i]; e(r, a, t(a), n) } return r } function ppe(n) { return function (e, t, r) { for (var i = -1, s = Object(e), a = r(e), o = a.length; o--;) { var l = a[n ? o : ++i]; if (t(s[l], l, s) === !1) break } return e } } var mpe = ppe(); const gpe = mpe; function Ape(n, e) { return n && gpe(n, e, Vo) } function vpe(n, e) { return function (t, r) { if (t == null) return t; if (!yc(t)) return n(t, r); for (var i = t.length, s = e ? i : -1, a = Object(t); (e ? s-- : ++s < i) && r(a[s], s, a) !== !1;); return t } } var ype = vpe(Ape); const Vp = ype; function xpe(n, e, t, r) { return Vp(n, function (i, s, a) { e(r, i, t(i), a) }), r } function _pe(n, e) { return function (t, r) { var i = nr(t) ? dpe : xpe, s = e ? e() : {}; return i(t, n, xc(r), s) } } var SQ = Object.prototype, Epe = SQ.hasOwnProperty, Cpe = PT(function (n, e) { n = Object(n); var t = -1, r = e.length, i = r > 2 ? e[2] : void 0; for (i && H8(e[0], e[1], i) && (r = 1); ++t < r;)for (var s = e[t], a = V8(s), o = -1, l = a.length; ++o < l;) { var u = a[o], c = n[u]; (c === void 0 || Z1(c, SQ[u]) && !Epe.call(n, u)) && (n[u] = s[u]) } return n }); const WT = Cpe; function wP(n) { return Eu(n) && yc(n) } function TQ(n, e, t) { for (var r = -1, i = n == null ? 0 : n.length; ++r < i;)if (t(e, n[r])) return !0; return !1 } var Spe = 200; function Tpe(n, e, t, r) { var i = -1, s = nQ, a = !0, o = n.length, l = [], u = e.length; if (!o) return l; t && (e = K1(e, t2(t))), r ? (s = TQ, a = !1) : e.length >= Spe && (s = HT, a = !1, e = new um(e)); e: for (; ++i < o;) { var c = n[i], h = t == null ? c : t(c); if (c = r || c !== 0 ? c : 0, a && h === h) { for (var d = u; d--;)if (e[d] === h) continue e; l.push(c) } else s(e, h, r) || l.push(c) } return l } var wpe = PT(function (n, e) { return wP(n) ? Tpe(n, j8(e, 1, wP, !0)) : [] }); const J8 = wpe; function cm(n) { var e = n == null ? 0 : n.length; return e ? n[e - 1] : void 0 } function Ys(n, e, t) { var r = n == null ? 0 : n.length; return r ? (e = t || e === void 0 ? 1 : q1(e), cQ(n, e < 0 ? 0 : e, r)) : [] } function y1(n, e, t) { var r = n == null ? 0 : n.length; return r ? (e = t || e === void 0 ? 1 : q1(e), e = r - e, cQ(n, 0, e < 0 ? 0 : e)) : [] } function Ipe(n) { return typeof n == "function" ? n : om } function tn(n, e) { var t = nr(n) ? eQ : Vp; return t(n, Ipe(e)) } function Mpe(n, e) { for (var t = -1, r = n == null ? 0 : n.length; ++t < r;)if (!e(n[t], t, n)) return !1; return !0 } function bpe(n, e) { var t = !0; return Vp(n, function (r, i, s) { return t = !!e(r, i, s), t }), t } function Au(n, e, t) { var r = nr(n) ? Mpe : bpe; return t && H8(n, e, t) && (e = void 0), r(n, xc(e)) } function wQ(n, e) { var t = []; return Vp(n, function (r, i, s) { e(r, i, s) && t.push(r) }), t } function Ol(n, e) { var t = nr(n) ? UT : wQ; return t(n, xc(e)) } function Bpe(n) { return function (e, t, r) { var i = Object(e); if (!yc(e)) { var s = xc(t); e = Vo(e), t = function (o) { return s(i[o], o, i) } } var a = n(e, t, r); return a > -1 ? i[s ? e[a] : a] : void 0 } } var Rpe = Math.max; function Ppe(n, e, t) { var r = n == null ? 0 : n.length; if (!r) return -1; var i = t == null ? 0 : q1(t); return i < 0 && (i = Rpe(r + i, 0)), tQ(n, xc(e), i) } var Dpe = Bpe(Ppe); const fm = Dpe; function Cu(n) { return n && n.length ? n[0] : void 0 } function Lpe(n, e) { var t = -1, r = yc(n) ? Array(n.length) : []; return Vp(n, function (i, s, a) { r[++t] = e(i, s, a) }), r } function Gt(n, e) { var t = nr(n) ? K1 : Lpe; return t(n, xc(e)) } function Il(n, e) { return j8(Gt(n, e), 1) } var Fpe = Object.prototype, kpe = Fpe.hasOwnProperty, Npe = _pe(function (n, e, t) { kpe.call(n, t) ? n[t].push(e) : RT(n, t, [e]) }); const Ope = Npe; var Upe = Object.prototype, Gpe = Upe.hasOwnProperty; function Qpe(n, e) { return n != null && Gpe.call(n, e) } function Zt(n, e) { return n != null && CQ(n, e, Qpe) } var Hpe = "[object String]"; function po(n) { return typeof n == "string" || !nr(n) && Eu(n) && $h(n) == Hpe } function zpe(n, e) { return K1(e, function (t) { return n[t] }) } function gs(n) { return n == null ? [] : zpe(n, Vo(n)) } var Vpe = Math.max; function za(n, e, t, r) { n = yc(n) ? n : gs(n), t = t && !r ? q1(t) : 0; var i = n.length; return t < 0 && (t = Vpe(i + t, 0)), po(n) ? t <= i && n.indexOf(e, t) > -1 : !!i && BT(n, e, t) > -1 } var Wpe = Math.max; function IP(n, e, t) { var r = n == null ? 0 : n.length; if (!r) return -1; var i = t == null ? 0 : q1(t); return i < 0 && (i = Wpe(r + i, 0)), BT(n, e, i) } var Xpe = "[object Map]", Ype = "[object Set]", jpe = Object.prototype, Jpe = jpe.hasOwnProperty; function Hr(n) { if (n == null) return !0; if (yc(n) && (nr(n) || typeof n == "string" || typeof n.splice == "function" || g1(n) || LT(n) || z8(n))) return !n.length; var e = lm(n); if (e == Xpe || e == Ype) return !n.size; if (e2(n)) return !lQ(n).length; for (var t in n) if (Jpe.call(n, t)) return !1; return !0 } var Kpe = "[object RegExp]"; function qpe(n) { return Eu(n) && $h(n) == Kpe } var MP = Gh && Gh.isRegExp, Zpe = MP ? t2(MP) : qpe; const vf = Zpe; function yf(n) { return n === void 0 } var $pe = "Expected a function"; function e0e(n) { if (typeof n != "function") throw new TypeError($pe); return function () { var e = arguments; switch (e.length) { case 0: return !n.call(this); case 1: return !n.call(this, e[0]); case 2: return !n.call(this, e[0], e[1]); case 3: return !n.call(this, e[0], e[1], e[2]) }return !n.apply(this, e) } } function t0e(n, e, t, r) { if (!Fl(n)) return n; e = Y8(e, n); for (var i = -1, s = e.length, a = s - 1, o = n; o != null && ++i < s;) { var l = n2(e[i]), u = t; if (l === "__proto__" || l === "constructor" || l === "prototype") return n; if (i != a) { var c = o[l]; u = r ? r(c, l, o) : void 0, u === void 0 && (u = Fl(c) ? c : G8(e[i + 1]) ? [] : {}) } Q8(o, l, u), o = o[l] } return n } function n0e(n, e, t) { for (var r = -1, i = e.length, s = {}; ++r < i;) { var a = e[r], o = NT(n, a); t(o, a) && t0e(s, Y8(a, n), o) } return s } function Ru(n, e) { if (n == null) return {}; var t = K1(mQ(n), function (r) { return [r] }); return e = xc(e), n0e(n, t, function (r, i) { return e(r, i[0]) }) } function r0e(n, e, t, r, i) { return i(n, function (s, a, o) { t = r ? (r = !1, s) : e(t, s, a, o) }), t } function Xo(n, e, t) { var r = nr(n) ? zfe : r0e, i = arguments.length < 3; return r(n, xc(e), t, i, Vp) } function K8(n, e) { var t = nr(n) ? UT : wQ; return t(n, e0e(xc(e))) } function i0e(n, e) { var t; return Vp(n, function (r, i, s) { return t = e(r, i, s), !t }), !!t } function IQ(n, e, t) { var r = nr(n) ? yQ : i0e; return t && H8(n, e, t) && (e = void 0), r(n, xc(e)) } var s0e = 1 / 0, a0e = F3 && 1 / zT(new F3([, -0]))[1] == s0e ? function (n) { return new F3(n) } : ds; const o0e = a0e; var l0e = 200; function u0e(n, e, t) { var r = -1, i = nQ, s = n.length, a = !0, o = [], l = o; if (t) a = !1, i = TQ; else if (s >= l0e) { var u = e ? null : o0e(n); if (u) return zT(u); a = !1, i = HT, l = new um } else l = e ? [] : o; e: for (; ++r < s;) { var c = n[r], h = e ? e(c) : c; if (c = t || c !== 0 ? c : 0, a && h === h) { for (var d = l.length; d--;)if (l[d] === h) continue e; e && l.push(h), o.push(c) } else i(l, h, t) || (l !== o && l.push(h), o.push(c)) } return o } function XT(n) { return n && n.length ? u0e(n) : [] } function O7(n) { console && console.error && console.error(`Error: ${n}`) } function MQ(n) { console && console.warn && console.warn(`Warning: ${n}`) } function bQ(n) { const e = new Date().getTime(), t = n(); return { time: new Date().getTime() - e, value: t } } function BQ(n) { function e() { } e.prototype = n; const t = new e; function r() { return typeof t.bar } return r(), r(), n } function c0e(n) { return f0e(n) ? n.LABEL : n.name } function f0e(n) { return po(n.LABEL) && n.LABEL !== "" } class _c { get definition() { return this._definition } set definition(e) { this._definition = e } constructor(e) { this._definition = e } accept(e) { e.visit(this), tn(this.definition, t => { t.accept(e) }) } } class Yo extends _c { constructor(e) { super([]), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } set definition(e) { } get definition() { return this.referencedRule !== void 0 ? this.referencedRule.definition : [] } accept(e) { e.visit(this) } } class wm extends _c { constructor(e) { super(e.definition), this.orgText = "", Wo(this, Ru(e, t => t !== void 0)) } } class mo extends _c { constructor(e) { super(e.definition), this.ignoreAmbiguities = !1, Wo(this, Ru(e, t => t !== void 0)) } } class fo extends _c { constructor(e) { super(e.definition), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } } class Ec extends _c { constructor(e) { super(e.definition), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } } class Cc extends _c { constructor(e) { super(e.definition), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } } class vs extends _c { constructor(e) { super(e.definition), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } } class Pu extends _c { constructor(e) { super(e.definition), this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } } class Du extends _c { get definition() { return this._definition } set definition(e) { this._definition = e } constructor(e) { super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, Wo(this, Ru(e, t => t !== void 0)) } } class vi { constructor(e) { this.idx = 1, Wo(this, Ru(e, t => t !== void 0)) } accept(e) { e.visit(this) } } function h0e(n) { return Gt(n, p6) } function p6(n) { function e(t) { return Gt(t, p6) } if (n instanceof Yo) { const t = { type: "NonTerminal", name: n.nonTerminalName, idx: n.idx }; return po(n.label) && (t.label = n.label), t } else { if (n instanceof mo) return { type: "Alternative", definition: e(n.definition) }; if (n instanceof fo) return { type: "Option", idx: n.idx, definition: e(n.definition) }; if (n instanceof Ec) return { type: "RepetitionMandatory", idx: n.idx, definition: e(n.definition) }; if (n instanceof Cc) return { type: "RepetitionMandatoryWithSeparator", idx: n.idx, separator: p6(new vi({ terminalType: n.separator })), definition: e(n.definition) }; if (n instanceof Pu) return { type: "RepetitionWithSeparator", idx: n.idx, separator: p6(new vi({ terminalType: n.separator })), definition: e(n.definition) }; if (n instanceof vs) return { type: "Repetition", idx: n.idx, definition: e(n.definition) }; if (n instanceof Du) return { type: "Alternation", idx: n.idx, definition: e(n.definition) }; if (n instanceof vi) { const t = { type: "Terminal", name: n.terminalType.name, label: c0e(n.terminalType), idx: n.idx }; po(n.label) && (t.terminalLabel = n.label); const r = n.terminalType.PATTERN; return n.terminalType.PATTERN && (t.pattern = vf(r) ? r.source : r), t } else { if (n instanceof wm) return { type: "Rule", name: n.name, orgText: n.orgText, definition: e(n.definition) }; throw Error("non exhaustive match") } } } class Im { visit(e) { const t = e; switch (t.constructor) { case Yo: return this.visitNonTerminal(t); case mo: return this.visitAlternative(t); case fo: return this.visitOption(t); case Ec: return this.visitRepetitionMandatory(t); case Cc: return this.visitRepetitionMandatoryWithSeparator(t); case Pu: return this.visitRepetitionWithSeparator(t); case vs: return this.visitRepetition(t); case Du: return this.visitAlternation(t); case vi: return this.visitTerminal(t); case wm: return this.visitRule(t); default: throw Error("non exhaustive match") } } visitNonTerminal(e) { } visitAlternative(e) { } visitOption(e) { } visitRepetition(e) { } visitRepetitionMandatory(e) { } visitRepetitionMandatoryWithSeparator(e) { } visitRepetitionWithSeparator(e) { } visitAlternation(e) { } visitTerminal(e) { } visitRule(e) { } } function d0e(n) { return n instanceof mo || n instanceof fo || n instanceof vs || n instanceof Ec || n instanceof Cc || n instanceof Pu || n instanceof vi || n instanceof wm } function xy(n, e = []) { return n instanceof fo || n instanceof vs || n instanceof Pu ? !0 : n instanceof Du ? IQ(n.definition, r => xy(r, e)) : n instanceof Yo && za(e, n) ? !1 : n instanceof _c ? (n instanceof Yo && e.push(n), Au(n.definition, r => xy(r, e))) : !1 } function p0e(n) { return n instanceof Du } function Yu(n) { if (n instanceof Yo) return "SUBRULE"; if (n instanceof fo) return "OPTION"; if (n instanceof Du) return "OR"; if (n instanceof Ec) return "AT_LEAST_ONE"; if (n instanceof Cc) return "AT_LEAST_ONE_SEP"; if (n instanceof Pu) return "MANY_SEP"; if (n instanceof vs) return "MANY"; if (n instanceof vi) return "CONSUME"; throw Error("non exhaustive match") } class q8 { walk(e, t = []) { tn(e.definition, (r, i) => { const s = Ys(e.definition, i + 1); if (r instanceof Yo) this.walkProdRef(r, s, t); else if (r instanceof vi) this.walkTerminal(r, s, t); else if (r instanceof mo) this.walkFlat(r, s, t); else if (r instanceof fo) this.walkOption(r, s, t); else if (r instanceof Ec) this.walkAtLeastOne(r, s, t); else if (r instanceof Cc) this.walkAtLeastOneSep(r, s, t); else if (r instanceof Pu) this.walkManySep(r, s, t); else if (r instanceof vs) this.walkMany(r, s, t); else if (r instanceof Du) this.walkOr(r, s, t); else throw Error("non exhaustive match") }) } walkTerminal(e, t, r) { } walkProdRef(e, t, r) { } walkFlat(e, t, r) { const i = t.concat(r); this.walk(e, i) } walkOption(e, t, r) { const i = t.concat(r); this.walk(e, i) } walkAtLeastOne(e, t, r) { const i = [new fo({ definition: e.definition })].concat(t, r); this.walk(e, i) } walkAtLeastOneSep(e, t, r) { const i = bP(e, t, r); this.walk(e, i) } walkMany(e, t, r) { const i = [new fo({ definition: e.definition })].concat(t, r); this.walk(e, i) } walkManySep(e, t, r) { const i = bP(e, t, r); this.walk(e, i) } walkOr(e, t, r) { const i = t.concat(r); tn(e.definition, s => { const a = new mo({ definition: [s] }); this.walk(a, i) }) } } function bP(n, e, t) { return [new fo({ definition: [new vi({ terminalType: n.separator })].concat(n.definition) })].concat(e, t) } function i2(n) { if (n instanceof Yo) return i2(n.referencedRule); if (n instanceof vi) return A0e(n); if (d0e(n)) return m0e(n); if (p0e(n)) return g0e(n); throw Error("non exhaustive match") } function m0e(n) { let e = []; const t = n.definition; let r = 0, i = t.length > r, s, a = !0; for (; i && a;)s = t[r], a = xy(s), e = e.concat(i2(s)), r = r + 1, i = t.length > r; return XT(e) } function g0e(n) { const e = Gt(n.definition, t => i2(t)); return XT(gu(e)) } function A0e(n) { return [n.terminalType] } const RQ = "_~IN~_"; class v0e extends q8 { constructor(e) { super(), this.topProd = e, this.follows = {} } startWalking() { return this.walk(this.topProd), this.follows } walkTerminal(e, t, r) { } walkProdRef(e, t, r) { const i = x0e(e.referencedRule, e.idx) + this.topProd.name, s = t.concat(r), a = new mo({ definition: s }), o = i2(a); this.follows[i] = o } } function y0e(n) { const e = {}; return tn(n, t => { const r = new v0e(t).startWalking(); Wo(e, r) }), e } function x0e(n, e) { return n.name + e + RQ } function rn(n) { return n.charCodeAt(0) } function F_(n, e) { Array.isArray(n) ? n.forEach(function (t) { e.push(t) }) : e.push(n) } function pg(n, e) { if (n[e] === !0) throw "duplicate flag " + e; n[e], n[e] = !0 } function F0(n) { if (n === void 0) throw Error("Internal Error - Should never get here!"); return !0 } function _0e() { throw Error("Internal Error - Should never get here!") } function BP(n) { return n.type === "Character" } const _y = []; for (let n = rn("0"); n <= rn("9"); n++)_y.push(n); const Ey = [rn("_")].concat(_y); for (let n = rn("a"); n <= rn("z"); n++)Ey.push(n); for (let n = rn("A"); n <= rn("Z"); n++)Ey.push(n); const RP = [rn(" "), rn("\f"), rn(`
`), rn("\r"), rn("	"), rn("\v"), rn("	"), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn(" "), rn("\u2028"), rn("\u2029"), rn(" "), rn(" "), rn("　"), rn("\uFEFF")], E0e = /[0-9a-fA-F]/, C5 = /[0-9]/, C0e = /[1-9]/; class S0e {
		constructor() { this.idx = 0, this.input = "", this.groupIdx = 0 } saveState() { return { idx: this.idx, input: this.input, groupIdx: this.groupIdx } } restoreState(e) { this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx } pattern(e) { this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/"); const t = this.disjunction(); this.consumeChar("/"); const r = { type: "Flags", loc: { begin: this.idx, end: e.length }, global: !1, ignoreCase: !1, multiLine: !1, unicode: !1, sticky: !1 }; for (; this.isRegExpFlag();)switch (this.popChar()) { case "g": pg(r, "global"); break; case "i": pg(r, "ignoreCase"); break; case "m": pg(r, "multiLine"); break; case "u": pg(r, "unicode"); break; case "y": pg(r, "sticky"); break }if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx)); return { type: "Pattern", flags: r, value: t, loc: this.loc(0) } } disjunction() { const e = [], t = this.idx; for (e.push(this.alternative()); this.peekChar() === "|";)this.consumeChar("|"), e.push(this.alternative()); return { type: "Disjunction", value: e, loc: this.loc(t) } } alternative() { const e = [], t = this.idx; for (; this.isTerm();)e.push(this.term()); return { type: "Alternative", value: e, loc: this.loc(t) } } term() { return this.isAssertion() ? this.assertion() : this.atom() } assertion() { const e = this.idx; switch (this.popChar()) { case "^": return { type: "StartAnchor", loc: this.loc(e) }; case "$": return { type: "EndAnchor", loc: this.loc(e) }; case "\\": switch (this.popChar()) { case "b": return { type: "WordBoundary", loc: this.loc(e) }; case "B": return { type: "NonWordBoundary", loc: this.loc(e) } }throw Error("Invalid Assertion Escape"); case "(": this.consumeChar("?"); let t; switch (this.popChar()) { case "=": t = "Lookahead"; break; case "!": t = "NegativeLookahead"; break }F0(t); const r = this.disjunction(); return this.consumeChar(")"), { type: t, value: r, loc: this.loc(e) } }return _0e() } quantifier(e = !1) { let t; const r = this.idx; switch (this.popChar()) { case "*": t = { atLeast: 0, atMost: 1 / 0 }; break; case "+": t = { atLeast: 1, atMost: 1 / 0 }; break; case "?": t = { atLeast: 0, atMost: 1 }; break; case "{": const i = this.integerIncludingZero(); switch (this.popChar()) { case "}": t = { atLeast: i, atMost: i }; break; case ",": let s; this.isDigit() ? (s = this.integerIncludingZero(), t = { atLeast: i, atMost: s }) : t = { atLeast: i, atMost: 1 / 0 }, this.consumeChar("}"); break }if (e === !0 && t === void 0) return; F0(t); break }if (!(e === !0 && t === void 0) && F0(t)) return this.peekChar(0) === "?" ? (this.consumeChar("?"), t.greedy = !1) : t.greedy = !0, t.type = "Quantifier", t.loc = this.loc(r), t } atom() { let e; const t = this.idx; switch (this.peekChar()) { case ".": e = this.dotAll(); break; case "\\": e = this.atomEscape(); break; case "[": e = this.characterClass(); break; case "(": e = this.group(); break }if (e === void 0 && this.isPatternCharacter() && (e = this.patternCharacter()), F0(e)) return e.loc = this.loc(t), this.isQuantifier() && (e.quantifier = this.quantifier()), e } dotAll() {
			return this.consumeChar("."), {
				type: "Set", complement: !0, value: [rn(`
`), rn("\r"), rn("\u2028"), rn("\u2029")]
			}
		} atomEscape() { switch (this.consumeChar("\\"), this.peekChar()) { case "1": case "2": case "3": case "4": case "5": case "6": case "7": case "8": case "9": return this.decimalEscapeAtom(); case "d": case "D": case "s": case "S": case "w": case "W": return this.characterClassEscape(); case "f": case "n": case "r": case "t": case "v": return this.controlEscapeAtom(); case "c": return this.controlLetterEscapeAtom(); case "0": return this.nulCharacterAtom(); case "x": return this.hexEscapeSequenceAtom(); case "u": return this.regExpUnicodeEscapeSequenceAtom(); default: return this.identityEscapeAtom() } } decimalEscapeAtom() { return { type: "GroupBackReference", value: this.positiveInteger() } } characterClassEscape() { let e, t = !1; switch (this.popChar()) { case "d": e = _y; break; case "D": e = _y, t = !0; break; case "s": e = RP; break; case "S": e = RP, t = !0; break; case "w": e = Ey; break; case "W": e = Ey, t = !0; break }if (F0(e)) return { type: "Set", value: e, complement: t } } controlEscapeAtom() {
			let e; switch (this.popChar()) {
				case "f": e = rn("\f"); break; case "n": e = rn(`
`); break; case "r": e = rn("\r"); break; case "t": e = rn("	"); break; case "v": e = rn("\v"); break
			}if (F0(e)) return { type: "Character", value: e }
		} controlLetterEscapeAtom() { this.consumeChar("c"); const e = this.popChar(); if (/[a-zA-Z]/.test(e) === !1) throw Error("Invalid "); return { type: "Character", value: e.toUpperCase().charCodeAt(0) - 64 } } nulCharacterAtom() { return this.consumeChar("0"), { type: "Character", value: rn("\0") } } hexEscapeSequenceAtom() { return this.consumeChar("x"), this.parseHexDigits(2) } regExpUnicodeEscapeSequenceAtom() { return this.consumeChar("u"), this.parseHexDigits(4) } identityEscapeAtom() { const e = this.popChar(); return { type: "Character", value: rn(e) } } classPatternCharacterAtom() {
			switch (this.peekChar()) {
				case `
`: case "\r": case "\u2028": case "\u2029": case "\\": case "]": throw Error("TBD"); default: const e = this.popChar(); return { type: "Character", value: rn(e) }
			}
		} characterClass() { const e = []; let t = !1; for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), t = !0); this.isClassAtom();) { const r = this.classAtom(); if (r.type, BP(r) && this.isRangeDash()) { this.consumeChar("-"); const i = this.classAtom(); if (i.type, BP(i)) { if (i.value < r.value) throw Error("Range out of order in character class"); e.push({ from: r.value, to: i.value }) } else F_(r.value, e), e.push(rn("-")), F_(i.value, e) } else F_(r.value, e) } return this.consumeChar("]"), { type: "Set", complement: t, value: e } } classAtom() {
			switch (this.peekChar()) {
				case "]": case `
`: case "\r": case "\u2028": case "\u2029": throw Error("TBD"); case "\\": return this.classEscape(); default: return this.classPatternCharacterAtom()
			}
		} classEscape() { switch (this.consumeChar("\\"), this.peekChar()) { case "b": return this.consumeChar("b"), { type: "Character", value: rn("\b") }; case "d": case "D": case "s": case "S": case "w": case "W": return this.characterClassEscape(); case "f": case "n": case "r": case "t": case "v": return this.controlEscapeAtom(); case "c": return this.controlLetterEscapeAtom(); case "0": return this.nulCharacterAtom(); case "x": return this.hexEscapeSequenceAtom(); case "u": return this.regExpUnicodeEscapeSequenceAtom(); default: return this.identityEscapeAtom() } } group() { let e = !0; switch (this.consumeChar("("), this.peekChar(0)) { case "?": this.consumeChar("?"), this.consumeChar(":"), e = !1; break; default: this.groupIdx++; break }const t = this.disjunction(); this.consumeChar(")"); const r = { type: "Group", capturing: e, value: t }; return e && (r.idx = this.groupIdx), r } positiveInteger() { let e = this.popChar(); if (C0e.test(e) === !1) throw Error("Expecting a positive integer"); for (; C5.test(this.peekChar(0));)e += this.popChar(); return parseInt(e, 10) } integerIncludingZero() { let e = this.popChar(); if (C5.test(e) === !1) throw Error("Expecting an integer"); for (; C5.test(this.peekChar(0));)e += this.popChar(); return parseInt(e, 10) } patternCharacter() {
			const e = this.popChar(); switch (e) {
				case `
`: case "\r": case "\u2028": case "\u2029": case "^": case "$": case "\\": case ".": case "*": case "+": case "?": case "(": case ")": case "[": case "|": throw Error("TBD"); default: return { type: "Character", value: rn(e) }
			}
		} isRegExpFlag() { switch (this.peekChar(0)) { case "g": case "i": case "m": case "u": case "y": return !0; default: return !1 } } isRangeDash() { return this.peekChar() === "-" && this.isClassAtom(1) } isDigit() { return C5.test(this.peekChar(0)) } isClassAtom(e = 0) {
			switch (this.peekChar(e)) {
				case "]": case `
`: case "\r": case "\u2028": case "\u2029": return !1; default: return !0
			}
		} isTerm() { return this.isAtom() || this.isAssertion() } isAtom() { if (this.isPatternCharacter()) return !0; switch (this.peekChar(0)) { case ".": case "\\": case "[": case "(": return !0; default: return !1 } } isAssertion() { switch (this.peekChar(0)) { case "^": case "$": return !0; case "\\": switch (this.peekChar(1)) { case "b": case "B": return !0; default: return !1 }case "(": return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!"); default: return !1 } } isQuantifier() { const e = this.saveState(); try { return this.quantifier(!0) !== void 0 } catch { return !1 } finally { this.restoreState(e) } } isPatternCharacter() {
			switch (this.peekChar()) {
				case "^": case "$": case "\\": case ".": case "*": case "+": case "?": case "(": case ")": case "[": case "|": case "/": case `
`: case "\r": case "\u2028": case "\u2029": return !1; default: return !0
			}
		} parseHexDigits(e) { let t = ""; for (let i = 0; i < e; i++) { const s = this.popChar(); if (E0e.test(s) === !1) throw Error("Expecting a HexDecimal digits"); t += s } return { type: "Character", value: parseInt(t, 16) } } peekChar(e = 0) { return this.input[this.idx + e] } popChar() { const e = this.peekChar(0); return this.consumeChar(void 0), e } consumeChar(e) { if (e !== void 0 && this.input[this.idx] !== e) throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx); if (this.idx >= this.input.length) throw Error("Unexpected end of input"); this.idx++ } loc(e) { return { begin: e, end: this.idx } }
	} class YT { visitChildren(e) { for (const t in e) { const r = e[t]; e.hasOwnProperty(t) && (r.type !== void 0 ? this.visit(r) : Array.isArray(r) && r.forEach(i => { this.visit(i) }, this)) } } visit(e) { switch (e.type) { case "Pattern": this.visitPattern(e); break; case "Flags": this.visitFlags(e); break; case "Disjunction": this.visitDisjunction(e); break; case "Alternative": this.visitAlternative(e); break; case "StartAnchor": this.visitStartAnchor(e); break; case "EndAnchor": this.visitEndAnchor(e); break; case "WordBoundary": this.visitWordBoundary(e); break; case "NonWordBoundary": this.visitNonWordBoundary(e); break; case "Lookahead": this.visitLookahead(e); break; case "NegativeLookahead": this.visitNegativeLookahead(e); break; case "Character": this.visitCharacter(e); break; case "Set": this.visitSet(e); break; case "Group": this.visitGroup(e); break; case "GroupBackReference": this.visitGroupBackReference(e); break; case "Quantifier": this.visitQuantifier(e); break }this.visitChildren(e) } visitPattern(e) { } visitFlags(e) { } visitDisjunction(e) { } visitAlternative(e) { } visitStartAnchor(e) { } visitEndAnchor(e) { } visitWordBoundary(e) { } visitNonWordBoundary(e) { } visitLookahead(e) { } visitNegativeLookahead(e) { } visitCharacter(e) { } visitSet(e) { } visitGroup(e) { } visitGroupBackReference(e) { } visitQuantifier(e) { } } let m6 = {}; const T0e = new S0e; function Z8(n) { const e = n.toString(); if (m6.hasOwnProperty(e)) return m6[e]; { const t = T0e.pattern(e); return m6[e] = t, t } } function w0e() { m6 = {} } const PQ = "Complement Sets are not supported for first char optimization", Cy = `Unable to use "first char" lexer optimizations:
`; function I0e(n, e = !1) {
		try { const t = Z8(n); return U7(t.value, {}, t.flags.ignoreCase) } catch (t) {
			if (t.message === PQ) e && MQ(`${Cy}	Unable to optimize: < ${n.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`); else {
				let r = ""; e && (r = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), O7(`${Cy}
	Failed parsing: < ${n.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues`+ r)
			}
		} return []
	} function U7(n, e, t) { switch (n.type) { case "Disjunction": for (let i = 0; i < n.value.length; i++)U7(n.value[i], e, t); break; case "Alternative": const r = n.value; for (let i = 0; i < r.length; i++) { const s = r[i]; switch (s.type) { case "EndAnchor": case "GroupBackReference": case "Lookahead": case "NegativeLookahead": case "StartAnchor": case "WordBoundary": case "NonWordBoundary": continue }const a = s; switch (a.type) { case "Character": S5(a.value, e, t); break; case "Set": if (a.complement === !0) throw Error(PQ); tn(a.value, l => { if (typeof l == "number") S5(l, e, t); else { const u = l; if (t === !0) for (let c = u.from; c <= u.to; c++)S5(c, e, t); else { for (let c = u.from; c <= u.to && c < Dg; c++)S5(c, e, t); if (u.to >= Dg) { const c = u.from >= Dg ? u.from : Dg, h = u.to, d = Qh(c), m = Qh(h); for (let g = d; g <= m; g++)e[g] = g } } } }); break; case "Group": U7(a.value, e, t); break; default: throw Error("Non Exhaustive Match") }const o = a.quantifier !== void 0 && a.quantifier.atLeast === 0; if (a.type === "Group" && G7(a) === !1 || a.type !== "Group" && o === !1) break } break; default: throw Error("non exhaustive match!") }return gs(e) } function S5(n, e, t) { const r = Qh(n); e[r] = r, t === !0 && M0e(n, e) } function M0e(n, e) { const t = String.fromCharCode(n), r = t.toUpperCase(); if (r !== t) { const i = Qh(r.charCodeAt(0)); e[i] = i } else { const i = t.toLowerCase(); if (i !== t) { const s = Qh(i.charCodeAt(0)); e[s] = s } } } function PP(n, e) { return fm(n.value, t => { if (typeof t == "number") return za(e, t); { const r = t; return fm(e, i => r.from <= i && i <= r.to) !== void 0 } }) } function G7(n) { const e = n.quantifier; return e && e.atLeast === 0 ? !0 : n.value ? nr(n.value) ? Au(n.value, G7) : G7(n.value) : !1 } class b0e extends YT { constructor(e) { super(), this.targetCharCodes = e, this.found = !1 } visitChildren(e) { if (this.found !== !0) { switch (e.type) { case "Lookahead": this.visitLookahead(e); return; case "NegativeLookahead": this.visitNegativeLookahead(e); return }super.visitChildren(e) } } visitCharacter(e) { za(this.targetCharCodes, e.value) && (this.found = !0) } visitSet(e) { e.complement ? PP(e, this.targetCharCodes) === void 0 && (this.found = !0) : PP(e, this.targetCharCodes) !== void 0 && (this.found = !0) } } function jT(n, e) { if (e instanceof RegExp) { const t = Z8(e), r = new b0e(n); return r.visit(t), r.found } else return fm(e, t => za(n, t.charCodeAt(0))) !== void 0 } const Pp = "PATTERN", Pg = "defaultMode", T5 = "modes"; let DQ = typeof new RegExp("(?:)").sticky == "boolean"; function B0e(n, e) {
		e = WT(e, {
			useSticky: DQ, debug: !1, safeMode: !1, positionTracking: "full", lineTerminatorCharacters: ["\r", `
`], tracer: (_, x) => x()
		}); const t = e.tracer; t("initCharCodeToOptimizedIndexMap", () => { $0e() }); let r; t("Reject Lexer.NA", () => { r = K8(n, _ => _[Pp] === Ml.NA) }); let i = !1, s; t("Transform Patterns", () => { i = !1, s = Gt(r, _ => { const x = _[Pp]; if (vf(x)) { const C = x.source; return C.length === 1 && C !== "^" && C !== "$" && C !== "." && !x.ignoreCase ? C : C.length === 2 && C[0] === "\\" && !za(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], C[1]) ? C[1] : e.useSticky ? LP(x) : DP(x) } else { if (Cf(x)) return i = !0, { exec: x }; if (typeof x == "object") return i = !0, x; if (typeof x == "string") { if (x.length === 1) return x; { const C = x.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"), T = new RegExp(C); return e.useSticky ? LP(T) : DP(T) } } else throw Error("non exhaustive match") } }) }); let a, o, l, u, c; t("misc mapping", () => { a = Gt(r, _ => _.tokenTypeIdx), o = Gt(r, _ => { const x = _.GROUP; if (x !== Ml.SKIPPED) { if (po(x)) return x; if (yf(x)) return !1; throw Error("non exhaustive match") } }), l = Gt(r, _ => { const x = _.LONGER_ALT; if (x) return nr(x) ? Gt(x, T => IP(r, T)) : [IP(r, x)] }), u = Gt(r, _ => _.PUSH_MODE), c = Gt(r, _ => Zt(_, "POP_MODE")) }); let h; t("Line Terminator Handling", () => { const _ = kQ(e.lineTerminatorCharacters); h = Gt(r, x => !1), e.positionTracking !== "onlyOffset" && (h = Gt(r, x => Zt(x, "LINE_BREAKS") ? !!x.LINE_BREAKS : FQ(x, _) === !1 && jT(_, x.PATTERN))) }); let d, m, g, v; t("Misc Mapping #2", () => { d = Gt(r, LQ), m = Gt(s, K0e), g = Xo(r, (_, x) => { const C = x.GROUP; return po(C) && C !== Ml.SKIPPED && (_[C] = []), _ }, {}), v = Gt(s, (_, x) => ({ pattern: s[x], longerAlt: l[x], canLineTerminator: h[x], isCustom: d[x], short: m[x], group: o[x], push: u[x], pop: c[x], tokenTypeIdx: a[x], tokenType: r[x] })) }); let y = !0, A = []; return e.safeMode || t("First Char Optimization", () => {
			A = Xo(r, (_, x, C) => {
				if (typeof x.PATTERN == "string") { const T = x.PATTERN.charCodeAt(0), I = Qh(T); k_(_, I, v[C]) } else if (nr(x.START_CHARS_HINT)) { let T; tn(x.START_CHARS_HINT, I => { const w = typeof I == "string" ? I.charCodeAt(0) : I, R = Qh(w); T !== R && (T = R, k_(_, R, v[C])) }) } else if (vf(x.PATTERN)) if (x.PATTERN.unicode) y = !1, e.ensureOptimizations && O7(`${Cy}	Unable to analyze < ${x.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`); else { const T = I0e(x.PATTERN, e.ensureOptimizations); Hr(T) && (y = !1), tn(T, I => { k_(_, I, v[C]) }) } else e.ensureOptimizations && O7(`${Cy}	TokenType: <${x.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), y = !1; return _
			}, [])
		}), { emptyGroups: g, patternIdxToConfig: v, charCodeToPatternIdxToConfig: A, hasCustom: i, canBeOptimized: y }
	} function R0e(n, e) { let t = []; const r = D0e(n); t = t.concat(r.errors); const i = L0e(r.valid), s = i.valid; return t = t.concat(i.errors), t = t.concat(P0e(s)), t = t.concat(H0e(s)), t = t.concat(z0e(s, e)), t = t.concat(V0e(s)), t } function P0e(n) { let e = []; const t = Ol(n, r => vf(r[Pp])); return e = e.concat(k0e(t)), e = e.concat(U0e(t)), e = e.concat(G0e(t)), e = e.concat(Q0e(t)), e = e.concat(N0e(t)), e } function D0e(n) { const e = Ol(n, i => !Zt(i, Pp)), t = Gt(e, i => ({ message: "Token Type: ->" + i.name + "<- missing static 'PATTERN' property", type: Pi.MISSING_PATTERN, tokenTypes: [i] })), r = J8(n, e); return { errors: t, valid: r } } function L0e(n) { const e = Ol(n, i => { const s = i[Pp]; return !vf(s) && !Cf(s) && !Zt(s, "exec") && !po(s) }), t = Gt(e, i => ({ message: "Token Type: ->" + i.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.", type: Pi.INVALID_PATTERN, tokenTypes: [i] })), r = J8(n, e); return { errors: t, valid: r } } const F0e = /[^\\][$]/; function k0e(n) {
		class e extends YT { constructor() { super(...arguments), this.found = !1 } visitEndAnchor(s) { this.found = !0 } } const t = Ol(n, i => { const s = i.PATTERN; try { const a = Z8(s), o = new e; return o.visit(a), o.found } catch { return F0e.test(s.source) } }); return Gt(t, i => ({
			message: `Unexpected RegExp Anchor Error:
	Token Type: ->`+ i.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`, type: Pi.EOI_ANCHOR_FOUND, tokenTypes: [i]
		}))
	} function N0e(n) { const e = Ol(n, r => r.PATTERN.test("")); return Gt(e, r => ({ message: "Token Type: ->" + r.name + "<- static 'PATTERN' must not match an empty string", type: Pi.EMPTY_MATCH_PATTERN, tokenTypes: [r] })) } const O0e = /[^\\[][\^]|^\^/; function U0e(n) {
		class e extends YT { constructor() { super(...arguments), this.found = !1 } visitStartAnchor(s) { this.found = !0 } } const t = Ol(n, i => { const s = i.PATTERN; try { const a = Z8(s), o = new e; return o.visit(a), o.found } catch { return O0e.test(s.source) } }); return Gt(t, i => ({
			message: `Unexpected RegExp Anchor Error:
	Token Type: ->`+ i.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`, type: Pi.SOI_ANCHOR_FOUND, tokenTypes: [i]
		}))
	} function G0e(n) { const e = Ol(n, r => { const i = r[Pp]; return i instanceof RegExp && (i.multiline || i.global) }); return Gt(e, r => ({ message: "Token Type: ->" + r.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')", type: Pi.UNSUPPORTED_FLAGS_FOUND, tokenTypes: [r] })) } function Q0e(n) { const e = []; let t = Gt(n, s => Xo(n, (a, o) => (s.PATTERN.source === o.PATTERN.source && !za(e, o) && o.PATTERN !== Ml.NA && (e.push(o), a.push(o)), a), [])); t = r2(t); const r = Ol(t, s => s.length > 1); return Gt(r, s => { const a = Gt(s, l => l.name); return { message: `The same RegExp pattern ->${Cu(s).PATTERN}<-has been used in all of the following Token Types: ${a.join(", ")} <-`, type: Pi.DUPLICATE_PATTERNS_FOUND, tokenTypes: s } }) } function H0e(n) { const e = Ol(n, r => { if (!Zt(r, "GROUP")) return !1; const i = r.GROUP; return i !== Ml.SKIPPED && i !== Ml.NA && !po(i) }); return Gt(e, r => ({ message: "Token Type: ->" + r.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String", type: Pi.INVALID_GROUP_TYPE_FOUND, tokenTypes: [r] })) } function z0e(n, e) { const t = Ol(n, i => i.PUSH_MODE !== void 0 && !za(e, i.PUSH_MODE)); return Gt(t, i => ({ message: `Token Type: ->${i.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${i.PUSH_MODE}<-which does not exist`, type: Pi.PUSH_MODE_DOES_NOT_EXIST, tokenTypes: [i] })) } function V0e(n) {
		const e = [], t = Xo(n, (r, i, s) => { const a = i.PATTERN; return a === Ml.NA || (po(a) ? r.push({ str: a, idx: s, tokenType: i }) : vf(a) && X0e(a) && r.push({ str: a.source, idx: s, tokenType: i })), r }, []); return tn(n, (r, i) => {
			tn(t, ({ str: s, idx: a, tokenType: o }) => {
				if (i < a && W0e(s, r.PATTERN)) {
					const l = `Token: ->${o.name}<- can never be matched.
Because it appears AFTER the Token Type ->${r.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`; e.push({ message: l, type: Pi.UNREACHABLE_PATTERN, tokenTypes: [r, o] })
				}
			})
		}), e
	} function W0e(n, e) { if (vf(e)) { const t = e.exec(n); return t !== null && t.index === 0 } else { if (Cf(e)) return e(n, 0, [], {}); if (Zt(e, "exec")) return e.exec(n, 0, [], {}); if (typeof e == "string") return e === n; throw Error("non exhaustive match") } } function X0e(n) { return fm([".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"], t => n.source.indexOf(t) !== -1) === void 0 } function DP(n) { const e = n.ignoreCase ? "i" : ""; return new RegExp(`^(?:${n.source})`, e) } function LP(n) { const e = n.ignoreCase ? "iy" : "y"; return new RegExp(`${n.source}`, e) } function Y0e(n, e, t) {
		const r = []; return Zt(n, Pg) || r.push({
			message: "A MultiMode Lexer cannot be initialized without a <" + Pg + `> property in its definition
`, type: Pi.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
		}), Zt(n, T5) || r.push({
			message: "A MultiMode Lexer cannot be initialized without a <" + T5 + `> property in its definition
`, type: Pi.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
		}), Zt(n, T5) && Zt(n, Pg) && !Zt(n.modes, n.defaultMode) && r.push({
			message: `A MultiMode Lexer cannot be initialized with a ${Pg}: <${n.defaultMode}>which does not exist
`, type: Pi.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
		}), Zt(n, T5) && tn(n.modes, (i, s) => {
			tn(i, (a, o) => {
				if (yf(a)) r.push({
					message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${s}> at index: <${o}>
`, type: Pi.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
				}); else if (Zt(a, "LONGER_ALT")) {
					const l = nr(a.LONGER_ALT) ? a.LONGER_ALT : [a.LONGER_ALT]; tn(l, u => {
						!yf(u) && !za(i, u) && r.push({
							message: `A MultiMode Lexer cannot be initialized with a longer_alt <${u.name}> on token <${a.name}> outside of mode <${s}>
`, type: Pi.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
						})
					})
				}
			})
		}), r
	} function j0e(n, e, t) {
		const r = []; let i = !1; const s = r2(gu(gs(n.modes))), a = K8(s, l => l[Pp] === Ml.NA), o = kQ(t); return e && tn(a, l => { const u = FQ(l, o); if (u !== !1) { const h = { message: Z0e(l, u), type: u.issue, tokenType: l }; r.push(h) } else Zt(l, "LINE_BREAKS") ? l.LINE_BREAKS === !0 && (i = !0) : jT(o, l.PATTERN) && (i = !0) }), e && !i && r.push({
			message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`, type: Pi.NO_LINE_BREAKS_FLAGS
		}), r
	} function J0e(n) { const e = {}, t = Vo(n); return tn(t, r => { const i = n[r]; if (nr(i)) e[r] = []; else throw Error("non exhaustive match") }), e } function LQ(n) { const e = n.PATTERN; if (vf(e)) return !1; if (Cf(e)) return !0; if (Zt(e, "exec")) return !0; if (po(e)) return !1; throw Error("non exhaustive match") } function K0e(n) { return po(n) && n.length === 1 ? n.charCodeAt(0) : !1 } const q0e = { test: function (n) { const e = n.length; for (let t = this.lastIndex; t < e; t++) { const r = n.charCodeAt(t); if (r === 10) return this.lastIndex = t + 1, !0; if (r === 13) return n.charCodeAt(t + 1) === 10 ? this.lastIndex = t + 2 : this.lastIndex = t + 1, !0 } return !1 }, lastIndex: 0 }; function FQ(n, e) { if (Zt(n, "LINE_BREAKS")) return !1; if (vf(n.PATTERN)) { try { jT(e, n.PATTERN) } catch (t) { return { issue: Pi.IDENTIFY_TERMINATOR, errMsg: t.message } } return !1 } else { if (po(n.PATTERN)) return !1; if (LQ(n)) return { issue: Pi.CUSTOM_LINE_BREAK }; throw Error("non exhaustive match") } } function Z0e(n, e) {
		if (e.issue === Pi.IDENTIFY_TERMINATOR) return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${n.name}> Token Type
	 Root cause: ${e.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`; if (e.issue === Pi.CUSTOM_LINE_BREAK) return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${n.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`; throw Error("non exhaustive match")
	} function kQ(n) { return Gt(n, t => po(t) ? t.charCodeAt(0) : t) } function k_(n, e, t) { n[e] === void 0 ? n[e] = [t] : n[e].push(t) } const Dg = 256; let g6 = []; function Qh(n) { return n < Dg ? n : g6[n] } function $0e() { if (Hr(g6)) { g6 = new Array(65536); for (let n = 0; n < 65536; n++)g6[n] = n > 255 ? 255 + ~~(n / 255) : n } } function s2(n, e) { const t = n.tokenTypeIdx; return t === e.tokenTypeIdx ? !0 : e.isParent === !0 && e.categoryMatchesMap[t] === !0 } function Sy(n, e) { return n.tokenTypeIdx === e.tokenTypeIdx } let FP = 1; const NQ = {}; function a2(n) { const e = e3e(n); t3e(e), r3e(e), n3e(e), tn(e, t => { t.isParent = t.categoryMatches.length > 0 }) } function e3e(n) { let e = ga(n), t = n, r = !0; for (; r;) { t = r2(gu(Gt(t, s => s.CATEGORIES))); const i = J8(t, e); e = e.concat(i), Hr(i) ? r = !1 : t = i } return e } function t3e(n) { tn(n, e => { UQ(e) || (NQ[FP] = e, e.tokenTypeIdx = FP++), kP(e) && !nr(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), kP(e) || (e.CATEGORIES = []), i3e(e) || (e.categoryMatches = []), s3e(e) || (e.categoryMatchesMap = {}) }) } function n3e(n) { tn(n, e => { e.categoryMatches = [], tn(e.categoryMatchesMap, (t, r) => { e.categoryMatches.push(NQ[r].tokenTypeIdx) }) }) } function r3e(n) { tn(n, e => { OQ([], e) }) } function OQ(n, e) { tn(n, t => { e.categoryMatchesMap[t.tokenTypeIdx] = !0 }), tn(e.CATEGORIES, t => { const r = n.concat(e); za(r, t) || OQ(r, t) }) } function UQ(n) { return Zt(n, "tokenTypeIdx") } function kP(n) { return Zt(n, "CATEGORIES") } function i3e(n) { return Zt(n, "categoryMatches") } function s3e(n) { return Zt(n, "categoryMatchesMap") } function a3e(n) { return Zt(n, "tokenTypeIdx") } const o3e = { buildUnableToPopLexerModeMessage(n) { return `Unable to pop Lexer Mode after encountering Token ->${n.image}<- The Mode Stack is empty` }, buildUnexpectedCharactersMessage(n, e, t, r, i) { return `unexpected character: ->${n.charAt(e)}<- at offset: ${e}, skipped ${t} characters.` } }; var Pi; (function (n) { n[n.MISSING_PATTERN = 0] = "MISSING_PATTERN", n[n.INVALID_PATTERN = 1] = "INVALID_PATTERN", n[n.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", n[n.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", n[n.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", n[n.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", n[n.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", n[n.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", n[n.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", n[n.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", n[n.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", n[n.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", n[n.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", n[n.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", n[n.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", n[n.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", n[n.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", n[n.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE" })(Pi || (Pi = {})); const Lg = {
		deferDefinitionErrorsHandling: !1, positionTracking: "full", lineTerminatorsPattern: /\n|\r\n?/g, lineTerminatorCharacters: [`
`, "\r"], ensureOptimizations: !1, safeMode: !1, errorMessageProvider: o3e, traceInitPerf: !1, skipValidations: !1, recoveryEnabled: !0
	}; Object.freeze(Lg); class Ml {
		constructor(e, t = Lg) {
			if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (i, s) => { if (this.traceInitPerf === !0) { this.traceInitIndent++; const a = new Array(this.traceInitIndent + 1).join("	"); this.traceInitIndent < this.traceInitMaxIdent && console.log(`${a}--> <${i}>`); const { time: o, value: l } = bQ(s), u = o > 10 ? console.warn : console.log; return this.traceInitIndent < this.traceInitMaxIdent && u(`${a}<-- <${i}> time: ${o}ms`), this.traceInitIndent--, l } else return s() }, typeof t == "boolean") throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`); this.config = Wo({}, Lg, t); const r = this.config.traceInitPerf; r === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof r == "number" && (this.traceInitMaxIdent = r, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
				let i, s = !0; this.TRACE_INIT("Lexer Config handling", () => {
					if (this.config.lineTerminatorsPattern === Lg.lineTerminatorsPattern) this.config.lineTerminatorsPattern = q0e; else if (this.config.lineTerminatorCharacters === Lg.lineTerminatorCharacters) throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`); if (t.safeMode && t.ensureOptimizations) throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.'); this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), nr(e) ? i = { modes: { defaultMode: ga(e) }, defaultMode: Pg } : (s = !1, i = ga(e))
				}), this.config.skipValidations === !1 && (this.TRACE_INIT("performRuntimeChecks", () => { this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(Y0e(i, this.trackStartLines, this.config.lineTerminatorCharacters)) }), this.TRACE_INIT("performWarningRuntimeChecks", () => { this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(j0e(i, this.trackStartLines, this.config.lineTerminatorCharacters)) })), i.modes = i.modes ? i.modes : {}, tn(i.modes, (o, l) => { i.modes[l] = K8(o, u => yf(u)) }); const a = Vo(i.modes); if (tn(i.modes, (o, l) => { this.TRACE_INIT(`Mode: <${l}> processing`, () => { if (this.modes.push(l), this.config.skipValidations === !1 && this.TRACE_INIT("validatePatterns", () => { this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(R0e(o, a)) }), Hr(this.lexerDefinitionErrors)) { a2(o); let u; this.TRACE_INIT("analyzeTokenTypes", () => { u = B0e(o, { lineTerminatorCharacters: this.config.lineTerminatorCharacters, positionTracking: t.positionTracking, ensureOptimizations: t.ensureOptimizations, safeMode: t.safeMode, tracer: this.TRACE_INIT }) }), this.patternIdxToConfig[l] = u.patternIdxToConfig, this.charCodeToPatternIdxToConfig[l] = u.charCodeToPatternIdxToConfig, this.emptyGroups = Wo({}, this.emptyGroups, u.emptyGroups), this.hasCustom = u.hasCustom || this.hasCustom, this.canModeBeOptimized[l] = u.canBeOptimized } }) }), this.defaultMode = i.defaultMode, !Hr(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {
					const l = Gt(this.lexerDefinitionErrors, u => u.message).join(`-----------------------
`); throw new Error(`Errors detected in definition of Lexer:
`+ l)
				} tn(this.lexerDefinitionWarning, o => { MQ(o.message) }), this.TRACE_INIT("Choosing sub-methods implementations", () => { if (DQ ? (this.chopInput = om, this.match = this.matchWithTest) : (this.updateLastIndex = ds, this.match = this.matchWithExec), s && (this.handleModes = ds), this.trackStartLines === !1 && (this.computeNewColumn = om), this.trackEndLines === !1 && (this.updateTokenEndLineColumnLocation = ds), /full/i.test(this.config.positionTracking)) this.createTokenInstance = this.createFullToken; else if (/onlyStart/i.test(this.config.positionTracking)) this.createTokenInstance = this.createStartOnlyToken; else if (/onlyOffset/i.test(this.config.positionTracking)) this.createTokenInstance = this.createOffsetOnlyToken; else throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`); this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom) }), this.TRACE_INIT("Failed Optimization Warnings", () => {
					const o = Xo(this.canModeBeOptimized, (l, u, c) => (u === !1 && l.push(c), l), []); if (t.ensureOptimizations && !Hr(o)) throw Error(`Lexer Modes: < ${o.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)
				}), this.TRACE_INIT("clearRegExpParserCache", () => { w0e() }), this.TRACE_INIT("toFastProperties", () => { BQ(this) })
			})
		} tokenize(e, t = this.defaultMode) {
			if (!Hr(this.lexerDefinitionErrors)) {
				const i = Gt(this.lexerDefinitionErrors, s => s.message).join(`-----------------------
`); throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
`+ i)
			} return this.tokenizeInternal(e, t)
		} tokenizeInternal(e, t) { let r, i, s, a, o, l, u, c, h, d, m, g, v, y, A; const _ = e, x = _.length; let C = 0, T = 0; const I = this.hasCustom ? 0 : Math.floor(e.length / 10), w = new Array(I), R = []; let b = this.trackStartLines ? 1 : void 0, B = this.trackStartLines ? 1 : void 0; const F = J0e(this.emptyGroups), U = this.trackStartLines, G = this.config.lineTerminatorsPattern; let Y = 0, Z = [], ne = []; const $ = [], L = []; Object.freeze(L); let Q; function D() { return Z } function V(Fe) { const we = Qh(Fe), ge = ne[we]; return ge === void 0 ? L : ge } const J = Fe => { if ($.length === 1 && Fe.tokenType.PUSH_MODE === void 0) { const we = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(Fe); R.push({ offset: Fe.startOffset, line: Fe.startLine, column: Fe.startColumn, length: Fe.image.length, message: we }) } else { $.pop(); const we = cm($); Z = this.patternIdxToConfig[we], ne = this.charCodeToPatternIdxToConfig[we], Y = Z.length; const ge = this.canModeBeOptimized[we] && this.config.safeMode === !1; ne && ge ? Q = V : Q = D } }; function Ee(Fe) { $.push(Fe), ne = this.charCodeToPatternIdxToConfig[Fe], Z = this.patternIdxToConfig[Fe], Y = Z.length, Y = Z.length; const we = this.canModeBeOptimized[Fe] && this.config.safeMode === !1; ne && we ? Q = V : Q = D } Ee.call(this, t); let xe; const Be = this.config.recoveryEnabled; for (; C < x;) { l = null; const Fe = _.charCodeAt(C), we = Q(Fe), ge = we.length; for (r = 0; r < ge; r++) { xe = we[r]; const tt = xe.pattern; u = null; const je = xe.short; if (je !== !1 ? Fe === je && (l = tt) : xe.isCustom === !0 ? (A = tt.exec(_, C, w, F), A !== null ? (l = A[0], A.payload !== void 0 && (u = A.payload)) : l = null) : (this.updateLastIndex(tt, C), l = this.match(tt, e, C)), l !== null) { if (o = xe.longerAlt, o !== void 0) { const Oe = o.length; for (s = 0; s < Oe; s++) { const K = Z[o[s]], de = K.pattern; if (c = null, K.isCustom === !0 ? (A = de.exec(_, C, w, F), A !== null ? (a = A[0], A.payload !== void 0 && (c = A.payload)) : a = null) : (this.updateLastIndex(de, C), a = this.match(de, e, C)), a && a.length > l.length) { l = a, u = c, xe = K; break } } } break } } if (l !== null) { if (h = l.length, d = xe.group, d !== void 0 && (m = xe.tokenTypeIdx, g = this.createTokenInstance(l, C, m, xe.tokenType, b, B, h), this.handlePayload(g, u), d === !1 ? T = this.addToken(w, T, g) : F[d].push(g)), e = this.chopInput(e, h), C = C + h, B = this.computeNewColumn(B, h), U === !0 && xe.canLineTerminator === !0) { let tt = 0, je, Oe; G.lastIndex = 0; do je = G.test(l), je === !0 && (Oe = G.lastIndex - 1, tt++); while (je === !0); tt !== 0 && (b = b + tt, B = h - Oe, this.updateTokenEndLineColumnLocation(g, d, Oe, tt, b, B, h)) } this.handleModes(xe, J, Ee, g) } else { const tt = C, je = b, Oe = B; let K = Be === !1; for (; K === !1 && C < x;)for (e = this.chopInput(e, 1), C++, i = 0; i < Y; i++) { const de = Z[i], Ce = de.pattern, Qe = de.short; if (Qe !== !1 ? _.charCodeAt(C) === Qe && (K = !0) : de.isCustom === !0 ? K = Ce.exec(_, C, w, F) !== null : (this.updateLastIndex(Ce, C), K = Ce.exec(e) !== null), K === !0) break } if (v = C - tt, B = this.computeNewColumn(B, v), y = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(_, tt, v, je, Oe), R.push({ offset: tt, line: je, column: Oe, length: v, message: y }), Be === !1) break } } return this.hasCustom || (w.length = T), { tokens: w, groups: F, errors: R } } handleModes(e, t, r, i) { if (e.pop === !0) { const s = e.push; t(i), s !== void 0 && r.call(this, s) } else e.push !== void 0 && r.call(this, e.push) } chopInput(e, t) { return e.substring(t) } updateLastIndex(e, t) { e.lastIndex = t } updateTokenEndLineColumnLocation(e, t, r, i, s, a, o) { let l, u; t !== void 0 && (l = r === o - 1, u = l ? -1 : 0, i === 1 && l === !0 || (e.endLine = s + u, e.endColumn = a - 1 + -u)) } computeNewColumn(e, t) { return e + t } createOffsetOnlyToken(e, t, r, i) { return { image: e, startOffset: t, tokenTypeIdx: r, tokenType: i } } createStartOnlyToken(e, t, r, i, s, a) { return { image: e, startOffset: t, startLine: s, startColumn: a, tokenTypeIdx: r, tokenType: i } } createFullToken(e, t, r, i, s, a, o) { return { image: e, startOffset: t, endOffset: t + o - 1, startLine: s, endLine: s, startColumn: a, endColumn: a + o - 1, tokenTypeIdx: r, tokenType: i } } addTokenUsingPush(e, t, r) { return e.push(r), t } addTokenUsingMemberAccess(e, t, r) { return e[t] = r, t++, t } handlePayloadNoCustom(e, t) { } handlePayloadWithCustom(e, t) { t !== null && (e.payload = t) } matchWithTest(e, t, r) { return e.test(t) === !0 ? t.substring(r, e.lastIndex) : null } matchWithExec(e, t) { const r = e.exec(t); return r !== null ? r[0] : null }
	} Ml.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace."; Ml.NA = /NOT_APPLICABLE/; function pA(n) { return GQ(n) ? n.LABEL : n.name } function GQ(n) { return po(n.LABEL) && n.LABEL !== "" } const l3e = "parent", NP = "categories", OP = "label", UP = "group", GP = "push_mode", QP = "pop_mode", HP = "longer_alt", zP = "line_breaks", VP = "start_chars_hint"; function QQ(n) { return u3e(n) } function u3e(n) {
		const e = n.pattern, t = {}; if (t.name = n.name, yf(e) || (t.PATTERN = e), Zt(n, l3e)) throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`; return Zt(n, NP) && (t.CATEGORIES = n[NP]), a2([t]), Zt(n, OP) && (t.LABEL = n[OP]), Zt(n, UP) && (t.GROUP = n[UP]), Zt(n, QP) && (t.POP_MODE = n[QP]), Zt(n, GP) && (t.PUSH_MODE = n[GP]), Zt(n, HP) && (t.LONGER_ALT = n[HP]), Zt(n, zP) && (t.LINE_BREAKS = n[zP]), Zt(n, VP) && (t.START_CHARS_HINT = n[VP]), t
	} const Dp = QQ({ name: "EOF", pattern: Ml.NA }); a2([Dp]); function JT(n, e, t, r, i, s, a, o) { return { image: e, startOffset: t, endOffset: r, startLine: i, endLine: s, startColumn: a, endColumn: o, tokenTypeIdx: n.tokenTypeIdx, tokenType: n } } function c3e(n, e) { return s2(n, e) } const HQ = {
		buildMismatchTokenMessage({ expected: n, actual: e, previous: t, ruleName: r }) { return `Expecting ${GQ(n) ? `--> ${pA(n)} <--` : `token of type --> ${n.name} <--`} but found --> '${e.image}' <--` }, buildNotAllInputParsedMessage({ firstRedundant: n, ruleName: e }) { return "Redundant input, expecting EOF but found: " + n.image }, buildNoViableAltMessage({ expectedPathsPerAlt: n, actual: e, previous: t, customUserDescription: r, ruleName: i }) {
			const s = "Expecting: ", o = `
but found: '`+ Cu(e).image + "'"; if (r) return s + r + o; {
				const l = Xo(n, (d, m) => d.concat(m), []), u = Gt(l, d => `[${Gt(d, m => pA(m)).join(", ")}]`), h = `one of these possible Token sequences:
${Gt(u, (d, m) => `  ${m + 1}. ${d}`).join(`
`)}`; return s + h + o
			}
		}, buildEarlyExitMessage({ expectedIterationPaths: n, actual: e, customUserDescription: t, ruleName: r }) {
			const i = "Expecting: ", a = `
but found: '`+ Cu(e).image + "'"; if (t) return i + t + a; {
				const l = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${Gt(n, u => `[${Gt(u, c => pA(c)).join(",")}]`).join(" ,")}>`; return i + l + a
			}
		}
	}; Object.freeze(HQ); const f3e = {
		buildRuleNotFoundError(n, e) {
			return "Invalid grammar, reference to a rule which is not defined: ->" + e.nonTerminalName + `<-
inside top level rule: ->`+ n.name + "<-"
		}
	}, tp = {
		buildDuplicateFoundError(n, e) {
			function t(c) { return c instanceof vi ? c.terminalType.name : c instanceof Yo ? c.nonTerminalName : "" } const r = n.name, i = Cu(e), s = i.idx, a = Yu(i), o = t(i), l = s > 0; let u = `->${a}${l ? s : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${e.length} times) in the top level rule: ->${r}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `; return u = u.replace(/[ \t]+/g, " "), u = u.replace(/\s\s+/g, `
`), u
		}, buildNamespaceConflictError(n) {
			return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${n.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`}, buildAlternationPrefixAmbiguityError(n) {
			const e = Gt(n.prefixPath, i => pA(i)).join(", "), t = n.alternation.idx === 0 ? "" : n.alternation.idx; return `Ambiguous alternatives: <${n.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${t}> inside <${n.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`}, buildAlternationAmbiguityError(n) {
			const e = Gt(n.prefixPath, i => pA(i)).join(", "), t = n.alternation.idx === 0 ? "" : n.alternation.idx; let r = `Ambiguous Alternatives Detected: <${n.ambiguityIndices.join(" ,")}> in <OR${t}> inside <${n.topLevelRule.name}> Rule,
<${e}> may appears as a prefix path in all these alternatives.
`; return r = r + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, r
		}, buildEmptyRepetitionError(n) {
			let e = Yu(n.repetition); return n.repetition.idx !== 0 && (e += n.repetition.idx), `The repetition <${e}> within Rule <${n.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`}, buildTokenNameError(n) { return "deprecated" }, buildEmptyAlternationError(n) {
			return `Ambiguous empty alternative: <${n.emptyChoiceIdx + 1}> in <OR${n.alternation.idx}> inside <${n.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`}, buildTooManyAlternativesError(n) {
			return `An Alternation cannot have more than 256 alternatives:
<OR${n.alternation.idx}> inside <${n.topLevelRule.name}> Rule.
 has ${n.alternation.definition.length + 1} alternatives.`
		}, buildLeftRecursionError(n) {
			const e = n.topLevelRule.name, t = Gt(n.leftRecursionPath, s => s.name), r = `${e} --> ${t.concat([e]).join(" --> ")}`; return `Left Recursion found in grammar.
rule: <${e}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${r}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`}, buildInvalidRuleNameError(n) { return "deprecated" }, buildDuplicateRuleNameError(n) { let e; return n.topLevelRule instanceof wm ? e = n.topLevelRule.name : e = n.topLevelRule, `Duplicate definition, rule: ->${e}<- is already defined in the grammar: ->${n.grammarName}<-` }
	}; function h3e(n, e) { const t = new d3e(n, e); return t.resolveRefs(), t.errors } class d3e extends Im { constructor(e, t) { super(), this.nameToTopRule = e, this.errMsgProvider = t, this.errors = [] } resolveRefs() { tn(gs(this.nameToTopRule), e => { this.currTopLevel = e, e.accept(this) }) } visitNonTerminal(e) { const t = this.nameToTopRule[e.nonTerminalName]; if (t) e.referencedRule = t; else { const r = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e); this.errors.push({ message: r, type: Ga.UNRESOLVED_SUBRULE_REF, ruleName: this.currTopLevel.name, unresolvedRefName: e.nonTerminalName }) } } } class p3e extends q8 { constructor(e, t) { super(), this.topProd = e, this.path = t, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1 } startWalking() { if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!"); return this.ruleStack = ga(this.path.ruleStack).reverse(), this.occurrenceStack = ga(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes } walk(e, t = []) { this.found || super.walk(e, t) } walkProdRef(e, t, r) { if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) { const i = t.concat(r); this.updateExpectedNext(), this.walk(e.referencedRule, i) } } updateExpectedNext() { Hr(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop()) } } class m3e extends p3e { constructor(e, t) { super(e, t), this.path = t, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence } walkTerminal(e, t, r) { if (this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found) { const i = t.concat(r), s = new mo({ definition: i }); this.possibleTokTypes = i2(s), this.found = !0 } } } class $8 extends q8 { constructor(e, t) { super(), this.topRule = e, this.occurrence = t, this.result = { token: void 0, occurrence: void 0, isEndOfRule: void 0 } } startWalking() { return this.walk(this.topRule), this.result } } class g3e extends $8 { walkMany(e, t, r) { if (e.idx === this.occurrence) { const i = Cu(t.concat(r)); this.result.isEndOfRule = i === void 0, i instanceof vi && (this.result.token = i.terminalType, this.result.occurrence = i.idx) } else super.walkMany(e, t, r) } } class WP extends $8 { walkManySep(e, t, r) { if (e.idx === this.occurrence) { const i = Cu(t.concat(r)); this.result.isEndOfRule = i === void 0, i instanceof vi && (this.result.token = i.terminalType, this.result.occurrence = i.idx) } else super.walkManySep(e, t, r) } } class A3e extends $8 { walkAtLeastOne(e, t, r) { if (e.idx === this.occurrence) { const i = Cu(t.concat(r)); this.result.isEndOfRule = i === void 0, i instanceof vi && (this.result.token = i.terminalType, this.result.occurrence = i.idx) } else super.walkAtLeastOne(e, t, r) } } class XP extends $8 { walkAtLeastOneSep(e, t, r) { if (e.idx === this.occurrence) { const i = Cu(t.concat(r)); this.result.isEndOfRule = i === void 0, i instanceof vi && (this.result.token = i.terminalType, this.result.occurrence = i.idx) } else super.walkAtLeastOneSep(e, t, r) } } function Q7(n, e, t = []) { t = ga(t); let r = [], i = 0; function s(o) { return o.concat(Ys(n, i + 1)) } function a(o) { const l = Q7(s(o), e, t); return r.concat(l) } for (; t.length < e && i < n.length;) { const o = n[i]; if (o instanceof mo) return a(o.definition); if (o instanceof Yo) return a(o.definition); if (o instanceof fo) r = a(o.definition); else if (o instanceof Ec) { const l = o.definition.concat([new vs({ definition: o.definition })]); return a(l) } else if (o instanceof Cc) { const l = [new mo({ definition: o.definition }), new vs({ definition: [new vi({ terminalType: o.separator })].concat(o.definition) })]; return a(l) } else if (o instanceof Pu) { const l = o.definition.concat([new vs({ definition: [new vi({ terminalType: o.separator })].concat(o.definition) })]); r = a(l) } else if (o instanceof vs) { const l = o.definition.concat([new vs({ definition: o.definition })]); r = a(l) } else { if (o instanceof Du) return tn(o.definition, l => { Hr(l.definition) === !1 && (r = a(l.definition)) }), r; if (o instanceof vi) t.push(o.terminalType); else throw Error("non exhaustive match") } i++ } return r.push({ partialPath: t, suffixDef: Ys(n, i) }), r } function zQ(n, e, t, r) { const i = "EXIT_NONE_TERMINAL", s = [i], a = "EXIT_ALTERNATIVE"; let o = !1; const l = e.length, u = l - r - 1, c = [], h = []; for (h.push({ idx: -1, def: n, ruleStack: [], occurrenceStack: [] }); !Hr(h);) { const d = h.pop(); if (d === a) { o && cm(h).idx <= u && h.pop(); continue } const m = d.def, g = d.idx, v = d.ruleStack, y = d.occurrenceStack; if (Hr(m)) continue; const A = m[0]; if (A === i) { const _ = { idx: g, def: Ys(m), ruleStack: y1(v), occurrenceStack: y1(y) }; h.push(_) } else if (A instanceof vi) if (g < l - 1) { const _ = g + 1, x = e[_]; if (t(x, A.terminalType)) { const C = { idx: _, def: Ys(m), ruleStack: v, occurrenceStack: y }; h.push(C) } } else if (g === l - 1) c.push({ nextTokenType: A.terminalType, nextTokenOccurrence: A.idx, ruleStack: v, occurrenceStack: y }), o = !0; else throw Error("non exhaustive match"); else if (A instanceof Yo) { const _ = ga(v); _.push(A.nonTerminalName); const x = ga(y); x.push(A.idx); const C = { idx: g, def: A.definition.concat(s, Ys(m)), ruleStack: _, occurrenceStack: x }; h.push(C) } else if (A instanceof fo) { const _ = { idx: g, def: Ys(m), ruleStack: v, occurrenceStack: y }; h.push(_), h.push(a); const x = { idx: g, def: A.definition.concat(Ys(m)), ruleStack: v, occurrenceStack: y }; h.push(x) } else if (A instanceof Ec) { const _ = new vs({ definition: A.definition, idx: A.idx }), x = A.definition.concat([_], Ys(m)), C = { idx: g, def: x, ruleStack: v, occurrenceStack: y }; h.push(C) } else if (A instanceof Cc) { const _ = new vi({ terminalType: A.separator }), x = new vs({ definition: [_].concat(A.definition), idx: A.idx }), C = A.definition.concat([x], Ys(m)), T = { idx: g, def: C, ruleStack: v, occurrenceStack: y }; h.push(T) } else if (A instanceof Pu) { const _ = { idx: g, def: Ys(m), ruleStack: v, occurrenceStack: y }; h.push(_), h.push(a); const x = new vi({ terminalType: A.separator }), C = new vs({ definition: [x].concat(A.definition), idx: A.idx }), T = A.definition.concat([C], Ys(m)), I = { idx: g, def: T, ruleStack: v, occurrenceStack: y }; h.push(I) } else if (A instanceof vs) { const _ = { idx: g, def: Ys(m), ruleStack: v, occurrenceStack: y }; h.push(_), h.push(a); const x = new vs({ definition: A.definition, idx: A.idx }), C = A.definition.concat([x], Ys(m)), T = { idx: g, def: C, ruleStack: v, occurrenceStack: y }; h.push(T) } else if (A instanceof Du) for (let _ = A.definition.length - 1; _ >= 0; _--) { const x = A.definition[_], C = { idx: g, def: x.definition.concat(Ys(m)), ruleStack: v, occurrenceStack: y }; h.push(C), h.push(a) } else if (A instanceof mo) h.push({ idx: g, def: A.definition.concat(Ys(m)), ruleStack: v, occurrenceStack: y }); else if (A instanceof wm) h.push(v3e(A, g, v, y)); else throw Error("non exhaustive match") } return c } function v3e(n, e, t, r) { const i = ga(t); i.push(n.name); const s = ga(r); return s.push(1), { idx: e, def: n.definition, ruleStack: i, occurrenceStack: s } } var Bi; (function (n) { n[n.OPTION = 0] = "OPTION", n[n.REPETITION = 1] = "REPETITION", n[n.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", n[n.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", n[n.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", n[n.ALTERNATION = 5] = "ALTERNATION" })(Bi || (Bi = {})); function VQ(n) { if (n instanceof fo || n === "Option") return Bi.OPTION; if (n instanceof vs || n === "Repetition") return Bi.REPETITION; if (n instanceof Ec || n === "RepetitionMandatory") return Bi.REPETITION_MANDATORY; if (n instanceof Cc || n === "RepetitionMandatoryWithSeparator") return Bi.REPETITION_MANDATORY_WITH_SEPARATOR; if (n instanceof Pu || n === "RepetitionWithSeparator") return Bi.REPETITION_WITH_SEPARATOR; if (n instanceof Du || n === "Alternation") return Bi.ALTERNATION; throw Error("non exhaustive match") } function y3e(n, e, t, r, i, s) { const a = KT(n, e, t), o = YQ(a) ? Sy : s2; return s(a, r, o, i) } function x3e(n, e, t, r, i, s) { const a = qT(n, e, i, t), o = YQ(a) ? Sy : s2; return s(a[0], o, r) } function _3e(n, e, t, r) { const i = n.length, s = Au(n, a => Au(a, o => o.length === 1)); if (e) return function (a) { const o = Gt(a, l => l.GATE); for (let l = 0; l < i; l++) { const u = n[l], c = u.length, h = o[l]; if (!(h !== void 0 && h.call(this) === !1)) e: for (let d = 0; d < c; d++) { const m = u[d], g = m.length; for (let v = 0; v < g; v++) { const y = this.LA(v + 1); if (t(y, m[v]) === !1) continue e } return l } } }; if (s && !r) { const a = Gt(n, l => gu(l)), o = Xo(a, (l, u, c) => (tn(u, h => { Zt(l, h.tokenTypeIdx) || (l[h.tokenTypeIdx] = c), tn(h.categoryMatches, d => { Zt(l, d) || (l[d] = c) }) }), l), {}); return function () { const l = this.LA(1); return o[l.tokenTypeIdx] } } else return function () { for (let a = 0; a < i; a++) { const o = n[a], l = o.length; e: for (let u = 0; u < l; u++) { const c = o[u], h = c.length; for (let d = 0; d < h; d++) { const m = this.LA(d + 1); if (t(m, c[d]) === !1) continue e } return a } } } } function E3e(n, e, t) { const r = Au(n, s => s.length === 1), i = n.length; if (r && !t) { const s = gu(n); if (s.length === 1 && Hr(s[0].categoryMatches)) { const o = s[0].tokenTypeIdx; return function () { return this.LA(1).tokenTypeIdx === o } } else { const a = Xo(s, (o, l, u) => (o[l.tokenTypeIdx] = !0, tn(l.categoryMatches, c => { o[c] = !0 }), o), []); return function () { const o = this.LA(1); return a[o.tokenTypeIdx] === !0 } } } else return function () { e: for (let s = 0; s < i; s++) { const a = n[s], o = a.length; for (let l = 0; l < o; l++) { const u = this.LA(l + 1); if (e(u, a[l]) === !1) continue e } return !0 } return !1 } } class C3e extends q8 { constructor(e, t, r) { super(), this.topProd = e, this.targetOccurrence = t, this.targetProdType = r } startWalking() { return this.walk(this.topProd), this.restDef } checkIsTarget(e, t, r, i) { return e.idx === this.targetOccurrence && this.targetProdType === t ? (this.restDef = r.concat(i), !0) : !1 } walkOption(e, t, r) { this.checkIsTarget(e, Bi.OPTION, t, r) || super.walkOption(e, t, r) } walkAtLeastOne(e, t, r) { this.checkIsTarget(e, Bi.REPETITION_MANDATORY, t, r) || super.walkOption(e, t, r) } walkAtLeastOneSep(e, t, r) { this.checkIsTarget(e, Bi.REPETITION_MANDATORY_WITH_SEPARATOR, t, r) || super.walkOption(e, t, r) } walkMany(e, t, r) { this.checkIsTarget(e, Bi.REPETITION, t, r) || super.walkOption(e, t, r) } walkManySep(e, t, r) { this.checkIsTarget(e, Bi.REPETITION_WITH_SEPARATOR, t, r) || super.walkOption(e, t, r) } } class WQ extends Im { constructor(e, t, r) { super(), this.targetOccurrence = e, this.targetProdType = t, this.targetRef = r, this.result = [] } checkIsTarget(e, t) { e.idx === this.targetOccurrence && this.targetProdType === t && (this.targetRef === void 0 || e === this.targetRef) && (this.result = e.definition) } visitOption(e) { this.checkIsTarget(e, Bi.OPTION) } visitRepetition(e) { this.checkIsTarget(e, Bi.REPETITION) } visitRepetitionMandatory(e) { this.checkIsTarget(e, Bi.REPETITION_MANDATORY) } visitRepetitionMandatoryWithSeparator(e) { this.checkIsTarget(e, Bi.REPETITION_MANDATORY_WITH_SEPARATOR) } visitRepetitionWithSeparator(e) { this.checkIsTarget(e, Bi.REPETITION_WITH_SEPARATOR) } visitAlternation(e) { this.checkIsTarget(e, Bi.ALTERNATION) } } function YP(n) { const e = new Array(n); for (let t = 0; t < n; t++)e[t] = []; return e } function N_(n) { let e = [""]; for (let t = 0; t < n.length; t++) { const r = n[t], i = []; for (let s = 0; s < e.length; s++) { const a = e[s]; i.push(a + "_" + r.tokenTypeIdx); for (let o = 0; o < r.categoryMatches.length; o++) { const l = "_" + r.categoryMatches[o]; i.push(a + l) } } e = i } return e } function S3e(n, e, t) { for (let r = 0; r < n.length; r++) { if (r === t) continue; const i = n[r]; for (let s = 0; s < e.length; s++) { const a = e[s]; if (i[a] === !0) return !1 } } return !0 } function XQ(n, e) { const t = Gt(n, a => Q7([a], 1)), r = YP(t.length), i = Gt(t, a => { const o = {}; return tn(a, l => { const u = N_(l.partialPath); tn(u, c => { o[c] = !0 }) }), o }); let s = t; for (let a = 1; a <= e; a++) { const o = s; s = YP(o.length); for (let l = 0; l < o.length; l++) { const u = o[l]; for (let c = 0; c < u.length; c++) { const h = u[c].partialPath, d = u[c].suffixDef, m = N_(h); if (S3e(i, m, l) || Hr(d) || h.length === e) { const v = r[l]; if (H7(v, h) === !1) { v.push(h); for (let y = 0; y < m.length; y++) { const A = m[y]; i[l][A] = !0 } } } else { const v = Q7(d, a + 1, h); s[l] = s[l].concat(v), tn(v, y => { const A = N_(y.partialPath); tn(A, _ => { i[l][_] = !0 }) }) } } } } return r } function KT(n, e, t, r) { const i = new WQ(n, Bi.ALTERNATION, r); return e.accept(i), XQ(i.result, t) } function qT(n, e, t, r) { const i = new WQ(n, t); e.accept(i); const s = i.result, o = new C3e(e, n, t).startWalking(), l = new mo({ definition: s }), u = new mo({ definition: o }); return XQ([l, u], r) } function H7(n, e) { e: for (let t = 0; t < n.length; t++) { const r = n[t]; if (r.length === e.length) { for (let i = 0; i < r.length; i++) { const s = e[i], a = r[i]; if ((s === a || a.categoryMatchesMap[s.tokenTypeIdx] !== void 0) === !1) continue e } return !0 } } return !1 } function T3e(n, e) { return n.length < e.length && Au(n, (t, r) => { const i = e[r]; return t === i || i.categoryMatchesMap[t.tokenTypeIdx] }) } function YQ(n) { return Au(n, e => Au(e, t => Au(t, r => Hr(r.categoryMatches)))) } function w3e(n) { const e = n.lookaheadStrategy.validate({ rules: n.rules, tokenTypes: n.tokenTypes, grammarName: n.grammarName }); return Gt(e, t => Object.assign({ type: Ga.CUSTOM_LOOKAHEAD_VALIDATION }, t)) } function I3e(n, e, t, r) { const i = Il(n, l => M3e(l, t)), s = G3e(n, e, t), a = Il(n, l => k3e(l, t)), o = Il(n, l => R3e(l, n, r, t)); return i.concat(s, a, o) } function M3e(n, e) { const t = new B3e; n.accept(t); const r = t.allProductions, i = Ope(r, b3e), s = Ru(i, o => o.length > 1); return Gt(gs(s), o => { const l = Cu(o), u = e.buildDuplicateFoundError(n, o), c = Yu(l), h = { message: u, type: Ga.DUPLICATE_PRODUCTIONS, ruleName: n.name, dslName: c, occurrence: l.idx }, d = jQ(l); return d && (h.parameter = d), h }) } function b3e(n) { return `${Yu(n)}_#_${n.idx}_#_${jQ(n)}` } function jQ(n) { return n instanceof vi ? n.terminalType.name : n instanceof Yo ? n.nonTerminalName : "" } class B3e extends Im { constructor() { super(...arguments), this.allProductions = [] } visitNonTerminal(e) { this.allProductions.push(e) } visitOption(e) { this.allProductions.push(e) } visitRepetitionWithSeparator(e) { this.allProductions.push(e) } visitRepetitionMandatory(e) { this.allProductions.push(e) } visitRepetitionMandatoryWithSeparator(e) { this.allProductions.push(e) } visitRepetition(e) { this.allProductions.push(e) } visitAlternation(e) { this.allProductions.push(e) } visitTerminal(e) { this.allProductions.push(e) } } function R3e(n, e, t, r) { const i = []; if (Xo(e, (a, o) => o.name === n.name ? a + 1 : a, 0) > 1) { const a = r.buildDuplicateRuleNameError({ topLevelRule: n, grammarName: t }); i.push({ message: a, type: Ga.DUPLICATE_RULE_NAME, ruleName: n.name }) } return i } function P3e(n, e, t) { const r = []; let i; return za(e, n) || (i = `Invalid rule override, rule: ->${n}<- cannot be overridden in the grammar: ->${t}<-as it is not defined in any of the super grammars `, r.push({ message: i, type: Ga.INVALID_RULE_OVERRIDE, ruleName: n })), r } function JQ(n, e, t, r = []) { const i = [], s = A6(e.definition); if (Hr(s)) return []; { const a = n.name; za(s, n) && i.push({ message: t.buildLeftRecursionError({ topLevelRule: n, leftRecursionPath: r }), type: Ga.LEFT_RECURSION, ruleName: a }); const l = J8(s, r.concat([n])), u = Il(l, c => { const h = ga(r); return h.push(c), JQ(n, c, t, h) }); return i.concat(u) } } function A6(n) { let e = []; if (Hr(n)) return e; const t = Cu(n); if (t instanceof Yo) e.push(t.referencedRule); else if (t instanceof mo || t instanceof fo || t instanceof Ec || t instanceof Cc || t instanceof Pu || t instanceof vs) e = e.concat(A6(t.definition)); else if (t instanceof Du) e = gu(Gt(t.definition, s => A6(s.definition))); else if (!(t instanceof vi)) throw Error("non exhaustive match"); const r = xy(t), i = n.length > 1; if (r && i) { const s = Ys(n); return e.concat(A6(s)) } else return e } class ZT extends Im { constructor() { super(...arguments), this.alternations = [] } visitAlternation(e) { this.alternations.push(e) } } function D3e(n, e) { const t = new ZT; n.accept(t); const r = t.alternations; return Il(r, s => { const a = y1(s.definition); return Il(a, (o, l) => { const u = zQ([o], [], s2, 1); return Hr(u) ? [{ message: e.buildEmptyAlternationError({ topLevelRule: n, alternation: s, emptyChoiceIdx: l }), type: Ga.NONE_LAST_EMPTY_ALT, ruleName: n.name, occurrence: s.idx, alternative: l + 1 }] : [] }) }) } function L3e(n, e, t) { const r = new ZT; n.accept(r); let i = r.alternations; return i = K8(i, a => a.ignoreAmbiguities === !0), Il(i, a => { const o = a.idx, l = a.maxLookahead || e, u = KT(o, n, l, a), c = O3e(u, a, n, t), h = U3e(u, a, n, t); return c.concat(h) }) } class F3e extends Im { constructor() { super(...arguments), this.allProductions = [] } visitRepetitionWithSeparator(e) { this.allProductions.push(e) } visitRepetitionMandatory(e) { this.allProductions.push(e) } visitRepetitionMandatoryWithSeparator(e) { this.allProductions.push(e) } visitRepetition(e) { this.allProductions.push(e) } } function k3e(n, e) { const t = new ZT; n.accept(t); const r = t.alternations; return Il(r, s => s.definition.length > 255 ? [{ message: e.buildTooManyAlternativesError({ topLevelRule: n, alternation: s }), type: Ga.TOO_MANY_ALTS, ruleName: n.name, occurrence: s.idx }] : []) } function N3e(n, e, t) { const r = []; return tn(n, i => { const s = new F3e; i.accept(s); const a = s.allProductions; tn(a, o => { const l = VQ(o), u = o.maxLookahead || e, c = o.idx, d = qT(c, i, l, u)[0]; if (Hr(gu(d))) { const m = t.buildEmptyRepetitionError({ topLevelRule: i, repetition: o }); r.push({ message: m, type: Ga.NO_NON_EMPTY_LOOKAHEAD, ruleName: i.name }) } }) }), r } function O3e(n, e, t, r) { const i = [], s = Xo(n, (o, l, u) => (e.definition[u].ignoreAmbiguities === !0 || tn(l, c => { const h = [u]; tn(n, (d, m) => { u !== m && H7(d, c) && e.definition[m].ignoreAmbiguities !== !0 && h.push(m) }), h.length > 1 && !H7(i, c) && (i.push(c), o.push({ alts: h, path: c })) }), o), []); return Gt(s, o => { const l = Gt(o.alts, c => c + 1); return { message: r.buildAlternationAmbiguityError({ topLevelRule: t, alternation: e, ambiguityIndices: l, prefixPath: o.path }), type: Ga.AMBIGUOUS_ALTS, ruleName: t.name, occurrence: e.idx, alternatives: o.alts } }) } function U3e(n, e, t, r) { const i = Xo(n, (a, o, l) => { const u = Gt(o, c => ({ idx: l, path: c })); return a.concat(u) }, []); return r2(Il(i, a => { if (e.definition[a.idx].ignoreAmbiguities === !0) return []; const l = a.idx, u = a.path, c = Ol(i, d => e.definition[d.idx].ignoreAmbiguities !== !0 && d.idx < l && T3e(d.path, u)); return Gt(c, d => { const m = [d.idx + 1, l + 1], g = e.idx === 0 ? "" : e.idx; return { message: r.buildAlternationPrefixAmbiguityError({ topLevelRule: t, alternation: e, ambiguityIndices: m, prefixPath: d.path }), type: Ga.AMBIGUOUS_PREFIX_ALTS, ruleName: t.name, occurrence: g, alternatives: m } }) })) } function G3e(n, e, t) { const r = [], i = Gt(e, s => s.name); return tn(n, s => { const a = s.name; if (za(i, a)) { const o = t.buildNamespaceConflictError(s); r.push({ message: o, type: Ga.CONFLICT_TOKENS_RULES_NAMESPACE, ruleName: a }) } }), r } function Q3e(n) { const e = WT(n, { errMsgProvider: f3e }), t = {}; return tn(n.rules, r => { t[r.name] = r }), h3e(t, e.errMsgProvider) } function H3e(n) { return n = WT(n, { errMsgProvider: tp }), I3e(n.rules, n.tokenTypes, n.errMsgProvider, n.grammarName) } const KQ = "MismatchedTokenException", qQ = "NoViableAltException", ZQ = "EarlyExitException", $Q = "NotAllInputParsedException", eH = [KQ, qQ, ZQ, $Q]; Object.freeze(eH); function Ty(n) { return za(eH, n.name) } class e4 extends Error { constructor(e, t) { super(e), this.token = t, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor) } } class tH extends e4 { constructor(e, t, r) { super(e, t), this.previousToken = r, this.name = KQ } } class z3e extends e4 { constructor(e, t, r) { super(e, t), this.previousToken = r, this.name = qQ } } class V3e extends e4 { constructor(e, t) { super(e, t), this.name = $Q } } class W3e extends e4 { constructor(e, t, r) { super(e, t), this.previousToken = r, this.name = ZQ } } const O_ = {}, nH = "InRuleRecoveryException"; class X3e extends Error { constructor(e) { super(e), this.name = nH } } class Y3e { initRecoverable(e) { this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = Zt(e, "recoveryEnabled") ? e.recoveryEnabled : Hh.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = j3e) } getTokenToInsert(e) { const t = JT(e, "", NaN, NaN, NaN, NaN, NaN, NaN); return t.isInsertedInRecovery = !0, t } canTokenTypeBeInsertedInRecovery(e) { return !0 } canTokenTypeBeDeletedInRecovery(e) { return !0 } tryInRepetitionRecovery(e, t, r, i) { const s = this.findReSyncTokenType(), a = this.exportLexerState(), o = []; let l = !1; const u = this.LA(1); let c = this.LA(1); const h = () => { const d = this.LA(0), m = this.errorMessageProvider.buildMismatchTokenMessage({ expected: i, actual: u, previous: d, ruleName: this.getCurrRuleFullName() }), g = new tH(m, u, this.LA(0)); g.resyncedTokens = y1(o), this.SAVE_ERROR(g) }; for (; !l;)if (this.tokenMatcher(c, i)) { h(); return } else if (r.call(this)) { h(), e.apply(this, t); return } else this.tokenMatcher(c, s) ? l = !0 : (c = this.SKIP_TOKEN(), this.addToResyncTokens(c, o)); this.importLexerState(a) } shouldInRepetitionRecoveryBeTried(e, t, r) { return !(r === !1 || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, t))) } getFollowsForInRuleRecovery(e, t) { const r = this.getCurrentGrammarPath(e, t); return this.getNextPossibleTokenTypes(r) } tryInRuleRecovery(e, t) { if (this.canRecoverWithSingleTokenInsertion(e, t)) return this.getTokenToInsert(e); if (this.canRecoverWithSingleTokenDeletion(e)) { const r = this.SKIP_TOKEN(); return this.consumeToken(), r } throw new X3e("sad sad panda") } canPerformInRuleRecovery(e, t) { return this.canRecoverWithSingleTokenInsertion(e, t) || this.canRecoverWithSingleTokenDeletion(e) } canRecoverWithSingleTokenInsertion(e, t) { if (!this.canTokenTypeBeInsertedInRecovery(e) || Hr(t)) return !1; const r = this.LA(1); return fm(t, s => this.tokenMatcher(r, s)) !== void 0 } canRecoverWithSingleTokenDeletion(e) { return this.canTokenTypeBeDeletedInRecovery(e) ? this.tokenMatcher(this.LA(2), e) : !1 } isInCurrentRuleReSyncSet(e) { const t = this.getCurrFollowKey(), r = this.getFollowSetFromFollowKey(t); return za(r, e) } findReSyncTokenType() { const e = this.flattenFollowSet(); let t = this.LA(1), r = 2; for (; ;) { const i = fm(e, s => c3e(t, s)); if (i !== void 0) return i; t = this.LA(r), r++ } } getCurrFollowKey() { if (this.RULE_STACK.length === 1) return O_; const e = this.getLastExplicitRuleShortName(), t = this.getLastExplicitRuleOccurrenceIndex(), r = this.getPreviousExplicitRuleShortName(); return { ruleName: this.shortRuleNameToFullName(e), idxInCallingRule: t, inRule: this.shortRuleNameToFullName(r) } } buildFullFollowKeyStack() { const e = this.RULE_STACK, t = this.RULE_OCCURRENCE_STACK; return Gt(e, (r, i) => i === 0 ? O_ : { ruleName: this.shortRuleNameToFullName(r), idxInCallingRule: t[i], inRule: this.shortRuleNameToFullName(e[i - 1]) }) } flattenFollowSet() { const e = Gt(this.buildFullFollowKeyStack(), t => this.getFollowSetFromFollowKey(t)); return gu(e) } getFollowSetFromFollowKey(e) { if (e === O_) return [Dp]; const t = e.ruleName + e.idxInCallingRule + RQ + e.inRule; return this.resyncFollows[t] } addToResyncTokens(e, t) { return this.tokenMatcher(e, Dp) || t.push(e), t } reSyncTo(e) { const t = []; let r = this.LA(1); for (; this.tokenMatcher(r, e) === !1;)r = this.SKIP_TOKEN(), this.addToResyncTokens(r, t); return y1(t) } attemptInRepetitionRecovery(e, t, r, i, s, a, o) { } getCurrentGrammarPath(e, t) { const r = this.getHumanReadableRuleStack(), i = ga(this.RULE_OCCURRENCE_STACK); return { ruleStack: r, occurrenceStack: i, lastTok: e, lastTokOccurrence: t } } getHumanReadableRuleStack() { return Gt(this.RULE_STACK, e => this.shortRuleNameToFullName(e)) } } function j3e(n, e, t, r, i, s, a) { const o = this.getKeyForAutomaticLookahead(r, i); let l = this.firstAfterRepMap[o]; if (l === void 0) { const d = this.getCurrRuleFullName(), m = this.getGAstProductions()[d]; l = new s(m, i).startWalking(), this.firstAfterRepMap[o] = l } let u = l.token, c = l.occurrence; const h = l.isEndOfRule; this.RULE_STACK.length === 1 && h && u === void 0 && (u = Dp, c = 1), !(u === void 0 || c === void 0) && this.shouldInRepetitionRecoveryBeTried(u, c, a) && this.tryInRepetitionRecovery(n, e, t, u) } const J3e = 4, ed = 8, rH = 1 << ed, iH = 2 << ed, z7 = 3 << ed, V7 = 4 << ed, W7 = 5 << ed, v6 = 6 << ed; function U_(n, e, t) { return t | e | n } class K3e { constructor(e) { var t; this.maxLookahead = (t = e == null ? void 0 : e.maxLookahead) !== null && t !== void 0 ? t : Hh.maxLookahead } validate(e) { const t = this.validateNoLeftRecursion(e.rules); if (Hr(t)) { const r = this.validateEmptyOrAlternatives(e.rules), i = this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead), s = this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead); return [...t, ...r, ...i, ...s] } return t } validateNoLeftRecursion(e) { return Il(e, t => JQ(t, t, tp)) } validateEmptyOrAlternatives(e) { return Il(e, t => D3e(t, tp)) } validateAmbiguousAlternationAlternatives(e, t) { return Il(e, r => L3e(r, t, tp)) } validateSomeNonEmptyLookaheadPath(e, t) { return N3e(e, t, tp) } buildLookaheadForAlternation(e) { return y3e(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, _3e) } buildLookaheadForOptional(e) { return x3e(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, VQ(e.prodType), E3e) } } class q3e { initLooksAhead(e) { this.dynamicTokensEnabled = Zt(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : Hh.dynamicTokensEnabled, this.maxLookahead = Zt(e, "maxLookahead") ? e.maxLookahead : Hh.maxLookahead, this.lookaheadStrategy = Zt(e, "lookaheadStrategy") ? e.lookaheadStrategy : new K3e({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = new Map } preComputeLookaheadFunctions(e) { tn(e, t => { this.TRACE_INIT(`${t.name} Rule Lookahead`, () => { const { alternation: r, repetition: i, option: s, repetitionMandatory: a, repetitionMandatoryWithSeparator: o, repetitionWithSeparator: l } = $3e(t); tn(r, u => { const c = u.idx === 0 ? "" : u.idx; this.TRACE_INIT(`${Yu(u)}${c}`, () => { const h = this.lookaheadStrategy.buildLookaheadForAlternation({ prodOccurrence: u.idx, rule: t, maxLookahead: u.maxLookahead || this.maxLookahead, hasPredicates: u.hasPredicates, dynamicTokensEnabled: this.dynamicTokensEnabled }), d = U_(this.fullRuleNameToShort[t.name], rH, u.idx); this.setLaFuncCache(d, h) }) }), tn(i, u => { this.computeLookaheadFunc(t, u.idx, z7, "Repetition", u.maxLookahead, Yu(u)) }), tn(s, u => { this.computeLookaheadFunc(t, u.idx, iH, "Option", u.maxLookahead, Yu(u)) }), tn(a, u => { this.computeLookaheadFunc(t, u.idx, V7, "RepetitionMandatory", u.maxLookahead, Yu(u)) }), tn(o, u => { this.computeLookaheadFunc(t, u.idx, v6, "RepetitionMandatoryWithSeparator", u.maxLookahead, Yu(u)) }), tn(l, u => { this.computeLookaheadFunc(t, u.idx, W7, "RepetitionWithSeparator", u.maxLookahead, Yu(u)) }) }) }) } computeLookaheadFunc(e, t, r, i, s, a) { this.TRACE_INIT(`${a}${t === 0 ? "" : t}`, () => { const o = this.lookaheadStrategy.buildLookaheadForOptional({ prodOccurrence: t, rule: e, maxLookahead: s || this.maxLookahead, dynamicTokensEnabled: this.dynamicTokensEnabled, prodType: i }), l = U_(this.fullRuleNameToShort[e.name], r, t); this.setLaFuncCache(l, o) }) } getKeyForAutomaticLookahead(e, t) { const r = this.getLastExplicitRuleShortName(); return U_(r, e, t) } getLaFuncFromCache(e) { return this.lookAheadFuncsCache.get(e) } setLaFuncCache(e, t) { this.lookAheadFuncsCache.set(e, t) } } class Z3e extends Im { constructor() { super(...arguments), this.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] } } reset() { this.dslMethods = { option: [], alternation: [], repetition: [], repetitionWithSeparator: [], repetitionMandatory: [], repetitionMandatoryWithSeparator: [] } } visitOption(e) { this.dslMethods.option.push(e) } visitRepetitionWithSeparator(e) { this.dslMethods.repetitionWithSeparator.push(e) } visitRepetitionMandatory(e) { this.dslMethods.repetitionMandatory.push(e) } visitRepetitionMandatoryWithSeparator(e) { this.dslMethods.repetitionMandatoryWithSeparator.push(e) } visitRepetition(e) { this.dslMethods.repetition.push(e) } visitAlternation(e) { this.dslMethods.alternation.push(e) } } const w5 = new Z3e; function $3e(n) { w5.reset(), n.accept(w5); const e = w5.dslMethods; return w5.reset(), e } function jP(n, e) { isNaN(n.startOffset) === !0 ? (n.startOffset = e.startOffset, n.endOffset = e.endOffset) : n.endOffset < e.endOffset && (n.endOffset = e.endOffset) } function JP(n, e) { isNaN(n.startOffset) === !0 ? (n.startOffset = e.startOffset, n.startColumn = e.startColumn, n.startLine = e.startLine, n.endOffset = e.endOffset, n.endColumn = e.endColumn, n.endLine = e.endLine) : n.endOffset < e.endOffset && (n.endOffset = e.endOffset, n.endColumn = e.endColumn, n.endLine = e.endLine) } function eme(n, e, t) { n.children[t] === void 0 ? n.children[t] = [e] : n.children[t].push(e) } function tme(n, e, t) { n.children[e] === void 0 ? n.children[e] = [t] : n.children[e].push(t) } const nme = "name"; function sH(n, e) { Object.defineProperty(n, nme, { enumerable: !1, configurable: !0, writable: !1, value: e }) } function rme(n, e) { const t = Vo(n), r = t.length; for (let i = 0; i < r; i++) { const s = t[i], a = n[s], o = a.length; for (let l = 0; l < o; l++) { const u = a[l]; u.tokenTypeIdx === void 0 && this[u.name](u.children, e) } } } function ime(n, e) {
		const t = function () { }; sH(t, n + "BaseSemantics"); const r = {
			visit: function (i, s) { if (nr(i) && (i = i[0]), !yf(i)) return this[i.name](i.children, s) }, validateVisitor: function () {
				const i = ame(this, e); if (!Hr(i)) {
					const s = Gt(i, a => a.msg); throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${s.join(`

`).replace(/\n/g, `
	`)}`)
				}
			}
		}; return t.prototype = r, t.prototype.constructor = t, t._RULE_NAMES = e, t
	} function sme(n, e, t) { const r = function () { }; sH(r, n + "BaseSemanticsWithDefaults"); const i = Object.create(t.prototype); return tn(e, s => { i[s] = rme }), r.prototype = i, r.prototype.constructor = r, r } var X7; (function (n) { n[n.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", n[n.MISSING_METHOD = 1] = "MISSING_METHOD" })(X7 || (X7 = {})); function ame(n, e) { return ome(n, e) } function ome(n, e) { const t = Ol(e, i => Cf(n[i]) === !1), r = Gt(t, i => ({ msg: `Missing visitor method: <${i}> on ${n.constructor.name} CST Visitor.`, type: X7.MISSING_METHOD, methodName: i })); return r2(r) } class lme { initTreeBuilder(e) { if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = Zt(e, "nodeLocationTracking") ? e.nodeLocationTracking : Hh.nodeLocationTracking, !this.outputCst) this.cstInvocationStateUpdate = ds, this.cstFinallyStateUpdate = ds, this.cstPostTerminal = ds, this.cstPostNonTerminal = ds, this.cstPostRule = ds; else if (/full/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = JP, this.setNodeLocationFromNode = JP, this.cstPostRule = ds, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = ds, this.setNodeLocationFromNode = ds, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular); else if (/onlyOffset/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = jP, this.setNodeLocationFromNode = jP, this.cstPostRule = ds, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = ds, this.setNodeLocationFromNode = ds, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular); else if (/none/i.test(this.nodeLocationTracking)) this.setNodeLocationFromToken = ds, this.setNodeLocationFromNode = ds, this.cstPostRule = ds, this.setInitialNodeLocation = ds; else throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`) } setInitialNodeLocationOnlyOffsetRecovery(e) { e.location = { startOffset: NaN, endOffset: NaN } } setInitialNodeLocationOnlyOffsetRegular(e) { e.location = { startOffset: this.LA(1).startOffset, endOffset: NaN } } setInitialNodeLocationFullRecovery(e) { e.location = { startOffset: NaN, startLine: NaN, startColumn: NaN, endOffset: NaN, endLine: NaN, endColumn: NaN } } setInitialNodeLocationFullRegular(e) { const t = this.LA(1); e.location = { startOffset: t.startOffset, startLine: t.startLine, startColumn: t.startColumn, endOffset: NaN, endLine: NaN, endColumn: NaN } } cstInvocationStateUpdate(e) { const t = { name: e, children: Object.create(null) }; this.setInitialNodeLocation(t), this.CST_STACK.push(t) } cstFinallyStateUpdate() { this.CST_STACK.pop() } cstPostRuleFull(e) { const t = this.LA(0), r = e.location; r.startOffset <= t.startOffset ? (r.endOffset = t.endOffset, r.endLine = t.endLine, r.endColumn = t.endColumn) : (r.startOffset = NaN, r.startLine = NaN, r.startColumn = NaN) } cstPostRuleOnlyOffset(e) { const t = this.LA(0), r = e.location; r.startOffset <= t.startOffset ? r.endOffset = t.endOffset : r.startOffset = NaN } cstPostTerminal(e, t) { const r = this.CST_STACK[this.CST_STACK.length - 1]; eme(r, t, e), this.setNodeLocationFromToken(r.location, t) } cstPostNonTerminal(e, t) { const r = this.CST_STACK[this.CST_STACK.length - 1]; tme(r, t, e), this.setNodeLocationFromNode(r.location, e.location) } getBaseCstVisitorConstructor() { if (yf(this.baseCstVisitorConstructor)) { const e = ime(this.className, Vo(this.gastProductionsCache)); return this.baseCstVisitorConstructor = e, e } return this.baseCstVisitorConstructor } getBaseCstVisitorConstructorWithDefaults() { if (yf(this.baseCstVisitorWithDefaultsConstructor)) { const e = sme(this.className, Vo(this.gastProductionsCache), this.getBaseCstVisitorConstructor()); return this.baseCstVisitorWithDefaultsConstructor = e, e } return this.baseCstVisitorWithDefaultsConstructor } getLastExplicitRuleShortName() { const e = this.RULE_STACK; return e[e.length - 1] } getPreviousExplicitRuleShortName() { const e = this.RULE_STACK; return e[e.length - 2] } getLastExplicitRuleOccurrenceIndex() { const e = this.RULE_OCCURRENCE_STACK; return e[e.length - 1] } } class ume { initLexerAdapter() { this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1 } set input(e) { if (this.selfAnalysisDone !== !0) throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor."); this.reset(), this.tokVector = e, this.tokVectorLength = e.length } get input() { return this.tokVector } SKIP_TOKEN() { return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : Iy } LA(e) { const t = this.currIdx + e; return t < 0 || this.tokVectorLength <= t ? Iy : this.tokVector[t] } consumeToken() { this.currIdx++ } exportLexerState() { return this.currIdx } importLexerState(e) { this.currIdx = e } resetLexerState() { this.currIdx = -1 } moveToTerminatedState() { this.currIdx = this.tokVector.length - 1 } getLexerPosition() { return this.exportLexerState() } } class cme { ACTION(e) { return e.call(this) } consume(e, t, r) { return this.consumeInternal(t, e, r) } subrule(e, t, r) { return this.subruleInternal(t, e, r) } option(e, t) { return this.optionInternal(t, e) } or(e, t) { return this.orInternal(t, e) } many(e, t) { return this.manyInternal(e, t) } atLeastOne(e, t) { return this.atLeastOneInternal(e, t) } CONSUME(e, t) { return this.consumeInternal(e, 0, t) } CONSUME1(e, t) { return this.consumeInternal(e, 1, t) } CONSUME2(e, t) { return this.consumeInternal(e, 2, t) } CONSUME3(e, t) { return this.consumeInternal(e, 3, t) } CONSUME4(e, t) { return this.consumeInternal(e, 4, t) } CONSUME5(e, t) { return this.consumeInternal(e, 5, t) } CONSUME6(e, t) { return this.consumeInternal(e, 6, t) } CONSUME7(e, t) { return this.consumeInternal(e, 7, t) } CONSUME8(e, t) { return this.consumeInternal(e, 8, t) } CONSUME9(e, t) { return this.consumeInternal(e, 9, t) } SUBRULE(e, t) { return this.subruleInternal(e, 0, t) } SUBRULE1(e, t) { return this.subruleInternal(e, 1, t) } SUBRULE2(e, t) { return this.subruleInternal(e, 2, t) } SUBRULE3(e, t) { return this.subruleInternal(e, 3, t) } SUBRULE4(e, t) { return this.subruleInternal(e, 4, t) } SUBRULE5(e, t) { return this.subruleInternal(e, 5, t) } SUBRULE6(e, t) { return this.subruleInternal(e, 6, t) } SUBRULE7(e, t) { return this.subruleInternal(e, 7, t) } SUBRULE8(e, t) { return this.subruleInternal(e, 8, t) } SUBRULE9(e, t) { return this.subruleInternal(e, 9, t) } OPTION(e) { return this.optionInternal(e, 0) } OPTION1(e) { return this.optionInternal(e, 1) } OPTION2(e) { return this.optionInternal(e, 2) } OPTION3(e) { return this.optionInternal(e, 3) } OPTION4(e) { return this.optionInternal(e, 4) } OPTION5(e) { return this.optionInternal(e, 5) } OPTION6(e) { return this.optionInternal(e, 6) } OPTION7(e) { return this.optionInternal(e, 7) } OPTION8(e) { return this.optionInternal(e, 8) } OPTION9(e) { return this.optionInternal(e, 9) } OR(e) { return this.orInternal(e, 0) } OR1(e) { return this.orInternal(e, 1) } OR2(e) { return this.orInternal(e, 2) } OR3(e) { return this.orInternal(e, 3) } OR4(e) { return this.orInternal(e, 4) } OR5(e) { return this.orInternal(e, 5) } OR6(e) { return this.orInternal(e, 6) } OR7(e) { return this.orInternal(e, 7) } OR8(e) { return this.orInternal(e, 8) } OR9(e) { return this.orInternal(e, 9) } MANY(e) { this.manyInternal(0, e) } MANY1(e) { this.manyInternal(1, e) } MANY2(e) { this.manyInternal(2, e) } MANY3(e) { this.manyInternal(3, e) } MANY4(e) { this.manyInternal(4, e) } MANY5(e) { this.manyInternal(5, e) } MANY6(e) { this.manyInternal(6, e) } MANY7(e) { this.manyInternal(7, e) } MANY8(e) { this.manyInternal(8, e) } MANY9(e) { this.manyInternal(9, e) } MANY_SEP(e) { this.manySepFirstInternal(0, e) } MANY_SEP1(e) { this.manySepFirstInternal(1, e) } MANY_SEP2(e) { this.manySepFirstInternal(2, e) } MANY_SEP3(e) { this.manySepFirstInternal(3, e) } MANY_SEP4(e) { this.manySepFirstInternal(4, e) } MANY_SEP5(e) { this.manySepFirstInternal(5, e) } MANY_SEP6(e) { this.manySepFirstInternal(6, e) } MANY_SEP7(e) { this.manySepFirstInternal(7, e) } MANY_SEP8(e) { this.manySepFirstInternal(8, e) } MANY_SEP9(e) { this.manySepFirstInternal(9, e) } AT_LEAST_ONE(e) { this.atLeastOneInternal(0, e) } AT_LEAST_ONE1(e) { return this.atLeastOneInternal(1, e) } AT_LEAST_ONE2(e) { this.atLeastOneInternal(2, e) } AT_LEAST_ONE3(e) { this.atLeastOneInternal(3, e) } AT_LEAST_ONE4(e) { this.atLeastOneInternal(4, e) } AT_LEAST_ONE5(e) { this.atLeastOneInternal(5, e) } AT_LEAST_ONE6(e) { this.atLeastOneInternal(6, e) } AT_LEAST_ONE7(e) { this.atLeastOneInternal(7, e) } AT_LEAST_ONE8(e) { this.atLeastOneInternal(8, e) } AT_LEAST_ONE9(e) { this.atLeastOneInternal(9, e) } AT_LEAST_ONE_SEP(e) { this.atLeastOneSepFirstInternal(0, e) } AT_LEAST_ONE_SEP1(e) { this.atLeastOneSepFirstInternal(1, e) } AT_LEAST_ONE_SEP2(e) { this.atLeastOneSepFirstInternal(2, e) } AT_LEAST_ONE_SEP3(e) { this.atLeastOneSepFirstInternal(3, e) } AT_LEAST_ONE_SEP4(e) { this.atLeastOneSepFirstInternal(4, e) } AT_LEAST_ONE_SEP5(e) { this.atLeastOneSepFirstInternal(5, e) } AT_LEAST_ONE_SEP6(e) { this.atLeastOneSepFirstInternal(6, e) } AT_LEAST_ONE_SEP7(e) { this.atLeastOneSepFirstInternal(7, e) } AT_LEAST_ONE_SEP8(e) { this.atLeastOneSepFirstInternal(8, e) } AT_LEAST_ONE_SEP9(e) { this.atLeastOneSepFirstInternal(9, e) } RULE(e, t, r = My) { if (za(this.definedRulesNames, e)) { const a = { message: tp.buildDuplicateRuleNameError({ topLevelRule: e, grammarName: this.className }), type: Ga.DUPLICATE_RULE_NAME, ruleName: e }; this.definitionErrors.push(a) } this.definedRulesNames.push(e); const i = this.defineRule(e, t, r); return this[e] = i, i } OVERRIDE_RULE(e, t, r = My) { const i = P3e(e, this.definedRulesNames, this.className); this.definitionErrors = this.definitionErrors.concat(i); const s = this.defineRule(e, t, r); return this[e] = s, s } BACKTRACK(e, t) { return function () { this.isBackTrackingStack.push(1); const r = this.saveRecogState(); try { return e.apply(this, t), !0 } catch (i) { if (Ty(i)) return !1; throw i } finally { this.reloadRecogState(r), this.isBackTrackingStack.pop() } } } getGAstProductions() { return this.gastProductionsCache } getSerializedGastProductions() { return h0e(gs(this.gastProductionsCache)) } } class fme {
		initRecognizerEngine(e, t) {
			if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = Sy, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, Zt(t, "serializedGrammar")) throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`); if (nr(e)) {
				if (Hr(e)) throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`); if (typeof e[0].startOffset == "number") throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)
			} if (nr(e)) this.tokensMap = Xo(e, (s, a) => (s[a.name] = a, s), {}); else if (Zt(e, "modes") && Au(gu(gs(e.modes)), a3e)) { const s = gu(gs(e.modes)), a = XT(s); this.tokensMap = Xo(a, (o, l) => (o[l.name] = l, o), {}) } else if (Fl(e)) this.tokensMap = ga(e); else throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition"); this.tokensMap.EOF = Dp; const r = Zt(e, "modes") ? gu(gs(e.modes)) : gs(e), i = Au(r, s => Hr(s.categoryMatches)); this.tokenMatcher = i ? Sy : s2, a2(gs(this.tokensMap))
		} defineRule(e, t, r) {
			if (this.selfAnalysisDone) throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`); const i = Zt(r, "resyncEnabled") ? r.resyncEnabled : My.resyncEnabled, s = Zt(r, "recoveryValueFunc") ? r.recoveryValueFunc : My.recoveryValueFunc, a = this.ruleShortNameIdx << J3e + ed; this.ruleShortNameIdx++, this.shortRuleNameToFull[a] = e, this.fullRuleNameToShort[e] = a; let o; return this.outputCst === !0 ? o = function (...c) { try { this.ruleInvocationStateUpdate(a, e, this.subruleIdx), t.apply(this, c); const h = this.CST_STACK[this.CST_STACK.length - 1]; return this.cstPostRule(h), h } catch (h) { return this.invokeRuleCatch(h, i, s) } finally { this.ruleFinallyStateUpdate() } } : o = function (...c) { try { return this.ruleInvocationStateUpdate(a, e, this.subruleIdx), t.apply(this, c) } catch (h) { return this.invokeRuleCatch(h, i, s) } finally { this.ruleFinallyStateUpdate() } }, Object.assign(o, { ruleName: e, originalGrammarAction: t })
		} invokeRuleCatch(e, t, r) { const i = this.RULE_STACK.length === 1, s = t && !this.isBackTracking() && this.recoveryEnabled; if (Ty(e)) { const a = e; if (s) { const o = this.findReSyncTokenType(); if (this.isInCurrentRuleReSyncSet(o)) if (a.resyncedTokens = this.reSyncTo(o), this.outputCst) { const l = this.CST_STACK[this.CST_STACK.length - 1]; return l.recoveredNode = !0, l } else return r(e); else { if (this.outputCst) { const l = this.CST_STACK[this.CST_STACK.length - 1]; l.recoveredNode = !0, a.partialCstResult = l } throw a } } else { if (i) return this.moveToTerminatedState(), r(e); throw a } } else throw e } optionInternal(e, t) { const r = this.getKeyForAutomaticLookahead(iH, t); return this.optionInternalLogic(e, t, r) } optionInternalLogic(e, t, r) { let i = this.getLaFuncFromCache(r), s; if (typeof e != "function") { s = e.DEF; const a = e.GATE; if (a !== void 0) { const o = i; i = () => a.call(this) && o.call(this) } } else s = e; if (i.call(this) === !0) return s.call(this) } atLeastOneInternal(e, t) { const r = this.getKeyForAutomaticLookahead(V7, e); return this.atLeastOneInternalLogic(e, t, r) } atLeastOneInternalLogic(e, t, r) { let i = this.getLaFuncFromCache(r), s; if (typeof t != "function") { s = t.DEF; const a = t.GATE; if (a !== void 0) { const o = i; i = () => a.call(this) && o.call(this) } } else s = t; if (i.call(this) === !0) { let a = this.doSingleRepetition(s); for (; i.call(this) === !0 && a === !0;)a = this.doSingleRepetition(s) } else throw this.raiseEarlyExitException(e, Bi.REPETITION_MANDATORY, t.ERR_MSG); this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, t], i, V7, e, A3e) } atLeastOneSepFirstInternal(e, t) { const r = this.getKeyForAutomaticLookahead(v6, e); this.atLeastOneSepFirstInternalLogic(e, t, r) } atLeastOneSepFirstInternalLogic(e, t, r) { const i = t.DEF, s = t.SEP; if (this.getLaFuncFromCache(r).call(this) === !0) { i.call(this); const o = () => this.tokenMatcher(this.LA(1), s); for (; this.tokenMatcher(this.LA(1), s) === !0;)this.CONSUME(s), i.call(this); this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, s, o, i, XP], o, v6, e, XP) } else throw this.raiseEarlyExitException(e, Bi.REPETITION_MANDATORY_WITH_SEPARATOR, t.ERR_MSG) } manyInternal(e, t) { const r = this.getKeyForAutomaticLookahead(z7, e); return this.manyInternalLogic(e, t, r) } manyInternalLogic(e, t, r) { let i = this.getLaFuncFromCache(r), s; if (typeof t != "function") { s = t.DEF; const o = t.GATE; if (o !== void 0) { const l = i; i = () => o.call(this) && l.call(this) } } else s = t; let a = !0; for (; i.call(this) === !0 && a === !0;)a = this.doSingleRepetition(s); this.attemptInRepetitionRecovery(this.manyInternal, [e, t], i, z7, e, g3e, a) } manySepFirstInternal(e, t) { const r = this.getKeyForAutomaticLookahead(W7, e); this.manySepFirstInternalLogic(e, t, r) } manySepFirstInternalLogic(e, t, r) { const i = t.DEF, s = t.SEP; if (this.getLaFuncFromCache(r).call(this) === !0) { i.call(this); const o = () => this.tokenMatcher(this.LA(1), s); for (; this.tokenMatcher(this.LA(1), s) === !0;)this.CONSUME(s), i.call(this); this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, s, o, i, WP], o, W7, e, WP) } } repetitionSepSecondInternal(e, t, r, i, s) { for (; r();)this.CONSUME(t), i.call(this); this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [e, t, r, i, s], r, v6, e, s) } doSingleRepetition(e) { const t = this.getLexerPosition(); return e.call(this), this.getLexerPosition() > t } orInternal(e, t) { const r = this.getKeyForAutomaticLookahead(rH, t), i = nr(e) ? e : e.DEF, a = this.getLaFuncFromCache(r).call(this, i); if (a !== void 0) return i[a].ALT.call(this); this.raiseNoAltException(t, e.ERR_MSG) } ruleFinallyStateUpdate() { if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) { const e = this.LA(1), t = this.errorMessageProvider.buildNotAllInputParsedMessage({ firstRedundant: e, ruleName: this.getCurrRuleFullName() }); this.SAVE_ERROR(new V3e(t, e)) } } subruleInternal(e, t, r) { let i; try { const s = r !== void 0 ? r.ARGS : void 0; return this.subruleIdx = t, i = e.apply(this, s), this.cstPostNonTerminal(i, r !== void 0 && r.LABEL !== void 0 ? r.LABEL : e.ruleName), i } catch (s) { throw this.subruleInternalError(s, r, e.ruleName) } } subruleInternalError(e, t, r) { throw Ty(e) && e.partialCstResult !== void 0 && (this.cstPostNonTerminal(e.partialCstResult, t !== void 0 && t.LABEL !== void 0 ? t.LABEL : r), delete e.partialCstResult), e } consumeInternal(e, t, r) { let i; try { const s = this.LA(1); this.tokenMatcher(s, e) === !0 ? (this.consumeToken(), i = s) : this.consumeInternalError(e, s, r) } catch (s) { i = this.consumeInternalRecovery(e, t, s) } return this.cstPostTerminal(r !== void 0 && r.LABEL !== void 0 ? r.LABEL : e.name, i), i } consumeInternalError(e, t, r) { let i; const s = this.LA(0); throw r !== void 0 && r.ERR_MSG ? i = r.ERR_MSG : i = this.errorMessageProvider.buildMismatchTokenMessage({ expected: e, actual: t, previous: s, ruleName: this.getCurrRuleFullName() }), this.SAVE_ERROR(new tH(i, t, s)) } consumeInternalRecovery(e, t, r) { if (this.recoveryEnabled && r.name === "MismatchedTokenException" && !this.isBackTracking()) { const i = this.getFollowsForInRuleRecovery(e, t); try { return this.tryInRuleRecovery(e, i) } catch (s) { throw s.name === nH ? r : s } } else throw r } saveRecogState() { const e = this.errors, t = ga(this.RULE_STACK); return { errors: e, lexerState: this.exportLexerState(), RULE_STACK: t, CST_STACK: this.CST_STACK } } reloadRecogState(e) { this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK } ruleInvocationStateUpdate(e, t, r) { this.RULE_OCCURRENCE_STACK.push(r), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(t) } isBackTracking() { return this.isBackTrackingStack.length !== 0 } getCurrRuleFullName() { const e = this.getLastExplicitRuleShortName(); return this.shortRuleNameToFull[e] } shortRuleNameToFullName(e) { return this.shortRuleNameToFull[e] } isAtEndOfInput() { return this.tokenMatcher(this.LA(1), Dp) } reset() { this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [] }
	} class hme { initErrorHandler(e) { this._errors = [], this.errorMessageProvider = Zt(e, "errorMessageProvider") ? e.errorMessageProvider : Hh.errorMessageProvider } SAVE_ERROR(e) { if (Ty(e)) return e.context = { ruleStack: this.getHumanReadableRuleStack(), ruleOccurrenceStack: ga(this.RULE_OCCURRENCE_STACK) }, this._errors.push(e), e; throw Error("Trying to save an Error which is not a RecognitionException") } get errors() { return ga(this._errors) } set errors(e) { this._errors = e } raiseEarlyExitException(e, t, r) { const i = this.getCurrRuleFullName(), s = this.getGAstProductions()[i], o = qT(e, s, t, this.maxLookahead)[0], l = []; for (let c = 1; c <= this.maxLookahead; c++)l.push(this.LA(c)); const u = this.errorMessageProvider.buildEarlyExitMessage({ expectedIterationPaths: o, actual: l, previous: this.LA(0), customUserDescription: r, ruleName: i }); throw this.SAVE_ERROR(new W3e(u, this.LA(1), this.LA(0))) } raiseNoAltException(e, t) { const r = this.getCurrRuleFullName(), i = this.getGAstProductions()[r], s = KT(e, i, this.maxLookahead), a = []; for (let u = 1; u <= this.maxLookahead; u++)a.push(this.LA(u)); const o = this.LA(0), l = this.errorMessageProvider.buildNoViableAltMessage({ expectedPathsPerAlt: s, actual: a, previous: o, customUserDescription: t, ruleName: this.getCurrRuleFullName() }); throw this.SAVE_ERROR(new z3e(l, this.LA(1), o)) } } class dme { initContentAssist() { } computeContentAssist(e, t) { const r = this.gastProductionsCache[e]; if (yf(r)) throw Error(`Rule ->${e}<- does not exist in this grammar.`); return zQ([r], t, this.tokenMatcher, this.maxLookahead) } getNextPossibleTokenTypes(e) { const t = Cu(e.ruleStack), i = this.getGAstProductions()[t]; return new m3e(i, e).startWalking() } } const t4 = { description: "This Object indicates the Parser is during Recording Phase" }; Object.freeze(t4); const KP = !0, qP = Math.pow(2, ed) - 1, aH = QQ({ name: "RECORDING_PHASE_TOKEN", pattern: Ml.NA }); a2([aH]); const oH = JT(aH, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1); Object.freeze(oH); const pme = {
		name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, children: {}
	}; class mme {
		initGastRecorder(e) { this.recordingProdStack = [], this.RECORDING_PHASE = !1 } enableRecording() { this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => { for (let e = 0; e < 10; e++) { const t = e > 0 ? e : ""; this[`CONSUME${t}`] = function (r, i) { return this.consumeInternalRecord(r, e, i) }, this[`SUBRULE${t}`] = function (r, i) { return this.subruleInternalRecord(r, e, i) }, this[`OPTION${t}`] = function (r) { return this.optionInternalRecord(r, e) }, this[`OR${t}`] = function (r) { return this.orInternalRecord(r, e) }, this[`MANY${t}`] = function (r) { this.manyInternalRecord(e, r) }, this[`MANY_SEP${t}`] = function (r) { this.manySepFirstInternalRecord(e, r) }, this[`AT_LEAST_ONE${t}`] = function (r) { this.atLeastOneInternalRecord(e, r) }, this[`AT_LEAST_ONE_SEP${t}`] = function (r) { this.atLeastOneSepFirstInternalRecord(e, r) } } this.consume = function (e, t, r) { return this.consumeInternalRecord(t, e, r) }, this.subrule = function (e, t, r) { return this.subruleInternalRecord(t, e, r) }, this.option = function (e, t) { return this.optionInternalRecord(t, e) }, this.or = function (e, t) { return this.orInternalRecord(t, e) }, this.many = function (e, t) { this.manyInternalRecord(e, t) }, this.atLeastOne = function (e, t) { this.atLeastOneInternalRecord(e, t) }, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD }) } disableRecording() { this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => { const e = this; for (let t = 0; t < 10; t++) { const r = t > 0 ? t : ""; delete e[`CONSUME${r}`], delete e[`SUBRULE${r}`], delete e[`OPTION${r}`], delete e[`OR${r}`], delete e[`MANY${r}`], delete e[`MANY_SEP${r}`], delete e[`AT_LEAST_ONE${r}`], delete e[`AT_LEAST_ONE_SEP${r}`] } delete e.consume, delete e.subrule, delete e.option, delete e.or, delete e.many, delete e.atLeastOne, delete e.ACTION, delete e.BACKTRACK, delete e.LA }) } ACTION_RECORD(e) { } BACKTRACK_RECORD(e, t) { return () => !0 } LA_RECORD(e) { return Iy } topLevelRuleRecord(e, t) {
			try { const r = new wm({ definition: [], name: e }); return r.name = e, this.recordingProdStack.push(r), t.call(this), this.recordingProdStack.pop(), r } catch (r) {
				if (r.KNOWN_RECORDER_ERROR !== !0) try {
					r.message = r.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`} catch { throw r } throw r
			}
		} optionInternalRecord(e, t) { return mg.call(this, fo, e, t) } atLeastOneInternalRecord(e, t) { mg.call(this, Ec, t, e) } atLeastOneSepFirstInternalRecord(e, t) { mg.call(this, Cc, t, e, KP) } manyInternalRecord(e, t) { mg.call(this, vs, t, e) } manySepFirstInternalRecord(e, t) { mg.call(this, Pu, t, e, KP) } orInternalRecord(e, t) { return gme.call(this, e, t) } subruleInternalRecord(e, t, r) {
			if (wy(t), !e || Zt(e, "ruleName") === !1) {
				const o = new Error(`<SUBRULE${ZP(t)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`); throw o.KNOWN_RECORDER_ERROR = !0, o
			} const i = cm(this.recordingProdStack), s = e.ruleName, a = new Yo({ idx: t, nonTerminalName: s, label: r == null ? void 0 : r.LABEL, referencedRule: void 0 }); return i.definition.push(a), this.outputCst ? pme : t4
		} consumeInternalRecord(e, t, r) {
			if (wy(t), !UQ(e)) {
				const a = new Error(`<CONSUME${ZP(t)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`); throw a.KNOWN_RECORDER_ERROR = !0, a
			} const i = cm(this.recordingProdStack), s = new vi({ idx: t, terminalType: e, label: r == null ? void 0 : r.LABEL }); return i.definition.push(s), oH
		}
	} function mg(n, e, t, r = !1) { wy(t); const i = cm(this.recordingProdStack), s = Cf(e) ? e : e.DEF, a = new n({ definition: [], idx: t }); return r && (a.separator = e.SEP), Zt(e, "MAX_LOOKAHEAD") && (a.maxLookahead = e.MAX_LOOKAHEAD), this.recordingProdStack.push(a), s.call(this), i.definition.push(a), this.recordingProdStack.pop(), t4 } function gme(n, e) { wy(e); const t = cm(this.recordingProdStack), r = nr(n) === !1, i = r === !1 ? n : n.DEF, s = new Du({ definition: [], idx: e, ignoreAmbiguities: r && n.IGNORE_AMBIGUITIES === !0 }); Zt(n, "MAX_LOOKAHEAD") && (s.maxLookahead = n.MAX_LOOKAHEAD); const a = IQ(i, o => Cf(o.GATE)); return s.hasPredicates = a, t.definition.push(s), tn(i, o => { const l = new mo({ definition: [] }); s.definition.push(l), Zt(o, "IGNORE_AMBIGUITIES") ? l.ignoreAmbiguities = o.IGNORE_AMBIGUITIES : Zt(o, "GATE") && (l.ignoreAmbiguities = !0), this.recordingProdStack.push(l), o.ALT.call(this), this.recordingProdStack.pop() }), t4 } function ZP(n) { return n === 0 ? "" : `${n}` } function wy(n) {
		if (n < 0 || n > qP) {
			const e = new Error(`Invalid DSL Method idx value: <${n}>
	Idx value must be a none negative value smaller than ${qP + 1}`); throw e.KNOWN_RECORDER_ERROR = !0, e
		}
	} class Ame { initPerformanceTracer(e) { if (Zt(e, "traceInitPerf")) { const t = e.traceInitPerf, r = typeof t == "number"; this.traceInitMaxIdent = r ? t : 1 / 0, this.traceInitPerf = r ? t > 0 : t } else this.traceInitMaxIdent = 0, this.traceInitPerf = Hh.traceInitPerf; this.traceInitIndent = -1 } TRACE_INIT(e, t) { if (this.traceInitPerf === !0) { this.traceInitIndent++; const r = new Array(this.traceInitIndent + 1).join("	"); this.traceInitIndent < this.traceInitMaxIdent && console.log(`${r}--> <${e}>`); const { time: i, value: s } = bQ(t), a = i > 10 ? console.warn : console.log; return this.traceInitIndent < this.traceInitMaxIdent && a(`${r}<-- <${e}> time: ${i}ms`), this.traceInitIndent--, s } else return t() } } function vme(n, e) { e.forEach(t => { const r = t.prototype; Object.getOwnPropertyNames(r).forEach(i => { if (i === "constructor") return; const s = Object.getOwnPropertyDescriptor(r, i); s && (s.get || s.set) ? Object.defineProperty(n.prototype, i, s) : n.prototype[i] = t.prototype[i] }) }) } const Iy = JT(Dp, "", NaN, NaN, NaN, NaN, NaN, NaN); Object.freeze(Iy); const Hh = Object.freeze({ recoveryEnabled: !1, maxLookahead: 3, dynamicTokensEnabled: !1, outputCst: !0, errorMessageProvider: HQ, nodeLocationTracking: "none", traceInitPerf: !1, skipValidations: !1 }), My = Object.freeze({ recoveryValueFunc: () => { }, resyncEnabled: !0 }); var Ga; (function (n) { n[n.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", n[n.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", n[n.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", n[n.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", n[n.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", n[n.LEFT_RECURSION = 5] = "LEFT_RECURSION", n[n.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", n[n.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", n[n.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", n[n.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", n[n.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", n[n.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", n[n.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", n[n.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION" })(Ga || (Ga = {})); class n4 {
		static performSelfAnalysis(e) { throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.") } performSelfAnalysis() {
			this.TRACE_INIT("performSelfAnalysis", () => {
				let e; this.selfAnalysisDone = !0; const t = this.className; this.TRACE_INIT("toFastProps", () => { BQ(this) }), this.TRACE_INIT("Grammar Recording", () => { try { this.enableRecording(), tn(this.definedRulesNames, i => { const a = this[i].originalGrammarAction; let o; this.TRACE_INIT(`${i} Rule`, () => { o = this.topLevelRuleRecord(i, a) }), this.gastProductionsCache[i] = o }) } finally { this.disableRecording() } }); let r = []; if (this.TRACE_INIT("Grammar Resolving", () => { r = Q3e({ rules: gs(this.gastProductionsCache) }), this.definitionErrors = this.definitionErrors.concat(r) }), this.TRACE_INIT("Grammar Validations", () => { if (Hr(r) && this.skipValidations === !1) { const i = H3e({ rules: gs(this.gastProductionsCache), tokenTypes: gs(this.tokensMap), errMsgProvider: tp, grammarName: t }), s = w3e({ lookaheadStrategy: this.lookaheadStrategy, rules: gs(this.gastProductionsCache), tokenTypes: gs(this.tokensMap), grammarName: t }); this.definitionErrors = this.definitionErrors.concat(i, s) } }), Hr(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => { const i = y0e(gs(this.gastProductionsCache)); this.resyncFollows = i }), this.TRACE_INIT("ComputeLookaheadFunctions", () => { var i, s; (s = (i = this.lookaheadStrategy).initialize) === null || s === void 0 || s.call(i, { rules: gs(this.gastProductionsCache) }), this.preComputeLookaheadFunctions(gs(this.gastProductionsCache)) })), !n4.DEFER_DEFINITION_ERRORS_HANDLING && !Hr(this.definitionErrors)) throw e = Gt(this.definitionErrors, i => i.message), new Error(`Parser Definition Errors detected:
 ${e.join(`
-------------------------------
`)}`)
			})
		} constructor(e, t) {
			this.definitionErrors = [], this.selfAnalysisDone = !1; const r = this; if (r.initErrorHandler(t), r.initLexerAdapter(), r.initLooksAhead(t), r.initRecognizerEngine(e, t), r.initRecoverable(t), r.initTreeBuilder(t), r.initContentAssist(), r.initGastRecorder(t), r.initPerformanceTracer(t), Zt(t, "ignoredIssues")) throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`); this.skipValidations = Zt(t, "skipValidations") ? t.skipValidations : Hh.skipValidations
		}
	} n4.DEFER_DEFINITION_ERRORS_HANDLING = !1; vme(n4, [Y3e, q3e, lme, ume, fme, cme, hme, dme, mme, Ame]); class yme { constructor(e = 4) { this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0 } _initWorker(e) { if (!this.workers[e]) { const t = this.workerCreator(); t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t } } _getIdleWorker() { for (let e = 0; e < this.pool; e++)if (!(this.workerStatus & 1 << e)) return e; return -1 } _onMessage(e, t) { const r = this.workersResolve[e]; if (r && r(t), this.queue.length) { const { resolve: i, msg: s, transfer: a } = this.queue.shift(); this.workersResolve[e] = i, this.workers[e].postMessage(s, a) } else this.workerStatus ^= 1 << e } setWorkerCreator(e) { this.workerCreator = e } setWorkerLimit(e) { this.pool = e } postMessage(e, t) { return new Promise(r => { const i = this._getIdleWorker(); i !== -1 ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = r, this.workers[i].postMessage(e, t)) : this.queue.push({ resolve: r, msg: e, transfer: t }) }) } dispose() { this.workers.forEach(e => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0 } } class xme extends Nh { constructor(e, t, r, i, s, a) { super(e, t, r, s, a), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = pi } } const G_ = new WeakMap; let Q_ = 0, H_; const Fg = class extends Us {
		constructor(n) { super(n), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new yme, this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.') } setTranscoderPath(n) { return this.transcoderPath = n, this } setWorkerLimit(n) { return this.workerPool.setWorkerLimit(n), this } detectSupport(n) { return this.workerConfig = { astcSupported: n.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: n.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: n.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: n.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: n.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: n.extensions.has("WEBGL_compressed_texture_pvrtc") || n.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, n.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this } init() {
			if (!this.transcoderPending) {
				const n = new _s(this.manager); n.setPath(this.transcoderPath), n.setWithCredentials(this.withCredentials); const e = n.loadAsync("basis_transcoder.js"), t = new _s(this.manager); t.setPath(this.transcoderPath), t.setResponseType("arraybuffer"), t.setWithCredentials(this.withCredentials); const r = t.loadAsync("basis_transcoder.wasm"); this.transcoderPending = Promise.all([e, r]).then(([i, s]) => {
					const a = Fg.BasisWorker.toString(), o = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Fg.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Fg.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Fg.BasisFormat), "/* basis_transcoder.js */", i, "/* worker */", a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o])), this.transcoderBinary = s, this.workerPool.setWorkerCreator(() => { const l = new Worker(this.workerSourceURL), u = this.transcoderBinary.slice(0); return l.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: u }, [u]), l })
				}), Q_ > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Q_++
			} return this.transcoderPending
		} load(n, e, t, r) { if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."); const i = new _s(this.manager); i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials), i.load(n, s => { if (G_.has(s)) return G_.get(s).promise.then(e).catch(r); this._createTexture(s).then(a => e ? e(a) : null).catch(r) }, t, r) } _createTextureFrom(n, e) { const { mipmaps: t, width: r, height: i, format: s, type: a, error: o, dfdTransferFn: l, dfdFlags: u } = n; if (a === "error") return Promise.reject(o); const c = e.layerCount > 1 ? new xme(t, r, i, e.layerCount, s, As) : new Nh(t, r, i, s, As); return c.minFilter = t.length === 1 ? wr : Dl, c.magFilter = wr, c.generateMipmaps = !1, c.needsUpdate = !0, "colorSpace" in c ? c.colorSpace = l === v7 ? "srgb" : "srgb-linear" : c.encoding = l === v7 ? 3001 : 3e3, c.premultiplyAlpha = !!(u & qre), c } async _createTexture(n, e = {}) { const t = tie(new Uint8Array(n)); if (t.vkFormat !== eG) return Eme(t); const r = e, i = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: n, taskConfig: r }, [n])).then(s => this._createTextureFrom(s.data, t)); return G_.set(n, { promise: i }), i } dispose() { return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Q_--, this }
	}; let r4 = Fg; Xe(r4, "BasisFormat", { ETC1S: 0, UASTC_4x4: 1 }); Xe(r4, "TranscoderFormat", { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }); Xe(r4, "EngineFormat", { RGBAFormat: Ri, RGBA_ASTC_4x4_Format: r1, RGBA_BPTC_Format: B3, RGBA_ETC2_EAC_Format: n1, RGBA_PVRTC_4BPPV1_Format: e1, RGBA_S3TC_DXT5_Format: b3, RGB_ETC1_Format: a8, RGB_ETC2_Format: t1, RGB_PVRTC_4BPPV1_Format: $A, RGB_S3TC_DXT1_Format: M3 }); Xe(r4, "BasisWorker", function () { let n, e, t; const r = _EngineFormat, i = _TranscoderFormat, s = _BasisFormat; self.addEventListener("message", function (g) { const v = g.data; switch (v.type) { case "init": n = v.config, a(v.transcoderBinary); break; case "transcode": e.then(() => { try { const { width: y, height: A, hasAlpha: _, mipmaps: x, format: C, dfdTransferFn: T, dfdFlags: I } = o(v.buffer), w = []; for (let R = 0; R < x.length; ++R)w.push(x[R].data.buffer); self.postMessage({ type: "transcode", id: v.id, width: y, height: A, hasAlpha: _, mipmaps: x, format: C, dfdTransferFn: T, dfdFlags: I }, w) } catch (y) { console.error(y), self.postMessage({ type: "error", id: v.id, error: y.message }) } }); break } }); function a(g) { e = new Promise(v => { t = { wasmBinary: g, onRuntimeInitialized: v }, BASIS(t) }).then(() => { t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.") }) } function o(g) { const v = new t.KTX2File(new Uint8Array(g)); function y() { v.close(), v.delete() } if (!v.isValid()) throw y(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file"); const A = v.isUASTC() ? s.UASTC_4x4 : s.ETC1S, _ = v.getWidth(), x = v.getHeight(), C = v.getLayers() || 1, T = v.getLevels(), I = v.getHasAlpha(), w = v.getDFDTransferFunc(), R = v.getDFDFlags(), { transcoderFormat: b, engineFormat: B } = h(A, _, x, I); if (!_ || !x || !T) throw y(), new Error("THREE.KTX2Loader:	Invalid texture"); if (!v.startTranscoding()) throw y(), new Error("THREE.KTX2Loader: .startTranscoding failed"); const F = []; for (let U = 0; U < T; U++) { const G = []; let Y, Z; for (let ne = 0; ne < C; ne++) { const $ = v.getImageLevelInfo(U, ne, 0); Y = $.origWidth < 4 ? $.origWidth : $.width, Z = $.origHeight < 4 ? $.origHeight : $.height; const L = new Uint8Array(v.getImageTranscodedSizeInBytes(U, ne, 0, b)); if (!v.transcodeImage(L, U, ne, 0, b, 0, -1, -1)) throw y(), new Error("THREE.KTX2Loader: .transcodeImage failed."); G.push(L) } F.push({ data: m(G), width: Y, height: Z }) } return y(), { width: _, height: x, hasAlpha: I, mipmaps: F, format: B, dfdTransferFn: w, dfdFlags: R } } const l = [{ if: "astcSupported", basisFormat: [s.UASTC_4x4], transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4], engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.BC7_M5, i.BC7_M5], engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.BC1, i.BC3], engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.ETC1, i.ETC2], engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.ETC1], engineFormat: [r.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA], engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }], u = l.sort(function (g, v) { return g.priorityETC1S - v.priorityETC1S }), c = l.sort(function (g, v) { return g.priorityUASTC - v.priorityUASTC }); function h(g, v, y, A) { let _, x; const C = g === s.ETC1S ? u : c; for (let T = 0; T < C.length; T++) { const I = C[T]; if (n[I.if] && I.basisFormat.includes(g) && !(A && I.transcoderFormat.length < 2) && !(I.needsPowerOfTwo && !(d(v) && d(y)))) return _ = I.transcoderFormat[A ? 1 : 0], x = I.engineFormat[A ? 1 : 0], { transcoderFormat: _, engineFormat: x } } return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), _ = i.RGBA32, x = r.RGBAFormat, { transcoderFormat: _, engineFormat: x } } function d(g) { return g <= 2 ? !0 : (g & g - 1) === 0 && g !== 0 } function m(g) { let v = 0; for (let _ = 0; _ < g.length; _++) { const x = g[_]; v += x.byteLength } const y = new Uint8Array(v); let A = 0; for (let _ = 0; _ < g.length; _++) { const x = g[_]; y.set(x, A), A += x.byteLength } return y } }); const $P = { [uG]: Ri, [aG]: Ri, [rG]: Ri, [_T]: Ri, [lG]: l3, [sG]: l3, [nG]: l3, [xT]: l3, [oG]: Jd, [iG]: Jd, [yT]: Jd, [tG]: Jd }, z_ = { [uG]: Oa, [aG]: Wi, [rG]: As, [_T]: As, [lG]: Oa, [sG]: Wi, [nG]: As, [xT]: As, [oG]: Oa, [iG]: Wi, [yT]: As, [tG]: As }, _me = { [_T]: 3001, [xT]: 3001, [yT]: 3001 }; async function Eme(n) { const { vkFormat: e, pixelWidth: t, pixelHeight: r, pixelDepth: i } = n; if ($P[e] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat."); const s = n.levels[0]; let a, o; if (n.supercompressionScheme === $U) a = s.levelData; else if (n.supercompressionScheme === Wre) H_ || (H_ = new Promise(async u => { const c = new nie; await c.init(), u(c) })), a = (await H_).decode(s.levelData, s.uncompressedByteLength); else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme."); z_[e] === Oa ? o = new Float32Array(a.buffer, a.byteOffset, a.byteLength / Float32Array.BYTES_PER_ELEMENT) : z_[e] === Wi ? o = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / Uint16Array.BYTES_PER_ELEMENT) : o = a; const l = i === 0 ? new ac(o, t, r) : new Xle(o, t, r, i); return l.type = z_[e], l.format = $P[e], l.encoding = _me[e] || 3e3, l.needsUpdate = !0, Promise.resolve(l) } const V_ = new WeakMap, kg = class extends Us {
		constructor(n) { super(n), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.workerConfig = null } setTranscoderPath(n) { return this.transcoderPath = n, this } setWorkerLimit(n) { return this.workerLimit = n, this } detectSupport(n) { return this.workerConfig = { astcSupported: n.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: n.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: n.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: n.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: n.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: n.extensions.has("WEBGL_compressed_texture_pvrtc") || n.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }, this } load(n, e, t, r) { const i = new _s(this.manager); i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials); const s = new Nh; return i.load(n, a => { if (V_.has(a)) return V_.get(a).promise.then(e).catch(r); this._createTexture([a]).then(function (o) { s.copy(o), s.needsUpdate = !0, e && e(s) }).catch(r) }, t, r), s } parseInternalAsync(n) { const { levels: e } = n, t = new Set; for (let r = 0; r < e.length; r++)t.add(e[r].data.buffer); return this._createTexture(Array.from(t), { ...n, lowLevel: !0 }) } _createTexture(n, e = {}) { let t, r; const i = e; let s = 0; for (let o = 0; o < n.length; o++)s += n[o].byteLength; const a = this._allocateWorker(s).then(o => (t = o, r = this.workerNextTaskID++, new Promise((l, u) => { t._callbacks[r] = { resolve: l, reject: u }, t.postMessage({ type: "transcode", id: r, buffers: n, taskConfig: i }, n) }))).then(o => { const { mipmaps: l, width: u, height: c, format: h } = o, d = new Nh(l, u, c, h, As); return d.minFilter = l.length === 1 ? wr : Dl, d.magFilter = wr, d.generateMipmaps = !1, d.needsUpdate = !0, d }); return a.catch(() => !0).then(() => { t && r && (t._taskLoad -= s, delete t._callbacks[r]) }), V_.set(n[0], { promise: a }), a } _initTranscoder() {
			if (!this.transcoderPending) {
				const n = new _s(this.manager); n.setPath(this.transcoderPath), n.setWithCredentials(this.withCredentials); const e = new Promise((i, s) => { n.load("basis_transcoder.js", i, void 0, s) }), t = new _s(this.manager); t.setPath(this.transcoderPath), t.setResponseType("arraybuffer"), t.setWithCredentials(this.withCredentials); const r = new Promise((i, s) => { t.load("basis_transcoder.wasm", i, void 0, s) }); this.transcoderPending = Promise.all([e, r]).then(([i, s]) => {
					const a = kg.BasisWorker.toString(), o = ["/* constants */", "let _EngineFormat = " + JSON.stringify(kg.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(kg.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(kg.BasisFormat), "/* basis_transcoder.js */", i, "/* worker */", a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o])), this.transcoderBinary = s
				})
			} return this.transcoderPending
		} _allocateWorker(n) { return this._initTranscoder().then(() => { if (this.workerPool.length < this.workerLimit) { const t = new Worker(this.workerSourceURL); t._callbacks = {}, t._taskLoad = 0, t.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: this.transcoderBinary }), t.onmessage = function (r) { const i = r.data; switch (i.type) { case "transcode": t._callbacks[i.id].resolve(i); break; case "error": t._callbacks[i.id].reject(i); break; default: console.error('THREE.BasisTextureLoader: Unexpected message, "' + i.type + '"') } }, this.workerPool.push(t) } else this.workerPool.sort(function (t, r) { return t._taskLoad > r._taskLoad ? -1 : 1 }); const e = this.workerPool[this.workerPool.length - 1]; return e._taskLoad += n, e }) } dispose() { for (let n = 0; n < this.workerPool.length; n++)this.workerPool[n].terminate(); return this.workerPool.length = 0, this }
	}; let i4 = kg; Xe(i4, "BasisFormat", { ETC1S: 0, UASTC_4x4: 1 }); Xe(i4, "TranscoderFormat", { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }); Xe(i4, "EngineFormat", { RGBAFormat: Ri, RGBA_ASTC_4x4_Format: r1, RGBA_BPTC_Format: B3, RGBA_ETC2_EAC_Format: n1, RGBA_PVRTC_4BPPV1_Format: e1, RGBA_S3TC_DXT5_Format: b3, RGB_ETC1_Format: a8, RGB_ETC2_Format: t1, RGB_PVRTC_4BPPV1_Format: $A, RGB_S3TC_DXT1_Format: M3 }); Xe(i4, "BasisWorker", function () { let n, e, t; const r = _EngineFormat, i = _TranscoderFormat, s = _BasisFormat; onmessage = function (_) { const x = _.data; switch (x.type) { case "init": n = x.config, a(x.transcoderBinary); break; case "transcode": e.then(() => { try { const { width: C, height: T, hasAlpha: I, mipmaps: w, format: R } = x.taskConfig.lowLevel ? o(x.taskConfig) : l(x.buffers[0]), b = []; for (let B = 0; B < w.length; ++B)b.push(w[B].data.buffer); self.postMessage({ type: "transcode", id: x.id, width: C, height: T, hasAlpha: I, mipmaps: w, format: R }, b) } catch (C) { console.error(C), self.postMessage({ type: "error", id: x.id, error: C.message }) } }); break } }; function a(_) { e = new Promise(x => { t = { wasmBinary: _, onRuntimeInitialized: x }, BASIS(t) }).then(() => { t.initializeBasis() }) } function o(_) { const { basisFormat: x, width: C, height: T, hasAlpha: I } = _, { transcoderFormat: w, engineFormat: R } = d(x, C, T, I), b = t.getBytesPerBlockOrPixel(w); m(t.isFormatSupported(w), "THREE.BasisTextureLoader: Unsupported format."); const B = []; if (x === s.ETC1S) { const F = new t.LowLevelETC1SImageTranscoder, { endpointCount: U, endpointsData: G, selectorCount: Y, selectorsData: Z, tablesData: ne } = _.globalData; try { let $; $ = F.decodePalettes(U, G, Y, Z), m($, "THREE.BasisTextureLoader: decodePalettes() failed."), $ = F.decodeTables(ne), m($, "THREE.BasisTextureLoader: decodeTables() failed."); for (let L = 0; L < _.levels.length; L++) { const Q = _.levels[L], D = _.globalData.imageDescs[L], V = y(w, Q.width, Q.height), J = new Uint8Array(V); $ = F.transcodeImage(w, J, V / b, Q.data, g(w, Q.width), v(w, Q.height), Q.width, Q.height, Q.index, D.rgbSliceByteOffset, D.rgbSliceByteLength, D.alphaSliceByteOffset, D.alphaSliceByteLength, D.imageFlags, I, !1, 0, 0), m($, "THREE.BasisTextureLoader: transcodeImage() failed for level " + Q.index + "."), B.push({ data: J, width: Q.width, height: Q.height }) } } finally { F.delete() } } else for (let F = 0; F < _.levels.length; F++) { const U = _.levels[F], G = y(w, U.width, U.height), Y = new Uint8Array(G), Z = t.transcodeUASTCImage(w, Y, G / b, U.data, g(w, U.width), v(w, U.height), U.width, U.height, U.index, 0, U.data.byteLength, 0, I, !1, 0, 0, -1, -1); m(Z, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + U.index + "."), B.push({ data: Y, width: U.width, height: U.height }) } return { width: C, height: T, hasAlpha: I, mipmaps: B, format: R } } function l(_) { const x = new t.BasisFile(new Uint8Array(_)), C = x.isUASTC() ? s.UASTC_4x4 : s.ETC1S, T = x.getImageWidth(0, 0), I = x.getImageHeight(0, 0), w = x.getNumLevels(0), R = x.getHasAlpha(); function b() { x.close(), x.delete() } const { transcoderFormat: B, engineFormat: F } = d(C, T, I, R); if (!T || !I || !w) throw b(), new Error("THREE.BasisTextureLoader:	Invalid texture"); if (!x.startTranscoding()) throw b(), new Error("THREE.BasisTextureLoader: .startTranscoding failed"); const U = []; for (let G = 0; G < w; G++) { const Y = x.getImageWidth(0, G), Z = x.getImageHeight(0, G), ne = new Uint8Array(x.getImageTranscodedSizeInBytes(0, G, B)); if (!x.transcodeImage(ne, 0, G, B, 0, R)) throw b(), new Error("THREE.BasisTextureLoader: .transcodeImage failed."); U.push({ data: ne, width: Y, height: Z }) } return b(), { width: T, height: I, hasAlpha: R, mipmaps: U, format: F } } const u = [{ if: "astcSupported", basisFormat: [s.UASTC_4x4], transcoderFormat: [i.ASTC_4x4, i.ASTC_4x4], engineFormat: [r.RGBA_ASTC_4x4_Format, r.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 }, { if: "bptcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.BC7_M5, i.BC7_M5], engineFormat: [r.RGBA_BPTC_Format, r.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 }, { if: "dxtSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.BC1, i.BC3], engineFormat: [r.RGB_S3TC_DXT1_Format, r.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 }, { if: "etc2Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.ETC1, i.ETC2], engineFormat: [r.RGB_ETC2_Format, r.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 }, { if: "etc1Supported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.ETC1, i.ETC1], engineFormat: [r.RGB_ETC1_Format, r.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 }, { if: "pvrtcSupported", basisFormat: [s.ETC1S, s.UASTC_4x4], transcoderFormat: [i.PVRTC1_4_RGB, i.PVRTC1_4_RGBA], engineFormat: [r.RGB_PVRTC_4BPPV1_Format, r.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 }], c = u.sort(function (_, x) { return _.priorityETC1S - x.priorityETC1S }), h = u.sort(function (_, x) { return _.priorityUASTC - x.priorityUASTC }); function d(_, x, C, T) { let I, w; const R = _ === s.ETC1S ? c : h; for (let b = 0; b < R.length; b++) { const B = R[b]; if (n[B.if] && B.basisFormat.includes(_) && !(B.needsPowerOfTwo && !(A(x) && A(C)))) return I = B.transcoderFormat[T ? 1 : 0], w = B.engineFormat[T ? 1 : 0], { transcoderFormat: I, engineFormat: w } } return console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32."), I = i.RGBA32, w = r.RGBAFormat, { transcoderFormat: I, engineFormat: w } } function m(_, x) { if (!_) throw new Error(x) } function g(_, x) { return Math.ceil(x / t.getFormatBlockWidth(_)) } function v(_, x) { return Math.ceil(x / t.getFormatBlockHeight(_)) } function y(_, x, C) { const T = t.getBytesPerBlockOrPixel(_); if (t.formatIsUncompressed(_)) return x * C * T; if (_ === i.PVRTC1_4_RGB || _ === i.PVRTC1_4_RGBA) { const I = x + 3 & -4, w = C + 3 & -4; return (Math.max(8, I) * Math.max(8, w) * 4 + 7) / 8 } return g(_, x) * v(_, C) * T } function A(_) { return _ <= 2 ? !0 : (_ & _ - 1) === 0 && _ !== 0 } }); const W_ = new WeakMap; class Cme extends Us {
		constructor(e) { super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath(e) { return this.decoderPath = e, this } setDecoderConfig(e) { return this.decoderConfig = e, this } setWorkerLimit(e) { return this.workerLimit = e, this } load(e, t, r, i) { const s = new _s(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, a => { const o = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(a, o).then(t).catch(i) }, r, i) } decodeDracoFile(e, t, r, i) { const s = { attributeIDs: r || this.defaultAttributeIDs, attributeTypes: i || this.defaultAttributeTypes, useUniqueIDs: !!r }; this.decodeGeometry(e, s).then(t) } decodeGeometry(e, t) { for (const l in t.attributeTypes) { const u = t.attributeTypes[l]; u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name) } const r = JSON.stringify(t); if (W_.has(e)) { const l = W_.get(e); if (l.key === r) return l.promise; if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let i; const s = this.workerNextTaskID++, a = e.byteLength, o = this._getWorker(s, a).then(l => (i = l, new Promise((u, c) => { i._callbacks[s] = { resolve: u, reject: c }, i.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))).then(l => this._createGeometry(l.geometry)); return o.catch(() => !0).then(() => { i && s && this._releaseTask(i, s) }), W_.set(e, { key: r, promise: o }), o } _createGeometry(e) { const t = new pn; e.index && t.setIndex(new lr(e.index.array, 1)); for (let r = 0; r < e.attributes.length; r++) { const i = e.attributes[r], s = i.name, a = i.array, o = i.itemSize; t.setAttribute(s, new lr(a, o)) } return t } _loadLibrary(e, t) { const r = new _s(this.manager); return r.setPath(this.decoderPath), r.setResponseType(t), r.setWithCredentials(this.withCredentials), new Promise((i, s) => { r.load(e, i, void 0, s) }) } preload() { return this._initDecoder(), this } _initDecoder() {
			if (this.decoderPending) return this.decoderPending; const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(r => {
				const i = r[0]; e || (this.decoderConfig.wasmBinary = r[1]); const s = Sme.toString(), a = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([a]))
			}), this.decoderPending
		} _getWorker(e, t) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { const i = new Worker(this.workerSourceURL); i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function (s) { const a = s.data; switch (a.type) { case "decode": i._callbacks[a.id].resolve(a); break; case "error": i._callbacks[a.id].reject(a); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + a.type + '"') } }, this.workerPool.push(i) } else this.workerPool.sort(function (i, s) { return i._taskLoad > s._taskLoad ? -1 : 1 }); const r = this.workerPool[this.workerPool.length - 1]; return r._taskCosts[e] = t, r._taskLoad += t, r }) } _releaseTask(e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] } debug() { console.log("Task load: ", this.workerPool.map(e => e._taskLoad)) } dispose() { for (let e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this }
	} function Sme() { let n, e; onmessage = function (a) { const o = a.data; switch (o.type) { case "init": n = o.decoderConfig, e = new Promise(function (c) { n.onModuleLoaded = function (h) { c({ draco: h }) }, DracoDecoderModule(n) }); break; case "decode": const l = o.buffer, u = o.taskConfig; e.then(c => { const h = c.draco, d = new h.Decoder, m = new h.DecoderBuffer; m.Init(new Int8Array(l), l.byteLength); try { const g = t(h, d, m, u), v = g.attributes.map(y => y.array.buffer); g.index && v.push(g.index.array.buffer), self.postMessage({ type: "decode", id: o.id, geometry: g }, v) } catch (g) { console.error(g), self.postMessage({ type: "error", id: o.id, error: g.message }) } finally { h.destroy(m), h.destroy(d) } }); break } }; function t(a, o, l, u) { const c = u.attributeIDs, h = u.attributeTypes; let d, m; const g = o.GetEncodedGeometryType(l); if (g === a.TRIANGULAR_MESH) d = new a.Mesh, m = o.DecodeBufferToMesh(l, d); else if (g === a.POINT_CLOUD) d = new a.PointCloud, m = o.DecodeBufferToPointCloud(l, d); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!m.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg()); const v = { index: null, attributes: [] }; for (const y in c) { const A = self[h[y]]; let _, x; if (u.useUniqueIDs) x = c[y], _ = o.GetAttributeByUniqueId(d, x); else { if (x = o.GetAttributeId(d, a[c[y]]), x === -1) continue; _ = o.GetAttribute(d, x) } v.attributes.push(i(a, o, d, y, A, _)) } return g === a.TRIANGULAR_MESH && (v.index = r(a, o, d)), a.destroy(d), v } function r(a, o, l) { const c = l.num_faces() * 3, h = c * 4, d = a._malloc(h); o.GetTrianglesUInt32Array(l, h, d); const m = new Uint32Array(a.HEAPF32.buffer, d, c).slice(); return a._free(d), { array: m, itemSize: 1 } } function i(a, o, l, u, c, h) { const d = h.num_components(), g = l.num_points() * d, v = g * c.BYTES_PER_ELEMENT, y = s(a, c), A = a._malloc(v); o.GetAttributeDataArrayForAllPoints(l, h, y, v, A); const _ = new c(a.HEAPF32.buffer, A, g).slice(); return a._free(A), { name: u, array: _, itemSize: d } } function s(a, o) { switch (o) { case Float32Array: return a.DT_FLOAT32; case Int8Array: return a.DT_INT8; case Int16Array: return a.DT_INT16; case Int32Array: return a.DT_INT32; case Uint8Array: return a.DT_UINT8; case Uint16Array: return a.DT_UINT16; case Uint32Array: return a.DT_UINT32 } } } let I5; const X_ = () => { if (I5) return I5; const n = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), r = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]); if (typeof WebAssembly != "object") return { supported: !1 }; let i = n; WebAssembly.validate(t) && (i = e); let s; const a = WebAssembly.instantiate(o(i), {}).then(h => { s = h.instance, s.exports.__wasm_call_ctors() }); function o(h) { const d = new Uint8Array(h.length); for (let g = 0; g < h.length; ++g) { const v = h.charCodeAt(g); d[g] = v > 96 ? v - 71 : v > 64 ? v - 65 : v > 47 ? v + 4 : v > 46 ? 63 : 62 } let m = 0; for (let g = 0; g < h.length; ++g)d[m++] = d[g] < 60 ? r[d[g]] : (d[g] - 60) * 64 + d[++g]; return d.buffer.slice(0, m) } function l(h, d, m, g, v, y) { const A = s.exports.sbrk, _ = m + 3 & -4, x = A(_ * g), C = A(v.length), T = new Uint8Array(s.exports.memory.buffer); T.set(v, C); const I = h(x, m, g, C, v.length); if (I === 0 && y && y(x, _, g), d.set(T.subarray(x, x + m * g)), A(x - A(0)), I !== 0) throw new Error(`Malformed buffer data: ${I}`) } const u = { 0: "", 1: "meshopt_decodeFilterOct", 2: "meshopt_decodeFilterQuat", 3: "meshopt_decodeFilterExp", NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, c = { 0: "meshopt_decodeVertexBuffer", 1: "meshopt_decodeIndexBuffer", 2: "meshopt_decodeIndexSequence", ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" }; return I5 = { ready: a, supported: !0, decodeVertexBuffer(h, d, m, g, v) { l(s.exports.meshopt_decodeVertexBuffer, h, d, m, g, s.exports[u[v]]) }, decodeIndexBuffer(h, d, m, g) { l(s.exports.meshopt_decodeIndexBuffer, h, d, m, g) }, decodeIndexSequence(h, d, m, g) { l(s.exports.meshopt_decodeIndexSequence, h, d, m, g) }, decodeGltfBuffer(h, d, m, g, v, y) { l(s.exports[c[v]], h, d, m, g, s.exports[u[y]]) } }, I5 }; let M5 = null, lH = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"; function uH(n, e, t) { return r => { t && t(r), n && (M5 || (M5 = new Cme), M5.setDecoderPath(typeof n == "string" ? n : lH), r.setDRACOLoader(M5)), e && r.setMeshoptDecoder(typeof X_ == "function" ? X_() : X_) } } function o2(n, e = !0, t = !0, r) { return V1(bT, n, uH(e, t, r)) } o2.preload = (n, e = !0, t = !0, r) => V1.preload(bT, n, uH(e, t, r)); o2.clear = n => V1.clear(bT, n); o2.setDecoderPath = n => { lH = n }; const Tme = ue.forwardRef(({ makeDefault: n, camera: e, regress: t, domElement: r, enableDamping: i = !0, keyEvents: s = !1, onChange: a, onStart: o, onEnd: l, ...u }, c) => { const h = su(I => I.invalidate), d = su(I => I.camera), m = su(I => I.gl), g = su(I => I.events), v = su(I => I.setEvents), y = su(I => I.set), A = su(I => I.get), _ = su(I => I.performance), x = e || d, C = r || g.connected || m.domElement, T = ue.useMemo(() => new ale(x), [x]); return Cm(() => { T.enabled && T.update() }, -1), ue.useEffect(() => (s && T.connect(s === !0 ? C : s), T.connect(C), () => void T.dispose()), [s, C, t, T, h]), ue.useEffect(() => { const I = b => { h(), t && _.regress(), a && a(b) }, w = b => { o && o(b) }, R = b => { l && l(b) }; return T.addEventListener("change", I), T.addEventListener("start", w), T.addEventListener("end", R), () => { T.removeEventListener("start", w), T.removeEventListener("end", R), T.removeEventListener("change", I) } }, [a, o, l, T, h, v]), ue.useEffect(() => { if (n) { const I = A().controls; return y({ controls: T }), () => y({ controls: I }) } }, [n, T]), ue.createElement("primitive", dc({ ref: c, object: T, enableDamping: i }, u)) }); function wme(n, e) { const t = ue.useRef(), [r] = ue.useState(() => e ? e instanceof Hn ? { current: e } : e : t), [i] = ue.useState(() => new EU(void 0)); ue.useLayoutEffect(() => { e && (r.current = e instanceof Hn ? e : e.current), i._root = r.current }); const s = ue.useRef({}), a = ue.useMemo(() => { const o = {}; return n.forEach(l => Object.defineProperty(o, l.name, { enumerable: !0, get() { if (r.current) return s.current[l.name] || (s.current[l.name] = i.clipAction(l, r.current)) }, configurable: !0 })), { ref: r, clips: n, actions: o, names: n.map(l => l.name), mixer: i } }, [n]); return Cm((o, l) => i.update(l)), ue.useEffect(() => { const o = r.current; return () => { s.current = {}, i.stopAllAction(), Object.values(a.actions).forEach(l => { o && i.uncacheAction(l, o) }) } }, [n]), a } const Y_ = parseInt(Su.replace(/\D+/g, "")) >= 154 ? "opaque_fragment" : "output_fragment"; class Ime extends N1 {
		constructor(e) {
			super(e), this.onBeforeCompile = (t, r) => {
				const { isWebGL2: i } = r.capabilities; t.fragmentShader = t.fragmentShader.replace(`#include <${Y_}>`, `
        ${i ? `#include <${Y_}>` : `#extension GL_OES_standard_derivatives : enable
#include <${Y_}>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <${parseInt(Su.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
      `)
			}
		}
	} const Mme = ue.forwardRef((n, e) => { const [t] = ue.useState(() => new Ime(null)); return ue.createElement("primitive", dc({}, n, { object: t, ref: e, attach: "material" })) }); let Td, gg; const bme = ue.createContext(null), eD = new bt, tD = new N, Bme = ue.forwardRef(({ children: n, range: e, limit: t = 1e3, ...r }, i) => { const s = ue.useRef(null), [a, o] = ue.useState([]), [[l, u, c]] = ue.useState(() => [new Float32Array(t * 3), Float32Array.from({ length: t * 3 }, () => 1), Float32Array.from({ length: t }, () => 1)]); ue.useEffect(() => { s.current.geometry.attributes.position.needsUpdate = !0 }), Cm(() => { for (s.current.updateMatrix(), s.current.updateMatrixWorld(), eD.copy(s.current.matrixWorld).invert(), s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, a.length), Td = 0; Td < a.length; Td++)gg = a[Td].current, gg.getWorldPosition(tD).applyMatrix4(eD), tD.toArray(l, Td * 3), s.current.geometry.attributes.position.needsUpdate = !0, gg.matrixWorldNeedsUpdate = !0, gg.color.toArray(u, Td * 3), s.current.geometry.attributes.color.needsUpdate = !0, c.set([gg.size], Td), s.current.geometry.attributes.size.needsUpdate = !0 }); const h = ue.useMemo(() => ({ getParent: () => s, subscribe: d => (o(m => [...m, d]), () => o(m => m.filter(g => g.current !== d.current))) }), []); return ue.createElement("points", dc({ userData: { instances: a }, matrixAutoUpdate: !1, ref: qU([i, s]), raycast: () => null }, r), ue.createElement("bufferGeometry", null, ue.createElement("bufferAttribute", { attach: "attributes-position", count: l.length / 3, array: l, itemSize: 3, usage: sc }), ue.createElement("bufferAttribute", { attach: "attributes-color", count: u.length / 3, array: u, itemSize: 3, usage: sc }), ue.createElement("bufferAttribute", { attach: "attributes-size", count: c.length, array: c, itemSize: 1, usage: sc })), ue.createElement(bme.Provider, { value: h }, n)) }), Rme = ue.forwardRef(({ children: n, positions: e, colors: t, sizes: r, stride: i = 3, ...s }, a) => { const o = ue.useRef(null); return Cm(() => { const l = o.current.geometry.attributes; l.position.needsUpdate = !0, t && (l.color.needsUpdate = !0), r && (l.size.needsUpdate = !0) }), ue.createElement("points", dc({ ref: qU([a, o]) }, s), ue.createElement("bufferGeometry", null, ue.createElement("bufferAttribute", { attach: "attributes-position", count: e.length / i, array: e, itemSize: i, usage: sc }), t && ue.createElement("bufferAttribute", { attach: "attributes-color", count: t.length / i, array: t, itemSize: 3, usage: sc }), r && ue.createElement("bufferAttribute", { attach: "attributes-size", count: r.length / i, array: r, itemSize: 1, usage: sc })), n) }), Pme = ue.forwardRef((n, e) => n.positions instanceof Float32Array ? ue.createElement(Rme, dc({}, n, { ref: e })) : ue.createElement(Bme, dc({}, n, { ref: e }))); function Dme({ all: n, scene: e, camera: t }) { const r = su(({ gl: a }) => a), i = su(({ camera: a }) => a), s = su(({ scene: a }) => a); return ue.useLayoutEffect(() => { const a = []; n && (e || s).traverse(u => { u.visible === !1 && (a.push(u), u.visible = !0) }), r.compile(e || s, t || i); const o = new zS(128); new HS(.01, 1e5, o).update(r, e || s), o.dispose(), a.forEach(u => u.visible = !1) }, []), null } const Lme = n => { const e = ue.useRef(), [t] = ue.useState(() => Vre(new Float32Array(5e3), { radius: 1.2 })); return Cm((r, i) => { e.current.rotation.x -= i / 10, e.current.rotation.y -= i / 15 }), re.jsx("group", { rotation: [0, 0, Math.PI / 4], children: re.jsx(Pme, { ref: e, positions: t, stride: 3, frustumCulled: !0, ...n, children: re.jsx(Mme, { transparent: !0, color: "#f272c8", size: .001, sizeAttenuation: !0, depthWrite: !1 }) }) }) }, Fme = () => re.jsx("div", { className: "starpart", children: re.jsxs(KU, { camera: { position: [0, 0, 1] }, children: [re.jsx(ue.Suspense, { fallback: null, children: re.jsx(Lme, {}) }), re.jsx(Dme, { all: !0 })] }) }); function kme(n) { const e = ue.useRef(), { nodes: t, materials: r, animations: i } = o2("/Taskverse/earth.gltf"); return wme(i, e), Cm(({ clock: s }) => { e.current.rotation.y += .003, e.current.rotation.x += .001 }), re.jsx("group", { ref: e, ...n, dispose: null, children: re.jsx("group", { name: "Sketchfab_Scene", children: re.jsx("group", { name: "Sketchfab_model", rotation: [-1.54, -.064, 0], children: re.jsxs("group", { name: "root", rotation: [0, Math.PI / 4, 0], children: [" ", re.jsxs("group", { name: "GLTF_SceneRootNode", rotation: [Math.PI / 2, 0, 0], children: [re.jsxs("group", { name: "Clouds_1", children: [re.jsx("mesh", { name: "Object_4", geometry: t.Object_4.geometry, material: r.Clouds, scale: [1.8, 1.8, 1.8] }), " "] }), re.jsxs("group", { name: "Planet_2", children: [re.jsx("mesh", { name: "Object_6", geometry: t.Object_6.geometry, material: r.Planet, scale: [1.8, 1.8, 1.8] }), " "] })] })] }) }) }) }) } o2.preload("/Taskverse/earth.gltf"); function Nme() { return re.jsxs(KU, { className: "canvas hide", id: "canvis", children: [re.jsx(Tme, { enableZoom: !1, enablePan: !1 }), re.jsx("ambientLight", { intensity: .5 }), re.jsx("directionalLight", { position: [-2, 5, 2], intensity: 1 }), re.jsx(kme, {})] }) } function cH(n) { var e, t, r = ""; if (typeof n == "string" || typeof n == "number") r += n; else if (typeof n == "object") if (Array.isArray(n)) for (e = 0; e < n.length; e++)n[e] && (t = cH(n[e])) && (r && (r += " "), r += t); else for (e in n) n[e] && (r && (r += " "), r += e); return r } function Wp() { for (var n, e, t = 0, r = ""; t < arguments.length;)(n = arguments[t++]) && (e = cH(n)) && (r && (r += " "), r += e); return r } let Ome = { data: "" }, Ume = n => typeof window == "object" ? ((n ? n.querySelector("#_goober") : window._goober) || Object.assign((n || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : n || Ome, Gme = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Qme = /\/\*[^]*?\*\/|  +/g, nD = /\n+/g, Qd = (n, e) => { let t = "", r = "", i = ""; for (let s in n) { let a = n[s]; s[0] == "@" ? s[1] == "i" ? t = s + " " + a + ";" : r += s[1] == "f" ? Qd(a, s) : s + "{" + Qd(a, s[1] == "k" ? "" : e) + "}" : typeof a == "object" ? r += Qd(a, e ? e.replace(/([^,])+/g, o => s.replace(/(^:.*)|([^,])+/g, l => /&/.test(l) ? l.replace(/&/g, o) : o ? o + " " + l : l)) : s) : a != null && (s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase(), i += Qd.p ? Qd.p(s, a) : s + ":" + a + ";") } return t + (e && i ? e + "{" + i + "}" : i) + r }, Uc = {}, fH = n => { if (typeof n == "object") { let e = ""; for (let t in n) e += t + fH(n[t]); return e } return n }, Hme = (n, e, t, r, i) => { let s = fH(n), a = Uc[s] || (Uc[s] = (l => { let u = 0, c = 11; for (; u < l.length;)c = 101 * c + l.charCodeAt(u++) >>> 0; return "go" + c })(s)); if (!Uc[a]) { let l = s !== n ? n : (u => { let c, h, d = [{}]; for (; c = Gme.exec(u.replace(Qme, ""));)c[4] ? d.shift() : c[3] ? (h = c[3].replace(nD, " ").trim(), d.unshift(d[0][h] = d[0][h] || {})) : d[0][c[1]] = c[2].replace(nD, " ").trim(); return d[0] })(n); Uc[a] = Qd(i ? { ["@keyframes " + a]: l } : l, t ? "" : "." + a) } let o = t && Uc.g ? Uc.g : null; return t && (Uc.g = Uc[a]), ((l, u, c, h) => { h ? u.data = u.data.replace(h, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l) })(Uc[a], e, r, o), a }, zme = (n, e, t) => n.reduce((r, i, s) => { let a = e[s]; if (a && a.call) { let o = a(t), l = o && o.props && o.props.className || /^go/.test(o) && o; a = l ? "." + l : o && typeof o == "object" ? o.props ? "" : Qd(o, "") : o === !1 ? "" : o } return r + i + (a ?? "") }, ""); function $T(n) { let e = this || {}, t = n.call ? n(e.p) : n; return Hme(t.unshift ? t.raw ? zme(t, [].slice.call(arguments, 1), e.p) : t.reduce((r, i) => Object.assign(r, i && i.call ? i(e.p) : i), {}) : t, Ume(e.target), e.g, e.o, e.k) } $T.bind({ g: 1 }); $T.bind({ k: 1 }); function rD(n, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r) } } function hH(n, e, t) { return e && rD(n.prototype, e), t && rD(n, t), n } function xr() { return xr = Object.assign || function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]) } return n }, xr.apply(this, arguments) } function dH(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e } function l2(n, e) { if (n == null) return {}; var t = {}, r = Object.keys(n), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (t[i] = n[i]); return t } function iD(n) { if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return n } var sD = function () { return "" }, pH = mr.createContext({ enqueueSnackbar: sD, closeSnackbar: sD }), Od = { downXs: "@media (max-width:599.95px)", upSm: "@media (min-width:600px)" }, aD = function (e) { return e.charAt(0).toUpperCase() + e.slice(1) }, ew = function (e) { return "" + aD(e.vertical) + aD(e.horizontal) }, b5 = function (e) { return !!e || e === 0 }, B5 = "unmounted", k0 = "exited", N0 = "entering", Ag = "entered", oD = "exiting", tw = function (n) { dH(e, n); function e(r) { var i; i = n.call(this, r) || this; var s = r.appear, a; return i.appearStatus = null, r.in ? s ? (a = k0, i.appearStatus = N0) : a = Ag : r.unmountOnExit || r.mountOnEnter ? a = B5 : a = k0, i.state = { status: a }, i.nextCallback = null, i } e.getDerivedStateFromProps = function (i, s) { var a = i.in; return a && s.status === B5 ? { status: k0 } : null }; var t = e.prototype; return t.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, t.componentDidUpdate = function (i) { var s = null; if (i !== this.props) { var a = this.state.status; this.props.in ? a !== N0 && a !== Ag && (s = N0) : (a === N0 || a === Ag) && (s = oD) } this.updateStatus(!1, s) }, t.componentWillUnmount = function () { this.cancelNextCallback() }, t.getTimeouts = function () { var i = this.props.timeout, s = i, a = i; return i != null && typeof i != "number" && typeof i != "string" && (a = i.exit, s = i.enter), { exit: a, enter: s } }, t.updateStatus = function (i, s) { i === void 0 && (i = !1), s !== null ? (this.cancelNextCallback(), s === N0 ? this.performEnter(i) : this.performExit()) : this.props.unmountOnExit && this.state.status === k0 && this.setState({ status: B5 }) }, t.performEnter = function (i) { var s = this, a = this.props.enter, o = i, l = this.getTimeouts(); if (!i && !a) { this.safeSetState({ status: Ag }, function () { s.props.onEntered && s.props.onEntered(s.node, o) }); return } this.props.onEnter && this.props.onEnter(this.node, o), this.safeSetState({ status: N0 }, function () { s.props.onEntering && s.props.onEntering(s.node, o), s.onTransitionEnd(l.enter, function () { s.safeSetState({ status: Ag }, function () { s.props.onEntered && s.props.onEntered(s.node, o) }) }) }) }, t.performExit = function () { var i = this, s = this.props.exit, a = this.getTimeouts(); if (!s) { this.safeSetState({ status: k0 }, function () { i.props.onExited && i.props.onExited(i.node) }); return } this.props.onExit && this.props.onExit(this.node), this.safeSetState({ status: oD }, function () { i.props.onExiting && i.props.onExiting(i.node), i.onTransitionEnd(a.exit, function () { i.safeSetState({ status: k0 }, function () { i.props.onExited && i.props.onExited(i.node) }) }) }) }, t.cancelNextCallback = function () { this.nextCallback !== null && this.nextCallback.cancel && (this.nextCallback.cancel(), this.nextCallback = null) }, t.safeSetState = function (i, s) { s = this.setNextCallback(s), this.setState(i, s) }, t.setNextCallback = function (i) { var s = this, a = !0; return this.nextCallback = function () { a && (a = !1, s.nextCallback = null, i()) }, this.nextCallback.cancel = function () { a = !1 }, this.nextCallback }, t.onTransitionEnd = function (i, s) { this.setNextCallback(s); var a = i == null && !this.props.addEndListener; if (!this.node || a) { setTimeout(this.nextCallback, 0); return } this.props.addEndListener && this.props.addEndListener(this.node, this.nextCallback), i != null && setTimeout(this.nextCallback, i) }, t.render = function () { var i = this.state.status; if (i === B5) return null; var s = this.props, a = s.children, o = l2(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]); return a(i, o) }, hH(e, [{ key: "node", get: function () { var i, s = (i = this.props.nodeRef) === null || i === void 0 ? void 0 : i.current; if (!s) throw new Error("notistack - Custom snackbar is not refForwarding"); return s } }]), e }(mr.Component); function O0() { } tw.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: O0, onEntering: O0, onEntered: O0, onExit: O0, onExiting: O0, onExited: O0 }; function lD(n, e) { typeof n == "function" ? n(e) : n && (n.current = e) } function Y7(n, e) { return ue.useMemo(function () { return n == null && e == null ? null : function (t) { lD(n, t), lD(e, t) } }, [n, e]) } function by(n) { var e = n.timeout, t = n.style, r = t === void 0 ? {} : t, i = n.mode; return { duration: typeof e == "object" ? e[i] || 0 : e, easing: r.transitionTimingFunction, delay: r.transitionDelay } } var j7 = { easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)", easeOut: "cubic-bezier(0.0, 0, 0.2, 1)", easeIn: "cubic-bezier(0.4, 0, 1, 1)", sharp: "cubic-bezier(0.4, 0, 0.6, 1)" }, mH = function (e) { e.scrollTop = e.scrollTop }, uD = function (e) { return Math.round(e) + "ms" }; function d3(n, e) { n === void 0 && (n = ["all"]); var t = e || {}, r = t.duration, i = r === void 0 ? 300 : r, s = t.easing, a = s === void 0 ? j7.easeInOut : s, o = t.delay, l = o === void 0 ? 0 : o, u = Array.isArray(n) ? n : [n]; return u.map(function (c) { var h = typeof i == "string" ? i : uD(i), d = typeof l == "string" ? l : uD(l); return c + " " + h + " " + a + " " + d }).join(",") } function Vme(n) { return n && n.ownerDocument || document } function gH(n) { var e = Vme(n); return e.defaultView || window } function Wme(n, e) { e === void 0 && (e = 166); var t; function r() { for (var i = this, s = arguments.length, a = new Array(s), o = 0; o < s; o++)a[o] = arguments[o]; var l = function () { n.apply(i, a) }; clearTimeout(t), t = setTimeout(l, e) } return r.clear = function () { clearTimeout(t) }, r } function Xme(n, e) { var t = e.getBoundingClientRect(), r = gH(e), i; if (e.fakeTransform) i = e.fakeTransform; else { var s = r.getComputedStyle(e); i = s.getPropertyValue("-webkit-transform") || s.getPropertyValue("transform") } var a = 0, o = 0; if (i && i !== "none" && typeof i == "string") { var l = i.split("(")[1].split(")")[0].split(","); a = parseInt(l[4], 10), o = parseInt(l[5], 10) } switch (n) { case "left": return "translateX(" + (r.innerWidth + a - t.left) + "px)"; case "right": return "translateX(-" + (t.left + t.width - a) + "px)"; case "up": return "translateY(" + (r.innerHeight + o - t.top) + "px)"; default: return "translateY(-" + (t.top + t.height - o) + "px)" } } function R5(n, e) { if (e) { var t = Xme(n, e); t && (e.style.webkitTransform = t, e.style.transform = t) } } var AH = ue.forwardRef(function (n, e) { var t = n.children, r = n.direction, i = r === void 0 ? "down" : r, s = n.in, a = n.style, o = n.timeout, l = o === void 0 ? 0 : o, u = n.onEnter, c = n.onEntered, h = n.onExit, d = n.onExited, m = l2(n, ["children", "direction", "in", "style", "timeout", "onEnter", "onEntered", "onExit", "onExited"]), g = ue.useRef(null), v = Y7(t.ref, g), y = Y7(v, e), A = function (w, R) { R5(i, w), mH(w), u && u(w, R) }, _ = function (w) { var R = (a == null ? void 0 : a.transitionTimingFunction) || j7.easeOut, b = by({ timeout: l, mode: "enter", style: xr({}, a, { transitionTimingFunction: R }) }); w.style.webkitTransition = d3("-webkit-transform", b), w.style.transition = d3("transform", b), w.style.webkitTransform = "none", w.style.transform = "none" }, x = function (w) { var R = (a == null ? void 0 : a.transitionTimingFunction) || j7.sharp, b = by({ timeout: l, mode: "exit", style: xr({}, a, { transitionTimingFunction: R }) }); w.style.webkitTransition = d3("-webkit-transform", b), w.style.transition = d3("transform", b), R5(i, w), h && h(w) }, C = function (w) { w.style.webkitTransition = "", w.style.transition = "", d && d(w) }, T = ue.useCallback(function () { g.current && R5(i, g.current) }, [i]); return ue.useEffect(function () { if (!(s || i === "down" || i === "right")) { var I = Wme(function () { g.current && R5(i, g.current) }), w = gH(g.current); return w.addEventListener("resize", I), function () { I.clear(), w.removeEventListener("resize", I) } } }, [i, s]), ue.useEffect(function () { s || T() }, [s, T]), ue.createElement(tw, Object.assign({ appear: !0, nodeRef: g, onEnter: A, onEntered: c, onEntering: _, onExit: x, onExited: C, in: s, timeout: l }, m), function (I, w) { return ue.cloneElement(t, xr({ ref: y, style: xr({ visibility: I === "exited" && !s ? "hidden" : void 0 }, a, {}, t.props.style) }, w)) }) }); AH.displayName = "Slide"; var s4 = function (e) { return mr.createElement("svg", Object.assign({ viewBox: "0 0 24 24", focusable: "false", style: { fontSize: 20, marginInlineEnd: 8, userSelect: "none", width: "1em", height: "1em", display: "inline-block", fill: "currentColor", flexShrink: 0 } }, e)) }, Yme = function () {
		return mr.createElement(s4, null, mr.createElement("path", {
			d: `M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41
        10.59L10 14.17L17.59 6.58L19 8L10 17Z`}))
	}, jme = function () { return mr.createElement(s4, null, mr.createElement("path", { d: "M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z" })) }, Jme = function () {
		return mr.createElement(s4, null, mr.createElement("path", {
			d: `M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,
        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,
        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z`}))
	}, Kme = function () {
		return mr.createElement(s4, null, mr.createElement("path", {
			d: `M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,
        0 22,12A10,10 0 0,0 12,2Z`}))
	}, qme = { default: void 0, success: mr.createElement(Yme, null), warning: mr.createElement(jme, null), error: mr.createElement(Jme, null), info: mr.createElement(Kme, null) }, mp = { maxSnack: 3, persist: !1, hideIconVariant: !1, disableWindowBlurListener: !1, variant: "default", autoHideDuration: 5e3, iconVariant: qme, anchorOrigin: { vertical: "bottom", horizontal: "left" }, TransitionComponent: AH, transitionDuration: { enter: 225, exit: 195 } }, Zme = function (e, t) { var r = function (s) { return typeof s == "number" || s === null }; return r(e) ? e : r(t) ? t : mp.autoHideDuration }, $me = function (e, t) { var r = function (s, a) { return a.some(function (o) { return typeof s === o }) }; return r(e, ["string", "number"]) ? e : r(e, ["object"]) ? xr({}, mp.transitionDuration, {}, r(t, ["object"]) && t, {}, e) : r(t, ["string", "number"]) ? t : r(t, ["object"]) ? xr({}, mp.transitionDuration, {}, t) : mp.transitionDuration }, ege = function (e, t) { return function (r, i) { return i === void 0 && (i = !1), i ? xr({}, mp[r], {}, t[r], {}, e[r]) : r === "autoHideDuration" ? Zme(e.autoHideDuration, t.autoHideDuration) : r === "transitionDuration" ? $me(e.transitionDuration, t.transitionDuration) : e[r] || t[r] || mp[r] } }; function u2(n) { return Object.entries(n).reduce(function (e, t) { var r, i = t[0], s = t[1]; return xr({}, e, (r = {}, r[i] = $T(s), r)) }, {}) } var hm = { SnackbarContainer: "notistack-SnackbarContainer", Snackbar: "notistack-Snackbar", CollapseWrapper: "notistack-CollapseWrapper", MuiContent: "notistack-MuiContent", MuiContentVariant: function (e) { return "notistack-MuiContent-" + e } }, cD = u2({ root: { height: 0 }, entered: { height: "auto" } }), j_ = "0px", J_ = 175, vH = ue.forwardRef(function (n, e) { var t = n.children, r = n.in, i = n.onExited, s = ue.useRef(null), a = ue.useRef(null), o = Y7(e, a), l = function () { return s.current ? s.current.clientHeight : 0 }, u = function (v) { v.style.height = j_ }, c = function (v) { var y = l(), A = by({ timeout: J_, mode: "enter" }), _ = A.duration, x = A.easing; v.style.transitionDuration = typeof _ == "string" ? _ : _ + "ms", v.style.height = y + "px", v.style.transitionTimingFunction = x || "" }, h = function (v) { v.style.height = "auto" }, d = function (v) { v.style.height = l() + "px" }, m = function (v) { mH(v); var y = by({ timeout: J_, mode: "exit" }), A = y.duration, _ = y.easing; v.style.transitionDuration = typeof A == "string" ? A : A + "ms", v.style.height = j_, v.style.transitionTimingFunction = _ || "" }; return ue.createElement(tw, { in: r, unmountOnExit: !0, onEnter: u, onEntered: h, onEntering: c, onExit: d, onExited: i, onExiting: m, nodeRef: a, timeout: J_ }, function (g, v) { return ue.createElement("div", Object.assign({ ref: o, className: Wp(cD.root, g === "entered" && cD.entered), style: xr({ pointerEvents: "all", overflow: "hidden", minHeight: j_, transition: d3("height") }, g === "entered" && { overflow: "visible" }, {}, g === "exited" && !r && { visibility: "hidden" }) }, v), ue.createElement("div", { ref: s, className: hm.CollapseWrapper, style: { display: "flex", width: "100%" } }, t)) }) }); vH.displayName = "Collapse"; var fD = { right: "left", left: "right", bottom: "up", top: "down" }, tge = function (e) { return e.horizontal !== "center" ? fD[e.horizontal] : fD[e.vertical] }, nge = function (e) { return "anchorOrigin" + ew(e) }, rge = function (e) { e === void 0 && (e = {}); var t = { containerRoot: !0, containerAnchorOriginTopCenter: !0, containerAnchorOriginBottomCenter: !0, containerAnchorOriginTopRight: !0, containerAnchorOriginBottomRight: !0, containerAnchorOriginTopLeft: !0, containerAnchorOriginBottomLeft: !0 }; return Object.keys(e).filter(function (r) { return !t[r] }).reduce(function (r, i) { var s; return xr({}, r, (s = {}, s[i] = e[i], s)) }, {}) }, ige = function () { }; function mA(n, e) { return n.reduce(function (t, r) { return r == null ? t : function () { for (var s = arguments.length, a = new Array(s), o = 0; o < s; o++)a[o] = arguments[o]; var l = [].concat(a); e && l.indexOf(e) === -1 && l.push(e), t.apply(this, l), r.apply(this, l) } }, ige) } var sge = typeof window < "u" ? ue.useLayoutEffect : ue.useEffect; function hD(n) { var e = ue.useRef(n); return sge(function () { e.current = n }), ue.useCallback(function () { return e.current.apply(void 0, arguments) }, []) } var yH = ue.forwardRef(function (n, e) { var t = n.children, r = n.className, i = n.autoHideDuration, s = n.disableWindowBlurListener, a = s === void 0 ? !1 : s, o = n.onClose, l = n.id, u = n.open, c = n.SnackbarProps, h = c === void 0 ? {} : c, d = ue.useRef(), m = hD(function () { o && o.apply(void 0, arguments) }), g = hD(function (x) { !o || x == null || (d.current && clearTimeout(d.current), d.current = setTimeout(function () { m(null, "timeout", l) }, x)) }); ue.useEffect(function () { return u && g(i), function () { d.current && clearTimeout(d.current) } }, [u, i, g]); var v = function () { d.current && clearTimeout(d.current) }, y = ue.useCallback(function () { i != null && g(i * .5) }, [i, g]), A = function (C) { h.onMouseEnter && h.onMouseEnter(C), v() }, _ = function (C) { h.onMouseLeave && h.onMouseLeave(C), y() }; return ue.useEffect(function () { if (!a && u) return window.addEventListener("focus", y), window.addEventListener("blur", v), function () { window.removeEventListener("focus", y), window.removeEventListener("blur", v) } }, [a, y, u]), ue.createElement("div", Object.assign({ ref: e }, h, { className: Wp(hm.Snackbar, r), onMouseEnter: A, onMouseLeave: _ }), t) }); yH.displayName = "Snackbar"; var K_, age = u2({ root: (K_ = { display: "flex", flexWrap: "wrap", flexGrow: 1 }, K_[Od.upSm] = { flexGrow: "initial", minWidth: "288px" }, K_) }), xH = ue.forwardRef(function (n, e) { var t = n.className, r = l2(n, ["className"]); return mr.createElement("div", Object.assign({ ref: e, className: Wp(age.root, t) }, r)) }); xH.displayName = "SnackbarContent"; var vg = u2({ root: { backgroundColor: "#313131", fontSize: "0.875rem", lineHeight: 1.43, letterSpacing: "0.01071em", color: "#fff", alignItems: "center", padding: "6px 16px", borderRadius: "4px", boxShadow: "0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)" }, lessPadding: { paddingLeft: 8 * 2.5 + "px" }, default: { backgroundColor: "#313131" }, success: { backgroundColor: "#43a047" }, error: { backgroundColor: "#d32f2f" }, warning: { backgroundColor: "#ff9800" }, info: { backgroundColor: "#2196f3" }, message: { display: "flex", alignItems: "center", padding: "8px 0" }, action: { display: "flex", alignItems: "center", marginLeft: "auto", paddingLeft: "16px", marginRight: "-8px" } }), dD = "notistack-snackbar", _H = ue.forwardRef(function (n, e) { var t = n.id, r = n.message, i = n.action, s = n.iconVariant, a = n.variant, o = n.hideIconVariant, l = n.style, u = n.className, c = s[a], h = i; return typeof h == "function" && (h = h(t)), mr.createElement(xH, { ref: e, role: "alert", "aria-describedby": dD, style: l, className: Wp(hm.MuiContent, hm.MuiContentVariant(a), vg.root, vg[a], u, !o && c && vg.lessPadding) }, mr.createElement("div", { id: dD, className: vg.message }, o ? null : c, r), h && mr.createElement("div", { className: vg.action }, h)) }); _H.displayName = "MaterialDesignContent"; var oge = ue.memo(_H), lge = u2({ wrappedRoot: { width: "100%", position: "relative", transform: "translateX(0)", top: 0, right: 0, bottom: 0, left: 0, minWidth: "288px" } }), uge = function (e) { var t = ue.useRef(), r = ue.useState(!0), i = r[0], s = r[1], a = mA([e.snack.onClose, e.onClose]), o = function () { e.snack.requestClose && a(null, "instructed", e.snack.id) }, l = ue.useCallback(function () { t.current = setTimeout(function () { s(function (b) { return !b }) }, 125) }, []); ue.useEffect(function () { return function () { t.current && clearTimeout(t.current) } }, []); var u = e.snack, c = e.classes, h = e.Component, d = h === void 0 ? oge : h, m = ue.useMemo(function () { return rge(c) }, [c]), g = u.open, v = u.SnackbarProps, y = u.TransitionComponent, A = u.TransitionProps, _ = u.transitionDuration, x = u.disableWindowBlurListener, C = u.content, T = l2(u, ["open", "SnackbarProps", "TransitionComponent", "TransitionProps", "transitionDuration", "disableWindowBlurListener", "content", "entered", "requestClose", "onEnter", "onEntered", "onExit", "onExited"]), I = xr({ direction: tge(T.anchorOrigin), timeout: _ }, A), w = C; typeof w == "function" && (w = w(T.id, T.message)); var R = ["onEnter", "onEntered", "onExit", "onExited"].reduce(function (b, B) { var F; return xr({}, b, (F = {}, F[B] = mA([e.snack[B], e[B]], T.id), F)) }, {}); return mr.createElement(vH, { in: i, onExited: R.onExited }, mr.createElement(yH, { open: g, id: T.id, disableWindowBlurListener: x, autoHideDuration: T.autoHideDuration, className: Wp(lge.wrappedRoot, m.root, m[nge(T.anchorOrigin)]), SnackbarProps: v, onClose: a }, mr.createElement(y, Object.assign({}, I, { appear: !0, in: g, onExit: R.onExit, onExited: l, onEnter: R.onEnter, onEntered: mA([R.onEntered, o], T.id) }), w || mr.createElement(d, Object.assign({}, T))))) }, yg, q_, P5, D5, Z_, Gc = { view: { default: 20, dense: 4 }, snackbar: { default: 6, dense: 2 } }, pD = "." + hm.CollapseWrapper, $_ = 16, L5 = u2({ root: (yg = { boxSizing: "border-box", display: "flex", maxHeight: "100%", position: "fixed", zIndex: 1400, height: "auto", width: "auto", transition: d3(["top", "right", "bottom", "left", "max-width"], { duration: 300, easing: "ease" }), pointerEvents: "none" }, yg[pD] = { padding: Gc.snackbar.default + "px 0px", transition: "padding 300ms ease 0ms" }, yg.maxWidth = "calc(100% - " + Gc.view.default * 2 + "px)", yg[Od.downXs] = { width: "100%", maxWidth: "calc(100% - " + $_ * 2 + "px)" }, yg), rootDense: (q_ = {}, q_[pD] = { padding: Gc.snackbar.dense + "px 0px" }, q_), top: { top: Gc.view.default - Gc.snackbar.default + "px", flexDirection: "column" }, bottom: { bottom: Gc.view.default - Gc.snackbar.default + "px", flexDirection: "column-reverse" }, left: (P5 = { left: Gc.view.default + "px" }, P5[Od.upSm] = { alignItems: "flex-start" }, P5[Od.downXs] = { left: $_ + "px" }, P5), right: (D5 = { right: Gc.view.default + "px" }, D5[Od.upSm] = { alignItems: "flex-end" }, D5[Od.downXs] = { right: $_ + "px" }, D5), center: (Z_ = { left: "50%", transform: "translateX(-50%)" }, Z_[Od.upSm] = { alignItems: "center" }, Z_) }), cge = function (e) { var t = e.classes, r = t === void 0 ? {} : t, i = e.anchorOrigin, s = e.dense, a = e.children, o = Wp(hm.SnackbarContainer, L5[i.vertical], L5[i.horizontal], L5.root, r.containerRoot, r["containerAnchorOrigin" + ew(i)], s && L5.rootDense); return mr.createElement("div", { className: o }, a) }, fge = ue.memo(cge), mD = function (e) { var t = typeof e == "string" || ue.isValidElement(e); return !t }, hge = function (n) { dH(e, n); function e(r) { var i; return i = n.call(this, r) || this, i.enqueueSnackbar = function (s, a) { if (a === void 0 && (a = {}), s == null) throw new Error("enqueueSnackbar called with invalid argument"); var o = mD(s) ? s : a, l = mD(s) ? s.message : s, u = o.key, c = o.preventDuplicate, h = l2(o, ["key", "preventDuplicate"]), d = b5(u), m = d ? u : new Date().getTime() + Math.random(), g = ege(h, i.props), v = xr({ id: m }, h, { message: l, open: !0, entered: !1, requestClose: !1, persist: g("persist"), action: g("action"), content: g("content"), variant: g("variant"), anchorOrigin: g("anchorOrigin"), disableWindowBlurListener: g("disableWindowBlurListener"), autoHideDuration: g("autoHideDuration"), hideIconVariant: g("hideIconVariant"), TransitionComponent: g("TransitionComponent"), transitionDuration: g("transitionDuration"), TransitionProps: g("TransitionProps", !0), iconVariant: g("iconVariant", !0), style: g("style", !0), SnackbarProps: g("SnackbarProps", !0), className: Wp(i.props.className, h.className) }); return v.persist && (v.autoHideDuration = void 0), i.setState(function (y) { if (c === void 0 && i.props.preventDuplicate || c) { var A = function (T) { return d ? T.id === m : T.message === l }, _ = y.queue.findIndex(A) > -1, x = y.snacks.findIndex(A) > -1; if (_ || x) return y } return i.handleDisplaySnack(xr({}, y, { queue: [].concat(y.queue, [v]) })) }), m }, i.handleDisplaySnack = function (s) { var a = s.snacks; return a.length >= i.maxSnack ? i.handleDismissOldest(s) : i.processQueue(s) }, i.processQueue = function (s) { var a = s.queue, o = s.snacks; return a.length > 0 ? xr({}, s, { snacks: [].concat(o, [a[0]]), queue: a.slice(1, a.length) }) : s }, i.handleDismissOldest = function (s) { if (s.snacks.some(function (c) { return !c.open || c.requestClose })) return s; var a = !1, o = !1, l = s.snacks.reduce(function (c, h) { return c + (h.open && h.persist ? 1 : 0) }, 0); l === i.maxSnack && (o = !0); var u = s.snacks.map(function (c) { return !a && (!c.persist || o) ? (a = !0, c.entered ? (c.onClose && c.onClose(null, "maxsnack", c.id), i.props.onClose && i.props.onClose(null, "maxsnack", c.id), xr({}, c, { open: !1 })) : xr({}, c, { requestClose: !0 })) : xr({}, c) }); return xr({}, s, { snacks: u }) }, i.handleEnteredSnack = function (s, a, o) { if (!b5(o)) throw new Error("handleEnteredSnack Cannot be called with undefined key"); i.setState(function (l) { var u = l.snacks; return { snacks: u.map(function (c) { return c.id === o ? xr({}, c, { entered: !0 }) : xr({}, c) }) } }) }, i.handleCloseSnack = function (s, a, o) { i.props.onClose && i.props.onClose(s, a, o); var l = o === void 0; i.setState(function (u) { var c = u.snacks, h = u.queue; return { snacks: c.map(function (d) { return !l && d.id !== o ? xr({}, d) : d.entered ? xr({}, d, { open: !1 }) : xr({}, d, { requestClose: !0 }) }), queue: h.filter(function (d) { return d.id !== o }) } }) }, i.closeSnackbar = function (s) { var a = i.state.snacks.find(function (o) { return o.id === s }); b5(s) && a && a.onClose && a.onClose(null, "instructed", s), i.handleCloseSnack(null, "instructed", s) }, i.handleExitedSnack = function (s, a) { if (!b5(a)) throw new Error("handleExitedSnack Cannot be called with undefined key"); i.setState(function (o) { var l = i.processQueue(xr({}, o, { snacks: o.snacks.filter(function (u) { return u.id !== a }) })); return l.queue.length === 0 ? l : i.handleDismissOldest(l) }) }, i.enqueueSnackbar, i.closeSnackbar, i.state = { snacks: [], queue: [], contextValue: { enqueueSnackbar: i.enqueueSnackbar.bind(iD(i)), closeSnackbar: i.closeSnackbar.bind(iD(i)) } }, i } var t = e.prototype; return t.render = function () { var i = this, s = this.state.contextValue, a = this.props, o = a.domRoot, l = a.children, u = a.dense, c = u === void 0 ? !1 : u, h = a.Components, d = h === void 0 ? {} : h, m = a.classes, g = this.state.snacks.reduce(function (y, A) { var _, x = ew(A.anchorOrigin), C = y[x] || []; return xr({}, y, (_ = {}, _[x] = [].concat(C, [A]), _)) }, {}), v = Object.keys(g).map(function (y) { var A = g[y], _ = A[0]; return mr.createElement(fge, { key: y, dense: c, anchorOrigin: _.anchorOrigin, classes: m }, A.map(function (x) { return mr.createElement(uge, { key: x.id, snack: x, classes: m, Component: d[x.variant], onClose: i.handleCloseSnack, onEnter: i.props.onEnter, onExit: i.props.onExit, onExited: mA([i.handleExitedSnack, i.props.onExited], x.id), onEntered: mA([i.handleEnteredSnack, i.props.onEntered], x.id) }) })) }); return mr.createElement(pH.Provider, { value: s }, l, o ? BF.createPortal(v, o) : v) }, hH(e, [{ key: "maxSnack", get: function () { return this.props.maxSnack || mp.maxSnack } }]), e }(ue.Component), dge = function () { return ue.useContext(pH) }; const x1 = { _origin: "https://api.emailjs.com" }, pge = (n, e = "https://api.emailjs.com") => { x1._userID = n, x1._origin = e }, EH = (n, e, t) => { if (!n) throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account"; if (!e) throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"; if (!t) throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"; return !0 }; class gD { constructor(e) { this.status = e ? e.status : 0, this.text = e ? e.responseText : "Network Error" } } const CH = (n, e, t = {}) => new Promise((r, i) => { const s = new XMLHttpRequest; s.addEventListener("load", ({ target: a }) => { const o = new gD(a); o.status === 200 || o.text === "OK" ? r(o) : i(o) }), s.addEventListener("error", ({ target: a }) => { i(new gD(a)) }), s.open("POST", x1._origin + n, !0), Object.keys(t).forEach(a => { s.setRequestHeader(a, t[a]) }), s.send(e) }), mge = (n, e, t, r) => { const i = r || x1._userID; return EH(i, n, e), CH("/api/v1.0/email/send", JSON.stringify({ lib_version: "3.11.0", user_id: i, service_id: n, template_id: e, template_params: t }), { "Content-type": "application/json" }) }, gge = n => { let e; if (typeof n == "string" ? e = document.querySelector(n) : e = n, !e || e.nodeName !== "FORM") throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"; return e }, Age = (n, e, t, r) => { const i = r || x1._userID, s = gge(t); EH(i, n, e); const a = new FormData(s); return a.append("lib_version", "3.11.0"), a.append("service_id", n), a.append("template_id", e), a.append("user_id", i), CH("/api/v1.0/email/send-form", a) }, vge = { init: pge, send: mge, sendForm: Age }, yge = () => { const n = ue.useRef(null), [e, t] = ue.useState(!1), r = { user_name: "", user_email: "", message: "" }, [i, s] = ue.useState(r), { enqueueSnackbar: a } = dge(), o = h => { const { name: d, value: m } = h.target; s({ ...i, [d]: m }) }, l = h => { h.preventDefault(); const d = u(i); if (Object.keys(d).length === 0) c(); else for (const m in d) a(d[m], { variant: "error" }) }, u = h => { const d = {}, m = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/; return h.user_name || (d.user_name = "Username is required!"), h.user_email ? m.test(h.user_email) || (d.user_email = "Invalid email format") : d.user_email = "Email is required!", h.message || (d.message = "Message is required!"), d }, c = () => { t(!0), vge.sendForm("mamadlol", "template_hjr0wau", n.current, "tS5GeiHJQ4Xe606TM").then(h => { a("Email sent successfully", { variant: "success" }), n.current.reset(), s(r), t(!1), console.log(h) }).catch(h => { a("Email sending failed", { variant: "error" }), t(!1), console.log(h) }) }; return re.jsxs("form", { ref: n, onSubmit: l, noValidate: !0, children: [re.jsx("h1", { className: "contact-head", children: "Contact" }), re.jsx("label", { children: "Your name" }), " ", re.jsx("br", {}), re.jsx("input", { type: "text", name: "user_name", value: i.user_name, onChange: o }), " ", re.jsx("br", {}), re.jsx("label", { children: "Your Email" }), " ", re.jsx("br", {}), re.jsx("input", { type: "email", name: "user_email", value: i.user_email, onChange: o }), " ", re.jsx("br", {}), re.jsx("label", { children: "Message" }), " ", re.jsx("br", {}), re.jsx("textarea", { name: "message", value: i.message, onChange: o }), " ", re.jsx("br", {}), re.jsx("button", { className: `snd ${e ? "sending" : ""}`, type: "submit", value: "Send", children: e ? "Sending..." : "Send!" })] }) }; function xge() { return re.jsx(hge, { maxSnack: 3, children: re.jsx(yge, {}) }) } const _ge = () => re.jsxs("div", { className: "contact-con", children: [re.jsx(Fme, {}), re.jsx("div", { className: "app ", children: re.jsxs("div", { className: "con", children: [re.jsx("div", { className: "box-con", children: re.jsx(xge, {}) }), re.jsx("div", { className: "planet-con", children: re.jsx(Nme, {}) })] }) })] }); var Ege = { prefix: "fab", iconName: "discord", icon: [640, 512, [], "f392", "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"] }, Cge = { prefix: "fab", iconName: "instagram", icon: [448, 512, [], "f16d", "M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"] }, Sge = { prefix: "fab", iconName: "telegram", icon: [496, 512, [62462, "telegram-plane"], "f2c6", "M248,8C111.033,8,0,119.033,0,256S111.033,504,248,504,496,392.967,496,256,384.967,8,248,8ZM362.952,176.66c-3.732,39.215-19.881,134.378-28.1,178.3-3.476,18.584-10.322,24.816-16.948,25.425-14.4,1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25,5.342-39.5,3.652-3.793,67.107-61.51,68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608,69.142-14.845,10.194-26.894,9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7,18.45-13.7,108.446-47.248,144.628-62.3c68.872-28.647,83.183-33.623,92.511-33.789,2.052-.034,6.639.474,9.61,2.885a10.452,10.452,0,0,1,3.53,6.716A43.765,43.765,0,0,1,362.952,176.66Z"] }; const Tge = () => re.jsx("div", { className: "footer", children: re.jsx("div", { className: "app ftp", children: re.jsxs("div", { className: "footer-con", children: [re.jsx("div", { className: "logo-right", children: re.jsxs("div", { className: "mrg", children: [re.jsx("img", { className: "footer-logo", src: Dk, alt: "" }), re.jsxs("p", { className: "mrgp", children: [re.jsx(si, { icon: Pj }), " ", re.jsx("span", { children: "2023  Taskify. All Rights Reserved" })] })] }) }), re.jsxs("div", { className: "medias", children: [re.jsx("div", { className: "hhh", children: re.jsxs("a", { className: "med discord", href: "", children: [" ", re.jsx(si, { icon: Ege }), " Discord"] }) }), re.jsx("div", { className: "hhh", children: re.jsxs("a", { className: "med instagram", href: "", children: [re.jsx(si, { icon: Cge }), " Instagram"] }) }), re.jsx("div", { className: "hhh", children: re.jsxs("a", { className: "med telegram", href: "", children: [re.jsx(si, { icon: Sge }), " Telegram"] }) })] })] }) }) }); function wge() { return re.jsxs(re.Fragment, { children: [re.jsx(Dj, {}), re.jsx(UX, {}), re.jsx(rJ, {}), re.jsx(oJ, {}), re.jsx(_ge, {}), re.jsx(Tge, {})] }) } eE.createRoot(document.getElementById("root")).render(re.jsx(mr.StrictMode, { children: re.jsx(wge, {}) }))
}); export default Ige();
